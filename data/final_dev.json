[{"instruction": "Generate java code\nactually walks the bag to make sure the count is correct and resets the running total ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "int function ( ) { _total = extractList ( ) . size ( ) ; return _total ; }"}, {"instruction": "Generate java code\ncontrols whether the compiler should perform statements recovery . to be effective , this method must be called before any of #getroot , #getastrewrite , #getimportremover . this method has no effect if the target object has been created with #compilationunitrewrite icompilationunit , compilationunit . defaults to true do perform statements recovery . ", "input": " ImportRewrite fImportRewrite \n ImportRemover fImportRemover \n WorkingCopyOwner fOwner \n ASTRewrite fRewrite \n boolean fStatementsRecovery \n List<TextEditGroup> fTextEditGroups \n ICompilationUnit fCu \n IDocument fRememberContent \n CompilationUnit fRoot \n boolean fResolveBindings \n boolean fBindingsRecovery \n void clearASTRewrite \n ASTRewrite getASTRewrite \n void rememberContent \n AST getAST \n void setBindingRecovery \n ImportRemover getImportRemover \n CompilationUnitChange createChange \n org.eclipse.jdt.internal.corext.refactoring.changes.CompilationUnitChange createChange \n CompilationUnitChange createChange \n CompilationUnitChange createChange \n void clearASTAndImportRewrites \n CompilationUnitChange attachChange \n CategorizedTextEditGroup createCategorizedGroupDescription \n TextEditGroup createGroupDescription \n void setResolveBindings \n ImportRewrite getImportRewrite \n ICompilationUnit getCu \n void clearImportRewrites \n void clearGroupDescriptionEdits \n CompilationUnit getRoot \n boolean isEmptyEdit", "output": "void function ( boolean arg0 ) { fStatementsRecovery = arg0 ; }"}, {"instruction": "Generate java code\noverride and return true for database updates that produce changed class metadata ", "input": " String _db4oVersion \n byte _db4oHeaderVersion \n String fileName \n String fileName \n String getTempPath \n void runDefrag \n void checkDatabaseFile \n void update \n int db4oMajorVersion \n void checkUpdatedDatabaseFile \n void investigateFileHeaderVersion \n boolean isApplicableForDb4oVersion \n void withDatabase \n void deconfigure \n void setUp \n String fileNamePrefix \n void assertObjectDeletion \n void assertObjectsAreReadable \n String databasePath \n void configureForStore \n void test \n void test \n void deconfigureForStore \n void configure \n void store \n void deconfigureForTest \n void tearDown \n void configureForTest \n void storeObject \n void createDatabase \n void createDatabase \n void assertObjectsAreUpdated \n void updateDatabaseFile \n String oldVersionFileName \n void createDatabaseFor \n byte db4oHeaderVersion \n int db4oMinorVersion \n String[] versionNames \n void runDeletionTests", "output": "boolean function ( ) { return false ; }"}, {"instruction": "Generate java code\nget identity znode . ", "input": " String ENCRYPTION_KEY_NO_ZNODE_NAME \n String KEY_VERSION_ZNODE_NAME \n String PRINCIPAL_NAME_ZNODE_NAME \n String baseZNode \n String CREATED_TIME_ZNODE_NAME \n String KDC_FLAGS_ZNODE_NAME \n String DISABLED_ZNODE_NAME \n String KEYS_ZNODE_NAME \n String IDENTITIES_ZNODE_NAME \n String KEY_ZNODE_NAME \n String EXPIRE_TIME_ZNODE_NAME \n String KEY_TYPE_ZNODE_NAME \n String LOCKED_ZNODE_NAME \n String getEncryptionKeyTypeZNode \n String getBaseZNode \n String getDisabledZNode \n String getKeyTypeZNode \n String getEncryptionKeyNoZNode \n String getEncryptionKeyZNode \n String getLockedZNode \n String getCreatedTimeZNode \n String getExpireTimeZNode \n String getKeyVersionZNode \n String getKeysZNode \n String getIdentitiesZNode \n List<String> getIdentityNames \n String getPrincipalNameZnode \n String getKdcFlagsZNode", "output": "String function ( String arg0 ) { return ZKUtil . joinZNode ( getIdentitiesZNode ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\ncompareto , lexicogaphical comparison . ", "input": " List<C> val \n Logger logger \n GenVectorModul<C> modul \n int signum \n GenVector<C> leftLinearCombination \n GenVector<C> rightScalarProduct \n GenVector<C> subtract \n GenVector<C> scalarMultiply \n GenVector<C> sum \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> leftScalarMultiply \n C scalarProduct \n GenVector<C> scalarProduct \n GenVector<C> abs \n int hashCode \n GenVector<C> negate \n boolean equals \n GenVector<C> clone \n boolean isZERO \n String toString", "output": "int function ( GenVector < C > arg0 ) { if ( ! modul . equals ( arg0 . modul ) ) { return - 1 ; } List < C > loc0 = arg0 . val ; int loc1 = 0 ; for ( C loc2 : val ) { int loc3 = loc2 . compareTo ( loc0 . get ( loc1 ++ ) ) ; if ( loc3 != 0 ) { return loc3 ; } } return 0 ; }"}, {"instruction": "Generate java code\nsets the tag position if one is associated with the nls element . ", "input": " Region fTagPosition \n String TAG_POSTFIX \n AccessorClassReference fAccessorClassReference \n boolean fIsEclipseNLS \n int TAG_PREFIX_LENGTH \n String TAG_PREFIX \n int fIndex \n int TAG_POSTFIX_LENGTH \n String fValue \n Region fPosition \n String getValue \n Region getPosition \n boolean isEclipseNLS \n boolean hasTag \n void setAccessorClassReference \n AccessorClassReference getAccessorClassReference \n void setValue \n String createTagText \n String getTagText \n String toString \n Region getTagPosition", "output": "void function ( int arg0 , int arg1 ) { fTagPosition = new Region ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nconvenience method to find a zero of a univariate real function . a default solver is used . ", "input": " UnivariateRealSolverFactory factory \n double[] bracket \n double[] bracket \n double midpoint \n void setup", "output": "double function ( UnivariateRealFunction arg0 , double arg1 , double arg2 ) { setup ( arg0 ) ; return factory . newDefaultSolver ( arg0 ) . solve ( arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\ndo we get multiple clicks even when the individual clicks are on different frames ? ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isWindows ( ) || Platform . isOSX ( ) || Platform . JAVA_VERSION < Platform . JAVA_1_3 ; }"}, {"instruction": "Generate java code\ngets the fractional second precision of the type qualifier of the interval data type descriptor of this field iff interval type . gets the interval type descriptor 's fractional second precision iff interval type . ", "input": " SqlIntervalQualifier intervalQualifier \n Integer precision \n Boolean isNullable \n String name \n Integer scale \n List<String> workspaceSchemaPath \n List<FieldType> fields \n SqlTypeName type \n String sql \n String getName \n String getName \n boolean isDynamic \n List<String> getWorkspaceSchemaPath \n SqlIntervalQualifier getIntervalQualifier \n boolean hasStar \n TimeUnit getEndUnit \n RelDataType getRowType \n Integer getPrecision \n void setSql \n String getSql \n TimeUnit getStartUnit \n List<FieldType> getFields \n Integer getScale \n SqlTypeName getType \n Boolean getIsNullable", "output": "Integer function ( ) { return null == intervalQualifier ? null : intervalQualifier . getFractionalSecondPrecisionPreservingDefault ( ) ; }"}, {"instruction": "Generate java code\nconvert drawable to byte array ", "input": " PlaceHolder placeHolder \n Drawable bitmapToDrawable \n void closeInputStream \n Bitmap drawableToBitmap \n Bitmap byteToBitmap \n Bitmap getBitmapFromUrl \n Bitmap getBitmapFromUrl \n Bitmap scaleImage \n byte[] bitmapToByte \n Bitmap scaleImageTo \n Drawable byteToDrawable \n Drawable getDrawableFromUrl \n Drawable getDrawableFromUrl \n InputStream getInputStreamFromUrl \n InputStream getInputStreamFromUrl", "output": "byte [ ] function ( Drawable arg0 ) { return bitmapToByte ( drawableToBitmap ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nresets migration flag . should only be used in tests . ", "input": " String APP_PREFS_NAME \n String PROFILE_PREFS_NAME_PREFIX \n String[] PROFILE_MIGRATIONS_0_TO_1 \n EnumSet<Flags> disableMigrations \n boolean migrationDone \n int PREFS_VERSION \n String LOGTAG \n String PREFS_VERSION_KEY \n int getVersion \n void migrateIfNecessary \n SharedPreferences forApp \n SharedPreferences forApp \n Editor migrateFromPreferenceManager \n void performMigration \n SharedPreferences forProfile \n SharedPreferences forProfile \n SharedPreferences forProfileName \n SharedPreferences forProfileName \n void putEntry", "output": "void function ( ) { migrationDone = false ; }"}, {"instruction": "Generate java code\ncomment f1z ", "input": " int I1z \n int I2z \n int I1 \n int I3 \n int I2 \n int I4 \n void fz \n void f \n void f11 \n void f1 \n void f2", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ncreates a dialog to present a refactoringstatus to the user . thefollowing values are returned from the dialogs open method : org.eclipse.jface.dialogs.idialogconstants #ok_id idialogconstants #ok_id : if the user has pressed the continue button . org.eclipse.jface.dialogs.idialogconstants #cancel_id idialogconstants #cancel_id : if the user has pressed the cancel button . org.eclipse.jface.dialogs.idialogconstants #back_id idialogconstants #back_id : if the user has pressed the back button . ", "input": " PlaceHolder placeHolder \n Dialog createRefactoringWizardDialog \n Composite createRefactoringHistoryControl \n Composite createSortableRefactoringHistoryControl \n PerformChangeOperation createUIAwareChangeOperation \n Dialog createLightWeightStatusDialog", "output": "Dialog function ( RefactoringStatus arg0 , Shell arg1 , String arg2 , boolean arg3 ) { return new RefactoringStatusDialog ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\ngets the current stroke color ", "input": " boolean knockout \n LineDashPattern lineDashPattern \n BaseColor fillColor \n float wordSpacing \n float leading \n BaseColor strokeColor \n int lineJoinStyle \n float miterLimit \n int lineCapStyle \n float lineWidth \n int renderMode \n PdfName colorSpaceFill \n PdfName colorSpaceStroke \n float fontSize \n float rise \n Matrix ctm \n float horizontalScaling \n float characterSpacing \n CMapAwareDocumentFont font \n float getFontSize \n int getRenderMode \n void setLineDashPattern \n int getLineJoinStyle \n PdfName getColorSpaceStroke \n float getCharacterSpacing \n void setLineWidth \n Matrix getCtm \n void setLineCapStyle \n PdfName getColorSpaceFill \n float getMiterLimit \n float getLineWidth \n float getWordSpacing \n boolean isKnockout \n BaseColor getFillColor \n CMapAwareDocumentFont getFont \n void setMiterLimit \n float getRise \n int getLineCapStyle \n float getLeading \n LineDashPattern getLineDashPattern \n float getHorizontalScaling \n void setLineJoinStyle", "output": "BaseColor function ( ) { return strokeColor ; }"}, {"instruction": "Generate java code\ntest method for org.jboss.security.config.securityconfiguration #getapplicationpolicy java.lang.string . ", "input": " PlaceHolder placeHolder \n void testGetCipherAlgorithm \n void testSetIterationCount \n void testGetKeyStoreURL \n void testGetSalt \n void testGetTrustStoreType \n void testGetKeyStoreType \n void testSetTrustStoreURL \n void testSetKeyStoreURL \n void testSetSalt \n void testLoadPassword \n void testSetCipherSpec \n void testGetExternalPasswordCacheInstance \n void testSetKeyStoreType \n void testIsDeepCopySubjectMode \n void testGetKeyStorePass \n WebArchive deployment \n void testSetTrustStorePass \n void testGetTrustStorePass \n void testSetCipherAlgorithm \n void testSetTrustStoreType \n void testGetTrustStoreURL \n void testSetDeepCopySubjectMode \n void testGetCipherSpec \n void testAddApplicationPolicy \n void testSetKeyStorePass \n void testRemoveApplicationPolicy \n void testSetCipherKey \n void testGetIterationCount \n void testGetCipherKey", "output": "void function ( ) { SecurityConfiguration . getApplicationPolicy ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncopy method ", "input": " PlaceHolder placeHolder \n void validateMin2 \n void validate \n Predicate[] validate \n void validate \n void validate", "output": "Transformer [ ] function ( Transformer [ ] arg0 ) { if ( arg0 == null ) { return null ; } return ( Transformer [ ] ) arg0 . clone ( ) ; }"}, {"instruction": "Generate java code\nabre el libro y retorna el marcador con la pagina actual ", "input": " String dimensiones \n int numeroPaginas \n String titulo \n String colorPortada \n String autor \n int marcador \n void setColorPortada \n void setDimensiones \n String getColorPortada \n String getAutor \n void setTitulo \n int cerrar \n String getTitulo \n void setNumeroPaginas \n int getNumeroPaginas \n int leer \n String getDimensiones \n void setMarcador \n int escribir \n void setAutor \n Libro clone \n String toString \n int getMarcador", "output": "int function ( ) { return this . getMarcador ( ) ; }"}, {"instruction": "Generate java code\nreturns the element surrounding the selection of the given editor . ", "input": " IJavaElement[] EMPTY_RESULT \n IJavaElement selectJavaElement \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] performForkedCodeResolve \n boolean canOperateOn \n IStructuredSelection getStructuredSelection \n IClassFile getInputAsClassFile \n IJavaElement[] codeResolveForked \n ITypeRoot getInput \n ITypeRoot getInput \n IType getTypeAtOffset \n IJavaElement[] codeResolveOrInputForked \n ICompilationUnit getInputAsCompilationUnit \n IJavaElement[] getElements \n IJavaElement resolveEnclosingElement \n IJavaElement resolveEnclosingElement", "output": "IJavaElement function ( JavaEditor arg0 , boolean arg1 ) { ITypeRoot loc0 = getInput ( arg0 , arg1 ) ; if ( loc0 != null ) return getElementAtOffset ( loc0 , ( ITextSelection ) arg0 . getSelectionProvider ( ) . getSelection ( ) ) ; return null ; }"}, {"instruction": "Generate java code\ncoordinates building a loadplan that defines just a single root entity return may have fetches . typically this includes building load plans for entity loading or cascade loading . ", "input": " PlaceHolder placeHolder \n LoadPlan buildRootCollectionLoadPlan", "output": "LoadPlan function ( LoadPlanBuildingAssociationVisitationStrategy arg0 , EntityPersister arg1 ) { MetamodelGraphWalker . visitEntity ( arg0 , arg1 ) ; return arg0 . buildLoadPlan ( ) ; }"}, {"instruction": "Generate java code\ncompute a single body-body or body-cell interaction ", "input": " MathVector acc0 \n MathVector pos \n double mass \n int IMAX \n MathVector pos0 \n double phi0 \n double EPS \n Body pskip \n Node loadTree \n int oldSubindex \n String toString \n double hackcofm \n HG walkSubTree", "output": "HG function ( HG arg0 ) { MathVector loc0 = new MathVector ( ) ; loc0 . subtraction ( pos , arg0 . pos0 ) ; double loc1 = loc0 . dotProduct ( ) + ( EPS * EPS ) ; double loc2 = Math . sqrt ( loc1 ) ; double loc3 = mass / loc2 ; arg0 . phi0 -= loc3 ; double loc4 = loc3 / loc1 ; loc0 . multScalar ( loc4 ) ; arg0 . acc0 . addition ( loc0 ) ; return arg0 ; }"}, {"instruction": "Generate java code\nset the name of the catalog to be searched , ornull to search the default catalog . ", "input": " String name \n String catalogName \n boolean optional \n String nameKey \n void setName \n String getNameKey \n String getName \n void setNameKey \n String getCatalogName \n boolean postprocess \n Command getCommand \n boolean isOptional \n boolean execute \n void setOptional", "output": "void function ( String arg0 ) { this . catalogName = arg0 ; }"}, {"instruction": "Generate java code\nreturn an iterator over values in a column . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n ColumnMetaData[] getColumnMetaData \n ColumnMetaData getColumnMetaData \n ColumnMetaData getColumnMetaData \n long getRowCount \n List<ColumnMetaData> getRoots \n void readColumnMetaData \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n ColumnFileMetaData getMetaData \n void readHeader \n void readMagic \n void close", "output": "ColumnValues < T > function ( int arg0 ) { return new ColumnValues < T > ( columns [ arg0 ] ) ; }"}, {"instruction": "Generate java code\nwhen the login machine terminates , we might not be in the married state , and therefore we ca n't sync . this method messages as much to the user . to avoid stopping us syncing altogether , we set a soft error rather than a hard error . in future , we would like to set a hard error if we are in , for example , the separated state , and then have some user initiated activity mark the android account as ready to sync again . this is tricky , though , so we play it safe for now . ", "input": " BlockingQueue<Result> latch \n SyncResult syncResult \n void setSyncResultSuccess \n void postponeSync \n void setSyncResultSoftError \n void handleError \n void handleSuccess \n void rejectSync \n void setSyncResultHardError", "output": "void function ( State arg0 ) { setSyncResultSoftError ( ) ; latch . offer ( Result . Error ) ; }"}, {"instruction": "Generate java code\nconverts the handle . handle need not exist , but must be a source reference . ", "input": " IType fOldType \n IType fNewType \n Map<IJavaElement,String> fRefactoredSimilarElements \n IMember resolveTypeInMember \n String resolveTypeName \n IMember[] convertElements \n void addElements \n String[] resolveParameterTypes \n String resolveElementName \n String replaceAll", "output": "IMember function ( IMember arg0 ) { final LinkedList < IMember > loc0 = new LinkedList < > ( ) ; addElements ( arg0 , loc0 ) ; final IMember [ ] loc1 = convertElements ( loc0 . toArray ( new IMember [ 0 ] ) ) ; return loc1 [ loc1 . length - 1 ] ; }"}, {"instruction": "Generate java code\nreturns the sampleduration of the track in seconds . ", "input": " Buffer outputBuffer \n Codec codec \n Buffer inputBuffer \n ArrayList<VideoTrack> tracks \n String nameFormat \n Format videoFormat \n int count \n int width \n Format fileFormat \n File dir \n int height \n boolean isVFRSupported \n Format getFileFormat \n boolean isEmpty \n void writeSamples \n int getTrackCount \n int addTrack \n int addVideoTrack \n void writeSample \n boolean isDataLimitReached \n Format getFormat \n void createCodec \n void write \n void write \n void close", "output": "Rational function ( int arg0 ) { VideoTrack loc0 = tracks . get ( arg0 ) ; return new Rational ( loc0 . count , 30 ) ; }"}, {"instruction": "Generate java code\ndoes a popularity reorder on this document set . ", "input": " boolean configured \n Distribution reorderIntvlDist \n boolean useRanks \n double zipfExp \n long meanReorderIntvl \n RandomGenerator rand \n String name \n ZipfDistribution dist \n int startRank \n Logger log \n List<Integer> keyPopularity \n int size \n void setName \n String getName \n int getKeyForPublish \n void checkConfigure \n void setMeanReorderIntvl \n void setZipfExp \n void configure \n int getSize \n boolean containsResourcesOf \n void setSize \n Distribution getReorderDistribution \n int getKeyForLookup \n void setBeginRank", "output": "void function ( ) { int loc0 = rand . nextInt ( size ) ; int loc1 = rand . nextInt ( size ) ; log . debug ( \"srini_string\" + Simulator . getCurrentTime ( ) + \"srini_string\" + loc0 + \"srini_string\" + loc1 ) ; keyPopularity . add ( loc1 , keyPopularity . remove ( loc0 ) ) ; getKeyForLookup ( ) ; }"}, {"instruction": "Generate java code\ngets the child scripts that make up this block . this list is live so that it can be modified if requried ", "input": " List list \n void addScript \n Script compile \n void trimWhitespace \n String toString \n void run \n void removeScript", "output": "List function ( ) { return list ; }"}, {"instruction": "Generate java code\nanalyzes if the given resource is the best matching for the given release . returns true if so , false otherwise . ", "input": " ResourceReleaseComparator resourceReleaseComparator \n List<ResourceEntity> getAllFutureReleases \n int compare \n boolean isBestMatchingPastReleaseTime \n Set<ResourceEntity> getResourceEntitiesByRelease \n Boolean isBestMatchingFutureReleaseTime \n Set<ConsumedResourceRelationEntity> getConsumedMasterRelationsForRelease \n Set<ProvidedResourceRelationEntity> getProvidedMasterRelationsForRelease \n Set<ResourceEntity> getConsumedRelatedResourcesByResourceType \n Set<ProvidedResourceRelationEntity> getProvidedSlaveRelationsForRelease \n ReleaseEntity findMostRelevantRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity findMostRelevantResource", "output": "boolean function ( @ NotNull ResourceEntity arg0 , @ NotNull ReleaseEntity arg1 ) { return arg0 . equals ( getResourceEntityForRelease ( arg0 . getResourceGroup ( ) , arg1 ) ) ; }"}, {"instruction": "Generate java code\nget the docker rest uri . ", "input": " String address \n int port \n String host \n String DEFAULT_HOST \n String DEFAULT_UNIX_ENDPOINT \n int DEFAULT_PORT \n URI uri \n String dockerCertPath \n int defaultPort \n DockerHost fromEnv \n String address \n int port \n String host \n DockerHost from \n String toString \n String dockerCertPath", "output": "URI function ( ) { return uri ; }"}, {"instruction": "Generate java code\ngets the value of the getcontentlanguage property . ", "input": " Owner owner \n PrincipalURL principalURL \n Creationdate creationdate \n Getlastmodified getlastmodified \n Getcontentlanguage getcontentlanguage \n Getetag getetag \n Getcontentlength getcontentlength \n SupportedReportSet supportedReportSet \n Acl acl \n PrincipalCollectionSet principalCollectionSet \n Resourcetype resourcetype \n List<Element> any \n QuotaUsedBytes quotaUsedBytes \n Lockdiscovery lockdiscovery \n QuotaAvailableBytes quotaAvailableBytes \n Getcontenttype getcontenttype \n Displayname displayname \n Supportedlock supportedlock \n Group group \n PrincipalCollectionSet getPrincipalCollectionSet \n Creationdate getCreationdate \n void setCreationdate \n void setQuotaAvailableBytes \n Getcontentlength getGetcontentlength \n Displayname getDisplayname \n void setGetcontenttype \n void setAcl \n Owner getOwner \n Getlastmodified getGetlastmodified \n Supportedlock getSupportedlock \n void setLockdiscovery \n void setOwner \n SupportedReportSet getSupportedReportSet \n void setSupportedReportSet \n void setSupportedlock \n void setPrincipalCollectionSet \n QuotaUsedBytes getQuotaUsedBytes \n Acl getAcl \n void setQuotaUsedBytes \n void setPrincipalURL \n PrincipalURL getPrincipalURL \n void setGetetag \n Resourcetype getResourcetype \n void setResourcetype \n Getetag getGetetag \n void setGroup \n Getcontenttype getGetcontenttype \n Group getGroup \n void setGetcontentlanguage \n Lockdiscovery getLockdiscovery \n void setGetlastmodified \n QuotaAvailableBytes getQuotaAvailableBytes \n void setDisplayname \n void setGetcontentlength \n List<Element> getAny", "output": "Getcontentlanguage function ( ) { return getcontentlanguage ; }"}, {"instruction": "Generate java code\nindicates whether or not the factory is configured to produce parsers which converts cdata nodes to text nodes and appends it to the adjacent if any text node . ", "input": " boolean validating \n boolean namespaceAware \n boolean whitespace \n boolean expandEntityRef \n boolean coalescing \n boolean ignoreComments \n void setCoalescing \n boolean isIgnoringElementContentWhitespace \n void setIgnoringElementContentWhitespace \n boolean isNamespaceAware \n void setNamespaceAware \n DocumentBuilderFactory newInstance \n boolean isValidating \n void setAttribute \n Object getAttribute \n boolean isExpandEntityReferences \n DocumentBuilder newDocumentBuilder \n void setValidating \n void setIgnoringComments \n void setExpandEntityReferences \n boolean isIgnoringComments", "output": "boolean function ( ) { return coalescing ; }"}, {"instruction": "Generate java code\ngets the number of persistent connections tracked by the connection manager currently being used to execute requests . the total number of connections in the pool is equal to available plus leased . ", "input": " int leased \n int max \n int pending \n int available \n int getMax \n String toString \n int getPending \n int getAvailable", "output": "int function ( ) { return this . leased ; }"}, {"instruction": "Generate java code\nlog an error to the log4j logger with error priority . ", "input": " String name \n boolean is12 \n Logger logger \n String FQCN \n void warn \n void warn \n void trace \n void trace \n void debug \n void debug \n boolean isInfoEnabled \n boolean isErrorEnabled \n Logger getLogger \n boolean isTraceEnabled \n boolean isWarnEnabled \n boolean isDebugEnabled \n boolean isFatalEnabled \n void fatal \n void fatal \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . ERROR , arg0 , arg1 ) ; } else { getLogger ( ) . log ( FQCN , Level . ERROR , arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nreturns the first child element of a node that matches the given tag name . ", "input": " PlaceHolder placeHolder \n List<Element> getAllChildElemsMatching", "output": "Element function ( Node arg0 , String arg1 ) { NodeList loc0 = arg0 . getChildNodes ( ) ; for ( int loc1 = 0 ; loc1 < loc0 . getLength ( ) ; loc1 ++ ) { Node loc2 = loc0 . item ( loc1 ) ; if ( loc2 . getNodeType ( ) == Node . ELEMENT_NODE && arg1 . equals ( loc2 . getNodeName ( ) ) ) return ( Element ) loc2 ; } return null ; }"}, {"instruction": "Generate java code\ngets the value of the fclink property . ", "input": " String fcLink \n String localPortID \n String displayName \n String fcKey \n ProvidedPortID id \n List<PropertyDeclaration> properties \n String resourceType \n String getFcKey \n String getDisplayName \n List<PropertyDeclaration> getProperties \n void setFcKey \n String getResourceType \n void setFcLink \n String getLocalPortID \n void setResourceType \n void setId \n ProvidedPortID getId \n void setLocalPortID \n void setDisplayName", "output": "String function ( ) { return fcLink ; }"}, {"instruction": "Generate java code\nchecks if this pdfobject is of the type pdfdictionary . ", "input": " int INDIRECT \n int STRING \n int DICTIONARY \n int NULL \n int NUMBER \n int type \n int NAME \n String NOTHING \n int BOOLEAN \n int ARRAY \n byte[] bytes \n String TEXT_UNICODE \n String TEXT_PDFDOCENCODING \n PRIndirectReference indRef \n int STREAM \n void toPdf \n void setContent \n void setIndRef \n int length \n boolean isStream \n PRIndirectReference getIndRef \n int type \n byte[] getBytes \n boolean isBoolean \n boolean isName \n boolean isNumber \n boolean isNull \n boolean isString \n String toString \n boolean canBeInObjStm \n boolean isArray \n boolean isIndirect", "output": "boolean function ( ) { return ( type == DICTIONARY ) ; }"}, {"instruction": "Generate java code\nset removed pair number . ", "input": " boolean useCriterion4 \n ColorPolynomial<C> pi \n int i \n ColorPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n int getPairNumber \n int hashCode \n void setUseCriterion3 \n boolean equals \n boolean getUseCriterion3 \n void setZero \n boolean isZero \n void setUseCriterion4 \n String toString \n int compareTo \n boolean getUseCriterion4", "output": "void function ( int arg0 ) { this . n = arg0 ; }"}, {"instruction": "Generate java code\ntwosided groebner base using pairlist class . ", "input": " SolvableGroebnerBase<C> sbb \n boolean debug \n Logger logger \n List<GenSolvablePolynomial<C>> leftGB \n ModuleList<C> leftGB \n boolean isTwosidedGB \n boolean isTwosidedGB \n List<GenSolvablePolynomial<C>> rightGB \n ModuleList<C> rightGB \n boolean isLeftGB \n boolean isLeftGB \n boolean isRightGB \n boolean isRightGB", "output": "List < GenSolvablePolynomial < C >> function ( int arg0 , List < GenSolvablePolynomial < C >> arg1 ) { return sbb . twosidedGB ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ncontrols whether the compiler should provide binding information for the ast nodes it creates . to be effective , this method must be called before any of #getroot , #getastrewrite , #getimportremover . this method has no effect if the target object has been created with #compilationunitrewrite icompilationunit , compilationunit . defaults to true do resolve bindings . ", "input": " ImportRewrite fImportRewrite \n ImportRemover fImportRemover \n WorkingCopyOwner fOwner \n ASTRewrite fRewrite \n boolean fStatementsRecovery \n List<TextEditGroup> fTextEditGroups \n ICompilationUnit fCu \n IDocument fRememberContent \n CompilationUnit fRoot \n boolean fResolveBindings \n boolean fBindingsRecovery \n void clearASTRewrite \n ASTRewrite getASTRewrite \n void rememberContent \n AST getAST \n void setBindingRecovery \n void setStatementsRecovery \n ImportRemover getImportRemover \n CompilationUnitChange createChange \n org.eclipse.jdt.internal.corext.refactoring.changes.CompilationUnitChange createChange \n CompilationUnitChange createChange \n CompilationUnitChange createChange \n void clearASTAndImportRewrites \n CompilationUnitChange attachChange \n CategorizedTextEditGroup createCategorizedGroupDescription \n TextEditGroup createGroupDescription \n ImportRewrite getImportRewrite \n ICompilationUnit getCu \n void clearImportRewrites \n void clearGroupDescriptionEdits \n CompilationUnit getRoot \n boolean isEmptyEdit", "output": "void function ( boolean arg0 ) { fResolveBindings = arg0 ; }"}, {"instruction": "Generate java code\ndispatch a keyup event . ", "input": " Point pointT \n abbot.swt.Robot _robot \n void robotKeyClick \n void doKeyDown \n void doKeyUp \n void mouseMove \n void mouseMove \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n int[] extractKeys \n void mouseUp \n void keyClick \n void keyClick \n void keyDown \n void keyDown \n Event createClickEvent \n void enterText", "output": "void function ( int arg0 ) { int [ ] loc0 = extractKeys ( arg0 ) ; for ( int loc1 = loc0 . length - 1 ; loc1 >= 0 ; -- loc1 ) doKeyUp ( loc0 [ loc1 ] ) ; }"}, {"instruction": "Generate java code\nlocal absolute value . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n C num \n int isunit \n C den \n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n int hashCode \n Local<C> negate \n boolean equals \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "Local < C > function ( ) { return new Local < C > ( ring , num . abs ( ) , den , true ) ; }"}, {"instruction": "Generate java code\ncompare two object ", "input": " PlaceHolder placeHolder \n String nullStrToEmpty \n Long[] transformLongArray \n long[] transformLongArray \n int compare \n Integer[] transformIntArray \n int[] transformIntArray", "output": "boolean function ( Object arg0 , Object arg1 ) { return arg0 == arg1 || ( arg0 == null ? arg1 == null : arg0 . equals ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nsets all probes to false . ", "input": " String name \n boolean[] probes \n long id \n String getName \n void merge \n void merge \n boolean[] getProbes \n long getId \n String toString \n void assertCompatibility", "output": "void function ( ) { Arrays . fill ( probes , false ) ; }"}, {"instruction": "Generate java code\ncreate an instance of providedportid ", "input": " QName _PropertyDeclaration_QNAME \n QName _ProvidedPort_QNAME \n QName _ApplicationPayload_QNAME \n QName _Application_QNAME \n QName _ApplicationID_QNAME \n QName _ApplicationReleaseBinding_QNAME \n QName _ConsumedPort_QNAME \n QName _ProvidedPortID_QNAME \n ConsumedPort createConsumedPort \n JAXBElement<ConsumedPort> createConsumedPort \n ApplicationPayload createApplicationPayload \n JAXBElement<ApplicationPayload> createApplicationPayload \n ApplicationReleaseBinding createApplicationReleaseBinding \n JAXBElement<ApplicationReleaseBinding> createApplicationReleaseBinding \n Application createApplication \n JAXBElement<Application> createApplication \n PropertyDeclaration createPropertyDeclaration \n JAXBElement<PropertyDeclaration> createPropertyDeclaration \n ApplicationID createApplicationID \n JAXBElement<ApplicationID> createApplicationID \n ProvidedPort createProvidedPort \n JAXBElement<ProvidedPort> createProvidedPort", "output": "ProvidedPortID function ( ) { return new ProvidedPortID ( ) ; }"}, {"instruction": "Generate java code\nadds the given locator . locators are queried in the sequence they have been added . ", "input": " int tabWidth \n List<ISourceFileLocator> delegates \n int getTabWidth \n Reader getSourceFile", "output": "void function ( final ISourceFileLocator arg0 ) { delegates . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nget a constant univpowerseries from a java.math.biginteger . ", "input": " UnivPowerSeries<C> ZERO \n String DEFAULT_NAME \n int truncate \n String var \n int DEFAULT_TRUNCATE \n UnivPowerSeries<C> ONE \n RingFactory<C> coFac \n Random random \n UnivPowerSeries<C> getTAN \n boolean isField \n boolean isCommutative \n UnivPowerSeries<C> getSIN \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> fromPolynomial \n java.math.BigInteger characteristic \n UnivPowerSeries<C> getEXP \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n int hashCode \n boolean equals \n UnivPowerSeries<C> getONE \n UnivPowerSeries<C> getZERO \n UnivPowerSeries<C> getCOS \n String toString \n boolean isAssociative \n UnivPowerSeries<C> copy \n UnivPowerSeries<C> fixPoint", "output": "UnivPowerSeries < C > function ( java . math . BigInteger arg0 ) { return ONE . multiply ( coFac . fromInteger ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nbrings the passed shell to the top of the drawing order so that it receives keyboard focus . ", "input": " String copyright \n IWorkbenchWindow getWorkbenchWindow \n void bringWorkbenchToFront \n IWorkbench getWorkbench", "output": "void function ( final Shell arg0 ) { Robot . syncExec ( arg0 . getDisplay ( ) , null , new Runnable ( ) { public void run ( ) { arg0 . forceActive ( ) ; arg0 . setFocus ( ) ; } } ) ; Robot . waitForIdle ( arg0 . getDisplay ( ) ) ; }"}, {"instruction": "Generate java code\ncreates and adds a new limit . ", "input": " WildcardMatcher excludesMatcher \n String excludes \n String includes \n WildcardMatcher includesMatcher \n List<Limit> limits \n ElementType element \n List<Limit> getLimits \n ElementType getElement \n void setExcludes \n void setLimits \n String getIncludes \n String getExcludes \n void setElement \n boolean matches \n void setIncludes", "output": "Limit function ( ) { final Limit loc0 = new Limit ( ) ; this . limits . add ( loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nskips the next char . ", "input": " String str \n int pos \n char ch \n char ch \n int pos \n int length \n boolean hasNext \n XMPDateTime parse \n XMPDateTime parse \n String render \n int gatherInt", "output": "void function ( ) { pos ++ ; }"}, {"instruction": "Generate java code\nmain method execution steps : 1 . configure jaxb for the classes in the com.cooksys.serialization.assignment.model package 2 . read a session object from the / input/memphis / directory using the methods defined above 3 . write the session object to the / output/session.xml file . jaxb annotations and configuration : you will have to add jaxb annotations to the classes in the com.cooksys.serialization.assignment.model package check the xml files in the / input / directory to determine how to configure the contact jaxb annotations the session object should marshal to look like the following : ... ... ... ... ", "input": " PlaceHolder placeHolder \n Instructor readInstructor \n void writeSession \n Session readSession \n Student readStudent \n List<Student> readStudents", "output": "void function ( String [ ] arg0 ) { JAXBContext loc0 = JAXBContext . newInstance ( Session . class ) ; writeSession ( readSession ( new File ( \"srini_string\" ) , loc0 ) , new File ( \"srini_string\" ) , loc0 ) ; }"}, {"instruction": "Generate java code\nthe `` friendly '' name for this machine ", "input": " Map<String,JsonBall> metadata \n Date created \n Type type \n Set<String> ips \n ImmutableSet.Builder<String> ips \n ImmutableMap.Builder<String,JsonBall> metadata \n String name \n String id \n State state \n Function<JsonBall,String> unquoteString \n String dataset \n int memorySizeMb \n Date updated \n int diskSizeGb \n Builder toBuilder \n Builder metadata \n String getId \n int compareTo \n Builder type \n Date getUpdated \n Map<String,String> getMetadataAsJsonLiterals \n int hashCode \n Builder builder \n Builder id \n Builder state \n String value \n String value \n Builder memorySizeMb \n Type fromValue \n State fromValue \n Map<String,String> getMetadata \n String apply \n Builder created \n int getDiskSizeGb \n String getDatasetURN \n Date getCreated \n Builder addMetadata \n Builder ips \n Builder addIp \n int getMemorySizeMb \n State getState \n Builder fromMachine \n Machine build \n Type getType \n boolean equals \n Builder name \n String toString \n String toString \n String toString \n Builder dataset \n Builder updated \n Set<String> getIps \n Builder diskSizeGb", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nset usecriterion4 . ", "input": " boolean useCriterion4 \n ColorPolynomial<C> pi \n int i \n ColorPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n int getPairNumber \n int hashCode \n void setUseCriterion3 \n boolean equals \n boolean getUseCriterion3 \n void setZero \n boolean isZero \n String toString \n int compareTo \n void pairNumber \n boolean getUseCriterion4", "output": "void function ( boolean arg0 ) { this . useCriterion4 = arg0 ; }"}, {"instruction": "Generate java code\nlook for fields in the specified class that begin with the specified prefix . ", "input": " String lineSep \n RootDoc root \n Map<ClassDoc,Set<ClassDoc>> cmap \n boolean dump_class_tree \n void gather_derived_classes \n void process_class_sorted_texinfo \n void process \n int find_enabled \n boolean start \n int optionLength \n void process_class_tree_txt", "output": "Vector < FieldDoc > function ( ClassDoc arg0 , String arg1 ) { Vector < FieldDoc > loc0 = new Vector < FieldDoc > ( ) ; for ( FieldDoc loc1 : arg0 . fields ( ) ) { if ( loc1 . name ( ) . startsWith ( arg1 ) ) loc0 . add ( loc1 ) ; } return ( loc0 ) ; }"}, {"instruction": "Generate java code\nthe violated property . ", "input": " String xmlname \n Time onExit \n HashMap<Integer,Violation> violationsMap \n Time onEntry \n Property property \n String name \n long serialVersionUID \n Time time \n Object readResolve \n Object readResolve \n Violation[] findViolations \n String toStringWithMethod \n String xmlString \n String xmlString \n Violation[] viosWithConfGEQ \n Violation[] withKind \n int hashCode \n int hashCode \n boolean equals \n boolean equals \n Violation get \n Violation get \n Violation get \n String toNiceString \n String toNiceString \n String toString \n String toString \n Time time \n Violation[] viosWithConfLT \n Violation[] withTime", "output": "Property function ( ) { return property ; }"}, {"instruction": "Generate java code\ndoes a single lookup . added by leo nobach ", "input": " Node<T> myNode \n PeerStatus peerStatus \n Logger log \n ComponentsConfig config \n boolean lookupEnabled \n void enablePeriodicLookup \n void connectivityChanged \n void beginPeriodicLookups \n void doConnect \n void routingTableBuilt \n void doDisconnect \n PeerStatus getPeerStatus \n double getSimSec", "output": "void function ( KademliaOverlayKey arg0 , OperationCallback < DHTObject > arg1 ) { KademliaOperation < DHTObject > loc0 = myNode . getOperationFactory ( ) . getDataLookupOperation ( arg0 , arg1 ) ; loc0 . scheduleImmediately ( ) ; }"}, {"instruction": "Generate java code\ncollects all received messages ", "input": " long receivedBytes \n int sentMsg \n int receivedMsg \n StatisticGenerationEvent event \n long sentBytes \n Logger log \n double[] getSentBytes \n void addReceivedMsg \n void stop \n double[] getSentMsg \n double[] getReceivedMsg \n void start \n void netMsgSend \n void netMsgDrop \n double[] getReceivedBytes \n void addSentMsg", "output": "void function ( NetMessage arg0 , NetID arg1 ) { addReceivedMsg ( arg0 ) ; receivedMsg ++ ; }"}, {"instruction": "Generate java code\nlog the specified exception . ", "input": " boolean sendToConsole \n placeholderType placeHolder", "output": "void function ( Throwable arg0 ) { if ( Platform . isRunning ( ) ) Logger . log ( arg0 ) ; else { if ( sendToConsole ) arg0 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\nreturn the items for this channel . ", "input": " String managingEditor \n String title \n String language \n String link \n ArrayList skipDays \n TextInput textInput \n String rating \n String pubDate \n String description \n String lastBuildDate \n String webMaster \n String copyright \n ArrayList skipHours \n ArrayList items \n Image image \n String docs \n double version \n void addSkipDay \n void removeItem \n void setCopyright \n String getWebMaster \n void setDescription \n String getDescription \n void addSkipHour \n String getDocs \n void addItem \n Item[] getItems \n String getTitle \n String[] getSkipHours \n String[] findSkipHours \n String[] findSkipDays \n void render \n void render \n void render \n void render \n void render \n void render \n String[] getSkipDays \n void setManagingEditor \n double getVersion \n String getLanguage \n String getCopyright \n void setVersion \n String getPubDate \n void setWebMaster \n void setTitle \n void setTextInput \n void setPubDate \n void setLink \n String getLink \n String getLastBuildDate \n void setDocs \n void removeSkipHour \n void removeSkipDay \n TextInput getTextInput \n Image getImage \n void setLastBuildDate \n void setRating \n String getManagingEditor \n void setImage \n void setLanguage \n String getRating", "output": "Item [ ] function ( ) { synchronized ( items ) { Item loc0 [ ] = new Item [ this . items . size ( ) ] ; return ( ( Item [ ] ) this . items . toArray ( loc0 ) ) ; } }"}, {"instruction": "Generate java code\ngetter for property ` name ' . ", "input": " CoreMessageLogger LOG \n boolean containsJoinFetchedCollection \n Fetch bagJoinFetch \n String name \n boolean containsJoinFetchedBag \n Map<String,Fetch> fetches \n Map<String,Fetch> getFetches \n boolean isContainsJoinFetchedBag \n void addFetch \n void addFetch \n void addFetch \n Fetch getFetchByRole \n boolean isContainsJoinFetchedCollection", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nretrieves and removes the top of the stack . ", "input": " Charset charset \n TagProcessorFactory tagFactory \n Map<String,Object> memory \n List<Element> ctn \n LinkProvider linkprovider \n boolean autoBookmark \n boolean acceptUnknown \n List<String> roottags \n String BOOKMARK_TREE \n String LAST_MARGIN_BOTTOM \n Rectangle pageSize \n String resourcesRootPath \n LinkedList<StackKeeper> queue \n CssAppliers cssAppliers \n ImageProvider imageProvider \n ImageProvider getImageProvider \n HtmlPipelineContext setTagFactory \n HtmlPipelineContext setAcceptUnknown \n boolean acceptUnknown \n LinkProvider getLinkProvider \n String getResourcesRootPath \n CssAppliers getCssAppliers \n HtmlPipelineContext charSet \n Charset charSet \n void setLastMarginBottom \n HtmlPipelineContext setImageProvider \n boolean isEmpty \n void setResourcesRootPath \n HtmlPipelineContext setCssApplier \n Map<String,Object> getMemory \n StackKeeper peek \n boolean autoBookmark \n HtmlPipelineContext autoBookmark \n HtmlPipelineContext setLinkProvider \n Float getLastMarginBottom \n Rectangle getPageSize \n List<Element> currentContent \n TagProcessor resolveProcessor \n HtmlPipelineContext clone \n List<String> getRootTags \n void setCssAppliers \n HtmlPipelineContext setRootTags \n void addFirst \n HtmlPipelineContext setPageSize", "output": "StackKeeper function ( ) { try { return this . queue . removeFirst ( ) ; } catch ( NoSuchElementException loc0 ) { throw new NoStackException ( ) ; } }"}, {"instruction": "Generate java code\ngetzero . ", "input": " GenVector<C> ZERO \n Logger logger \n RingFactory<C> coFac \n float density \n int cols \n List<GenVector<C>> BASIS \n Random random \n float DEFAULT_DENSITY \n GenVector<C> random \n GenVector<C> random \n GenVector<C> random \n GenVector<C> random \n GenVector<C> fromList \n int hashCode \n boolean equals \n GenVector<C> fromInteger \n GenVector<C> fromInteger \n String toString \n GenVector<C> copy \n GenVector<C> parse \n GenVector<C> parse", "output": "GenVector < C > function ( ) { return ZERO ; }"}, {"instruction": "Generate java code\nset level of section . ", "input": " List<Section> subsections \n Section parent \n List<Sentence> headerContent \n int level \n List<ListBlock> lists \n List<Paragraph> paragraphs \n void appendListElement \n ListBlock getListBlock \n int getNumberOfLists \n int getHeaderContentsListSize \n Paragraph getParagraph \n void appendSubSection \n Sentence getHeaderContent \n int getNumberOfSubsections \n Section getParentSection \n int getLevel \n List<Paragraph> getParagraphs \n int getNumberOfParagraphs \n List<ListBlock> getListBlocks \n void setParentSection \n List<Sentence> getHeaderContents \n Section getSubSection \n void appendListBlock \n Sentence getJoinedHeaderContents \n void appendParagraph", "output": "void function ( int arg0 ) { this . level = arg0 ; }"}, {"instruction": "Generate java code\nthis method is invoked at the server before the response is executed , but before the response has been formulated ", "input": " PlaceHolder placeHolder \n void clientStartConnect \n void clientFinishConnect \n void clientSendRequest \n void serverReceiveRequest \n void serverConnecting \n void clientReceiveResponse", "output": "void function ( RPCContext arg0 ) { }"}, {"instruction": "Generate java code\nadds a parameter to the request ; if the parameter is a file , the file is uploaded , otherwise the string value of the parameter is passed in the request ", "input": " Map<String,Object> mParameters \n String boundary \n OutputStream mOutput \n URLConnection mConnection \n Map<String,String> mCookies \n Random random \n void boundary \n void writeName \n void setParameters \n void newline \n void writeParameter \n void writeParameter \n void writeParameter \n HttpURLConnection post \n String randomString \n void postCookies \n void writeln \n void pipe \n void write \n void write", "output": "void function ( String arg0 , Object arg1 ) { mParameters . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the namespace uris found in the given xml file ", "input": " SAXParserFactory factory \n void setFactory \n XmlNamespaceFinder createNamespaceFinder \n SAXParserFactory getFactory", "output": "Set < String > function ( InputSource arg0 ) { XmlNamespaceFinder loc0 = createNamespaceFinder ( ) ; Set < String > loc1 = loc0 . parseContents ( arg0 ) ; if ( factory == null ) { factory = loc0 . getFactory ( ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nput list of task id to its queue ", "input": " ReentrantLock takeLock \n LinkedList<List<Integer>> taskIdsQueue \n Condition notEmpty \n LinkedBlockingQueue<BoltMsg> boltMsgQueue \n void putBoltMsg \n Object poll", "output": "void function ( List < Integer > arg0 ) { takeLock . lock ( ) ; try { taskIdsQueue . add ( arg0 ) ; notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } }"}, {"instruction": "Generate java code\nenable or disable debug mode by default , debug mode is enabled for development builds and disabled for exported apks - see buildconfig.debug ", "input": " int LOG_GENERAL \n OnLogListener logListener \n int LOG_COMMAND \n int LOG_NONE \n int LOG_ALL \n int logTypes \n int LOG_OUTPUT \n boolean sanityChecks \n boolean debug \n String TAG \n void setOnLogListener \n boolean getSanityChecksEnabled \n OnLogListener getOnLogListener \n void log \n void logCommon \n void onLog \n void setSanityChecksEnabled \n boolean getLogTypeEnabledEffective \n boolean getDebug \n void logCommand \n boolean getLogTypeEnabled \n void logOutput \n void setLogTypeEnabled \n boolean getSanityChecksEnabledEffective \n boolean onMainThread", "output": "void function ( boolean arg0 ) { debug = arg0 ; }"}, {"instruction": "Generate java code\nreturns the label of a path . ", "input": " String CODE_DELIMITERS \n String FILE_PATTERN_DELIMITERS \n String URL_DELIMITERS \n String getJavaCodeString \n String getWorkingSetLabel \n String getURLPart \n String getJavaElementName \n String getFilePattern \n String getResourceName \n String getResourceName \n String getVersionName \n String getFileName", "output": "String function ( IPath arg0 , boolean arg1 ) { String loc0 ; if ( arg1 ) { loc0 = arg0 . toOSString ( ) ; } else { loc0 = arg0 . makeRelative ( ) . toString ( ) ; } return Strings . markLTR ( loc0 ) ; }"}, {"instruction": "Generate java code\nanswer the condition monitor ", "input": " ConditionMonitor INSTANCE \n void add \n void add \n void removeAll \n int process \n com.windowtester.runtime.condition.ICondition[] getConditions \n void removeHandler", "output": "ConditionMonitor function ( ) { return INSTANCE ; }"}, {"instruction": "Generate java code\ngets the value of ours ", "input": " long theirs \n long ours \n String description \n int iterations \n int getIterations \n void setIterations \n void setOurs \n long getOurAvg \n String toString \n void setDescription \n void setTheirs \n long getTheirs \n String getDescription \n long getTheirAvg", "output": "long function ( ) { return this . ours ; }"}, {"instruction": "Generate java code\ncharacteristic of this ring . ", "input": " int blocksize \n GenMatrix<C> ZERO \n int DEFAULT_BSIZE \n GenMatrix<C> ONE \n Logger logger \n RingFactory<C> coFac \n float density \n int rows \n int cols \n Random random \n float DEFAULT_DENSITY \n GenMatrix<C> randomUpper \n GenMatrix<C> randomUpper \n GenMatrix<C> randomLower \n GenMatrix<C> randomLower \n GenMatrixRing<C> product \n GenMatrix<C> fromList \n boolean isField \n boolean isCommutative \n GenMatrix<C> parse \n GenMatrix<C> parse \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n int hashCode \n boolean equals \n GenMatrix<C> getONE \n GenMatrix<C> getZERO \n GenMatrix<C> fromInteger \n GenMatrix<C> fromInteger \n String toString \n boolean isAssociative \n GenMatrixRing<C> transpose \n GenMatrix<C> copy", "output": "java . math . BigInteger function ( ) { return coFac . characteristic ( ) ; }"}, {"instruction": "Generate java code\ntests that a class available in a jar , which is added as a class-path manifest attribute of a . rar is available for access from within a class in a . war deployment , belonging to the same . ear top level deployment . this tests section 8.3 of java ee6 spec ", "input": " PlaceHolder placeHolder \n Archive<?> createDeployment", "output": "void function ( @ ArquillianResource URL arg0 ) { final String loc0 = \"srini_string\" + arg0 . getHost ( ) + \"srini_string\" + arg0 . getPort ( ) + \"srini_string\" + JarClass . class . getName ( ) ; final String loc1 = HttpRequest . get ( loc0 , 2 , TimeUnit . SECONDS ) ; Assert . assertEquals ( Servlet . SUCCESS , loc1 ) ; }"}, {"instruction": "Generate java code\ninserts all the fonts recognized by itext in the directory into the map . the encoding will be basefont.cp1252 but can be changed later . ", "input": " HashMap<String,String> aliases \n String fontName \n byte pfb[] \n HashMap<String,BaseFontParameters> mapper \n boolean cached \n byte ttfAfm[] \n String encoding \n boolean embedded \n void putName \n HashMap<String,String> getAliases \n BaseFont awtToPdf \n void putAlias \n Font pdfToAwt \n int insertFile \n HashMap<String,BaseFontParameters> getMapper \n BaseFontParameters getBaseFontParameters \n void insertNames", "output": "int function ( String arg0 ) { File loc0 = new File ( arg0 ) ; if ( ! loc0 . exists ( ) || ! loc0 . isDirectory ( ) ) return 0 ; File loc1 [ ] = loc0 . listFiles ( ) ; if ( loc1 == null ) return 0 ; int loc2 = 0 ; for ( int loc3 = 0 ; loc3 < loc1 . length ; ++ loc3 ) { loc2 += insertFile ( loc1 [ loc3 ] ) ; } return loc2 ; }"}, {"instruction": "Generate java code\nlog the specified message and object ", "input": " ILog sysOutLog \n PrintWriter sysOut \n ILog log \n String PRODUCT_ID \n void setLog \n void printLogObject \n void removeLogListener \n void logNoHeader \n void logStackTrace \n void printLogStatus \n IStatus createLogStatus \n void printLogMessage \n void printLog \n void close \n void addLogListener \n org.osgi.framework.Bundle getBundle", "output": "void function ( String arg0 , Object arg1 ) { if ( Tracer . isDebugging ( ) ) printLog ( sysOut , arg0 , arg1 ) ; IStatus loc0 = createLogStatus ( arg0 , arg1 , \"srini_string\" ) ; try { log . log ( loc0 ) ; } catch ( Throwable loc1 ) { } }"}, {"instruction": "Generate java code\nsets the value of the nresults property . ", "input": " BigInteger nresults \n BigInteger getNresults", "output": "void function ( BigInteger arg0 ) { this . nresults = arg0 ; }"}, {"instruction": "Generate java code\nstore an invalid script exception describing the proper script usage . this should be used by derived classes whenever parsing indicates invalid input . ", "input": " String description \n Resolver resolver \n String copyright \n Throwable invalidScriptError \n WidgetTester tester \n String toXMLString \n String getXMLTag \n Widget resolve \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n String getDescription \n String getDefaultDescription \n void runStep \n WidgetTester resolveTester \n void setScriptError \n HashMap createAttributeMap \n HashMap getAttributes \n void writeObject \n Element addContent \n void parseStepAttributes \n String getUsage \n void readObject \n String toEditableString \n Step createStep \n Step createStep \n Class resolveClass \n WidgetFinder getFinder \n Resolver getResolver", "output": "void function ( String arg0 ) { String loc0 = getUsage ( ) ; if ( arg0 != null ) { MessageFormat loc1 = new MessageFormat ( Strings . get ( \"srini_string\" ) ) ; loc0 = loc1 . format ( new Object [ ] { loc0 , arg0 } ) ; } setScriptError ( new InvalidScriptException ( loc0 ) ) ; }"}, {"instruction": "Generate java code\ntest whether the widget in question is showing . ", "input": " IUIContext ui \n IWidgetLocator locator \n placeholderType placeHolder", "output": "boolean function ( ) { return ui . findAll ( locator ) . length == 1 ; }"}, {"instruction": "Generate java code\nreturns a unit vector based on an angular direction . for example , angle 0 creates vector 0,1 , angle pi/2 creates vector 1,0 . ", "input": " VectorXZ NULL_VECTOR \n VectorXZ Z_UNIT \n double x \n VectorXZ X_UNIT \n double z \n VectorXZ add \n Function<VectorXZ,VectorXYZ> xyzFunction \n double angleTo \n VectorXZ mult \n List<VectorXYZ> listXYZ \n double lengthSquared \n double distance \n VectorXZ invert \n VectorXZ subtract \n double dot \n double length \n double distanceTo \n double angleBetween \n double distanceSquared \n double getX \n double getY \n double getZ \n int hashCode \n VectorXZ normalize \n boolean equals \n VectorXYZ xyz \n double angle \n String toString \n VectorXZ rightNormal", "output": "VectorXZ function ( double arg0 ) { return new VectorXZ ( sin ( arg0 ) , cos ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreads 16-bit rgb and converts it to 24-bit rgb . endian is defined by input stream . ", "input": " byte[] byteBuf \n void writeInt24LE \n void readRGBs555to24 \n void readInts24LE \n void writeInts24LE \n void readRGBs565to24 \n void writeInts24 \n int readInt24LE \n int readRGB555to24 \n void readRGBs555to24LE \n int readRGB555to24LE \n void writeInt24", "output": "int function ( ImageInputStream arg0 ) { int loc0 = arg0 . readUnsignedShort ( ) ; return ( ( loc0 & 0xf800 ) << 8 ) | ( ( loc0 & 0x3800 ) << 5 ) | ( ( loc0 & 0x07e0 ) << 5 ) | ( ( loc0 & 0x0060 ) << 3 ) | ( ( loc0 & 0x001f ) << 3 ) | ( ( loc0 & 0x0007 ) ) ; }"}, {"instruction": "Generate java code\nexecutes the closure whose matching predicate returns true ", "input": " Closure[] iClosures \n Predicate[] iPredicates \n long serialVersionUID \n Closure iDefault \n Closure getDefaultClosure \n Closure[] getClosures \n Closure getInstance \n Closure getInstance \n Predicate[] getPredicates", "output": "void function ( Object arg0 ) { for ( int loc0 = 0 ; loc0 < iPredicates . length ; loc0 ++ ) { if ( iPredicates [ loc0 ] . evaluate ( arg0 ) == true ) { iClosures [ loc0 ] . execute ( arg0 ) ; return ; } } iDefault . execute ( arg0 ) ; }"}, {"instruction": "Generate java code\nread the random bytes from an input file and store them into an arraylist . ", "input": " File inputFile \n ArrayList<Byte> bytes \n File outputImage \n BufferedImage getGrayscale \n boolean create", "output": "boolean function ( ArrayList < Byte > arg0 ) { try { FileInputStream loc0 = new FileInputStream ( inputFile ) ; byte [ ] loc1 = new byte [ 1 ] ; while ( loc0 . read ( loc1 ) != - 1 ) { arg0 . add ( new Byte ( loc1 [ 0 ] ) ) ; } loc0 . close ( ) ; return true ; } catch ( Exception loc3 ) { loc3 . printStackTrace ( ) ; } return false ; }"}, {"instruction": "Generate java code\nreturns the derivative of the polynomial spline function as a univariaterealfunction ", "input": " int n \n long serialVersionUID \n PolynomialFunction polynomials[] \n double knots[] \n double[] getKnots \n boolean isStrictlyIncreasing \n PolynomialSplineFunction polynomialSplineDerivative \n int getN \n PolynomialFunction[] getPolynomials \n double value", "output": "UnivariateRealFunction function ( ) { return polynomialSplineDerivative ( ) ; }"}, {"instruction": "Generate java code\nalways throw an exception . ", "input": " Closure INSTANCE \n long serialVersionUID \n Closure getInstance", "output": "void function ( Object arg0 ) { throw new FunctorException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the type of the rightermost child atom . most atoms have no child atoms , so the `` left type '' and the `` right type '' are the same : the atom 's type . this also is the default implementation . but some atoms are composed of child atoms put one after another in a horizontal row . these atoms must override this method . ", "input": " int type \n int type_limits \n int alignment \n int getLeftType \n Box createBox \n Atom clone", "output": "int function ( ) { return type ; }"}, {"instruction": "Generate java code\ngetter for property mu . ", "input": " int DIGEST_MODE \n BufferedReader filePointer \n int CONSTANT_MODE \n int mode \n double mu \n EmpiricalDistribution empiricalDistribution \n URL valuesFileURL \n double sigma \n RandomDataImpl randomData \n int REPLAY_MODE \n int EXPONENTIAL_MODE \n int GAUSSIAN_MODE \n int UNIFORM_MODE \n EmpiricalDistribution getEmpiricalDistribution \n double getNextUniform \n void closeReplayFile \n void setMode \n double getNext \n void fill \n double[] fill \n double getSigma \n void computeDistribution \n void computeDistribution \n void setMu \n void setValuesFileURL \n void setValuesFileURL \n double getNextReplay \n URL getValuesFileURL \n void setSigma \n void resetReplayFile \n double getNextGaussian \n int getMode \n double getNextDigest \n double getNextExponential", "output": "double function ( ) { return mu ; }"}, {"instruction": "Generate java code\ncreate an doublelistiterator doublelistiterator wrappingthe specified listiterator listiterator . when the given iterator is null , returns null . ", "input": " ListIterator _iterator \n double next \n void add \n void set \n double previous \n boolean hasPrevious \n boolean hasNext \n int nextIndex \n int previousIndex \n void remove", "output": "DoubleListIterator function ( ListIterator arg0 ) { return null == arg0 ? null : new ListIteratorDoubleListIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\nremove all countries that are not defined in the set ", "input": " HashMap<String,String[]> countryLookup \n ArrayList<String> pingErCountry \n ArrayList<String> pingErRegion \n long serialVersionUID \n Logger log \n HashMap<String,String> pingErCountryRegions \n String pingErCountryRegionFilename \n void importPingErCountryRegionFile \n String getGeoIpCountryName \n String getPingErCountryName \n boolean containsPingErCountryOrRegion \n ArrayList<String> getPingErRegions \n void addCountryFromGeoIP \n String getPingErCountryRegionFilename \n Element exportToXML \n void assignCountryCodeToPingErData \n Set<String> getCountryCodes \n String getPingErRegionName \n ArrayList<String> getPingErCountrys \n void importFromXML \n void importFromXML", "output": "void function ( Set < String > arg0 ) { countryLookup . keySet ( ) . retainAll ( arg0 ) ; }"}, {"instruction": "Generate java code\nset the parser for a given class . returns the old one , if any . ", "input": " String copyright \n HashMap parsers \n Object[] eval \n Object eval \n Parser getParser \n String replace \n String[] parseArgumentList \n String unescapeBrackets \n Parser findParser \n String substitute \n boolean isExtension", "output": "Parser function ( Class arg0 , Parser arg1 ) { Parser loc0 = ( Parser ) parsers . get ( arg0 ) ; parsers . put ( arg0 , arg1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn a unmodifiable list that has all elements of the given collection . ", "input": " PlaceHolder placeHolder \n T getNthIteratedElement \n T getNthIteratedElement \n boolean containsIdentical \n List<String> prefix \n T removeMatching \n String toStringInLines \n List<String> toStringLines \n SortedSet<Integer> findAll \n String toStringInSortedLines \n List<List<T>> chunkUp \n boolean areDisjoint \n Set<T> intersection \n Set<T> xor \n String join \n List<T> map \n Set<T> getAll \n boolean containsEquivalent \n Set<T> diff \n Map<Integer,Set<Object[]>> createPerArityGroups \n Set<T> union \n List<T> concat \n List<String> sort \n List<T> concatAll \n boolean allInstancesOf \n List<T> unique \n List<List<T>> allCombinations \n T[] addToArray", "output": "List < T > function ( Collection < T > arg0 ) { return Collections . unmodifiableList ( new ArrayList < T > ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nget kdc tcp port ", "input": " KdcConfig kdcConfig \n BackendConfig backendConfig \n KOptions startupOptions \n int getKdcPort \n String getKdcRealm \n int checkGetKdcTcpPort \n int getKdcUdpPort \n int checkGetKdcUdpPort \n boolean allowTcp \n boolean allowUdp \n KdcConfig getKdcConfig \n String getKdcHost \n BackendConfig getBackendConfig", "output": "int function ( ) { int loc0 = startupOptions . getIntegerOption ( KdcServerOption . KDC_TCP_PORT ) ; if ( loc0 < 1 ) { loc0 = kdcConfig . getKdcTcpPort ( ) ; } if ( loc0 < 1 ) { loc0 = getKdcPort ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nload a map for the current locale to translate a character into a corresponding virtual keycode-based keystroke . ", "input": " KeyStrokeMapProvider generator \n Map chars \n boolean loaded \n Map characterMap \n Map keyStrokeMap \n Map keycodes \n Map generateKeyStrokeMappings \n void loadMaps \n Map getKeyStrokeMap \n Map getCharacterMap \n InputStream findMap \n void main \n KeyStroke getKeyStroke \n String[] getMapNames \n String[] getMapDescriptions \n String getOSType \n char getChar \n String getFilename \n Map generateCharacterMappings \n KeyStrokeMapProvider getGenerator \n Map loadKeyStrokeMap \n String[] getMapStrings", "output": "Map function ( ) { loadMaps ( ) ; return characterMap ; }"}, {"instruction": "Generate java code\ncleans str by replacing all characters that are not valid java indentifier parts with '' _ '' . ", "input": " int dkconfig_compile_timeout \n Logger debug \n FileCompiler fileCompiler \n boolean dkconfig_delete_splitters_on_exit \n String tempdir \n int guid \n String dkconfig_compiler \n boolean matchPptRegex \n void compileFiles \n SpinfoFileParser parse_spinfofile \n void loadSplitters \n String createTempDir \n void load_splitters \n boolean matchPpt \n String getFileName \n String getTempDir \n void printAll \n void debugPrintln", "output": "String function ( String arg0 ) { char [ ] loc0 = arg0 . toCharArray ( ) ; for ( int loc1 = 0 ; loc1 < loc0 . length ; loc1 ++ ) { char loc2 = loc0 [ loc1 ] ; if ( ! Character . isJavaIdentifierPart ( loc2 ) ) { loc0 [ loc1 ] = '_' ; } } return new String ( loc0 ) ; }"}, {"instruction": "Generate java code\nmodinteger comparison . ", "input": " java.math.BigInteger val \n ModIntegerRing ring \n ModInteger MIREM \n java.math.BigInteger getSymmetricVal \n int MISIGN \n ModInteger gcd \n ModInteger sum \n ModInteger MINEG \n ModInteger MISUM \n int hashCode \n ModInteger MIDIF \n ModInteger divide \n ModInteger multiply \n int signum \n boolean isONE \n ModInteger inverse \n int MICOMP \n java.math.BigInteger getVal \n boolean isUnit \n ModInteger subtract \n ModInteger MIABS \n ModInteger MIINV \n ModInteger[] egcd \n java.math.BigInteger getModul \n ModInteger abs \n ModInteger MIQ \n ModInteger negate \n boolean equals \n ModInteger clone \n boolean isZERO \n String toString \n ModInteger MIPROD \n ModInteger remainder", "output": "int function ( ModInteger arg0 ) { java . math . BigInteger loc0 = arg0 . val ; if ( ring != arg0 . ring ) { loc0 = loc0 . mod ( ring . modul ) ; } return val . compareTo ( loc0 ) ; }"}, {"instruction": "Generate java code\nunambiguous identification of a account ", "input": " Pattern bicRegex \n PartyIdentification32 createParty \n RemittanceInformation5 createRmtInf_struct \n XMLGregorianCalendar createXMLGregorianCalendarDate \n RemittanceInformation5 createRmtInf \n BranchAndFinancialInstitutionIdentification4 createFinInstnId \n XMLGregorianCalendar createXMLGregorianCalendar \n AmountType3Choice createAmount", "output": "CashAccount16 function ( String arg0 ) { CashAccount16 loc0 = new CashAccount16 ( ) ; AccountIdentification4Choice loc1 = new AccountIdentification4Choice ( ) ; loc1 . setIBAN ( arg0 ) ; loc0 . setId ( loc1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncreates an unmarshaller from the sardineutil #jaxb_context . note : the unmarshaller is not thread safe , so it must be created for every request . ", "input": " JAXBContext JAXB_CONTEXT \n String CUSTOM_NAMESPACE_URI \n String DEFAULT_NAMESPACE_URI \n String DEFAULT_NAMESPACE_PREFIX \n List<ThreadLocal<SimpleDateFormat>> DATETIME_FORMATS \n String CUSTOM_NAMESPACE_PREFIX \n String[] SUPPORTED_DATE_FORMATS \n DocumentBuilderFactory factory \n Marshaller createMarshaller \n Date parseDate \n T unmarshal \n Map<QName,String> toQName \n List<QName> toQName \n QName toQName \n QName createQNameWithCustomNamespace \n String toXml \n Element createElement \n Element createElement \n Document createDocument \n QName createQNameWithDefaultNamespace", "output": "Unmarshaller function ( ) { try { return JAXB_CONTEXT . createUnmarshaller ( ) ; } catch ( JAXBException loc0 ) { throw new RuntimeException ( loc0 . getMessage ( ) , loc0 ) ; } }"}, {"instruction": "Generate java code\ndiscards any characters outside of the base64 alphabet see page 25 of rfc 2045 `` any characters outside of the base64 alphabet are to be ignored in base64 encoded data . '' ", "input": " byte[] decodingTable \n byte[] encodingTable \n void encode \n byte[] encode \n int computeEncodedSize \n byte[] decode \n byte[] decode \n String decode \n String decode \n boolean isValidBase64Byte \n String discardNonBase64Chars", "output": "byte [ ] function ( byte [ ] arg0 ) { byte loc0 [ ] = new byte [ arg0 . length ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0 . length ; loc2 ++ ) { if ( isValidBase64Byte ( arg0 [ loc2 ] ) ) { loc0 [ loc1 ++ ] = arg0 [ loc2 ] ; } } byte loc3 [ ] = new byte [ loc1 ] ; System . arraycopy ( loc0 , 0 , loc3 , 0 , loc1 ) ; return loc3 ; }"}, {"instruction": "Generate java code\nget a message with one parameter as an primitive int . the parameter will replace the string '' 1 '' found in the message . ", "input": " String BASE_PATH \n HashMap<String,String> currentLanguage \n HashMap<String,String> defaultLanguage \n HashMap<String,String> getLanguageMessages \n String getMessage \n String getMessage \n void setMessages \n HashMap<String,String> readLanguageStream \n HashMap<String,String> readLanguageStream \n boolean setLanguage", "output": "String function ( String arg0 , int arg1 ) { return getComposedMessage ( arg0 , String . valueOf ( arg1 ) , null , null , null ) ; }"}, {"instruction": "Generate java code\nattach a non-null propertychangelistener to this object . ", "input": " IPropertyDescriptor[] EMPTY_ARRAY \n PropertyChangeSupport pcsDelegate \n long serialVersionUID \n void firePropertyChange \n Object getPropertyValue \n void setPropertyValue \n Object getEditableValue \n IPropertyDescriptor[] getPropertyDescriptors \n void resetPropertyValue \n boolean isPropertySet \n void removePropertyChangeListener \n void readObject", "output": "void function ( PropertyChangeListener arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( ) ; } pcsDelegate . addPropertyChangeListener ( arg0 ) ; }"}, {"instruction": "Generate java code\ncreates a new instance . ", "input": " ReflectConstructor _constructor \n Object[] _args \n ReflectConstructorSpec UNSPECIFIED_CONSTRUCTOR \n TernaryBool _canBeInstantiated \n ReflectConstructorSpec INVALID_CONSTRUCTOR \n TernaryBool canBeInstantiated", "output": "Object function ( ) { if ( _constructor == null ) { return null ; } return _constructor . newInstance ( _args ) ; }"}, {"instruction": "Generate java code\ninterpret a short as its binary form ", "input": " PlaceHolder placeHolder \n long asLong \n int toInt \n String toBinaryString \n String toBinaryString \n String toBinaryString \n byte[] fromInt \n byte[] fromLong", "output": "byte [ ] function ( int arg0 ) { byte [ ] loc0 = new byte [ 2 ] ; loc0 [ 0 ] = ( byte ) ( arg0 >> 8 ) ; loc0 [ 1 ] = ( byte ) ( ( arg0 << 8 ) >> 8 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nserialize tree using preorder dfs ", "input": " int index \n Node deserializeUtil \n String serializeLevelOrder \n void serializeUtil \n void main \n Node deserializeLevelOrder \n Node deserialize", "output": "String function ( Node arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; serializeUtil ( arg0 , loc0 ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ncopy a file if the source exist . ", "input": " int BUFSIZE \n Logger LOG \n ThreadLocal cwd_ \n void mkLink \n void mkLink \n void fileCopy \n void warn \n String calcRelativeLink \n void debug \n String getArtifact \n String run \n void setCwd \n String mavenCopy \n void error \n void info", "output": "void function ( final String arg0 , final String arg1 ) { fileCopyIfExist ( arg0 , arg1 , false ) ; }"}, {"instruction": "Generate java code\ncheck whether servlet which uses runas with different role than in needed for secured ejb invocation can not correctly invoked that ejb method in httpservlet.destroy method during stopping server . ", "input": " String DEPLOYMENT \n String incorrectRoleResult \n File CORRECT_ROLE_AND_UNDEPLOY \n String correctRoleResult \n File WORK_DIR \n ManagementClient managementClient \n Deployer deployer \n File INCORRECT_ROLE_AND_STOP_SERVER \n File INCORRECT_ROLE_AND_UNDEPLOY \n File CORRECT_ROLE_AND_STOP_SERVER \n void checkDoGetMethodWithCorrectRole \n void runDestroyMethodInUndeploying \n void checkDoGetMethodWithIncorrectRole \n void checkDestroyInUndeployingMethodWithIncorrectRole \n String readFirstLineOfFile \n void checkDestroyMethodInStopServerWithCorrectRole \n void checkInitMethodWithIncorrectRole \n void checkInitMethodWithCorrectRole \n void checkDestroyInUndeployingMethodWithCorrectRole \n void runServletWithCorrectRole \n void finish \n void initialize \n void runServletWithIncorrectRole \n void runDestroyMethodInStopServer \n WebArchive deployment", "output": "void function ( ) { assertTrue ( \"srini_string\" + \"srini_string\" , readFirstLineOfFile ( INCORRECT_ROLE_AND_STOP_SERVER ) . contains ( DESTROY_METHOD_NOT_PASS ) ) ; }"}, {"instruction": "Generate java code\nobtains the tracked route . if a route has been tracked , it is #isconnected connected . if not connected , nothing has been tracked so far . ", "input": " boolean connected \n HttpHost targetHost \n TunnelType tunnelled \n InetAddress localAddress \n HttpHost[] proxyChain \n boolean secure \n LayerType layered \n void connectProxy \n HttpHost getProxyHost \n boolean isConnected \n TunnelType getTunnelType \n boolean isSecure \n LayerType getLayerType \n InetAddress getLocalAddress \n void tunnelTarget \n void layerProtocol \n HttpHost getTargetHost \n void connectTarget \n boolean isTunnelled \n int hashCode \n int getHopCount \n boolean isLayered \n boolean equals \n Object clone \n void reset \n String toString \n void tunnelProxy \n HttpHost getHopTarget", "output": "HttpRoute function ( ) { return ! this . connected ? null : new HttpRoute ( this . targetHost , this . localAddress , this . proxyChain , this . secure , this . tunnelled , this . layered ) ; }"}, {"instruction": "Generate java code\nreturns always null . ", "input": " IStatus OK_STATUS \n String fStatusMessage \n int fSeverity \n boolean isWarning \n int getSeverity \n String getMessage \n boolean isMultiStatus \n boolean matches \n IStatus[] getChildren \n boolean isError \n void setError \n boolean isOK \n String getPlugin \n void setOK \n String toString \n void setInfo \n boolean isInfo \n int getCode \n void setWarning", "output": "Throwable function ( ) { return null ; }"}, {"instruction": "Generate java code\ngets the field type at the specifed index . ", "input": " PlaceHolder placeHolder \n int[] getValues \n boolean isEqual \n DateTimeField getField \n DateTimeField getField \n int indexOfSupported \n int indexOfSupported \n boolean isSupported \n int compareTo \n boolean isBefore \n DateTimeField[] getFields \n int hashCode \n int get \n boolean equals \n String toString \n int indexOf \n int indexOf \n boolean isAfter \n DateTime toDateTime \n DateTimeFieldType[] getFieldTypes", "output": "DateTimeFieldType function ( int arg0 ) { return getField ( arg0 , getChronology ( ) ) . getType ( ) ; }"}, {"instruction": "Generate java code\nreturns whether windows send mouse motion events to awt listeners . ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean hasMultiClickFrameBug \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isOSX ( ) && Platform . JAVA_VERSION >= Platform . JAVA_1_4 && Platform . JAVA_VERSION <= 0x1425 ; }"}, {"instruction": "Generate java code\ndetermines the difference in days between d and this date . for example , if this date is 12/15/1997 and d is 12/14/1997 , the difference is 1 . if this date occurs before d , the result is negative . ", "input": " int month \n int year \n int day \n int daysInMonth \n int beginOfTime \n int dayInYear \n boolean isLeapYear \n boolean isValidDate \n String toString \n void main \n int daysInYear \n boolean isAfter \n boolean isBefore", "output": "int function ( Date arg0 ) { int loc0 ; int loc1 = Math . abs ( arg0 . beginOfTime ( ) - this . beginOfTime ( ) ) ; if ( this . isBefore ( arg0 ) ) { loc0 = - 1 ; } else if ( this . isAfter ( arg0 ) ) { loc0 = 1 ; } else { loc0 = 0 ; } return loc0 * loc1 ; }"}, {"instruction": "Generate java code\nmaintains a count of the number of methods call sites resolve to . may give an idea as to how `` dynamic '' a program is . ", "input": " String configName \n int nLiveMethods \n Map morphicity \n int nNoPreexist \n int nLiveClasses \n int nInlined \n void noteNoPreexist \n void printSummary \n void noteInlined \n void setConfigName \n void noteLiveMethods \n void noteLiveClasses", "output": "void function ( final int arg0 ) { final Integer loc0 = new Integer ( arg0 ) ; final Integer loc1 = ( Integer ) this . morphicity . get ( loc0 ) ; if ( loc1 == null ) { this . morphicity . put ( loc0 , new Integer ( 1 ) ) ; } else { this . morphicity . put ( loc0 , new Integer ( loc1 . intValue ( ) + 1 ) ) ; } }"}, {"instruction": "Generate java code\nverifies that the endpoints specify an interval , throws illegalargumentexception if not ", "input": " double functionValueAccuracy \n boolean resultComputed \n double defaultFunctionValueAccuracy \n UnivariateRealFunction f \n double relativeAccuracy \n double absoluteAccuracy \n double result \n int iterationCount \n int defaultMaximalIterationCount \n int maximalIterationCount \n double defaultAbsoluteAccuracy \n double defaultRelativeAccuracy \n long serialVersionUID \n double getFunctionValueAccuracy \n void setAbsoluteAccuracy \n void verifySequence \n boolean isSequence \n void setResult \n void setRelativeAccuracy \n void resetFunctionValueAccuracy \n int getMaximalIterationCount \n void resetRelativeAccuracy \n double getAbsoluteAccuracy \n int getIterationCount \n void resetAbsoluteAccuracy \n double getResult \n void setMaximalIterationCount \n void resetMaximalIterationCount \n boolean isBracketing \n void clearResult \n void verifyBracketing \n double getRelativeAccuracy \n void setFunctionValueAccuracy", "output": "void function ( double arg0 , double arg1 ) { if ( arg0 >= arg1 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 + \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nbinds this connection to the given socket . this socket will be used by the connection to send and receive data . after this method 's execution the connection status will be reported as open and the #isopen will return true . ", "input": " SessionInputBufferImpl inbuffer \n HttpConnectionMetricsImpl connMetrics \n ContentLengthStrategy outgoingContentStrategy \n SessionOutputBufferImpl outbuffer \n Socket socket \n ContentLengthStrategy incomingContentStrategy \n boolean open \n void setSocketTimeout \n int getLocalPort \n HttpConnectionMetrics getMetrics \n OutputStream createOutputStream \n int getRemotePort \n InetAddress getLocalAddress \n void ensureOpen \n boolean awaitInput \n void close \n void incrementResponseCount \n void doFlush \n OutputStream prepareOutput \n void incrementRequestCount \n HttpEntity prepareInput \n InetAddress getRemoteAddress \n int fillInputBuffer \n InputStream getSocketInputStream \n int getSocketTimeout \n InputStream createInputStream \n boolean isOpen \n Socket getSocket \n OutputStream getSocketOutputStream \n SessionInputBuffer getSessionInputBuffer \n String toString \n boolean isStale \n SessionOutputBuffer getSessionOutputBuffer \n void shutdown", "output": "void function ( final Socket arg0 ) { Args . notNull ( arg0 , \"srini_string\" ) ; this . socket = arg0 ; this . open = true ; this . inbuffer . bind ( null ) ; this . outbuffer . bind ( null ) ; }"}, {"instruction": "Generate java code\nconstructor for handshake message ", "input": " ByteBuffer peerId \n HashMap<String,Object> data \n MessageType type \n ByteBuffer msg \n Message Bitfield \n int getBegin \n int getIndex \n MessageType getType \n ByteBuffer getPeerId \n Message Request \n int getLength \n int compareTo \n ByteBuffer getBytes \n BitSet getBitfield", "output": "Message function ( ByteBuffer arg0 , ByteBuffer arg1 ) { Message loc0 = new Message ( arg0 ) ; loc0 . type = MessageType . Handshake ; loc0 . data . put ( \"srini_string\" , arg1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nsets the type of message that is intended to be transmitted over the connection that this collection is associated with . ", "input": " Map<String,MessageType> myMsgTypeByMd5Sum \n Map<String,Map<String,MessageType>> myMsgTypesByPackage \n String myTopType \n Logger myLogger \n Splitter MSG_SPLITTER \n Map<String,MessageType> myMsgTypesByName \n MessageType getMessageType \n MessageType getMessageType \n MessageType getMessageType \n List<String> parseMessageList \n void parseMessages", "output": "void function ( String arg0 ) { myTopType = arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the items property . ", "input": " USAddress billTo \n String comment \n Items items \n XMLGregorianCalendar orderDate \n USAddress shipTo \n USAddress getShipTo \n USAddress getBillTo \n void setBillTo \n void setItems \n void setOrderDate \n void setComment \n XMLGregorianCalendar getOrderDate \n String getComment \n void setShipTo", "output": "Items function ( ) { return items ; }"}, {"instruction": "Generate java code\ncreate an instance of consumedport ", "input": " QName _PropertyDeclaration_QNAME \n QName _ProvidedPort_QNAME \n QName _ApplicationPayload_QNAME \n QName _Application_QNAME \n QName _ApplicationID_QNAME \n QName _ApplicationReleaseBinding_QNAME \n QName _ConsumedPort_QNAME \n QName _ProvidedPortID_QNAME \n ApplicationPayload createApplicationPayload \n JAXBElement<ApplicationPayload> createApplicationPayload \n ProvidedPortID createProvidedPortID \n JAXBElement<ProvidedPortID> createProvidedPortID \n ApplicationReleaseBinding createApplicationReleaseBinding \n JAXBElement<ApplicationReleaseBinding> createApplicationReleaseBinding \n Application createApplication \n JAXBElement<Application> createApplication \n PropertyDeclaration createPropertyDeclaration \n JAXBElement<PropertyDeclaration> createPropertyDeclaration \n ApplicationID createApplicationID \n JAXBElement<ApplicationID> createApplicationID \n ProvidedPort createProvidedPort \n JAXBElement<ProvidedPort> createProvidedPort", "output": "ConsumedPort function ( ) { return new ConsumedPort ( ) ; }"}, {"instruction": "Generate java code\ngetter for the right margin . ", "input": " Rectangle2D.Float textRectangle \n void renderImage \n float getHeight \n float getLlx \n float getLly \n float getWidth \n void beginTextBlock \n void endTextBlock \n float getUry \n void renderText", "output": "float function ( ) { return textRectangle . x + textRectangle . width ; }"}, {"instruction": "Generate java code\ndecide whether or not online checking is allowed . ", "input": " CertificateVerifier verifier \n boolean onlineCheckingAllowed \n List<VerificationOK> verify", "output": "void function ( boolean arg0 ) { this . onlineCheckingAllowed = arg0 ; }"}, {"instruction": "Generate java code\ncreates a new pmml object representing the pmml model defined in the inputstream specified as argument ", "input": " ModelOutputs outFields \n String blobKey \n File model \n Map<String,Object> config \n ModelOutputs modelOutputs \n ModelRunner newModelRunner \n ModelRunner newModelRunner \n InputStream getPmmlModelBlob \n InputStream getPmmlModelBlob \n Evaluator newEvaluator \n Evaluator newEvaluator \n Evaluator newEvaluator \n Evaluator newEvaluator \n Evaluator newEvaluator", "output": "PMML function ( InputStream arg0 ) { Objects . requireNonNull ( arg0 ) ; return IOUtil . unmarshal ( arg0 ) ; }"}, {"instruction": "Generate java code\ndeposit deposits `` amt '' dollars into this account . ", "input": " int number \n int balance \n String name \n int getNumber \n int getKey \n int getBalance \n boolean lessThan \n String toString \n String getOwner \n void withdraw", "output": "void function ( int arg0 ) { if ( arg0 >= 0 ) { balance = balance + arg0 ; } else { System . out . println ( \"srini_string\" + arg0 ) ; } }"}, {"instruction": "Generate java code\ninit the client . ", "input": " String USAGE \n String getPassword \n void requestTicket \n KOptions convertOptions \n void main \n void printUsage", "output": "KrbClient function ( File arg0 ) { KrbClient loc0 ; if ( arg0 != null ) { loc0 = new KrbClient ( arg0 ) ; } else { loc0 = new KrbClient ( ) ; } loc0 . init ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the string representation of this mnemonic . information from the mnemonic string may be retrieved using methodmnemonic #methodmnemonic string , and subsequently the imethod may be retrieved with methodmnemonic #findmethod itype ", "input": " String fMethodSignature \n IMethod fMethod \n char MNEMONIC_DELIMITER \n String fMethodName \n int LENGTH \n boolean fIsConstructor \n String getMethodSignature \n String getMethodName \n IMethod findMethod \n int hashCode \n boolean isConstructor \n boolean equals \n boolean exists \n String getStableSignature \n IMethod getMethod", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( getMethodName ( ) ) ; loc0 . append ( MNEMONIC_DELIMITER ) ; loc0 . append ( isConstructor ( ) ) ; loc0 . append ( MNEMONIC_DELIMITER ) ; loc0 . append ( getMethodSignature ( ) ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ninteger comparison . ", "input": " java.math.BigInteger val \n BigInteger ONE \n BigInteger ZERO \n Random random \n BigInteger IRAND \n boolean isField \n boolean isCommutative \n BigInteger gcd \n BigInteger IPROD \n BigInteger sum \n int compareTo \n BigInteger IABS \n java.math.BigInteger characteristic \n BigInteger random \n BigInteger random \n int hashCode \n BigInteger IDIF \n BigInteger divide \n BigInteger copy \n BigInteger multiply \n BigInteger IGCD \n int signum \n BigInteger ISUM \n boolean isONE \n BigInteger inverse \n java.math.BigInteger getVal \n BigInteger INEG \n BigInteger valueOf \n BigInteger valueOf \n boolean isUnit \n BigInteger subtract \n BigInteger IQ \n BigInteger[] IQR \n BigInteger parse \n BigInteger parse \n BigInteger[] egcd \n int ISIGN \n BigInteger abs \n BigInteger IREM \n BigInteger[] divideAndRemainder \n BigInteger negate \n boolean equals \n BigInteger clone \n BigInteger getONE \n BigInteger getZERO \n BigInteger fromInteger \n BigInteger fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigInteger remainder", "output": "int function ( BigInteger arg0 , BigInteger arg1 ) { if ( arg0 == null ) return - arg1 . signum ( ) ; return arg0 . compareTo ( arg1 ) ; }"}, {"instruction": "Generate java code\nsize of current list . ", "input": " List<java.math.BigInteger> val \n java.math.BigInteger last \n void addMedium \n java.math.BigInteger getLongPrime \n Iterator<java.math.BigInteger> iterator \n java.math.BigInteger get \n void addLarge \n String toString \n void addSmall \n boolean checkPrimes", "output": "int function ( ) { return val . size ( ) ; }"}, {"instruction": "Generate java code\nquotient random . ", "input": " RingFactory<C> ring \n boolean debug \n Logger logger \n int hashCode \n boolean isField \n boolean equals \n Quotient<C> getONE \n boolean isCommutative \n Quotient<C> getZERO \n Quotient<C> fromInteger \n Quotient<C> fromInteger \n boolean isAssociative \n String toString \n Quotient<C> parse \n Quotient<C> parse \n Quotient<C> copy \n java.math.BigInteger characteristic", "output": "Quotient < C > function ( int arg0 , Random arg1 ) { C loc0 = ring . random ( arg0 , arg1 ) ; C loc1 = ring . random ( arg0 , arg1 ) ; while ( loc1 . isZERO ( ) ) { loc1 = ring . random ( arg0 , arg1 ) ; } return new Quotient < C > ( this , loc0 , loc1 , false ) ; }"}, {"instruction": "Generate java code\nfor the given sqlexception , locates the x/open-compliant sqlstate . ", "input": " PlaceHolder placeHolder \n int extractErrorCode \n String extractSqlStateClassCode \n String determineSqlStateClassCode", "output": "String function ( SQLException arg0 ) { String loc0 = arg0 . getSQLState ( ) ; SQLException loc1 = arg0 . getNextException ( ) ; while ( loc0 == null && loc1 != null ) { loc0 = loc1 . getSQLState ( ) ; loc1 = loc1 . getNextException ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nallows for the setting of the border 's color independently of the content 's color . ", "input": " boolean border \n Position position \n ConsoleSystemInterface si \n int width \n String spaces \n Position inPosition \n int inHeight \n CSIColor foreColor \n int height \n CSIColor borderColor \n int inWidth \n void drawBorder \n void clearBox \n void recalcInnerBounds \n int getForeColor \n int getWidth \n void draw \n void setWidth \n void setHeight \n void setBounds \n void setPosition \n void setForeColor \n void setForeColor \n int getHeight \n void setBorder \n boolean hasBorder", "output": "void function ( CSIColor arg0 ) { borderColor = arg0 ; }"}, {"instruction": "Generate java code\na helper to make creating a springconfig easier with values mapping to the origami values . ", "input": " double tension \n double friction \n SpringConfig defaultConfig \n placeholderType placeHolder", "output": "SpringConfig function ( double arg0 , double arg1 ) { return new SpringConfig ( OrigamiValueConverter . tensionFromOrigamiValue ( arg0 ) , OrigamiValueConverter . frictionFromOrigamiValue ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nspecifies that matching pairs of this character delimit string constants . ", "input": " Reader reader \n Error err \n StreamTokenizer stok \n void set_error_handler \n boolean isQString \n void need \n String nextToken \n int ttype \n void tok_error \n void commentChar \n boolean isWord \n String token", "output": "void function ( int arg0 ) { stok . quoteChar ( arg0 ) ; }"}, {"instruction": "Generate java code\nparse an reader ", "input": " String text \n Charset charset \n StateController controller \n XMLParserMemory memory \n List<XMLParserListener> listeners \n TagState tagState \n ParserMonitor monitor \n State state \n XMLParserMemory memory \n void startElement \n InputStreamReader detectEncoding \n char currentLastChar \n XMLParser removeListener \n Charset getCharset \n TagState currentTagState \n void currentTagState \n String current \n void endElement \n void flush \n void parseWithReader \n void unknownData \n String currentTag \n void setMonitor \n String bufferToString \n void setState \n void comment \n StateController selectState \n void text \n XMLParser append \n XMLParser append \n XMLParser append \n void callText \n XMLParser addListener \n int bufferSize", "output": "void function ( final Reader arg0 ) { parseWithReader ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the leftmost x-position of the bounding box . ", "input": " JLabel label \n double xGrow \n double yGrow \n double x \n double y \n Color color \n int getHeight \n int getY \n void grow \n void setColor \n String toString \n int getWidth \n void draw \n void translate \n void paintShape", "output": "int function ( ) { return ( int ) Math . round ( x - xGrow ) ; }"}, {"instruction": "Generate java code\nreturn columns for the schema . ", "input": " Schema schema \n Map<Schema,Schema> seen \n List<ColumnMetaData> columns \n List<Integer> arrayWidths \n String p \n String p \n ColumnMetaData addColumn \n ValueType simpleValueType \n boolean isSimple \n void columnize \n int[] getArrayWidths \n void addArrayColumn", "output": "ColumnMetaData [ ] function ( ) { return columns . toArray ( new ColumnMetaData [ columns . size ( ) ] ) ; }"}, {"instruction": "Generate java code\nthe current state of this machine ", "input": " Map<String,JsonBall> metadata \n Date created \n Type type \n Set<String> ips \n ImmutableSet.Builder<String> ips \n ImmutableMap.Builder<String,JsonBall> metadata \n String name \n String id \n State state \n Function<JsonBall,String> unquoteString \n String dataset \n int memorySizeMb \n Date updated \n int diskSizeGb \n Builder toBuilder \n Builder metadata \n String getName \n String getId \n int compareTo \n Builder type \n Date getUpdated \n Map<String,String> getMetadataAsJsonLiterals \n int hashCode \n Builder builder \n Builder id \n Builder state \n String value \n String value \n Builder memorySizeMb \n Type fromValue \n State fromValue \n Map<String,String> getMetadata \n String apply \n Builder created \n int getDiskSizeGb \n String getDatasetURN \n Date getCreated \n Builder addMetadata \n Builder ips \n Builder addIp \n int getMemorySizeMb \n Builder fromMachine \n Machine build \n Type getType \n boolean equals \n Builder name \n String toString \n String toString \n String toString \n Builder dataset \n Builder updated \n Set<String> getIps \n Builder diskSizeGb", "output": "State function ( ) { return state ; }"}, {"instruction": "Generate java code\nthe amount of hits for this query ", "input": " long executionMaxTime \n String[] ITEM_DESCRIPTIONS \n long cacheHitCount \n String query \n String TABULAR_TYPE_NAME \n long cachePutCount \n CompositeType COMPOSITE_TYPE \n long cacheMissCount \n String[] INDEX_NAMES \n long executionAvgTime \n long executionMinTime \n String COMPOSITE_TYPE_NAME \n OpenType[] ITEM_TYPES \n long executionCount \n String[] ITEM_NAMES \n String COMPOSITE_TYPE_DESCRIPTION \n long executionRowCount \n TabularType TABULAR_TYPE \n String TABULAR_TYPE_DESCRIPTION \n void add \n long getCachePutCount \n TabularData newTabularDataInstance \n long getExecutionCount \n long getExecutionAvgTime \n long getCacheMissCount \n long getExecutionRowCount \n long getExecutionMinTime \n QueryStats[] fromTabularData \n String toString \n CompositeData toCompositeData \n String getQuery \n long getExecutionMaxTime", "output": "long function ( ) { return cacheHitCount ; }"}, {"instruction": "Generate java code\ntests construction of the client chain . the created certificates can be displayed with a command like : openssl pkcs12 - nodes - info - in / tmp/test . p12 > / tmp/test . cert & & openssl x509 - noout - text - in / tmp/test . cert ", "input": " PlaceHolder placeHolder \n void validateChain \n void testKdcChain \n void setUp", "output": "void function ( ) { X509Certificate [ ] loc0 = CertificateChainFactory . getClientChain ( ) ; validateChain ( loc0 ) ; }"}, {"instruction": "Generate java code\nparse key-value pairs to map , ignore empty key ", "input": " String DEFAULT_KEY_AND_VALUE_PAIR_SEPARATOR \n String DEFAULT_KEY_AND_VALUE_SEPARATOR \n K getKeyByValue \n boolean putMapNotNullKeyAndValue \n String toJson \n boolean putMapNotEmptyKeyAndValue \n boolean putMapNotEmptyKeyAndValue \n boolean putMapNotNullKey \n boolean isEmpty \n boolean putMapNotEmptyKey", "output": "Map < String , String > function ( String arg0 , boolean arg1 ) { return parseKeyAndValueToMap ( arg0 , DEFAULT_KEY_AND_VALUE_SEPARATOR , DEFAULT_KEY_AND_VALUE_PAIR_SEPARATOR , arg1 ) ; }"}, {"instruction": "Generate java code\nappends a column separator to the output file . ", "input": " Logger log \n String description \n int clusterIDLength \n String style \n boolean started \n String fileDescr \n String seed \n int BUFFER_CAPACITY \n String filePrefix \n String fileSuffix \n PrintWriter out \n void appendClusterID \n void setOutputFilePrefix \n void stopped \n void start \n void appendNewLine \n void started \n void setDescription \n boolean isStarted \n void setOutputFileSuffix \n void setOutputFile \n void setOutputFileDescr \n void stop \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void setStyle \n void setSeed \n String getFileName", "output": "void function ( ) { if ( out != null ) { out . print ( ' ' ) ; } }"}, {"instruction": "Generate java code\nfires a label provider changed event to all registered listeners only listeners registered at the time this method is called are notified . ", "input": " ArrayList<ILabelDecorator> fLabelDecorators \n JavaElementImageProvider fImageLabelProvider \n ListenerList<ILabelProviderListener> fListeners \n StorageLabelProvider fStorageLabelProvider \n int fImageFlags \n long fTextFlags \n ILabelDecorator[] getDecorators \n StyledString getStyledText \n void addLabelDecorator \n String getText \n String decorateText \n void removeListener \n void setImageFlags \n Color getForeground \n Image decorateImage \n long getTextFlags \n long evaluateTextFlags \n void dispose \n void setTextFlags \n Image getImage \n boolean isLabelProperty \n Color getBackground \n int evaluateImageFlags \n int getImageFlags \n void addListener", "output": "void function ( final LabelProviderChangedEvent arg0 ) { for ( final ILabelProviderListener loc0 : fListeners ) { SafeRunner . run ( new SafeRunnable ( ) { @ Override public void run ( ) { loc0 . labelProviderChanged ( arg0 ) ; } } ) ; } }"}, {"instruction": "Generate java code\nset parser state to specialcharstate . ", "input": " State closeStarComment \n State selfClosing \n State tagAttributes \n State unquoted \n State unknown \n State inTag \n State cdata \n State previousState \n State doctype \n State tagEncountered \n State singleQuoted \n XMLParser parser \n State xml \n State specialChar \n State doubleQuoted \n State closingTag \n State comment \n State attrValue \n State starComment \n State currentState \n State closeComment \n State processingInstruction \n XMLParser closeStarComment \n XMLParser selfClosing \n XMLParser tagAttributes \n XMLParser unquotedAttr \n XMLParser attributeValue \n XMLParser doubleQuotedAttr \n XMLParser singleQuotedAttr \n XMLParser previousState \n XMLParser unknown \n XMLParser inTag \n XMLParser cdata \n XMLParser doctype \n XMLParser tagEncountered \n XMLParser setState \n XMLParser closingTag \n XMLParser comment \n XMLParser starComment \n XMLParser processingInstructions \n XMLParser closeComment", "output": "XMLParser function ( ) { return setState ( this . specialChar ) ; }"}, {"instruction": "Generate java code\npops a non-wide expression off the stack . ", "input": " ArrayList stack \n int height \n Expr pop \n void set \n int size \n Expr[] pop2 \n Expr get \n boolean isEmpty \n void replace \n String toString \n void push \n Expr peek \n Expr peek \n int height", "output": "Expr function ( ) { final Expr loc0 = ( Expr ) stack . remove ( stack . size ( ) - 1 ) ; final Type loc1 = loc0 . loc1 ( ) ; if ( loc1 . isWide ( ) ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } height -- ; return loc0 ; }"}, {"instruction": "Generate java code\nnotify the testmonitor that a new test is starting . passing null signals that a test has ended or that none is running . ", "input": " ITestIdentifier _runningTest \n TestMonitor _monitor \n void endTestCase \n String getCurrentTestCaseID \n ITestIdentifier getRunningTest \n void logTestStart \n String getId \n void beginTestCase \n TestMonitor getInstance \n NoRunningTestId noTest \n void setRunningTest \n boolean isTestRunning", "output": "void function ( ITestIdentifier arg0 ) { if ( arg0 == null ) endTestCase ( ) ; else { logTestStart ( arg0 ) ; setRunningTest ( arg0 ) ; } }"}, {"instruction": "Generate java code\nextract a portion of the bytes from the given stream. , wrapping them in a new stream . ", "input": " int BUFFER_SIZE \n CoreMessageLogger LOG \n int getSuggestedBufferSize \n long determineLengthForBufferSizing \n boolean isNClob \n byte[] extractBytes \n byte[] extractBytes \n String extractString \n String extractString \n String extractString \n String extractString", "output": "InputStream function ( InputStream arg0 , long arg1 , int arg2 ) { return new BinaryStreamImpl ( extractBytes ( arg0 , arg1 , arg2 ) ) ; }"}, {"instruction": "Generate java code\njust calls getnext.override this to get notified on encountered content . ", "input": " Pipeline<?> next \n Pipeline<?> init \n String getContextKey \n void setNext \n Pipeline<?> getNext \n T getLocalContext \n Pipeline<?> close \n Pipeline<?> open", "output": "Pipeline < ? > function ( final WorkerContext arg0 , final Tag arg1 , final String arg2 , final ProcessObject arg3 ) { return getNext ( ) ; }"}, {"instruction": "Generate java code\ncolorpolynomial summation . ", "input": " GenPolynomial<GenPolynomial<C>> red \n GenPolynomial<GenPolynomial<C>> green \n GenPolynomial<GenPolynomial<C>> white \n List<GenPolynomial<C>> getRedCoefficients \n boolean isONE \n ExpVector leadingExpVector \n Map.Entry<ExpVector,GenPolynomial<C>> leadingMonomial \n boolean checkInvariant \n ColorPolynomial<C> subtract \n ColorPolynomial<C> subtract \n int length \n boolean isDetermined \n GenPolynomial<GenPolynomial<C>> getPolynomial \n ColorPolynomial<C> abs \n int hashCode \n boolean equals \n boolean isZERO \n List<GenPolynomial<C>> getGreenCoefficients \n String toString \n ColorPolynomial<C> divide \n GenPolynomial<GenPolynomial<C>> getEssentialPolynomial \n ColorPolynomial<C> multiply \n ColorPolynomial<C> multiply", "output": "ColorPolynomial < C > function ( GenPolynomial < C > arg0 , ExpVector arg1 ) { GenPolynomial < GenPolynomial < C >> loc0 , loc1 , loc2 ; loc0 = green ; loc1 = red ; loc2 = white ; if ( green . getMap ( ) . keySet ( ) . contains ( arg1 ) ) { loc0 = green . sum ( arg0 , arg1 ) ; } else if ( red . getMap ( ) . keySet ( ) . contains ( arg1 ) ) { loc1 = red . sum ( arg0 , arg1 ) ; } else { loc2 = white . sum ( arg0 , arg1 ) ; } return new ColorPolynomial < C > ( loc0 , loc1 , loc2 ) ; }"}, {"instruction": "Generate java code\ncompresses the hashtable to the minimum prime size as defined by primefinder that will hold all of the elements currently in the table . if you have done a lot of remove operations and plan to do a lot of queries or insertions or iteration , it is a good idea to invoke this method . doing so will accomplish two things : you 'll free memory allocated to the table but no longer needed because of the remove s. you 'll get better query/insert/iterator performance because there wo n't be any removed slots to skip over when probing for indices in the table . ", "input": " int _size \n int _free \n float _loadFactor \n long serialVersionUID \n int _maxSize \n boolean _autoCompactTemporaryDisable \n float _autoCompactionFactor \n int _autoCompactRemovesRemaining \n float DEFAULT_LOAD_FACTOR \n int DEFAULT_INITIAL_CAPACITY \n void setAutoCompactionFactor \n void writeExternal \n void trimToSize \n boolean isEmpty \n void clear \n void rehash \n float getAutoCompactionFactor \n void reenableAutoCompaction \n int capacity \n int size \n void tempDisableAutoCompaction \n void postInsertHook \n void computeMaxSize \n Object clone \n void readExternal \n void removeAt \n int setUp \n void computeNextAutoCompactionAmount \n void ensureCapacity \n int calculateGrownCapacity", "output": "void function ( ) { rehash ( PrimeFinder . nextPrime ( ( int ) Math . ceil ( size ( ) / _loadFactor ) + 1 ) ) ; computeMaxSize ( capacity ( ) ) ; if ( _autoCompactionFactor != 0 ) { computeNextAutoCompactionAmount ( size ( ) ) ; } }"}, {"instruction": "Generate java code\nshows other information than a stack trace . ", "input": " Clipboard fClipboard \n Table fTable \n IPropertyChangeListener fFontPropertyChangeListener \n FailureTableDisplay fFailureTableDisplay \n String FAILURE_FONT \n ShowStackTraceInConsoleViewAction fShowTraceInConsoleAction \n TestElement fFailure \n CompareResultsAction fCompareAction \n TestRunnerViewPart fTestRunner \n String fInputTrace \n int MAX_LABEL_LENGTH \n String FRAME_PREFIX \n String getSelectedText \n FailureTableDisplay getFailureTableDisplay \n Action createOpenEditorAction \n void clear \n void refresh \n String[] getFilterPatterns \n void updateEnablement \n void updateTable \n Composite getComposite \n void showFailure \n void initMenu \n TestElement getFailedTest \n Shell getShell \n void propertyChange \n String getTrace \n void dispose \n void menuAboutToShow", "output": "void function ( String arg0 ) { clear ( ) ; TableItem loc0 = fFailureTableDisplay . newTableItem ( ) ; loc0 . setText ( arg0 ) ; }"}, {"instruction": "Generate java code\nread a correct answer from a file . ", "input": " String feedback \n int correct \n int TESTS \n String printOutput \n void runSpecialTest \n String appendFeedback \n void main \n void run \n String printList \n void judge \n void runTest", "output": "List < Integer > function ( String arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; try { Scanner loc1 = new Scanner ( new File ( arg0 ) ) ; while ( loc1 . hasNextInt ( ) ) { loc0 . add ( loc1 . nextInt ( ) ) ; } } catch ( Exception loc1 ) { feedback += \"srini_string\" ; } return loc0 ; }"}, {"instruction": "Generate java code\ncalled when an event is done busying up the ui thread . ", "input": " int eventDepth \n GraphModel graphModel \n Timer warmDownTimer \n int TICK_TIME \n double blockedTimeInWindow \n double[] weights \n double WINDOW_SLIDE_INCREMENT \n double weightedUtilizationPercent \n double WINDOW_WIDTH \n double maxUtilization \n double[] windowHistory \n double currentWindowStart \n double currentMarker \n double scaledWeightedUtilization \n void updateWeightedUtilization \n double calculateCurrentUtilization \n double getThreadUtilization \n void enterBlocking \n void slideWindowTo \n void run \n double dotProduct", "output": "void function ( double arg0 ) { assert ( currentWindowStart >= 0 ) ; slideWindowTo ( arg0 ) ; blockedTimeInWindow = arg0 - currentMarker ; currentMarker = arg0 ; eventDepth -- ; warmDownTimer . schedule ( TICK_TIME ) ; }"}, {"instruction": "Generate java code\ncompares two non-null boolean objects according to the value of #sortstruefirst . ", "input": " BooleanComparator TRUE_FIRST \n long serialVersionUID \n BooleanComparator FALSE_FIRST \n boolean trueFirst \n BooleanComparator getTrueFirstComparator \n BooleanComparator getBooleanComparator \n int hashCode \n boolean equals \n boolean sortsTrueFirst \n BooleanComparator getFalseFirstComparator", "output": "int function ( Boolean arg0 , Boolean arg1 ) { boolean loc0 = arg0 . booleanValue ( ) ; boolean loc1 = arg1 . booleanValue ( ) ; return ( loc0 ^ loc1 ) ? ( ( loc0 ^ trueFirst ) ? 1 : - 1 ) : 0 ; }"}, {"instruction": "Generate java code\nreturns a label for a resource name . ", "input": " PlaceHolder placeHolder \n String getURLPart \n String getFilePattern \n String markLTR \n String getVersionName \n String getPathLabel", "output": "String function ( IResource arg0 ) { return markLTR ( arg0 . getName ( ) , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the value of the tags property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the tags property . for example , to add a new item , do as follows : gettags . add newitem ; objects of the following type s are allowed in the list string ", "input": " String validationPattern \n boolean isValueOptional \n boolean encrypted \n String machineInterpretationKey \n String displayName \n String defaultValue \n String technicalKey \n boolean isKeyOptional \n List<String> tags \n String exampleValue \n void setDefaultValue \n String getExampleValue \n String getValidationPattern \n boolean isIsKeyOptional \n void setIsKeyOptional \n void setDisplayName \n void setMachineInterpretationKey \n void setExampleValue \n String getDefaultValue \n String getTechnicalKey \n void setEncrypted \n void setTechnicalKey \n String getDisplayName \n boolean isEncrypted \n String getMachineInterpretationKey \n void setValidationPattern \n boolean isIsValueOptional \n void setIsValueOptional", "output": "List < String > function ( ) { if ( tags == null ) { tags = new ArrayList < String > ( ) ; } return this . tags ; }"}, {"instruction": "Generate java code\nremoves the entry at position index in the list . ", "input": " Set<Serializable> querySpaces \n boolean sorted \n Sorter<E> sorter \n ArrayList<E> executables \n int INIT_QUEUE_LIST_SIZE \n boolean add \n void writeExternal \n Iterator<E> iterator \n Set<Serializable> getQuerySpaces \n int size \n E get \n boolean isEmpty \n void clear \n void removeLastN \n void readExternal \n void sort \n void sort \n void afterDeserialize", "output": "E function ( int arg0 ) { final E loc0 = executables . remove ( arg0 ) ; if ( loc0 . getPropertySpaces ( ) != null && loc0 . getPropertySpaces ( ) . length > 0 ) { querySpaces = null ; } return loc0 ; }"}, {"instruction": "Generate java code\nhash code for this biginteger . ", "input": " java.math.BigInteger val \n BigInteger ONE \n BigInteger ZERO \n Random random \n BigInteger IRAND \n boolean isField \n boolean isCommutative \n BigInteger gcd \n BigInteger IPROD \n BigInteger sum \n int compareTo \n BigInteger IABS \n java.math.BigInteger characteristic \n BigInteger random \n BigInteger random \n BigInteger IDIF \n BigInteger divide \n BigInteger copy \n BigInteger multiply \n BigInteger IGCD \n int signum \n BigInteger ISUM \n boolean isONE \n BigInteger inverse \n java.math.BigInteger getVal \n BigInteger INEG \n BigInteger valueOf \n BigInteger valueOf \n boolean isUnit \n BigInteger subtract \n BigInteger IQ \n BigInteger[] IQR \n BigInteger parse \n BigInteger parse \n BigInteger[] egcd \n int ISIGN \n BigInteger abs \n BigInteger IREM \n BigInteger[] divideAndRemainder \n BigInteger negate \n boolean equals \n BigInteger clone \n BigInteger getONE \n BigInteger getZERO \n BigInteger fromInteger \n BigInteger fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n int ICOMP \n BigInteger remainder", "output": "int function ( ) { return val . hashCode ( ) ; }"}, {"instruction": "Generate java code\nlog a message to the log4j logger with trace priority . currently logs to debug level in log4j . ", "input": " String name \n boolean is12 \n Logger logger \n String FQCN \n void warn \n void warn \n void debug \n void debug \n boolean isInfoEnabled \n boolean isErrorEnabled \n Logger getLogger \n boolean isTraceEnabled \n boolean isWarnEnabled \n boolean isDebugEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void info \n void info", "output": "void function ( Object arg0 ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . DEBUG , arg0 , null ) ; } else { getLogger ( ) . log ( FQCN , Level . DEBUG , arg0 , null ) ; } }"}, {"instruction": "Generate java code\nevaluate complex polynomial . note coefficients are always c 1 to c n , c 0 is always 0,0 . ", "input": " double DTR \n double P10 \n int N_ITER \n double C22 \n double C48 \n double TWOPI \n double P02 \n double FORTPI \n double MILLION \n double RTD \n double C88 \n double C04 \n double C66 \n double C02 \n double P01 \n double QUARTERPI \n double PI \n double EPS10 \n double C06 \n double C68 \n double P00 \n double C44 \n double C46 \n double C00 \n double SECONDS_TO_RAD \n double HALFPI \n double C08 \n double P11 \n int MAX_ITER \n double P20 \n double authlat \n double niceNumber \n double atan2d \n double distance \n double greatCircleDistance \n double atand \n double radToDeg \n double[] authset \n double normalizeLatitude \n double cosd \n double mlfn \n double tand \n double sqrt \n double degToRad \n double phi2 \n double hypot \n double acosd \n double msfn \n double frac \n double[] enfn \n double atan2 \n double normalizeLongitude \n double qsfn \n double asind \n double sphericalAzimuth \n boolean sameSigns \n boolean sameSigns \n double geographicLatitude \n double inv_mlfn \n double cross \n boolean isIdentity \n double acos \n double dmsToDeg \n double longitudeDistance \n double geocentricLatitude \n double tsfn \n double trunc \n double takeSign \n int takeSign \n double sind \n double normalizeAngle \n double asin \n double dmsToRad \n Complex zpoly1d", "output": "Complex function ( Complex arg0 , Complex [ ] arg1 ) { Complex loc0 = new Complex ( arg1 [ arg1 . length - 1 ] ) ; double loc1 ; int loc2 = arg1 . length - 1 ; while ( loc2 -- > 0 ) { Complex loc3 = arg1 [ loc2 ] ; loc0 . r = loc3 . r + arg0 . r * ( loc1 = loc0 . r ) - arg0 . i * loc0 . i ; loc0 . i = loc3 . i + arg0 . r * loc0 . i + arg0 . i * loc1 ; } loc0 . r = arg0 . r * ( loc1 = loc0 . r ) - arg0 . i * loc0 . i ; loc0 . i = arg0 . r * loc0 . i + arg0 . i * loc1 ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the successor or children nodes of this graphnode . ", "input": " int preIndex \n int postIndex \n HashSet succs \n HashSet preds \n int preOrderIndex \n int postOrderIndex \n void setPostOrderIndex \n void setPreOrderIndex \n Collection preds", "output": "Collection function ( ) { return succs ; }"}, {"instruction": "Generate java code\nverifies the default page size a4 . ", "input": " HtmlPipelineContext ctx \n void verifydefaultAcceptUnknown \n void verifydefaultRoottags \n void setup \n void verifydefaultBookmarksEnabled \n void verifyMemory", "output": "void function ( ) { Assert . assertEquals ( PageSize . A4 , ctx . getPageSize ( ) ) ; }"}, {"instruction": "Generate java code\nreturn true iff this quadrant is adjacent to the boundary of an image in the given direction . ", "input": " PlaceHolder placeHolder \n Quadrant reflect \n QuadTreeNode child", "output": "boolean function ( int arg0 ) { return ( arg0 == QuadTreeNode . SOUTH || arg0 == QuadTreeNode . WEST ) ; }"}, {"instruction": "Generate java code\nthe measurement has been started . ", "input": " Logger log \n String description \n int clusterIDLength \n String style \n boolean started \n String fileDescr \n String seed \n int BUFFER_CAPACITY \n String filePrefix \n String fileSuffix \n PrintWriter out \n void appendClusterID \n void setOutputFilePrefix \n void stopped \n void start \n void appendNewLine \n void setDescription \n boolean isStarted \n void setOutputFileSuffix \n void setOutputFile \n void appendSeparator \n void setOutputFileDescr \n void stop \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void setStyle \n void setSeed \n String getFileName", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ncopies the contents of the stack into a native array . note that this will not pop them out of the stack . ", "input": " TLongArrayList _list \n int DEFAULT_CAPACITY \n long pop \n int size \n void clear \n void reset \n void push \n long peek", "output": "long [ ] function ( ) { return _list . toNativeArray ( ) ; }"}, {"instruction": "Generate java code\nget a cssresolver implementation . ", "input": " XMLWorkerHelper myself \n TagProcessorFactory tpf \n CssFile defaultCssFile \n ElementList parseToElementList \n TagProcessorFactory getDefaultTagProcessorFactory \n CssFile getCSS \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n void parseXHtml \n XMLWorkerHelper getInstance \n CssFile getDefaultCSS", "output": "CSSResolver function ( final boolean arg0 ) { CSSResolver loc0 = new StyleAttrCSSResolver ( ) ; if ( arg0 ) { loc0 . addCss ( getDefaultCSS ( ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns the time of the message , when it was sent , received or dropped . ", "input": " long size \n Class msgClass \n long timestamp \n Class getMsgClass \n long getSize", "output": "long function ( ) { return timestamp ; }"}, {"instruction": "Generate java code\nitem returns this node 's item . if this node is invalid , throws an exception . ", "input": " Object item \n List myList \n ListNode next \n ListNode prev \n boolean isValidNode \n void setItem \n void insertAfter \n void remove \n void insertBefore", "output": "Object function ( ) { if ( ! isValidNode ( ) ) { throw new InvalidNodeException ( ) ; } return item ; }"}, {"instruction": "Generate java code\ndetermines whether a notification should hold a foreground service to keep gecko alive ", "input": " Notification mForegroundNotification \n ConcurrentHashMap<Integer,Notification> mNotifications \n NotificationManagerCompat mNotificationManager \n Context mContext \n int mForegroundNotificationId \n void add \n void add \n void updateForegroundNotification \n void setForegroundNotification \n void update \n boolean isDone \n void remove", "output": "boolean function ( int arg0 ) { final Notification loc0 = mNotifications . get ( arg0 ) ; return isOngoing ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns true if this registry maps one or more keys to the specified value . ", "input": " Map _values \n Map _register \n WidgetLocator add \n String getKey \n Set getEntries \n boolean containsKey \n IWidgetIdentifier get \n IWidgetIdentifier remove", "output": "boolean function ( IWidgetIdentifier arg0 ) { return _register . containsValue ( arg0 ) ; }"}, {"instruction": "Generate java code\nprocess : null arguemnts ", "input": " Annotations annotations \n void testProcessConnectionDefinition \n void testProcessActivation \n void testProcessConnectorFail \n void tearDown \n void testProcessConfigProperty \n void testProcessNullAnnotationRepository \n void beforeClass \n void setup \n void testProcessConnector \n void afterClass \n void testProcessAuthenticationMechanism \n void testProcessAdministeredObject \n void testProcessConnectionDefinitions \n URI getURI", "output": "void function ( ) { annotations . process ( null , null , null ) ; }"}, {"instruction": "Generate java code\nresidue negate . ", "input": " C val \n ResidueRing<C> ring \n boolean debug \n int isunit \n Logger logger \n int signum \n boolean isONE \n Residue<C> inverse \n boolean isUnit \n Residue<C> subtract \n Residue<C> gcd \n Residue<C> sum \n int compareTo \n Residue<C>[] egcd \n Residue<C> abs \n int hashCode \n boolean equals \n Residue<C> clone \n boolean isZERO \n String toString \n Residue<C> divide \n Residue<C> multiply \n Residue<C> remainder", "output": "Residue < C > function ( ) { return new Residue < C > ( ring , val . negate ( ) ) ; }"}, {"instruction": "Generate java code\nextended groebner base using critical pair class . ", "input": " Reduction<C> red \n boolean debug \n Logger logger \n boolean isGB \n boolean isGB \n List<GenPolynomial<C>> minimalGB \n List<GenPolynomial<C>> GB \n boolean isReductionMatrix \n boolean isReductionMatrix", "output": "ExtendedGB < C > function ( int arg0 , List < GenPolynomial < C >> arg1 ) { throw new RuntimeException ( \"srini_string\" + this . getClass ( ) . getSimpleName ( ) ) ; }"}, {"instruction": "Generate java code\nthe setup of testcase is : send message + - > ejb3 mdb @runas - > ejb3 slsb - > ejb2 slsb & & ejb2 slsb ", "input": " InitialContext initialContext \n String PRINCIPAL \n Archive<?> runAsEJB2 \n Archive<?> runAsEJB3 \n void clientCall \n void setup \n void tearDown", "output": "void function ( ) { ConnectionFactory loc0 = ( ConnectionFactory ) initialContext . lookup ( \"srini_string\" ) ; String loc1 = HelloBean . sendMessage ( loc0 ) ; Assert . assertEquals ( String . format ( \"srini_string\" , HowdyBean . SAYING , PRINCIPAL , HolaBean . SAYING , PRINCIPAL , GoodByeBean . SAYING ) , loc1 ) ; }"}, {"instruction": "Generate java code\nadd an additional skip hour name . ", "input": " String managingEditor \n String title \n String language \n String link \n ArrayList skipDays \n TextInput textInput \n String rating \n String pubDate \n String description \n String lastBuildDate \n String webMaster \n String copyright \n ArrayList skipHours \n ArrayList items \n Image image \n String docs \n double version \n void addSkipDay \n void removeItem \n void setCopyright \n String getWebMaster \n void setDescription \n String getDescription \n String getDocs \n void addItem \n Item[] getItems \n String getTitle \n String[] getSkipHours \n String[] findSkipHours \n String[] findSkipDays \n void render \n void render \n void render \n void render \n void render \n void render \n String[] getSkipDays \n void setManagingEditor \n double getVersion \n String getLanguage \n String getCopyright \n void setVersion \n String getPubDate \n void setWebMaster \n void setTitle \n void setTextInput \n Item[] findItems \n void setPubDate \n void setLink \n String getLink \n String getLastBuildDate \n void setDocs \n void removeSkipHour \n void removeSkipDay \n TextInput getTextInput \n Image getImage \n void setLastBuildDate \n void setRating \n String getManagingEditor \n void setImage \n void setLanguage \n String getRating", "output": "void function ( String arg0 ) { synchronized ( skipHours ) { skipHours . add ( arg0 ) ; } }"}, {"instruction": "Generate java code\nchecks if the pdf has to be in conformance with pdf/x -3:2002 ", "input": " PdfWriter writer \n int pdfxConformance \n boolean isPdfIso \n void checkPdfIsoConformance \n int getPDFXConformance \n boolean isPdfX1A2001 \n boolean isPdfX \n void setPDFXConformance", "output": "boolean function ( ) { return pdfxConformance == PdfWriter . PDFX32002 ; }"}, {"instruction": "Generate java code\nset the parent widgetlocator . ", "input": " long serialVersionUID \n HashMap _map \n int UNASSIGNED \n int _index \n WidgetLocator _parentInfo \n Class _cls \n String _nameOrLabel \n IWidgetMatcher _matcher \n int getIndex \n void setData \n WidgetLocator getParentInfo \n String getNameOrLabel \n IWidgetLocator[] findAll \n boolean matches \n Map getDataMap \n Class getTargetClass \n void setIndex \n int hashCode \n boolean equals \n String toString \n String getTargetClassName \n String getData", "output": "void function ( WidgetLocator arg0 ) { _parentInfo = arg0 ; }"}, {"instruction": "Generate java code\nthis method attempts to find two values a and b satisfying lowerbound f a f b if f is continuous on a , b , this means that a and b bracket a root of f . the algorithm starts by setting a : = initial -1 ; b : = initial +1 , examines the value of the function at a and b and keeps moving the endpoints out by one unit each time through a loop that terminates when one of the following happens : f a f b -- success ! a = lower and b = upper -- convergenceexception integer.max _ value iterations elapse -- convergenceexception note : this method can take integer.max _ value iterations to throw a convergenceexception . unless you are confident that there is a root between lowerbound and upperbound near initial , it is better to use #bracket univariaterealfunction , double , double , double , int , explicitly specifying the maximum number of iterations . ", "input": " UnivariateRealSolverFactory factory \n double solve \n double solve \n double midpoint \n void setup", "output": "double [ ] function ( UnivariateRealFunction arg0 , double arg1 , double arg2 , double arg3 ) { return bracket ( arg0 , arg1 , arg2 , arg3 , Integer . MAX_VALUE ) ; }"}, {"instruction": "Generate java code\nreturns true if o is a routingtableentry and has the same kademliaoverlaycontact as this . specifics of this routing table entry such as stale counter are ignored . ", "input": " long lastSeen \n int staleCounter \n KademliaOverlayContact<T> contact \n int getStaleCounter \n int hashCode \n int increaseStaleCounter \n String toString \n long getLastSeen \n KademliaOverlayContact<T> getContact \n void seen", "output": "boolean function ( Object arg0 ) { if ( arg0 instanceof RoutingTableEntry ) { return this . contact . getOverlayID ( ) . equals ( ( ( RoutingTableEntry < ? > ) arg0 ) . getContact ( ) . getOverlayID ( ) ) ; } return false ; }"}, {"instruction": "Generate java code\nget the minimal key from this map with respect to the preset comparator for which valuepredicate holds for its associated value . ", "input": " SortedMap<K,V> kSmallest \n int k \n boolean containsKey \n Collection<V> values \n void clear \n boolean isInRange \n boolean put \n boolean put \n boolean put \n V remove \n boolean containsValue \n K getMaxKey \n int size \n K firstKey \n void putAll \n void putAll \n void putAll \n void putAll \n void putAll \n V get \n void setAllValues \n K lastKey \n String toString \n Set<K> keySet", "output": "K function ( final Predicate < V > arg0 ) { for ( final Map . Entry < K , V > loc0 : kSmallest . entrySet ( ) ) { if ( arg0 . isTrue ( loc0 . getValue ( ) ) ) { return loc0 . getKey ( ) ; } } return null ; }"}, {"instruction": "Generate java code\ndelete customer schema for fresh setup per test . ", "input": " String DB_URL \n DbCustomerDao dao \n Customer existingCustomer \n String EXCEPTION_CAUSE \n ExpectedException exception \n void addingShouldResultInSuccess \n void deletionShouldBeFailureAndNotAffectExistingCustomers \n void retrievingAllCustomersFailsWithExceptionAsFeedbackToClient \n void updatingACustomerFailsWithFeedbackToTheClient \n void retrieveShouldReturnNoCustomer \n void createSchema \n void updationShouldBeFailureAndNotAffectExistingCustomers \n void deletionShouldBeSuccessAndCustomerShouldBeNonAccessible \n void addingShouldResultInFailureAndNotAffectExistingCustomers \n void assertCustomerCountIs \n void addingACustomerFailsWithExceptionAsFeedbackToClient \n DataSource mockedDatasource \n void setUp \n void setUp \n void updationShouldBeSuccessAndAccessingTheSameCustomerShouldReturnUpdatedInformation \n void retrievingACustomerByIdFailsWithExceptionAsFeedbackToClient \n int getNonExistingCustomerId \n void deletingACustomerFailsWithExceptionAsFeedbackToTheClient", "output": "void function ( ) { try ( Connection loc0 = DriverManager . getConnection ( DB_URL ) ; Statement loc1 = loc0 . createStatement ( ) ) { loc1 . execute ( CustomerSchemaSql . DELETE_SCHEMA_SQL ) ; } }"}, {"instruction": "Generate java code\nis this contact offline ? ", "input": " boolean isOffline \n long lastAction \n TransInfo transInfo \n long ttl \n void updateLastAction \n void markAsOffline \n boolean equals \n ReplicationDHTContact clone \n long getLastAction \n TransInfo getTransInfo", "output": "boolean function ( ) { return isOffline || Simulator . getCurrentTime ( ) > ttl + lastAction ; }"}, {"instruction": "Generate java code\nlistsum computes the sum of terms in a list . ", "input": " PlaceHolder placeHolder \n ListNode createGeomSeries \n void main", "output": "double function ( ListNode arg0 ) { if ( arg0 == null ) { return 0.0 ; } return ( ( Double ) arg0 . item ) . doubleValue ( ) + listSum ( arg0 . next ) ; }"}, {"instruction": "Generate java code\nlog the specified exception . ", "input": " ILog sysOutLog \n PrintWriter sysOut \n ILog log \n String PRODUCT_ID \n void setLog \n void printLogObject \n void removeLogListener \n void logNoHeader \n void logStackTrace \n void printLogStatus \n IStatus createLogStatus \n void printLogMessage \n void printLog \n void close \n void addLogListener \n org.osgi.framework.Bundle getBundle", "output": "void function ( Throwable arg0 ) { log ( \"srini_string\" , arg0 ) ; }"}, {"instruction": "Generate java code\nlog a message and exception with trace log level . ", "input": " String name \n boolean classAndMethodFound \n Logger logger \n String sourceMethodName \n String sourceClassName \n void debug \n void debug \n void log \n Logger getLogger \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void warn \n void warn \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isDebugEnabled \n void getClassAndMethod \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { log ( Level . FINEST , String . valueOf ( arg0 ) , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the new productid . ", "input": " long signature1 \n int productID \n String manufacturer \n int vendorID \n long version \n long signature2 \n String productDescription \n String serialNumber \n int MAX_HEADER_LENGTH \n String manufacturerID \n boolean remoteWakeupCapable \n boolean pnpEnabled \n int maxPower \n boolean selfPowered \n boolean isPnpEnabled \n long getSignature2 \n void setPnpEnabled \n void setManufacturer \n void setMaxPower \n void setProductDescription \n String getManufacturer \n void setSelfPowered \n long getSignature1 \n void setManufacturerID \n boolean isRemoteWakeupCapable \n String getManufacturerID \n void validate \n int getMaxPower \n long getVersion \n void setSignature1 \n String getSerialNumber \n void setSerialNumber \n void setVersion \n void setSignature2 \n String getProductDescription \n int getProductID \n boolean isSelfPowered \n void setRemoteWakeupCapable \n void setVendorID \n int getVendorID", "output": "void function ( int arg0 ) { this . productID = arg0 ; }"}, {"instruction": "Generate java code\nadd a file to the collection . ", "input": " ArrayList<String> files \n MusicPlayer player \n void listAllFilles \n void listFile \n void removeFile \n int getNumberOfFiles \n void listMatching \n int findFirst \n void stopPlaying \n void startPlaying \n void playSampleOf", "output": "void function ( String arg0 ) { files . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nfind the timestamp associated with the given metrics , and remove all metrics objects from the start of the queue up to and including the one provided . note that because of draw coalescing , the metrics object passed in here may not be the one at the head of the queue , and so we must iterate our way through the list to find it . this must only be called from the compositor thread . ", "input": " DisplayPortMetrics[] mMetrics \n long[] mTimestamps \n String LOGTAG \n int mTail \n int BUFFER_SIZE \n int mHead \n boolean add \n void reset", "output": "long function ( DisplayPortMetrics arg0 ) { int loc0 = mTail ; int loc1 = ( mHead + 1 ) % BUFFER_SIZE ; while ( loc1 != loc0 ) { if ( mMetrics [ loc1 ] . fuzzyEquals ( arg0 ) ) { long loc2 = mTimestamps [ loc1 ] ; mHead = loc1 ; return loc2 ; } loc1 = ( loc1 + 1 ) % BUFFER_SIZE ; } return - 1 ; }"}, {"instruction": "Generate java code\ngets an object containing the image dictionary and bytes . ", "input": " PdfIndirectReference ref \n InlineImageInfo inlineImageInfo \n PdfImageObject imageObject \n PdfDictionary colorSpaceDictionary \n GraphicsState gs \n Vector getStartPoint \n ImageRenderInfo createForXObject \n PdfIndirectReference getRef \n ImageRenderInfo createForEmbeddedImage \n BaseColor getCurrentFillColor \n void prepareImageObject \n Matrix getImageCTM \n float getArea", "output": "PdfImageObject function ( ) { prepareImageObject ( ) ; return imageObject ; }"}, {"instruction": "Generate java code\nisvalidnode returns true if this node is valid ; false otherwise . ", "input": " boolean valid \n Object item \n TreeNode parent \n Object item \n int children \n void removeLeaf \n void insertChild \n TreeNode nextSibling \n void setItem \n TreeNode child", "output": "boolean function ( ) { return valid ; }"}, {"instruction": "Generate java code\ncompares this protocol version with another one . only protocol versions with the same protocol name can be compared . this method does not define a total ordering , as it would be required for java.lang.comparable . ", "input": " String protocol \n int major \n int minor \n long serialVersionUID \n int getMinor \n boolean lessEquals \n int hashCode \n boolean isComparable \n boolean equals \n boolean greaterEquals \n int getMajor \n Object clone \n String getProtocol \n String toString \n ProtocolVersion forVersion", "output": "int function ( final ProtocolVersion arg0 ) { Args . notNull ( arg0 , \"srini_string\" ) ; Args . check ( this . protocol . equals ( arg0 . protocol ) , \"srini_string\" , this , arg0 ) ; int loc0 = getMajor ( ) - arg0 . getMajor ( ) ; if ( loc0 == 0 ) { loc0 = getMinor ( ) - arg0 . getMinor ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsaves the current content into the given output stream . ", "input": " SessionInfoStore sessionInfos \n ExecutionDataStore executionData \n void load \n void load \n SessionInfoStore getSessionInfoStore \n ExecutionDataStore getExecutionDataStore", "output": "void function ( final OutputStream arg0 ) { final ExecutionDataWriter loc0 = new ExecutionDataWriter ( arg0 ) ; sessionInfos . accept ( loc0 ) ; executionData . accept ( loc0 ) ; }"}, {"instruction": "Generate java code\ndoes this registry contain the named function ", "input": " Dialect dialect \n Map<String,SQLFunction> userFunctions \n SQLFunction findSQLFunction", "output": "boolean function ( String arg0 ) { final String loc0 = arg0 . toLowerCase ( Locale . ROOT ) ; return userFunctions . containsKey ( loc0 ) || dialect . getFunctions ( ) . containsKey ( loc0 ) ; }"}, {"instruction": "Generate java code\ngenerate a random power series with d = 0.7 . ", "input": " UnivPowerSeries<C> ZERO \n String DEFAULT_NAME \n int truncate \n String var \n int DEFAULT_TRUNCATE \n UnivPowerSeries<C> ONE \n RingFactory<C> coFac \n Random random \n UnivPowerSeries<C> getTAN \n boolean isField \n boolean isCommutative \n UnivPowerSeries<C> getSIN \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> fromPolynomial \n java.math.BigInteger characteristic \n UnivPowerSeries<C> getEXP \n int hashCode \n boolean equals \n UnivPowerSeries<C> getONE \n UnivPowerSeries<C> getZERO \n UnivPowerSeries<C> getCOS \n UnivPowerSeries<C> fromInteger \n UnivPowerSeries<C> fromInteger \n String toString \n boolean isAssociative \n UnivPowerSeries<C> copy \n UnivPowerSeries<C> fixPoint", "output": "UnivPowerSeries < C > function ( int arg0 , Random arg1 ) { return random ( arg0 , 0.7f , arg1 ) ; }"}, {"instruction": "Generate java code\nfunction to get object data by its id ", "input": " String m_Url \n String m_Key \n String m_Packing \n String m_Language \n String m_Format \n String getPacking \n String getLanguage \n void setPacking \n String getObjectsInBoxByBBox \n String getObjectInBox \n String getObjectsInBoxByLatLon \n String doSendApiRequest \n void setFormat \n String getObjectsInPoint \n String getObjectsInBoxByTile \n String getObjectsInBoxByTile \n String getObjectsBySearchQuery \n String getObjectsBySearchQuery \n String getFormat \n void setLanguage", "output": "String function ( int arg0 ) { return doSendApiRequest ( \"srini_string\" , \"srini_string\" + arg0 ) ; }"}, {"instruction": "Generate java code\ngets the cached token value from a bundle . ", "input": " String TOKEN_SOURCE_KEY \n long INVALID_BUNDLE_MILLISECONDS \n String TOKEN_KEY \n String PERMISSIONS_KEY \n String EXPIRATION_DATE_KEY \n String DECLINED_PERMISSIONS_KEY \n String LAST_REFRESH_DATE_KEY \n String IS_SSO_KEY \n String USER_FBID_KEY \n void putDeclinedPermissions \n long getExpirationMilliseconds \n void putLastRefreshDate \n List<String> getPermissions \n void save \n void clear \n void putToken \n void putSource \n Date getExpirationDate \n boolean hasTokenInformation \n void putPermissions \n void putExpirationMilliseconds \n Bundle load \n long getLastRefreshMilliseconds \n Date getLastRefreshDate \n AccessTokenSource getSource \n void putLastRefreshMilliseconds \n Date getDate \n void putExpirationDate \n void putDate", "output": "String function ( Bundle arg0 ) { Validate . notNull ( arg0 , \"srini_string\" ) ; return arg0 . getString ( TOKEN_KEY ) ; }"}, {"instruction": "Generate java code\nget a description of the reason this os delegate is invalid . ", "input": " String reason \n IWindowService getWindowService \n INativeConditionFactory getConditionFactory \n void invalid \n InvalidOSDelegate forReason \n String toString", "output": "String function ( ) { return reason ; }"}, {"instruction": "Generate java code\ncalled when a lookup previously started succeeded . ", "input": " FilesharingApplication app \n FSEvents ev \n void setFSApplication \n void lookupStarted \n void publishStarted \n void lookupMadeHop \n void publishSucceeded \n FilesharingApplication getFSApplication", "output": "void function ( OverlayContact arg0 , Object arg1 , int arg2 ) { ev . lookupSucceeded ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nformats time as milliseconds with units . ", "input": " String UNIT_MILLISECONDS \n String UNIT_SECONDS \n String format \n String format \n String format \n String formatToFixedDecimalPoint \n String formatSeconds \n String formatSeconds", "output": "String function ( double arg0 , int arg1 ) { return formatToFixedDecimalPoint ( arg0 , arg1 ) + UNIT_MILLISECONDS ; }"}, {"instruction": "Generate java code\nreturns the number of covered branches starting from this instruction . ", "input": " int coveredBranches \n int line \n Instruction predecessor \n int branches \n int getBranches \n void addBranch \n int getLine \n void setPredecessor \n void setCovered", "output": "int function ( ) { return coveredBranches ; }"}, {"instruction": "Generate java code\nreturns true if a memorybin with the given uri name already exists in this storage . ", "input": " int _pageSize \n int DEFAULT_PAGESIZE \n Map<String,Bin> _binsByUri \n Bin produceBin \n void rename \n Bin bin \n void bin \n void delete \n Bin open", "output": "boolean function ( String arg0 ) { return _binsByUri . containsKey ( arg0 ) ; }"}, {"instruction": "Generate java code\nreads the next token skipping over the comments . ", "input": " int COMMAND_TYPE \n PRTokeniser tokeniser \n PdfObject readPRObject \n void setTokeniser \n PdfArray readArray \n ArrayList<PdfObject> parse \n PdfDictionary readDictionary \n PRTokeniser getTokeniser", "output": "boolean function ( ) { while ( tokeniser . nextToken ( ) ) { if ( tokeniser . getTokenType ( ) == TokenType . COMMENT ) continue ; return true ; } return false ; }"}, {"instruction": "Generate java code\nincrease the accounting . returns whether the allocation fit within limits . ", "input": " Accountant parent \n AtomicLong allocationLimit \n AtomicLong peakAllocation \n long reservation \n boolean ok \n AtomicLong locallyHeldMemory \n void releaseBytes \n void updatePeak \n AllocationOutcome allocateBytes \n AllocationOutcome allocate \n long getLimit \n void setLimit \n long getPeakMemoryAllocation \n boolean isOk \n long getAllocatedMemory \n void close \n boolean isOverLimit", "output": "boolean function ( long arg0 ) { final AllocationOutcome loc0 = allocate ( arg0 , true , true ) ; return loc0 . isOk ( ) ; }"}, {"instruction": "Generate java code\ndebugging to see if the object has already been freed . ", "input": " AtomicReferenceArray<T> _freeStack \n AtomicInteger _top \n boolean allowFree \n T allocate \n void freeCareful \n boolean free", "output": "boolean function ( T arg0 ) { int loc0 = _top . get ( ) ; for ( int loc1 = loc0 - 1 ; loc1 >= 0 ; loc1 -- ) { if ( _freeStack . get ( loc1 ) == arg0 ) { return true ; } } return false ; }"}, {"instruction": "Generate java code\nfollowing method performs the initialization ", "input": " String OUTPUT_FILE \n PrintStream error \n PrintStream output \n FileLoggerModule singleton \n String ERROR_FILE \n Logger LOGGER \n void unprepare \n void printErrorString \n void printString \n FileLoggerModule getSingleton", "output": "FileLoggerModule function ( ) { LOGGER . debug ( \"srini_string\" ) ; this . output = new PrintStream ( new FileOutputStream ( OUTPUT_FILE ) ) ; this . error = new PrintStream ( new FileOutputStream ( ERROR_FILE ) ) ; return this ; }"}, {"instruction": "Generate java code\ngenerate variable string . ", "input": " String var \n int N \n String order \n String sum1 \n String varList \n String varList \n String polyList \n String sumUm \n void main \n String toString", "output": "String function ( int arg0 ) { if ( arg0 < 0 ) { return variable ( - arg0 ) ; } if ( arg0 > N ) { return \"srini_string\" ; } return var + arg0 ; }"}, {"instruction": "Generate java code\nthis method is optional . it allows automatic command hiding in situations when the command should not be visible . for example the ` entity ' command will not be made available before the user has defined his persistence settings in the roo shell or directly in the project . you can define multiple methods annotated with cliavailabilityindicator if your commands have differingvisibility requirements . ", "input": " TypicalsecurityOperations operations \n String setup", "output": "boolean function ( ) { return operations . isCommandAvailable ( ) ; }"}, {"instruction": "Generate java code\nobtains the host string , without scheme prefix . ", "input": " String hostname \n InetAddress address \n String lcHostname \n int port \n long serialVersionUID \n String schemeName \n String DEFAULT_SCHEME_NAME \n int getPort \n String getHostName \n int hashCode \n String toURI \n boolean equals \n Object clone \n InetAddress getAddress \n String toString \n String getSchemeName", "output": "String function ( ) { if ( this . port != - 1 ) { final StringBuilder loc0 = new StringBuilder ( this . hostname . length ( ) + 6 ) ; loc0 . append ( this . hostname ) ; loc0 . append ( \"srini_string\" ) ; loc0 . append ( Integer . toString ( this . port ) ) ; return loc0 . toString ( ) ; } else { return this . hostname ; } }"}, {"instruction": "Generate java code\nmust be called in the ui thread . ", "input": " Change fChange \n int fSaveMode \n IRunnableContext fExecContext \n boolean fForked \n boolean fForkChangeExecution \n Shell fParent \n int fStopSeverity \n PerformChangeOperation fPerformChangeOperation \n Refactoring fRefactoring \n boolean showStatusDialog \n void run", "output": "void function ( boolean arg0 , boolean arg1 ) { perform ( arg0 , false , arg1 ) ; }"}, {"instruction": "Generate java code\ncompare equal tag names . ", "input": " PlaceHolder placeHolder \n void validateChildrenNotNull \n void compareFalse \n void validateParentSetOnAdd \n void compareFalseTagAndNS \n void validateAttributesNotNull \n void validateCssNotNull \n void compareTrueNS \n void validateChildNotSetOnSetParent \n void compareFalseNS", "output": "void function ( ) { Assert . assertTrue ( new Tag ( \"srini_string\" ) . compareTag ( new Tag ( \"srini_string\" ) ) ) ; }"}, {"instruction": "Generate java code\ntransforms a list into another one , element by element , given a transformer . ", "input": " PlaceHolder placeHolder \n void filter \n void copyNSortedAndFiltered \n void filterMap \n void copyNSorted \n double getQuantile \n void splitMap \n List<T> getRandomPartFrom \n E getRandomEntry \n E getRandomEntry \n void copyUntilFull", "output": "List < Tt > function ( List < Ts > arg0 , Transformer < Ts , Tt > arg1 ) { List < Tt > loc0 = new ArrayList < Tt > ( arg0 . size ( ) ) ; for ( Ts loc1 : arg0 ) loc0 . add ( arg1 . transform ( loc1 ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\nadds the given executiondata object into the store . if there isalready execution data with this same class id , this structure is merged with the given one . ", "input": " Map<Long,ExecutionData> entries \n Set<String> names \n boolean contains \n void subtract \n void subtract \n ExecutionData get \n ExecutionData get \n void reset \n Collection<ExecutionData> getContents \n void visitClassExecution \n void accept", "output": "void function ( final ExecutionData arg0 ) { final Long loc0 = Long . valueOf ( arg0 . getId ( ) ) ; final ExecutionData loc1 = entries . get ( loc0 ) ; if ( loc1 == null ) { entries . put ( loc0 , arg0 ) ; names . add ( arg0 . getName ( ) ) ; } else { loc1 . merge ( arg0 ) ; } }"}, {"instruction": "Generate java code\nall the messages will be retrieved by the serviceexecutor by calling this method and process them . retrieves and removes the head of this queue , or returns null if this queue is empty . ", "input": " BlockingQueue<Message> blkQueue \n Logger LOGGER \n void submitMsg", "output": "Message function ( ) { Message loc1 = null ; try { loc1 = blkQueue . poll ( ) ; } catch ( Exception loc0 ) { LOGGER . error ( loc0 . getMessage ( ) ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nfree up runway ", "input": " int larnacaAirportNumberOfRunways \n Passenger[] passengersArray \n Airport larnacaAirport \n Plane[] planesArray \n Flight[] flightsArray \n int numberOfPassengers \n int numberOfFlightAttributes \n Runway[] runwaysArray \n int numberOfFlights \n void setLarnacaAirport \n void setPassengersArray \n void initializeLarnacaAirport \n void setFlightsArray \n Passenger[] getPassengersArray \n Object[][] getArrivalsOrDeparturesList \n void loadFromFile \n void initializeRunwaysArray \n Plane[] getPlanesArray \n void setRunwaysArray \n Object[][] getFlightData \n void initializePlanesArray \n void setPlanesArray \n void saveToFile \n void initializeFlightsArray \n boolean checkForFreeRunways \n void initializePassengersArray \n Airport getLarnacaAirport \n Object[] getArrivalsOrDeparturesRecord \n String[] getListOfAllFlightCodes \n Runway[] getRunwaysArray \n Flight[] getFlightsArray \n Object[] getFlightsRow", "output": "void function ( ) { for ( int loc0 = 0 ; loc0 < larnacaAirportNumberOfRunways ; loc0 ++ ) if ( Scenario . getRunwaysArray ( ) [ loc0 ] . isRunwayOccupied ( ) ) { Scenario . getRunwaysArray ( ) [ loc0 ] . setRunwayOccupied ( false ) ; break ; } }"}, {"instruction": "Generate java code\nunpack string sent from server into id and landmarkname used for search and displaying landmarks in listview ", "input": " String sec_id \n double latitude \n String name \n int cat_id \n String packedString \n String description \n String SEP_CHARACTER \n int id \n double longitude \n void setName \n void setLatitude \n String getName \n double getLongitude \n double getLatitude \n void setId \n Landmark fullUnpack \n int getId \n String toString \n void setDescription \n void setLongitude \n String getDescription", "output": "Landmark function ( ) { String [ ] loc0 = packedString . split ( SEP_CHARACTER ) ; id = Integer . parseInt ( loc0 [ 0 ] ) ; name = loc0 [ 1 ] ; return this ; }"}, {"instruction": "Generate java code\nswaps two characters in a stringbuilder object ", "input": " int MATRA_E \n int LETTER_HA \n int HALANTA \n int MATRA_AI \n int MATRA_HLR \n int MATRA_I \n int LETTER_A \n int LETTER_KA \n int LETTER_AU \n int MATRA_AA \n char[] langTable \n int MATRA_HLRR \n boolean IsSwaraMatra \n String process \n boolean IsSwaraLetter \n boolean IsVyanjana \n boolean isRTL", "output": "void function ( StringBuilder arg0 , int arg1 , int arg2 ) { char loc0 = arg0 . charAt ( arg1 ) ; arg0 . setCharAt ( arg1 , arg0 . charAt ( arg2 ) ) ; arg0 . setCharAt ( arg2 , loc0 ) ; }"}, {"instruction": "Generate java code\ninvokes the underlying listiterator #remove method . ", "input": " ListIterator iterator \n void add \n Object next \n void set \n Object previous \n boolean hasPrevious \n boolean hasNext \n ListIterator getListIterator \n int nextIndex \n int previousIndex \n void setListIterator", "output": "void function ( ) { getListIterator ( ) . remove ( ) ; }"}, {"instruction": "Generate java code\nconverts a hash code in the range integer.min _ value ... integer.max _ value to a value in the range 0 ... size of hash table - 1 . this function should have package protection so we can test it , and should be used by insert , find , and remove . ", "input": " int entryNum \n List[] hashArray \n int numCollisions \n int findBuckets \n int size \n Entry find \n void makeEmpty \n boolean isEmpty \n Entry insert \n void main \n int findPrimes \n Entry remove", "output": "int function ( int arg0 ) { return ( ( 600 * arg0 + 99 ) % 2147483647 ) % ( hashArray . length ) ; }"}, {"instruction": "Generate java code\nappends a byte to the buffer . ", "input": " String encoding \n int length \n byte[] buffer \n InputStream getByteStream \n String getEncoding \n byte byteAt \n int length \n void ensureCapacity \n int charAt", "output": "void function ( byte arg0 ) { ensureCapacity ( length + 1 ) ; buffer [ length ++ ] = arg0 ; }"}, {"instruction": "Generate java code\nreturn the n'th long down the stack , where 0 is the top element and size -1 is the bottom element . ", "input": " ArrayLongList list \n long pop \n int search \n int size \n long get \n void clear \n long push \n boolean empty", "output": "long function ( int arg0 ) { if ( list . isEmpty ( ) ) { throw new EmptyStackException ( ) ; } return list . get ( list . size ( ) - arg0 - 1 ) ; }"}, {"instruction": "Generate java code\nremoves the first occurrence of the given listener . ", "input": " Object STATE_EDITABLE \n StyleProvider provider \n List listeners \n Object UNDEFINED \n Object STATE_READ_ONLY \n StyleListener providerListener \n Object getStyle \n void setStyleProvider \n void addStyleListener \n Object getStyleState \n void setStyle \n void styleChanged \n void propogateChange", "output": "void function ( StyleListener arg0 ) { listeners . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\ncheck for existence or lack thereof of a field . ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria lt \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria nin \n Criteria nin \n Criteria and \n Criteria gte \n Criteria create \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria eq \n Criteria gt \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( boolean arg0 ) { this . criteriaType = RelationalOperator . EXISTS ; this . right = ValueNode . toValueNode ( arg0 ) ; this . left = left . asPathNode ( ) . asExistsCheck ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nretrieves the column names corresponding to the collection elements for the given collection role . ", "input": " SessionFactoryImplementor sfi \n Map<String,PropertyMapping> collectionPropertyMappingByRole \n QueryableCollection getCollectionPersister \n Type getElementType \n JoinSequence createJoinSequence \n JoinSequence createJoinSequence \n Type findFunctionReturnType \n Type findFunctionReturnType \n PropertyMapping getCollectionPropertyMapping \n AssociationType getElementAssociationType \n String getImportedClassName \n SQLFunction requireSQLFunction \n SessionFactoryImplementor getFactory \n boolean hasPhysicalDiscriminatorColumn \n EntityPersister requireClassPersister \n QueryableCollection requireQueryableCollection \n String[][] generateColumnNames \n String getIdentifierOrUniqueKeyPropertyName \n int getColumnSpan \n String getAssociatedEntityName \n JoinSequence createCollectionJoinSequence \n Queryable findQueryableUsingImports \n Queryable findQueryableUsingImports \n boolean isStrictJPAQLComplianceEnabled \n EntityPersister findEntityPersisterByName \n SQLFunction findSQLFunction", "output": "String [ ] function ( String arg0 , String arg1 ) { return getCollectionPropertyMapping ( arg0 ) . toColumns ( arg1 , CollectionPropertyNames . COLLECTION_ELEMENTS ) ; }"}, {"instruction": "Generate java code\nreset grid . ", "input": " boolean[][] newCell \n int[][] grid \n boolean[][] hasCombined \n boolean canMoveLeft \n int getCell \n boolean canMoveDown \n void generateNextCell \n void moveDown \n void resetMoved \n int getSize \n boolean canMoveUp \n boolean canMoveRight \n void moveRight \n boolean isGridFull \n void moveLeft \n boolean IsCellNew \n void initializeGame \n void moveUp", "output": "void function ( int arg0 ) { grid = new int [ arg0 ] [ arg0 ] ; }"}, {"instruction": "Generate java code\nsubclasses may want to override this method in order to store a reference to the parent of a given node that can then be used to calculate current node 's value in #update . in that case it is important to also override #ondetachedfromnode to clear thatreference once current node gets detached . ", "input": " int mTag \n int DEFAULT_ANIMATED_NODE_CHILD_COUNT \n int INITIAL_BFS_COLOR \n List<AnimatedNode> mChildren \n int mActiveIncomingNodes \n int mBFSColor \n void onDetachedFromNode \n void removeChild \n void update \n void addChild", "output": "void function ( AnimatedNode arg0 ) { }"}, {"instruction": "Generate java code\ncollect a jdr report when run outside the application server . ", "input": " InjectedValue<ServerEnvironment> serverEnvironmentValue \n ServerEnvironment serverEnvironment \n ExecutorService executorService \n ServiceName SERVICE_NAME \n ModelControllerClient controllerClient \n InjectedValue<ModelController> modelControllerValue \n JdrReportService getValue \n void stop \n ServiceController<JdrReportCollector> addService \n void start \n JdrReport collect", "output": "JdrReport function ( CLI arg0 , String arg1 , String arg2 , int arg3 ) { return new JdrRunner ( arg0 , arg1 , arg2 , arg3 , null , null ) . collect ( ) ; }"}, {"instruction": "Generate java code\nwith both deep and shallow extended persistence context inheritance , a bean creating another local bean via jndi lookup will also use the extended persistence context inheritance rules . this tests that two levels of jndi lookup does use the same xpc . see http://java.net/projects/jpa-spec/lists/jsr338-experts/archive/2012-06/message/28 for more details than the jpa 2.0 specification includes . ", "input": " String ARCHIVE_NAME \n InitialContext iniCtx \n T lookup \n void testShouldGetEjbExceptionBecauseEPCIsAddedToTxAfterPc \n void testChildInheritanceFromParentExtendedPersistenceContextViaBusinessMethodUsingJndiLookup \n Archive<?> deploy", "output": "void function ( ) { TopLevelBean loc0 = lookup ( \"srini_string\" , TopLevelBean . class ) ; loc0 . induceCreationViaJNDILookup ( ) ; }"}, {"instruction": "Generate java code\nconstruye la clausula where de un statement a partir de las condiciones especificadas . ", "input": " DataSource ds \n Object[] serializeObjectForIncremental \n String[] getColumnNames \n String getIncrementalColumnName \n String getTableName \n void update \n void insert \n Object[] serializeKey \n QueryCondition[] getConditionsFromKey \n String[] getKeyColumnNames \n List<T> findAll \n void delete \n T buildObject \n T findById \n Object[] serializeObject \n boolean truncateTable \n List<T> findByConditions \n K getKeyFromObject", "output": "String [ ] function ( QueryCondition [ ] arg0 ) { String [ ] loc0 = new String [ arg0 . length ] ; for ( int loc1 = 0 ; loc1 < loc0 . length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] . getColumnName ( ) + \"srini_string\" + arg0 [ loc1 ] . getOperator ( ) . toString ( ) + \"srini_string\" ; return loc0 ; }"}, {"instruction": "Generate java code\nthis method sets the value of the database column sys_ip_area . city ", "input": " String areaCode \n String IPCODE_UNKNOWN \n String city \n String province \n String edu \n String district \n String company \n Date createTime \n Long endIp \n String owner \n Long startIp \n String country \n boolean isIp \n void setCountry \n Date getCreateTime \n String getCountry \n void setProvince \n long valueOfIpv4 \n String getEdu \n Long getStartIp \n Long getEndIp \n String getOwner \n void setStartIp \n void setEndIp \n void setOwner \n String getStartIpv4 \n String getEndIpv4 \n String getAreaCode \n String ipv4 \n String getDistrict \n String getProvince \n void setDistrict \n void setCompany \n String getCity \n void setAreaCode \n void setCreateTime \n String getCompany \n void setEdu \n String toString", "output": "void function ( String arg0 ) { this . city = arg0 ; }"}, {"instruction": "Generate java code\nsets the path of the file to be loaded , to the given value . ", "input": " boolean loaded \n String fileName \n String loadData \n boolean fileExists \n String getFileName \n boolean isLoaded", "output": "void function ( String arg0 ) { this . fileName = arg0 ; }"}, {"instruction": "Generate java code\ntrack the given document id for eventual obsolescence and deletion , and give it priority since we know this id has made it to the server , and we definitely do n't want to orphan it . ", "input": " SharedPreferences sharedPrefs \n String LOG_TAG \n ExtendedJSONObject getObsoleteIds \n int compare \n int numberOfObsoleteIds \n boolean hasObsoleteIds \n void removeObsoleteId \n void setObsoleteIds \n void purgeObsoleteIds \n void limitObsoleteIds \n void decrementObsoleteId \n Collection<String> getBatchOfObsoleteIds \n String getNextObsoleteId \n void addObsoleteId \n void decrementObsoleteIdAttempts \n void decrementObsoleteIdAttempts", "output": "void function ( String arg0 ) { ExtendedJSONObject loc0 = getObsoleteIds ( ) ; loc0 . put ( arg0 , HealthReportConstants . DELETION_ATTEMPTS_PER_KNOWN_TO_BE_ON_SERVER_DOCUMENT_ID ) ; setObsoleteIds ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns the 1-based position where a value is on this stack . if the value occurs as an item in this stack , this method returns the distance from the top of the stack of the occurrence nearest the top of the stack ; the topmost item on the stack is considered to be at distance 1 . ", "input": " ArrayBooleanList list \n boolean pop \n int size \n boolean get \n void clear \n boolean push \n boolean empty \n boolean peek \n boolean peek", "output": "int function ( boolean arg0 ) { for ( int loc0 = list . size ( ) - 1 ; loc0 >= 0 ; loc0 -- ) { if ( list . get ( loc0 ) == arg0 ) { return list . size ( ) - loc0 ; } } return - 1 ; }"}, {"instruction": "Generate java code\nparse local from string . ", "input": " Logger logger \n Ideal<C> ideal \n GenPolynomialRing<C> ring \n int isField \n Local<C> random \n Local<C> random \n Local<C> random \n int hashCode \n boolean isField \n boolean equals \n Local<C> getONE \n boolean isCommutative \n Local<C> getZERO \n Local<C> fromInteger \n Local<C> fromInteger \n boolean isAssociative \n String toString \n Local<C> copy \n java.math.BigInteger characteristic", "output": "Local < C > function ( String arg0 ) { GenPolynomial < C > loc0 = ring . parse ( arg0 ) ; return new Local < C > ( this , loc0 ) ; }"}, {"instruction": "Generate java code\nreturns the df -- branch information in the form class : method : line-number ", "input": " boolean overwrite \n boolean debug_df \n String outputfile \n String scratchdir \n Sequence getSingletonElt \n Variable find_value_by_name \n void main \n void run_cmd \n String getDriverCode", "output": "String function ( Branch arg0 , DataFlowInput arg1 ) { return ( arg0 . getClassName ( ) + \"srini_string\" + arg0 . getMethodName ( ) + \"srini_string\" + arg0 . getLineNumber ( ) ) ; }"}, {"instruction": "Generate java code\nunregister an image panel ", "input": " ColorExplorerDialog colorDialog \n Stevironment instance \n ColorExplorerMenuItem colorExplorerMenuItem \n void registerImagePanel \n ColorExplorerMenuItem getColorExplorerMenuItem \n Stevironment getInstance", "output": "void function ( ImagePanel arg0 ) { arg0 . removeMouseMotionListener ( colorDialog ) ; }"}, {"instruction": "Generate java code\nparse algebraicnumber from reader . ", "input": " GenPolynomialRing<C> ring \n int isField \n GenPolynomial<C> modul \n boolean isField \n boolean isCommutative \n AlgebraicNumber<C> interpolate \n java.math.BigInteger characteristic \n AlgebraicNumber<C> random \n AlgebraicNumber<C> random \n int hashCode \n boolean equals \n AlgebraicNumber<C> getONE \n AlgebraicNumber<C> getZERO \n AlgebraicNumber<C> fromInteger \n AlgebraicNumber<C> fromInteger \n boolean isAssociative \n String toString \n AlgebraicNumber<C> copy \n AlgebraicNumber<C> chineseRemainder", "output": "AlgebraicNumber < C > function ( Reader arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the weight of given key ", "input": " Map<T,Integer> nodePosition \n List<Node> allNodes \n int weight \n T key \n void add \n T min \n void printPositionMap \n void swap \n void updatePositionMap \n Node extractMinNode \n void printHeap \n void main \n T extractMin \n void decrease \n boolean containsData \n boolean empty", "output": "Integer function ( T arg0 ) { Integer loc0 = nodePosition . get ( arg0 ) ; if ( loc0 == null ) { return null ; } else { return allNodes . get ( loc0 ) . weight ; } }"}, {"instruction": "Generate java code\ngets a comparator that can sort boolean objects . the parameter specifies whether true or false is sorted first . the comparator throws nullpointerexception if a null value is compared . ", "input": " Comparator NATURAL_COMPARATOR \n Comparator transformedComparator \n Object min \n Comparator reversedComparator \n Object max \n Comparator naturalComparator \n Comparator chainedComparator \n Comparator chainedComparator \n Comparator chainedComparator \n Comparator nullHighComparator \n Comparator nullLowComparator", "output": "Comparator function ( boolean arg0 ) { return BooleanComparator . getBooleanComparator ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis is an access method for the per-call state provided by the client to the server . ", "input": " Map<String,ByteBuffer> requestCallMeta \n Map<String,ByteBuffer> responseCallMeta \n Object response \n List<ByteBuffer> requestPayload \n List<ByteBuffer> responsePayload \n HandshakeRequest handshakeRequest \n HandshakeResponse handshakeResponse \n Exception error \n Message message \n void setResponseCallMeta \n List<ByteBuffer> getRequestPayload \n void setRequestHandshakeMeta \n Map<String,ByteBuffer> requestHandshakeMeta \n void setRequestPayload \n void setResponsePayload \n Message getMessage \n void setResponse \n void setResponseHandshakeMeta \n void setRequestCallMeta \n Exception error \n void setMessage \n void setHandshakeRequest \n Map<String,ByteBuffer> responseHandshakeMeta \n boolean isError \n Map<String,ByteBuffer> responseCallMeta \n HandshakeRequest getHandshakeRequest \n Object response \n void setError \n void setHandshakeResponse \n HandshakeResponse getHandshakeResponse \n List<ByteBuffer> getResponsePayload", "output": "Map < String , ByteBuffer > function ( ) { if ( requestCallMeta == null ) { requestCallMeta = new HashMap < String , ByteBuffer > ( ) ; } return requestCallMeta ; }"}, {"instruction": "Generate java code\ngets the value of the getcontenttype property . ", "input": " Owner owner \n PrincipalURL principalURL \n Creationdate creationdate \n Getlastmodified getlastmodified \n Getcontentlanguage getcontentlanguage \n Getetag getetag \n Getcontentlength getcontentlength \n SupportedReportSet supportedReportSet \n Acl acl \n PrincipalCollectionSet principalCollectionSet \n Resourcetype resourcetype \n List<Element> any \n QuotaUsedBytes quotaUsedBytes \n Lockdiscovery lockdiscovery \n QuotaAvailableBytes quotaAvailableBytes \n Getcontenttype getcontenttype \n Displayname displayname \n Supportedlock supportedlock \n Group group \n PrincipalCollectionSet getPrincipalCollectionSet \n Creationdate getCreationdate \n void setCreationdate \n void setQuotaAvailableBytes \n Getcontentlength getGetcontentlength \n Displayname getDisplayname \n void setGetcontenttype \n void setAcl \n Owner getOwner \n Getlastmodified getGetlastmodified \n Supportedlock getSupportedlock \n void setLockdiscovery \n void setOwner \n SupportedReportSet getSupportedReportSet \n void setSupportedReportSet \n void setSupportedlock \n void setPrincipalCollectionSet \n QuotaUsedBytes getQuotaUsedBytes \n Acl getAcl \n void setQuotaUsedBytes \n void setPrincipalURL \n PrincipalURL getPrincipalURL \n void setGetetag \n Resourcetype getResourcetype \n Getcontentlanguage getGetcontentlanguage \n void setResourcetype \n Getetag getGetetag \n void setGroup \n Group getGroup \n void setGetcontentlanguage \n Lockdiscovery getLockdiscovery \n void setGetlastmodified \n QuotaAvailableBytes getQuotaAvailableBytes \n void setDisplayname \n void setGetcontentlength \n List<Element> getAny", "output": "Getcontenttype function ( ) { return getcontenttype ; }"}, {"instruction": "Generate java code\nconverts an element representing a location into a location object . ", "input": " InputStreamGetter input \n boolean isValid \n Difficulty puzzleDifficulty \n int puzzleSize \n boolean matchesSchema \n KenKenPuzzle buildPuzzle \n int getPuzzleSize \n boolean isValid \n Schema compileSchema \n KenKenPuzzle getKenKenPuzzle \n Grid parseGrid \n Difficulty getPuzzleDifficulty \n int getSize \n void setLoaderInfo \n Element getSolutionBoardElement \n Cage parseCage \n int getDifficulty", "output": "Location function ( Element arg0 ) { int loc0 = Integer . parseInt ( arg0 . getAttribute ( \"srini_string\" ) ) ; char loc1 = arg0 . getAttribute ( \"srini_string\" ) . charAt ( 0 ) ; return new Location ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nset the context attribute key under which we will store the request locale . ", "input": " String localeKey \n String getLocaleKey \n boolean execute \n Locale getLocale", "output": "void function ( String arg0 ) { this . localeKey = arg0 ; }"}, {"instruction": "Generate java code\nquery if this ring is a field . ", "input": " RingFactory<C> ring \n boolean debug \n Logger logger \n Quotient<C> random \n Quotient<C> random \n int hashCode \n boolean equals \n Quotient<C> getONE \n boolean isCommutative \n Quotient<C> getZERO \n Quotient<C> fromInteger \n Quotient<C> fromInteger \n boolean isAssociative \n String toString \n Quotient<C> parse \n Quotient<C> parse \n Quotient<C> copy \n java.math.BigInteger characteristic", "output": "boolean function ( ) { return true ; }"}, {"instruction": "Generate java code\noverride to inject . ", "input": " ISemanticEvent[] _selection \n IEventSequenceCommandFactory _commandFactory \n ISemanticEvent[] EMPTY_SELECTION \n List _listeners \n IEventSequence _sequence \n ActionProvider _actionProvider \n List getListeners \n void select \n void sessionStarted \n IAction[] getActions \n void clickDelete \n IEventSequence remove \n ICommandStack getCommandStack \n ISemanticEvent[] getEvents \n boolean canUndo \n IEventSequence removeAll \n IEventSequence removeAll \n void undo \n void addListener \n IEventGroup group \n IEventSequence add \n IEventSequence add \n void sessionEnded \n EventSequenceCommandFactory createCommandFactory \n boolean isEmpty \n boolean hasSelection \n ActionProvider getActionProvider \n void removeListener \n IEventSequenceCommandFactory getCommandFactory \n ActionProvider createActionProvider \n ISemanticEvent[] getSelection \n void setSelection \n IEventSequence addAll \n IEventSequence getSequence \n void exec \n void changed", "output": "SequenceCommandLabelProvider function ( ) { return new SequenceCommandLabelProvider ( ) ; }"}, {"instruction": "Generate java code\nsets the iterator for this iterator to use . if iteration has started , this effectively resets the iterator . ", "input": " Predicate predicate \n Object nextObject \n Iterator iterator \n boolean nextObjectSet \n Object next \n Iterator getIterator \n void setPredicate \n Predicate getPredicate \n boolean hasNext \n boolean setNextObject \n void remove", "output": "void function ( Iterator arg0 ) { this . iterator = arg0 ; }"}, {"instruction": "Generate java code\nreturns entity content as a inputstream if set using #setstream java.io.inputstream method . ", "input": " File file \n boolean gzipCompress \n InputStream stream \n byte[] binary \n String contentEncoding \n boolean chunked \n String text \n List<NameValuePair> parameters \n Serializable serializable \n ContentType contentType \n EntityBuilder setBinary \n String getContentEncoding \n boolean isGzipCompress \n EntityBuilder setStream \n String getText \n void clearContent \n EntityBuilder setContentEncoding \n EntityBuilder chunked \n EntityBuilder setSerializable \n File getFile \n EntityBuilder setParameters \n EntityBuilder setParameters \n Serializable getSerializable \n EntityBuilder setFile \n boolean isChunked \n EntityBuilder gzipCompress \n HttpEntity build \n List<NameValuePair> getParameters \n EntityBuilder create \n ContentType getContentType \n ContentType getContentOrDefault \n byte[] getBinary \n EntityBuilder setContentType \n EntityBuilder setText", "output": "InputStream function ( ) { return stream ; }"}, {"instruction": "Generate java code\nsets the checks if is test . ", "input": " String errorMessage \n String numberChosen \n String buyerName \n Boolean isTest \n String getNumberChosen \n String getBuyerName \n void execute \n String getErrorMessage", "output": "void function ( Boolean arg0 ) { this . isTest = arg0 ; }"}, {"instruction": "Generate java code\nreturns the clone of the passed documentwrapper with filled documentwrapper #getdocumentmetadata and documentwrapper #getrowid only ", "input": " Logger log \n List<DocumentWrapper> extractDocumentWrappers \n String getPublicationYear \n Author getAuthor \n List<Author> getAuthors \n List<DocumentProtos.DocumentMetadata> extractDocumentMetadata \n String getMainTitle", "output": "DocumentWrapper function ( DocumentWrapper arg0 ) { return DocumentWrapper . newBuilder ( ) . setDocumentMetadata ( arg0 . getDocumentMetadata ( ) ) . setRowId ( arg0 . getRowId ( ) ) . build ( ) ; }"}, {"instruction": "Generate java code\nremoving an item . similar to stack . ", "input": " Node next \n Item item \n Node last \n int size \n Node first \n void enqueue \n int size \n boolean isEmpty \n void main", "output": "Item function ( ) { Item loc0 = first . item ; first = first . next ; size -- ; if ( isEmpty ( ) ) { last = null ; } return loc0 ; }"}, {"instruction": "Generate java code\nsets the replicated resources of the neighbor to the given set one-hop replication ", "input": " TokenBucket queryTokens \n Set<IResource> resources \n ISchedQueue<EnqueuedQuery> relayQueue \n int lastDegreeObserved \n TimeoutSet<Integer> queryUIDsRelayed \n ISchedQueue<EnqueuedQuery> getRelayQueue \n TokenBucket getQueryTokenBucket \n void markQueryAsRelayed \n Set<IResource> getResources \n void setLastDegreeObserved \n boolean removeQueryFromCache \n void setRelayQueue \n String toString \n boolean hasRelayedQuery \n int getLastDegreeObserved", "output": "void function ( Set < IResource > arg0 ) { this . resources = arg0 ; }"}, {"instruction": "Generate java code\ntests that the entity listeners are correctly invoked and have access to the java : comp/ejbcontext when an entity is persisted via a stateless cmt bean ", "input": " InitialContext iniCtx \n String ARCHIVE_NAME \n void testCDICallbackInvoked \n T lookup \n T rawLookup \n void doBMTTest \n void testSLSBBMT \n void doCMTTest \n void testSFSBBMT \n void testSingletonBMT \n void testSingletonCMT \n Archive<?> deploy \n void testSFSBCMT", "output": "void function ( ) { MyListener . setInvocationCount ( 0 ) ; SLSBCMT loc0 = lookup ( \"srini_string\" , SLSBCMT . class ) ; this . doCMTTest ( loc0 , 3 ) ; }"}, {"instruction": "Generate java code\ncheck authorization for `` read table '' for given db.table . a hiveaccesscontrolexception is thrownfor illegal access . ", "input": " HiveAuthorizer authorizerV2 \n org.slf4j.Logger logger \n boolean authzEnabled \n void authorizeShowTables \n void authorizeShowDatabases \n void authorize", "output": "void function ( final String arg0 , final String arg1 ) { if ( ! authzEnabled ) { return ; } HivePrivilegeObject loc0 = new HivePrivilegeObject ( HivePrivilegeObjectType . TABLE_OR_VIEW , arg0 , arg1 ) ; authorize ( HiveOperationType . QUERY , ImmutableList . of ( loc0 ) , Collections . < HivePrivilegeObject > emptyList ( ) , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the value of the allprop property . ", "input": " Prop prop \n Allprop allprop \n Propname propname \n void setPropname \n void setProp \n Prop getProp \n void setAllprop \n Propname getPropname", "output": "Allprop function ( ) { return allprop ; }"}, {"instruction": "Generate java code\nchecking if the value of x is equal to the sum of obstacle value x and obstacle width . ", "input": " int HEIGHT \n int JUMP \n int x \n int y \n int ground \n int WIDTH \n int moveY \n int DOWN \n void draw \n boolean crashOnGround \n void down \n void jump", "output": "boolean function ( Obstacles arg0 ) { if ( x == arg0 . x + 150 ) { return true ; } return false ; }"}, {"instruction": "Generate java code\nget the tag number . ", "input": " boolean isImplicit \n int tagNo \n boolean isAppSpecific \n TaggingOption newExplicitAppSpecific \n boolean isImplicit \n TaggingOption newImplicitAppSpecific \n TaggingOption newImplicitContextSpecific \n Tag getTag \n TaggingOption newExplicitContextSpecific \n boolean isAppSpecific", "output": "int function ( ) { return tagNo ; }"}, {"instruction": "Generate java code\nsubtract a duration from a timestamp . ", "input": " BigInteger NANOS_PER_SECOND_BIG_INTEGER \n long DURATION_SECONDS_MAX \n long DURATION_SECONDS_MIN \n long TIMESTAMP_SECONDS_MAX \n long NANOS_PER_SECOND \n long TIMESTAMP_SECONDS_MIN \n Timestamp add \n Duration add \n Duration distance \n Duration createDurationFromMicros \n Timestamp createTimestampFromMillis \n BigInteger toBigInteger \n BigInteger toBigInteger \n Duration createDurationFromNanos \n Timestamp createTimestampFromMicros \n Duration createDurationFromMillis \n Duration createDurationFromBigInteger \n Duration parseDuration \n long toNanos \n long toNanos \n Timestamp getEpoch \n Timestamp parseTimestamp \n String toString \n String toString \n long toMillis \n long toMillis \n Duration divide \n Duration divide \n long divide \n Timestamp createTimestampFromNanos \n Timestamp getCurrentTime \n Duration multiply \n Duration multiply \n long toMicros \n long toMicros \n Duration remainder \n Duration normalizedDuration", "output": "Timestamp function ( Timestamp arg0 , Duration arg1 ) { return Timestamps . subtract ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nthis factory method creates and returns a property given the class and name parameters , where the `` name '' parameter represents either : a public getname method on the class which takes no arguments , plus an optional public setname method which takes a value of the same type returned by getname a public isname method on the class which takes no arguments , plus an optional public setname method which takes a value of the same type returned by isname a public name field on the class if either of the get/is method alternatives is found on the class , but an appropriate setname method is not found , the property will be #isreadonly readonly . calling the #set object , object method on sucha property is allowed , but will have no effect . if neither the methods nor the field are found on the class a nosuchpropertyexception exception will be thrown . ", "input": " String mName \n Class<V> mType \n boolean isReadOnly \n void set \n String getName \n Class<V> getType \n V get", "output": "Property < T , V > function ( Class < T > arg0 , Class < V > arg1 , String arg2 ) { return new ReflectiveProperty < T , V > ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nensures that the object given as a method parameter is not null . ", "input": " PlaceHolder placeHolder \n void isTrue \n void isTrue \n void notEmpty", "output": "void function ( Object arg0 , String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( arg1 ) ; } }"}, {"instruction": "Generate java code\nlog a message and exception with warn log level . ", "input": " String name \n boolean classAndMethodFound \n Logger logger \n String sourceMethodName \n String sourceClassName \n void debug \n void debug \n void log \n Logger getLogger \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isDebugEnabled \n void getClassAndMethod \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { log ( Level . WARNING , String . valueOf ( arg0 ) , arg1 ) ; }"}, {"instruction": "Generate java code\ntriggers an incremental build if this save helper did save files before . ", "input": " boolean fFilesSaved \n int SAVE_ALL \n int SAVE_REFACTORING \n int fSaveMode \n int SAVE_NOTHING \n int SAVE_ALL_ALWAYS_ASK \n boolean didSaveFiles \n ILabelProvider createDialogLabelProvider \n boolean saveEditors \n boolean askSaveAllDirtyEditors", "output": "void function ( ) { if ( fFilesSaved && ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ) { new GlobalBuildAction ( JavaPlugin . getActiveWorkbenchWindow ( ) , IncrementalProjectBuilder . INCREMENTAL_BUILD ) . run ( ) ; } }"}, {"instruction": "Generate java code\nreturns true iff the collection contains an element equivalent to the given one , as decided by the hasher . ", "input": " PlaceHolder placeHolder \n T getNthIteratedElement \n T getNthIteratedElement \n boolean containsIdentical \n List<String> prefix \n T removeMatching \n String toStringInLines \n List<String> toStringLines \n SortedSet<Integer> findAll \n String toStringInSortedLines \n List<List<T>> chunkUp \n boolean areDisjoint \n Set<T> intersection \n Set<T> xor \n String join \n List<T> map \n List<T> roCopyList \n Set<T> getAll \n Set<T> diff \n Map<Integer,Set<Object[]>> createPerArityGroups \n Set<T> union \n List<T> concat \n List<String> sort \n List<T> concatAll \n boolean allInstancesOf \n List<T> unique \n List<List<T>> allCombinations \n T[] addToArray", "output": "boolean function ( Collection < T > arg0 , Object arg1 , Hasher arg2 ) { for ( T loc0 : arg0 ) { if ( arg2 . equals ( loc0 , arg1 ) ) return true ; } return false ; }"}, {"instruction": "Generate java code\ncreate additional h2 schema . ", "input": " String VALIDATE_FAILURE_EXPECTED \n String extractTestName \n T locateAnnotation \n List<S> collectAnnotations \n String extractMethodName \n String extractIgnoreMessage \n boolean isNotEmpty \n String extractMessage", "output": "void function ( String arg0 , Map arg1 ) { arg1 . put ( Environment . URL , arg1 . get ( Environment . URL ) + \"srini_string\" + arg0 ) ; }"}, {"instruction": "Generate java code\nreturn the disjuction of two criterions . ", "input": " PlaceHolder placeHolder \n AuditProperty<Object> revisionProperty \n AuditProperty<RevisionType> revisionType \n AuditCriterion not \n AuditConjunction conjunction \n AuditProperty<Number> revisionNumber \n AuditDisjunction disjunction \n AuditCriterion and \n AuditProperty<Object> property \n AuditId id \n AuditRelatedId relatedId", "output": "AuditCriterion function ( AuditCriterion arg0 , AuditCriterion arg1 ) { return new LogicalAuditExpression ( arg0 , arg1 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the composites . ", "input": " List components \n One one \n List manyToMany \n Foo foo \n int count \n Collection bag \n Simple simple \n Many many \n Set composites \n Collection lazyBag \n Collection cascades \n String name \n Set ternarySet \n Glarch glarch \n List oneToMany \n long id \n Map ternaryMap \n void setName \n void setName \n void setCascades \n String getName \n String getName \n void setBag \n void setFoo \n Map getTernaryMap \n long getId \n Glarch getGlarch \n List getOneToMany \n void setComposites \n void setGlarch \n int hashCode \n Many getMany \n Foo getFoo \n List getComponents \n void setId \n Collection getBag \n int getCount \n Collection getLazyBag \n void setCount \n void setComponents \n void setOneToMany \n void setOne \n void setLazyBag \n Simple getSimple \n void setTernaryMap \n void setMany \n void setTernarySet \n void setSimple \n List getManyToMany \n boolean equals \n One getOne \n void setManyToMany \n String toString \n Collection getCascades \n Set getTernarySet", "output": "Set function ( ) { return composites ; }"}, {"instruction": "Generate java code\nreturns the z component of the cross product between vectors bc and ba . ", "input": " float x \n float y \n float getX \n float getY \n void orderBestPatterns \n float distance \n int hashCode \n boolean equals \n String toString", "output": "float function ( ResultPoint arg0 , ResultPoint arg1 , ResultPoint arg2 ) { float loc0 = arg1 . x ; float loc1 = arg1 . y ; return ( ( arg2 . x - loc0 ) * ( arg0 . y - loc1 ) ) - ( ( arg2 . y - loc1 ) * ( arg0 . x - loc0 ) ) ; }"}, {"instruction": "Generate java code\ncreates a progressrequestbody that can be used for showing uploading progress ", "input": " String CONTENT_ENCODING_GZIP \n RequestBody createGzip \n InputStream getFileInputStream \n boolean isGzipEncoding \n RequestBody create \n RequestBody getEmptyBody", "output": "ProgressRequestBody function ( RequestBody arg0 , ProgressRequestListener arg1 ) { return new ProgressRequestBody ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nchecks the length of a code and if a code consists of numbers only . ", "input": " PlaceHolder placeHolder \n boolean isLowercase \n boolean isValid \n boolean isUppercase \n String check", "output": "boolean function ( String arg0 , int arg1 ) { if ( arg0 . length ( ) != arg1 ) return false ; for ( char loc0 : arg0 . toCharArray ( ) ) if ( loc0 < 48 || loc0 > 57 ) return false ; return true ; }"}, {"instruction": "Generate java code\nwait for the reveal action to complete . ", "input": " TableItemTester _tableItemTester \n int REVEAL_WAIT \n TableTester _tableTester \n Widget reveal \n Widget reveal \n void revealColumn \n void showColumn", "output": "void function ( ) { UIDriver . pause ( REVEAL_WAIT ) ; }"}, {"instruction": "Generate java code\nsets the start point of the subpath . ", "input": " List<Shape> segments \n Point2D startPoint \n boolean closed \n Point2D getStartPoint \n boolean isSinglePointOpen \n void addSegment \n boolean isDegenerate \n boolean isClosed \n boolean isEmpty \n boolean isSinglePointClosed \n List<Point2D> getPiecewiseLinearApproximation \n Point2D getLastPoint \n void setClosed \n List<Shape> getSegments", "output": "void function ( Point2D arg0 ) { setStartPoint ( ( float ) arg0 . getX ( ) , ( float ) arg0 . getY ( ) ) ; }"}, {"instruction": "Generate java code\nsets the linked list node after this one . ", "input": " TLinkable _next \n TLinkable _previous \n TLinkable getPrevious \n TLinkable getNext \n void setPrevious", "output": "void function ( TLinkable arg0 ) { _next = arg0 ; }"}, {"instruction": "Generate java code\ngets the java encoding from the iana encoding . if the encoding can not be found it returns the input . ", "input": " Map<String,String> MAP \n placeholderType placeHolder", "output": "String function ( final String arg0 ) { String loc0 = arg0 . toUpperCase ( ) ; String loc1 = MAP . get ( loc0 ) ; if ( loc1 == null ) loc1 = arg0 ; return loc1 ; }"}, {"instruction": "Generate java code\nadd a link to sentence ", "input": " long serialVersionUID \n List<String> links \n List<TokenElement> tokens \n List<LineOffset> offsetMap \n int lineNumber \n String content \n int startPositionOffset \n boolean isFirstSentence \n int getOffsetMapSize \n void setContent \n List<String> getLinks \n void setOffsetMap \n String getContent \n List<TokenElement> getTokens \n Optional<LineOffset> getOffset \n boolean isFirstSentence \n void setTokens \n int getLineNumber \n int getOffsetPosition \n int hashCode \n boolean equals \n int getStartPositionOffset \n void setIsFirstSentence \n void setLineNumber \n String toString \n List<LineOffset> getOffsetMap", "output": "void function ( String arg0 ) { this . links . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the matcher identifying the parent of the target of this match . ", "input": " IWidgetMatcher _parentMatcher \n int _index \n int DEFAULT_INDEX \n IWidgetMatcher _matcher \n IWidgetMatcher getTargetMatcher \n String toString \n boolean matches \n boolean matches \n boolean testIndex", "output": "IWidgetMatcher function ( ) { return _parentMatcher ; }"}, {"instruction": "Generate java code\nreturns true if the doubly-nested set did not contain v. ", "input": " DoubleKeyMap<K1,K2,Set<V>> dkMap \n boolean addAll \n Set<V> get \n void clear \n boolean containsKeys \n String toString \n Set<K2> getK2Set \n boolean remove \n Set<K1> getK1Set \n void ensureSetExists \n Set<V> getAllVs", "output": "boolean function ( K1 arg0 , K2 arg1 , V arg2 ) { ensureSetExists ( arg0 , arg1 ) ; return dkMap . get ( arg0 , arg1 ) . add ( arg2 ) ; }"}, {"instruction": "Generate java code\nsearches for the first subsequence of a that matches sub elementwise . elements of sub are considered to match elements of a if they pass the #eq test . ", "input": " double max_ratio \n double min_ratio \n boolean off \n boolean isElemMatch \n int compare \n boolean isSubset \n boolean ne \n boolean lt \n boolean gte \n void set_rel_diff \n boolean eq \n boolean lte \n boolean gt", "output": "int function ( double [ ] arg0 , double [ ] arg1 ) { int loc0 = arg0 . length - arg1 . length ; outer : for ( int loc1 = 0 ; loc1 <= loc0 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg1 . length ; loc2 ++ ) { if ( ne ( arg0 [ loc1 + loc2 ] , arg1 [ loc2 ] ) ) { continue outer ; } } return ( loc1 ) ; } return ( - 1 ) ; }"}, {"instruction": "Generate java code\nsequential number of the statement , as assigned by the account servicer . the sequential number is increased incrementally for each statement sent electronically . ", "input": " BankToCustomerStatementV02 bankToCustomerStatement \n Document document \n GroupHeader42 groupHeader \n AccountStatement2 stmt \n CashAccount16 getRltdAcct \n List<ReportEntry2> getNtry \n String getAddtlStmtInf \n BankToCustomerStatement read \n PartyIdentification32 getMsgRcpt \n Date getToDt \n Date getCreDtTm \n Date getCreDtTm \n Pagination getMsgPgntn \n String getAddtlInf \n String getId \n Date getFrDt \n TotalTransactions2 getTxsSummry \n List<AccountInterest2> getIntrst \n CashAccount20 getAcct \n String getMsgId \n ReportingSource1Choice getRptgSrc \n List<AccountStatement> getStmt \n CopyDuplicate1Code getCpyDplctInd \n BigDecimal getLglSeqNb \n List<CashBalance3> getBal", "output": "BigDecimal function ( ) { return stmt . getElctrncSeqNb ( ) ; }"}, {"instruction": "Generate java code\nthe globally unique id for this dataset ", "input": " String urn \n boolean isDefault \n Map<String,JsonBall> requirements \n String os \n ImmutableMap.Builder<String,JsonBall> requirements \n Date created \n String name \n String description \n String id \n Type type \n Function<JsonBall,String> unquoteString \n String version \n Builder toBuilder \n String getOs \n String getName \n Builder description \n Map<String,String> getRequirementsAsJsonLiterals \n int compareTo \n Builder type \n Builder addRequirement \n String getDescription \n int hashCode \n Builder builder \n Builder id \n String getVersion \n Builder requirements \n Map<String,String> getRequirements \n Builder os \n String apply \n Builder created \n Date getCreated \n Builder version \n Builder urn \n Builder fromDataset \n Builder isDefault \n boolean isDefault \n String getUrn \n Dataset build \n Type getType \n boolean equals \n Builder name \n String toString", "output": "String function ( ) { return id ; }"}, {"instruction": "Generate java code\nsave motorbikes that we previously put a down payment on pending db changes should be flushed as per jpa 7.9.1 container responsibilities for xpc : when a business method of the stateful session bean is invoked , if the stateful session bean uses container managed transaction demarcation , and the entity manager is not already associated with the current jta transaction , the container associates the entity manager with the current jta transaction and calls entitymanager.jointransaction . ", "input": " EntityManager entityManager \n Motorbike downPaymentOnBikeNoTx \n Motorbike find \n void forceRollback \n Motorbike createMotorBike", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nreturns the maximum x value in the model . ", "input": " Entry<Double,Integer> next \n Integer HIGHLIGHT_CRITICAL \n Iterator<Entry<Double,Integer>> subMapIterator \n Integer HIGHLIGHT_VALIDATION \n Integer HIGHLIGHT_INFO \n Double xValue \n Integer HIGHLIGHT_NONE \n double delta \n Integer yValue \n TreeMap<Double,Integer> values \n Integer HIGHLIGHT_WARNING \n HighlightEntry next \n Double getKey \n Integer getValue \n int severityToHighlight \n int size \n Integer setValue \n void clear \n void addData \n HighlightModel create \n boolean hasNext \n Iterator<HighlightEntry> getRangeValues \n void remove", "output": "double function ( ) { return values . lastKey ( ) ; }"}, {"instruction": "Generate java code\nsole entry point to application , as always . ", "input": " PlaceHolder placeHolder \n void printCapitalized", "output": "void function ( String [ ] arg0 ) { String loc0 ; TextIO . putln ( \"srini_string\" ) ; loc0 = TextIO . getln ( ) ; TextIO . putln ( ) ; TextIO . putln ( \"srini_string\" ) ; printCapitalized ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable , empty longlist . ", "input": " LongIterator EMPTY_LONG_ITERATOR \n LongList EMPTY_LONG_LIST \n LongListIterator EMPTY_LONG_LIST_ITERATOR \n LongList singletonLongList \n LongListIterator unmodifiableLongListIterator \n LongIterator getEmptyLongIterator \n LongList unmodifiableLongList \n LongIterator singletonLongIterator \n LongListIterator singletonLongListIterator \n LongListIterator getEmptyLongListIterator \n LongIterator unmodifiableLongIterator", "output": "LongList function ( ) { return EMPTY_LONG_LIST ; }"}, {"instruction": "Generate java code\nreturn root columns ' metadata . roots are columns that have no parent . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n ColumnMetaData[] getColumnMetaData \n ColumnMetaData getColumnMetaData \n ColumnMetaData getColumnMetaData \n long getRowCount \n void readColumnMetaData \n ColumnValues<T> getValues \n ColumnValues<T> getValues \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n ColumnFileMetaData getMetaData \n void readHeader \n void readMagic \n void close", "output": "List < ColumnMetaData > function ( ) { List < ColumnMetaData > loc0 = new ArrayList < ColumnMetaData > ( ) ; for ( int loc1 = 0 ; loc1 < columnCount ; loc1 ++ ) if ( columns [ loc1 ] . metaData . getParent ( ) == null ) loc0 . add ( columns [ loc1 ] . metaData ) ; return loc0 ; }"}, {"instruction": "Generate java code\nuse for system classes only , since not classloader or reflector-aware ", "input": " PlaceHolder placeHolder \n void lockFile \n Object createWeakReference \n Reflector createReflector \n Class constructorClass \n void killYapRef \n boolean isConnected \n Thread addShutdownHook \n Object weakReferenceTarget \n Constructor serializableConstructor \n void forEachCollectionElement \n void registerCollections \n long nanoTime \n Reflector reflectorForType \n Object deserialize \n void extendConfiguration \n Config4Class extendConfiguration \n void unlockFile \n Object createActivateObjectReference \n int ver \n NetTypeHandler[] types \n void setAccessible \n void commonConfigurations \n String format \n boolean isEnum \n void throwIllegalArgumentException \n Object createReferenceQueue \n byte[] serialize \n void pollReferenceQueue \n Object getContextClassLoader \n Object getYapRefObject \n Class loadClass \n void removeShutdownHook \n boolean isCollectionTranslator \n boolean useNativeSerialization \n NetTypeHandler[] netTypes", "output": "boolean function ( String arg0 , String arg1 , Class [ ] arg2 ) { return false ; }"}, {"instruction": "Generate java code\nreturns a default formatted string with fields separated by '' , '' ", "input": " String component \n String task \n String values \n String messageId \n String ts \n void prepare \n void log \n void close", "output": "String function ( ) { return new Date ( Long . parseLong ( ts ) ) . toString ( ) + \"srini_string\" + component + \"srini_string\" + task + \"srini_string\" + messageId + \"srini_string\" + values ; }"}, {"instruction": "Generate java code\nreturns null if it was created , the value otherwise . ", "input": " String _subdir \n TreeMap<BigInteger,Object> _curr \n TransactionalState _state \n boolean _strictOrder \n Object init \n Object getLastState \n void overrideState \n Object getState \n void cleanupBefore \n boolean hasCache \n void removeState \n String txPath \n String txPath \n void sync", "output": "Object function ( BigInteger arg0 , StateInitializer arg1 ) { if ( _curr . containsKey ( arg0 ) ) { return _curr . get ( arg0 ) ; } else { getState ( arg0 , arg1 ) ; return null ; } }"}, {"instruction": "Generate java code\nsets the value of the fckey property . ", "input": " String fcLink \n String localPortID \n String displayName \n String fcKey \n ProvidedPortID id \n List<PropertyDeclaration> properties \n String resourceType \n String getFcLink \n String getFcKey \n String getDisplayName \n List<PropertyDeclaration> getProperties \n String getResourceType \n void setFcLink \n String getLocalPortID \n void setResourceType \n void setId \n ProvidedPortID getId \n void setLocalPortID \n void setDisplayName", "output": "void function ( String arg0 ) { this . fcKey = arg0 ; }"}, {"instruction": "Generate java code\nparse residue from reader . ", "input": " Ideal<C> ideal \n Logger logger \n GreatestCommonDivisor<C> engine \n GenPolynomialRing<C> ring \n int isField \n Residue<C> random \n Residue<C> random \n Residue<C> random \n int hashCode \n boolean isField \n boolean equals \n Residue<C> getONE \n boolean isCommutative \n Residue<C> getZERO \n Residue<C> fromInteger \n Residue<C> fromInteger \n boolean isAssociative \n String toString \n Residue<C> copy \n java.math.BigInteger characteristic", "output": "Residue < C > function ( Reader arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\neasy hook to build an identifier using the keyword safe identifierhelper . ", "input": " ImplicitNamingStrategy INSTANCE \n String transformEntityName \n Identifier determineTenantIdColumnName \n String transformAttributePath \n Identifier determineMapKeyColumnName \n Identifier determineForeignKeyName \n Identifier determineJoinTableName \n Identifier determineIndexName \n Identifier determineBasicColumnName \n Identifier determineCollectionTableName \n Identifier determineJoinColumnName \n Identifier determinePrimaryTableName \n Identifier determineDiscriminatorColumnName \n Identifier determineAnyDiscriminatorColumnName \n Identifier determineUniqueKeyName \n Identifier determineIdentifierColumnName \n Identifier determinePrimaryKeyJoinColumnName \n Identifier determineListIndexColumnName \n Identifier determineAnyKeyColumnName", "output": "Identifier function ( String arg0 , MetadataBuildingContext arg1 ) { return arg1 . getMetadataCollector ( ) . getDatabase ( ) . getJdbcEnvironment ( ) . getIdentifierHelper ( ) . toIdentifier ( arg0 ) ; }"}, {"instruction": "Generate java code\nget output data language ", "input": " String m_Url \n String m_Key \n String m_Packing \n String m_Language \n String m_Format \n String getPacking \n void setPacking \n String getObjectsInBoxByBBox \n String getObjectById \n String getObjectInBox \n String getObjectsInBoxByLatLon \n String doSendApiRequest \n void setFormat \n String getObjectsInPoint \n String getObjectsInBoxByTile \n String getObjectsInBoxByTile \n String getObjectsBySearchQuery \n String getObjectsBySearchQuery \n String getFormat \n void setLanguage", "output": "String function ( ) { return m_Language ; }"}, {"instruction": "Generate java code\nremoves the data from the specified fieldnumber , if there was any . ", "input": " boolean mGarbage \n FieldData[] mData \n int mSize \n FieldData DELETED \n int[] mFieldNumbers \n boolean isEmpty \n int binarySearch \n FieldData dataAt \n void put \n int idealByteArraySize \n int size \n int hashCode \n FieldData get \n boolean equals \n FieldArray clone \n void gc \n boolean arrayEquals \n boolean arrayEquals \n int idealIntArraySize", "output": "void function ( int arg0 ) { int loc0 = binarySearch ( arg0 ) ; if ( loc0 >= 0 && mData [ loc0 ] != DELETED ) { mData [ loc0 ] = DELETED ; mGarbage = true ; } }"}, {"instruction": "Generate java code\nputs the given collection of keys into this map according to the contract of #put object , object . the values will be set to null . the keys are added in the order of the collection 's iterator . ", "input": " SortedMap<K,V> kSmallest \n int maxSize \n boolean containsKey \n Collection<V> values \n void clear \n boolean isInRange \n boolean put \n boolean put \n boolean put \n V remove \n boolean containsValue \n K getMinKey \n K getMaxKey \n int size \n K firstKey \n V get \n void setAllValues \n K lastKey \n String toString \n Set<K> keySet", "output": "void function ( final Collection < ? extends K > arg0 ) { for ( final K loc0 : arg0 ) { put ( loc0 , null ) ; } }"}, {"instruction": "Generate java code\nremoves a script from this block ", "input": " List list \n List getScriptList \n void addScript \n Script compile \n void trimWhitespace \n String toString \n void run", "output": "void function ( Script arg0 ) { list . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nset the index into the constant pool of the field 's constant value . ", "input": " ClassInfo classInfo \n int name \n int modifiers \n int type \n Attribute[] attrs \n ConstantValue constantValue \n int typeIndex \n int nameIndex \n void setNameIndex \n String toString \n void setTypeIndex \n void setModifiers \n int modifiers \n void write \n ClassInfo declaringClass \n int constantValue", "output": "void function ( final int arg0 ) { if ( constantValue != null ) { constantValue . setConstantValueIndex ( arg0 ) ; } }"}, {"instruction": "Generate java code\niterate over the ppttoplevels and trim them . ", "input": " long serialVersionUID \n Map<String,PptTopLevel> nameToPpt \n void add \n Iterator<PptTopLevel> ppt_all_iterator \n Collection<PptTopLevel> asCollection \n Iterator<PptTopLevel> pptIterator \n Collection<PptTopLevel> all_ppts \n void repCheck \n int size \n void addAll \n boolean containsName \n void removeUnsampled \n PptTopLevel get \n PptTopLevel get \n Collection<String> nameStringSet \n int countSlices \n String toString", "output": "void function ( ) { for ( PptTopLevel loc0 : nameToPpt . values ( ) ) { loc0 . trimToSize ( ) ; } }"}, {"instruction": "Generate java code\nsets the value of the caller property . ", "input": " String caller \n String user \n String uuid \n String getCaller \n String getUser \n String getUuid \n void setUser \n void setUuid", "output": "void function ( String arg0 ) { this . caller = arg0 ; }"}, {"instruction": "Generate java code\nequal iff both have the same number of ratterms and those ratterms are pairwise equal . ", "input": " Vector underlying_terms \n RatTerm[] terms \n void set \n int size \n String printDebug \n RatTerm get \n void insert \n String toString \n void addElement \n RatTermVec copy \n void remove", "output": "boolean function ( RatTermVec arg0 ) { if ( arg0 . size ( ) != this . size ( ) ) { return false ; } for ( int loc0 = 0 ; loc0 < this . size ( ) ; loc0 ++ ) { if ( ! this . get ( loc0 ) . equals ( arg0 . get ( loc0 ) ) ) { return false ; } } return true ; }"}, {"instruction": "Generate java code\nreturns the initial size of the memoryfile . ", "input": " int i_incrementSizeBy \n int INITIAL_SIZE_AND_INC \n int i_initialSize \n byte[] i_bytes \n void setBytes \n void setIncrementSizeBy \n int getIncrementSizeBy \n void setInitialSize \n byte[] getBytes", "output": "int function ( ) { return i_initialSize ; }"}, {"instruction": "Generate java code\nchecks to see whether the comparator is now locked against further changes . ", "input": " int UNKNOWN_AFTER \n int counter \n int unknownObjectBehavior \n boolean isLocked \n int UNKNOWN_BEFORE \n int UNKNOWN_THROW_EXCEPTION \n Map map \n boolean add \n void setUnknownObjectBehavior \n int compare \n int getUnknownObjectBehavior \n boolean isLocked \n boolean addAsEqual", "output": "void function ( ) { if ( isLocked ( ) ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nremoves a template to the set . ", "input": " String fTemplateTag \n int TEMPLATE_PARSE_EXCEPTION \n String CONTEXT_ATTRIBUTE \n List<Template> fTemplates \n int TEMPLATE_IO_EXCEPTION \n ContextTypeRegistry fRegistry \n String DESCRIPTION_ATTRIBUTE \n String NAME_ATTRIBUTE \n void add \n String getAttributeValue \n String validateTemplate \n void throwReadException \n void saveToStream \n void clear \n Template getFirstTemplate \n Template[] getTemplates \n Template[] getTemplates \n void addFromFile \n void saveToFile \n void addFromStream \n boolean exists \n String getTemplateTag \n void throwWriteException", "output": "void function ( Template arg0 ) { fTemplates . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the date time as a java.util.date . the date object created has exactly the same millisecond instant as this object . ", "input": " PlaceHolder placeHolder \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n boolean isEqual \n boolean isEqual \n DateTimeZone getZone \n boolean isSupported \n int compareTo \n boolean isBeforeNow \n Instant toInstant \n boolean isBefore \n boolean isBefore \n boolean isEqualNow \n MutableDateTime toMutableDateTimeISO \n DateTime toDateTimeISO \n int hashCode \n int get \n int get \n boolean equals \n String toString \n String toString \n boolean isAfter \n boolean isAfter \n DateTime toDateTime \n DateTime toDateTime \n DateTime toDateTime \n boolean isAfterNow", "output": "Date function ( ) { return new Date ( getMillis ( ) ) ; }"}, {"instruction": "Generate java code\nquery if this ring is commutative . ", "input": " GenPolynomialRing<C> ring \n int isField \n GenPolynomial<C> modul \n boolean isField \n AlgebraicNumber<C> interpolate \n AlgebraicNumber<C> parse \n AlgebraicNumber<C> parse \n java.math.BigInteger characteristic \n AlgebraicNumber<C> random \n AlgebraicNumber<C> random \n int hashCode \n boolean equals \n AlgebraicNumber<C> getONE \n AlgebraicNumber<C> getZERO \n AlgebraicNumber<C> fromInteger \n AlgebraicNumber<C> fromInteger \n boolean isAssociative \n String toString \n AlgebraicNumber<C> copy \n AlgebraicNumber<C> chineseRemainder", "output": "boolean function ( ) { return ring . isCommutative ( ) ; }"}, {"instruction": "Generate java code\ncreates a new com.datastax.driver.core.batchstatement.type #logged batch statement for the specified cql statement builders . ", "input": " PlaceHolder placeHolder \n BatchCQLStatementTupleMapper unLoggedBatch \n CqlMapper.DefaultCqlMapper all \n CQLStatementTupleMapper async \n ContextQuery named \n ContextQuery namedByField \n BatchCQLStatementTupleMapper newBatchStatementBuilder \n BatchCQLStatementTupleMapper counterBatch \n FieldSelector field \n BoundCQLStatementMapperBuilder boundQuery \n BoundCQLStatementMapperBuilder boundQuery \n FieldSelector[] fields \n SimpleCQLStatementMapperBuilder simpleQuery \n SimpleCQLStatementMapperBuilder simpleQuery", "output": "BatchCQLStatementTupleMapper function ( CQLStatementBuilder ... arg0 ) { return newBatchStatementBuilder ( BatchStatement . Type . LOGGED , arg0 ) ; }"}, {"instruction": "Generate java code\nreturn the directory into which we put our self-extracted native libraries . ", "input": " byte[] cachedBuffer \n void reliablyCopyExecutable \n void deleteOrThrow \n FileLocker lockLibsDirectory \n void freeCopyBuffer \n File createLibsDirectory \n int findAbiScore \n void dumbDeleteRecrusive \n String[] getSupportedAbis \n String[] getSupportedAbis \n void fallocateIfSupported \n void fallocate", "output": "File function ( Context arg0 ) { return new File ( arg0 . getApplicationInfo ( ) . dataDir , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nmakes sure the passed object is in the collection . equals comparison . ", "input": " int _size \n List4 _last \n List4 _first \n int _version \n void prepend \n void replace \n boolean remove \n Object singleElement \n Iterator4 iterator \n void removeAll \n void removeAll \n List4 find \n void assertNotNull \n Object get \n Object get \n void replaceByIdentity \n Object[] toArray \n Object[] toArray \n void adjustOnRemoval \n int indexOf \n void doPrepend \n List4 findByIdentity \n boolean add \n void doAdd \n boolean containsAll \n void clear \n boolean isEmpty \n int version \n boolean contains \n int size \n void addAll \n void addAll \n void addAll \n Object deepClone \n boolean containsByIdentity \n String toString \n Iterator4 internalIterator \n void changed", "output": "Object function ( Object arg0 ) { List4 loc0 = find ( arg0 ) ; if ( loc0 == null ) { add ( arg0 ) ; return arg0 ; } return loc0 . _element ; }"}, {"instruction": "Generate java code\ncloses a given closable . ", "input": " String filePrefix \n File CreateTempFile \n String parseSubstring", "output": "void function ( final Closeable arg0 ) { if ( arg0 != null ) { try { arg0 . close ( ) ; } catch ( final IOException loc0 ) { loc0 . printStackTrace ( ) ; } } }"}, {"instruction": "Generate java code\nasks the user to select a string . ", "input": " String priceUpdate \n Connection conn \n Scanner in \n ArrayList<String> publishers \n String allQuery \n String publisherQuery \n String authorPublisherQuery \n String authorQuery \n ArrayList<String> authors \n Connection getConnection \n void main \n void changePrices \n void executeQuery", "output": "String function ( String arg0 , List < String > arg1 ) { while ( true ) { System . out . println ( arg0 ) ; for ( int loc0 = 0 ; loc0 < arg1 . size ( ) ; loc0 ++ ) System . out . printf ( \"srini_string\" , loc0 + 1 , arg1 . get ( loc0 ) ) ; int loc1 = in . nextInt ( ) ; if ( loc1 > 0 && loc1 <= arg1 . size ( ) ) return arg1 . get ( loc1 - 1 ) ; } }"}, {"instruction": "Generate java code\ngetter for property ` connectedtosession ' . ", "input": " String sessionFactoryUuid \n String entityName \n SessionImplementor session \n Boolean readOnlyBeforeAttachedToSession \n boolean allowLoadOutsideTransaction \n Logger log \n boolean initialized \n boolean readOnly \n Serializable id \n Object target \n boolean unwrap \n void checkTargetState \n void permissiveInitialization \n Object getImplementation \n Object getImplementation \n void setIdentifier \n void unsetSession \n void prepareForPossibleLoadingOutsideTransaction \n boolean isReadOnlySettingAvailable \n Object getTarget \n void setReadOnlyBeforeAttachedToSession \n boolean isReadOnly \n boolean isUnwrap \n boolean isUninitialized \n Serializable getIdentifier \n void setImplementation \n void errorIfReadOnlySettingNotAvailable \n EntityKey generateEntityKeyOrNull \n void setSession \n void initialize \n String getEntityName \n void setUnwrap \n Object getProxyOrNull \n Boolean isReadOnlyBeforeAttachedToSession \n SessionImplementor getSession \n void setReadOnly", "output": "boolean function ( ) { return getProxyOrNull ( ) != null ; }"}, {"instruction": "Generate java code\nreturns the internal source viewer . ", "input": " SourceViewer fSourceViewer \n ViewForm fForm \n CLabel fLabel \n Image fPaneImage \n Control getControl \n SourceViewer createSourceViewer \n void updateTitle \n void setInput \n void createControl", "output": "SourceViewer function ( ) { return fSourceViewer ; }"}, {"instruction": "Generate java code\ninserts the child as the first child of the parent , all other children are shifted over to the ` right ' . ", "input": " FilterPredicate predicate \n List collectedNodes \n AST getLastSibling \n AST findTypeInChildren \n AST findPreviousSibling \n String getPathText \n void getPathText \n String getTokenTypeName \n boolean isSubtreeChild \n String getDebugString \n List getCollectedNodes \n Integer extractIntegerValue \n AST create \n AST createParent \n String getConstantName \n boolean exclude \n boolean exclude \n AST createBinarySubtree \n boolean include \n Map generateTokenNameCache \n void appendSibling \n ASTArray createAstArray \n AST createTree \n List collectChildren \n AST getLastChild \n void makeSiblingOfParent \n void visit \n boolean hasExactlyOneChild \n AST insertSibling \n List collect \n AST createSibling", "output": "void function ( AST arg0 , AST arg1 ) { if ( arg0 . getFirstChild ( ) == null ) { arg0 . setFirstChild ( arg1 ) ; } else { AST loc0 = arg0 . getFirstChild ( ) ; arg0 . setFirstChild ( arg1 ) ; arg1 . setNextSibling ( loc0 ) ; } }"}, {"instruction": "Generate java code\ngetter to find out if filling out fields is allowed after signing . ", "input": " boolean certification \n boolean fillInAllowed \n boolean annotationsAllowed \n PdfName action \n PdfArray fields \n List<FieldLock> fieldLocks \n List<FieldLock> getFieldLocks \n PdfArray getFields \n boolean isCertification \n PdfName getAction \n String toString \n boolean isAnnotationsAllowed", "output": "boolean function ( ) { return fillInAllowed ; }"}, {"instruction": "Generate java code\nreturns all the indices of statements where v is an input to the statement . ", "input": " List<MStatement> statements \n MSequence makeCopy \n void findInfluencingVars \n Sequence toImmutableSequence \n int getIndex \n Map<MVariable,MVariable> insert \n String toCodeString \n MVariable getVariable \n MStatement getDeclaringStatement \n void checkRep \n int size \n StatementKind getStatementKind \n List<MVariable> getInputs \n String toString \n MStatement getStatement \n int numInfluencingStatements", "output": "List < Integer > function ( MVariable arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = arg0 . getDeclIndex ( ) + 1 ; loc1 < size ( ) ; loc1 ++ ) { if ( statements . get ( loc1 ) . inputs . contains ( arg0 ) ) loc0 . add ( loc1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsetter method for property classname . ", "input": " Class<?>[] parameterTypes \n String requestId \n String methodName \n String className \n Object[] parameters \n void setParameterTypes \n void setParameters \n String getMethodName \n void setMethodName \n void setRequestId \n Object[] getParameters \n Class<?>[] getParameterTypes \n String toString \n String getClassName \n String getRequestId", "output": "void function ( String arg0 ) { this . className = arg0 ; }"}, {"instruction": "Generate java code\nget this period as an immutable period object . the period will use periodtype.standard . ", "input": " long START_1972 \n int iPeriod \n long serialVersionUID \n DurationFieldType getFieldType \n DurationFieldType getFieldType \n boolean isSupported \n int compareTo \n int getValue \n int getValue \n int size \n int hashCode \n void setValue \n int get \n boolean equals \n PeriodType getPeriodType \n MutablePeriod toMutablePeriod \n int between \n int between \n int standardPeriodIn", "output": "Period function ( ) { return Period . ZERO . withFields ( this ) ; }"}, {"instruction": "Generate java code\na classeditor 's hash code is based upon the hash code of the name of the class it edits . ", "input": " boolean dirty \n ClassInfo classInfo \n Type[] interfaces \n Type superclass \n EditorContext context \n ConstantPool constants \n Type type \n boolean DEBUG \n void setInterface \n void setInterfaces \n boolean isStatic \n boolean isSuper \n MethodInfo[] methods \n void commit \n boolean isPrivate \n Type type \n int modifiers \n void setDirty \n void setFinal \n void setSuper \n boolean isDirty \n boolean isProtected \n Type superclass \n void setProtected \n EditorContext context \n boolean isPublic \n boolean isFinal \n ConstantPool constants \n boolean isInterface \n ClassInfo classInfo \n void setPublic \n Type[] interfaces \n void addInterface \n void addInterface \n void setStatic \n void setType \n void commitOnly \n boolean isAbstract \n void setSuperclass \n boolean equals \n String name \n void setAbstract \n String toString \n void visit \n FieldInfo[] fields \n void setPrivate", "output": "int function ( ) { return ( this . name ( ) . hashCode ( ) ) ; }"}, {"instruction": "Generate java code\nget the list of polynomials . ", "input": " ArrayList<GenPolynomial<C>> P \n ArrayList<BitSet> red \n boolean useCriterion4 \n int putCount \n Logger logger \n GenPolynomialRing<C> ring \n boolean oneInGB \n int remCount \n int moduleVars \n Reduction<C> reduction \n TreeMap<ExpVector,LinkedList<Pair<C>>> pairlist \n int putOne \n int putCount \n boolean hasNext \n int remCount \n boolean criterion3 \n int put \n Pair<C> removeNext", "output": "ArrayList < GenPolynomial < C >> function ( ) { return P ; }"}, {"instruction": "Generate java code\nevaluates the body of a tag ", "input": " List list \n List getScriptList \n void addScript \n Script compile \n void trimWhitespace \n String toString \n void removeScript", "output": "void function ( JellyContext arg0 , XMLOutput arg1 ) { for ( Iterator loc0 = list . iterator ( ) ; loc0 . hasNext ( ) ; ) { Script loc1 = ( Script ) loc0 . next ( ) ; loc1 . run ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\ncreates a criterion using equality ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria lt \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria nin \n Criteria nin \n Criteria and \n Criteria gte \n Criteria create \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria gt \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n Criteria exists \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( Object arg0 ) { return is ( arg0 ) ; }"}, {"instruction": "Generate java code\npause . ", "input": " long syncTimeout \n void typeKeyboardEnterkey \n void type \n void waitFor \n void doType \n void doType \n void typeUsingKeyPress", "output": "void function ( long arg0 ) { try { Thread . sleep ( arg0 ) ; } catch ( InterruptedException loc0 ) { loc0 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\nthis class delegates this call ", "input": " RenderListener delegate \n RenderFilter[] filters \n void renderImage \n void endTextBlock \n void renderText", "output": "void function ( ) { delegate . beginTextBlock ( ) ; }"}, {"instruction": "Generate java code\ncreates an add operation using the specified address and parameters ", "input": " String INDEX \n String KEY \n String getName \n ModelNode getAttributeValue \n ModelNode createWriteAttributeOperation \n ModelNode createReadAttributeOperation \n Set<String> getAllWriteAttributeOperationNames \n void setPathAddress \n ModelNode createMapEntryOperation \n ModelNode createListRemoveOperation \n ModelNode createListRemoveOperation \n ModelNode createUndefineAttributeOperation \n String getAttributeName \n ModelNode createCompositeOperation \n ModelNode createCompositeOperation \n ModelNode createReadResourceOperation \n ModelNode createMapRemoveOperation \n ModelNode createMapClearOperation \n ModelNode createMapPutOperation \n ModelNode createDescribeOperation \n boolean isIncludeDefaults \n ModelNode createListElementOperation \n ModelNode createListElementOperation \n ModelNode createListAddOperation \n ModelNode createListGetOperation \n ModelNode createAttributeOperation \n ModelNode createMapGetOperation \n PathAddress getPathAddress", "output": "ModelNode function ( PathAddress arg0 , Map < Attribute , ModelNode > arg1 ) { ModelNode loc0 = Util . createAddOperation ( arg0 ) ; for ( Map . Entry < Attribute , ModelNode > loc1 : arg1 . entrySet ( ) ) { loc0 . get ( loc1 . getKey ( ) . getName ( ) ) . set ( loc1 . getValue ( ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ncreates a new search scope with all compilation units possibly referencing javaelement , considering the visibility of the element , references only from source ", "input": " PlaceHolder placeHolder \n void addRelatedReferencing \n IPackageFragmentRoot[] getAllScopeElements \n IJavaSearchScope createRelatedProjectsScope \n void addRelatedReferenced \n IJavaSearchScope createReferencedScope \n IJavaSearchScope createReferencedScope \n IClasspathEntry getReferencingClassPathEntry \n IJavaProject[] getRelatedProjects \n Collection<IJavaProject> getReferencingProjects \n void addReferencingProjects \n int getVisibility", "output": "IJavaSearchScope function ( IJavaElement arg0 ) { return RefactoringScopeFactory . create ( arg0 , true , true ) ; }"}, {"instruction": "Generate java code\nreturns the index of the element that would be returned by a subsequent call to previous . a return value of -1 indicates that the iterator is currently at the start . ", "input": " boolean beforeFirst \n boolean nextCalled \n boolean removed \n Object object \n Object next \n void add \n void set \n Object previous \n boolean hasPrevious \n void reset \n boolean hasNext \n int nextIndex \n void remove", "output": "int function ( ) { return ( beforeFirst ? - 1 : 0 ) ; }"}, {"instruction": "Generate java code\nreturns the selection mode of the given ast node regarding this selection . possible values are intersects , before , selected , and after . ", "input": " int fLength \n int fExclusiveEnd \n int INTERSECTS \n int AFTER \n int fStart \n int BEFORE \n int SELECTED \n int getExclusiveEnd \n Selection createFromStartEnd \n boolean coveredBy \n boolean coveredBy \n int getOffset \n boolean liesOutside \n Selection createFromStartLength \n int getEndVisitSelectionMode \n int getLength \n String toString \n boolean endsIn \n int getInclusiveEnd \n boolean covers \n boolean covers", "output": "int function ( ASTNode arg0 ) { int loc0 = arg0 . getStartPosition ( ) ; int loc1 = loc0 + arg0 . getLength ( ) ; if ( loc1 <= fStart ) return BEFORE ; else if ( covers ( arg0 ) ) return SELECTED ; else if ( fExclusiveEnd <= loc0 ) return AFTER ; return INTERSECTS ; }"}, {"instruction": "Generate java code\nreturn a description of this script step . ", "input": " String description \n Resolver resolver \n Throwable invalidScriptError \n long serialVersionUID \n String toXMLString \n Map getAttributes \n String getXMLTag \n void writeObject \n void usage \n void usage \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n Element addContent \n String getDescription \n void parseStepAttributes \n String getUsage \n void readObject \n String getDefaultDescription \n String toEditableString \n Step createStep \n Step createStep \n void runStep \n ComponentTester resolveTester \n Class resolveClass \n void setScriptError \n Resolver getResolver \n Map createAttributeMap", "output": "String function ( ) { return getDescription ( ) ; }"}, {"instruction": "Generate java code\ncomposition 4 . a1 , a2 , a3 and a4 are objects . l is a list . m = comp a1 , comp a2 , comp a3 , comp a4 , l . ", "input": " LIST<?> SIL \n Iterator<C> iter \n LinkedList<C> list \n void SFIRST \n LIST<C> LIST1 \n LIST<C> RED3 \n LIST<C> LIST3 \n LIST<C> RED4 \n LIST<C> LIST2 \n C THIRD \n LIST<C> LIST5 \n int LENGTH \n LIST<C> RED2 \n LIST<C> LIST4 \n LIST<C> COMP \n LIST<C> INV \n int ORDER \n LIST<C> COMP2 \n int EXTENT \n void SRED \n C LELT \n boolean EQUAL \n LIST<C> LIST10 \n boolean isEmpty \n LIST<C> CCONC \n C FIRST \n LIST<C> REDUCT \n C FOURTH \n LIST<C> RED \n LIST<C> CINV \n boolean isNull \n String toString \n C SECOND \n long CLOCK \n LIST<C> CONC", "output": "LIST < C > function ( C arg0 , C arg1 , C arg2 , C arg3 , LIST < C > arg4 ) { LIST < C > loc0 = arg4 ; if ( arg4 == null ) { loc0 = new LIST < C > ( ) ; } loc0 . list . addFirst ( arg3 ) ; loc0 . list . addFirst ( arg2 ) ; loc0 . list . addFirst ( arg1 ) ; loc0 . list . addFirst ( arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the current state of the renderer . ", "input": " long MATCH_LONGEST_US \n int STATE_UNPREPARED \n long UNKNOWN_TIME_US \n int STATE_PREPARED \n int STATE_ENABLED \n long END_OF_TRACK_US \n int STATE_STARTED \n int state \n int STATE_RELEASED \n boolean doPrepare \n int prepare \n void onReleased \n void release \n boolean isReady \n void handleMessage \n void start \n int getTrackCount \n long getDurationUs \n void seekTo \n MediaClock getMediaClock \n void onStarted \n void stop \n void enable \n void disable \n long getBufferedPositionUs \n void onEnabled \n void maybeThrowError \n MediaFormat getFormat \n void doSomeWork \n void onStopped \n void onDisabled \n boolean isEnded", "output": "int function ( ) { return state ; }"}, {"instruction": "Generate java code\n#register opmodemanager is called by the sdk game in order to registeropmode classes or instances that will participate in an ftc game . there are two mechanisms by which an opmode may be registered . 1 the preferred method is by means of class annotations in the opmode itself . see , for example the class annotations in conceptnullop . 2 the other , retired , method is to modify this #register opmodemanager method to include explicit calls to opmodemanager.register . this method of modifying this file directly is discouraged , as it makes updates to the sdk harder to integrate into your code . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "void function ( OpModeManager arg0 ) { BlocksOpMode . registerAll ( arg0 ) ; AnnotatedOpModeRegistrar . register ( arg0 ) ; }"}, {"instruction": "Generate java code\nverify if the given writer is not ` null ' ", "input": " TemporaryFolder testFolder \n void testActualWrite \n void testNonExistentFile \n void testIoException", "output": "void function ( ) { final File loc0 = this . testFolder . newFile ( ) ; new SimpleFileWriter ( loc0 . getPath ( ) , Assert :: assertNotNull ) ; }"}, {"instruction": "Generate java code\nreads the device descriptor from the devices eeprom . ", "input": " Device device \n DeviceDescriptor deviceDescriptor \n void writeUserArea \n void writeUserArea \n void erase \n void erase \n int getUserAreaSize \n DeviceDescriptor getDeviceDescriptor \n int readUserArea \n int readUserArea \n int readUserAreaSize \n void checkIsOpen \n void writeDeviceDescriptor \n void writeDeviceDescriptor", "output": "DeviceDescriptor function ( ) { checkIsOpen ( ) ; return readDeviceDescriptor ( device . getHandle ( ) ) ; }"}, {"instruction": "Generate java code\ncreate an instance of isdvinfo ", "input": " QName _HistoryHeader_QNAME \n QName _ISDVInfo_QNAME \n QName _KeyValuePairList_QNAME \n QName _LocalizedMessage_QNAME \n QName _BusinessException_QNAME \n QName _Message_QNAME \n QName _CallContext_QNAME \n QName _ValidationException_QNAME \n QName _NotFoundException_QNAME \n QName _ValidationContext_QNAME \n QName _TimePeriod_QNAME \n QName _OpenTimePeriod_QNAME \n QName _LocalizedString_QNAME \n QName _KeyValuePair_QNAME \n QName _TechnicalException_QNAME \n ValidationException createValidationException \n JAXBElement<ValidationException> createValidationException \n CallContext createCallContext \n JAXBElement<CallContext> createCallContext \n OpenTimePeriod createOpenTimePeriod \n JAXBElement<OpenTimePeriod> createOpenTimePeriod \n LocalizedMessage createLocalizedMessage \n JAXBElement<LocalizedMessage> createLocalizedMessage \n TechnicalException createTechnicalException \n JAXBElement<TechnicalException> createTechnicalException \n KeyValuePairList createKeyValuePairList \n JAXBElement<KeyValuePairList> createKeyValuePairList \n TimePeriod createTimePeriod \n JAXBElement<TimePeriod> createTimePeriod \n LocalizedString createLocalizedString \n JAXBElement<LocalizedString> createLocalizedString \n HistoryHeader createHistoryHeader \n JAXBElement<HistoryHeader> createHistoryHeader \n KeyValuePair createKeyValuePair \n JAXBElement<KeyValuePair> createKeyValuePair \n BusinessException createBusinessException \n JAXBElement<BusinessException> createBusinessException \n NotFoundException createNotFoundException \n JAXBElement<NotFoundException> createNotFoundException \n ValidationContext createValidationContext \n JAXBElement<ValidationContext> createValidationContext \n Message createMessage \n JAXBElement<Message> createMessage", "output": "ISDVInfo function ( ) { return new ISDVInfo ( ) ; }"}, {"instruction": "Generate java code\nverifies if image is a stack owner . should be false . ", "input": " Image i \n Tag I \n WorkerContext workerContextImpl \n void init \n void verifyEnd", "output": "void function ( ) { Assert . assertFalse ( i . isStackOwner ( ) ) ; }"}, {"instruction": "Generate java code\nsets the input info . ", "input": " String inputInfo \n String outputMessage \n List<String> validatorErrorMessage \n List<String> getValidatorErrorMessage \n String getInputInfo \n void setValidatorErrorMessage \n String getOutputMessage \n void setOutputMessage", "output": "void function ( String arg0 ) { this . inputInfo = arg0 ; }"}, {"instruction": "Generate java code\nreturns the label for a url , uri or url part . example is ` http://www.x.xom/s.html#1 ' ", "input": " String CONCAT_STRING \n String getFilePattern \n String markLTR \n String getResourceName \n String getResourceName \n String getVersionName \n String getPathLabel", "output": "String function ( String arg0 ) { return markLTR ( arg0 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ntrace is never enabled . ", "input": " PlaceHolder placeHolder \n void warn \n void warn \n void trace \n void trace \n void debug \n void debug \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isDebugEnabled \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void info \n void info \n void fatal \n void fatal", "output": "boolean function ( ) { return false ; }"}, {"instruction": "Generate java code\nexecutes the body of the tag and returns the result as a string . ", "input": " Tag parent \n JellyContext context \n boolean hasTrimmed \n Script body \n boolean escapeText \n Boolean shouldTrim \n Tag getParent \n boolean isTrim \n Script getBody \n void setBody \n void invokeBody \n boolean isEscapeText \n void setEscapeText \n void setTrim \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n void setContext \n void setParent \n JellyContext getContext \n void trimBody", "output": "String function ( boolean arg0 ) { StringWriter loc0 = new StringWriter ( ) ; invokeBody ( XMLOutput . createXMLOutput ( loc0 , arg0 ) ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nopens an objectcontainer objectcontainer on the specified database file for local use . a database file can only be opened once , subsequent attempts to open another objectcontainer objectcontainer against the same file will result ina databasefilelockedexception databasefilelockedexception . database files can only be accessed for read/write access from one process one java vm at one time . all versions except for db4o mobile edition use an internal mechanism to lock the database file for other processes . ", "input": " PlaceHolder placeHolder \n EmbeddedConfiguration newConfiguration", "output": "EmbeddedObjectContainer function ( EmbeddedConfiguration arg0 , String arg1 ) { if ( null == arg0 ) { throw new ArgumentNullException ( ) ; } return ObjectContainerFactory . openObjectContainer ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nlog a message with error log level . ", "input": " String name \n Logger logger \n void debug \n void debug \n void log \n Logger getLogger \n boolean isWarnEnabled \n boolean isFatalEnabled \n void fatal \n void fatal \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isDebugEnabled \n void info \n void info", "output": "void function ( Object arg0 ) { log ( Level . SEVERE , String . valueOf ( arg0 ) , null ) ; }"}, {"instruction": "Generate java code\nreplaces getcontexts call but ensures that if list not yet initialized then empty list will be returned ", "input": " PlaceHolder placeHolder \n Set<T> getContexts \n void setContexts \n void addToContextList \n List<T> getContextsByLowestContext \n Integer getId \n void addContext \n T getOrCreateContext \n T getContext \n T createContext", "output": "Set < T > function ( ) { if ( getContexts ( ) == null ) { return Collections . unmodifiableSet ( new HashSet < T > ( ) ) ; } return getContexts ( ) ; }"}, {"instruction": "Generate java code\nreturns the center of the line ", "input": " VectorXZ rightNormal \n MapNode startNode \n VectorXZ direction \n MapNode endNode \n MapNode getOtherNode \n VectorXZ getRightNormal \n VectorXZ getDirection \n LineSegmentXZ getLineSegment \n boolean isConnectedTo \n boolean isConnectedTo \n MapNode getEndNode \n List<MapNode> getStartEndNodes \n boolean sharesBothNodes \n MapNode getStartNode", "output": "VectorXZ function ( ) { return ( startNode . getPos ( ) . add ( endNode . getPos ( ) ) ) . mult ( 0.5 ) ; }"}, {"instruction": "Generate java code\nreturns the result so far . ", "input": " Vector lastEnd \n StringBuffer result \n Vector lastStart \n void renderImage \n void appendTextChunk \n void beginTextBlock \n void endTextBlock \n void renderText", "output": "String function ( ) { return result . toString ( ) ; }"}, {"instruction": "Generate java code\nnegative of this matrix . ", "input": " List<C> val \n Logger logger \n GenMatrixRing<C> ring \n ArrayList<ArrayList<C>> matrix \n int hashValue \n GenMatrix<C> leftLinearCombination \n int signum \n boolean isONE \n GenMatrix<C> inverse \n boolean isUnit \n GenMatrix<C> subtract \n GenMatrix<C> scalarMultiply \n GenMatrix<C> gcd \n GenMatrix<C> sum \n GenMatrix<C> linearCombination \n GenMatrix<C> linearCombination \n GenMatrix<C> linearCombination \n int compareTo \n GenMatrix<C>[] egcd \n GenMatrix<C> leftScalarMultiply \n GenMatrix<C> abs \n int hashCode \n GenMatrix<C> multiplySimple \n boolean equals \n GenMatrix<C> clone \n boolean isZERO \n GenMatrix<C> divide \n String toString \n GenMatrix<C> transpose \n GenMatrix<C> multiply \n GenMatrix<C> remainder", "output": "GenMatrix < C > function ( ) { ArrayList < ArrayList < C >> loc0 = new ArrayList < ArrayList < C >> ( ring . rows ) ; for ( ArrayList < C > loc1 : matrix ) { ArrayList < C > loc2 = new ArrayList < C > ( ring . cols ) ; for ( C loc3 : loc1 ) { C loc4 = loc3 . negate ( ) ; loc2 . add ( loc4 ) ; } loc0 . add ( loc2 ) ; } return new GenMatrix < C > ( ring , loc0 ) ; }"}, {"instruction": "Generate java code\nforeignable external link ", "input": " boolean isTesting \n String typeName \n Clob propertyValue \n Clob exampleValue \n boolean isEncrypted \n String propContName \n Integer descriptorId \n String typeContName \n Integer typeId \n Clob defaultValue \n String resourceName \n String fcExternalKey \n String technicalKey \n String mik \n Integer propContextId \n String origin \n Integer cardinalityProperty \n Integer propertyValueTypeId \n String displayName \n String fcOwner \n Integer propertyId \n Integer masterTypeId \n boolean isNullable \n String fcExternalLink \n String validationRegex \n String loadedFor \n boolean isOptional \n String validationLogic \n String descriptorOrigin \n Integer typeContextId \n Clob propertyComment \n ResourceEditPropertyBuilder withDisplayAndTechKeyName \n ResourceEditPropertyBuilder withOrigin \n ResourceEditPropertyBuilder withValidationRegex \n ResourceEditPropertyBuilder withIsEncrypted \n ResourceEditPropertyBuilder withDescriptorOrigin \n Clob convert \n ResourceEditPropertyBuilder withTechnicalKey \n ResourceEditPropertyBuilder withMasterResTypeName \n ResourceEditPropertyBuilder withLoadedFor \n ResourceEditPropertyBuilder withDisplayName \n ResourceEditPropertyBuilder withValue \n ResourceEditPropertyBuilder withDefaultValue \n ResourceEditPropertyBuilder withDescriptorId \n ResourceEditPropertyBuilder withTypeId \n ResourceEditPropertyBuilder withDescriptor \n ResourceEditPropertyBuilder withCardinality \n ResourceEditPropertyBuilder withPropTypeContName \n ResourceEditPropertyBuilder withValidationLogic \n ResourceEditPropertyBuilder withPropertyContextTypeId \n ResourceEditPropertyBuilder withPropertyId \n ResourceEditPropertyBuilder withPropContName \n ResourceEditPropertyBuilder withComment \n ResourceEditPropertyBuilder withFcOwner \n ResourceEditPropertyBuilder withMasterResTypeId \n ResourceEditPropertyBuilder withFcExternalKey \n ResourceEditProperty build \n ResourceEditPropertyBuilder withIsTesting \n ResourceEditPropertyBuilder withExampleValue \n ResourceEditPropertyBuilder withResourceName \n ResourceEditPropertyBuilder withPropContextId \n ResourceEditPropertyBuilder withIsNullable", "output": "ResourceEditPropertyBuilder function ( String arg0 ) { this . fcExternalLink = arg0 ; return this ; }"}, {"instruction": "Generate java code\nmaps a cql value to the specified field from an input tuple . ", "input": " PlaceHolder placeHolder \n BatchCQLStatementTupleMapper unLoggedBatch \n CqlMapper.DefaultCqlMapper all \n CQLStatementTupleMapper async \n ContextQuery named \n ContextQuery namedByField \n BatchCQLStatementTupleMapper newBatchStatementBuilder \n BatchCQLStatementTupleMapper counterBatch \n BatchCQLStatementTupleMapper loggedBatch \n BoundCQLStatementMapperBuilder boundQuery \n BoundCQLStatementMapperBuilder boundQuery \n FieldSelector[] fields \n SimpleCQLStatementMapperBuilder simpleQuery \n SimpleCQLStatementMapperBuilder simpleQuery", "output": "FieldSelector function ( final String arg0 ) { return new FieldSelector ( arg0 ) ; }"}, {"instruction": "Generate java code\ndecides if this response is fresh enough based last-modified and date , if available . this entry is meant to be used when isresponsefresh returns false . the algorithm is as follows : if last-modified and date are defined , freshness lifetime is coefficient date-lastmodified , else freshness lifetime is defaultlifetime ", "input": " long MAX_AGE \n boolean isRevalidatable \n long getResidentTimeSecs \n boolean mayReturnStaleIfError \n boolean mayReturnStaleIfError \n long getHeuristicFreshnessLifetimeSecs \n Date getLastModifiedValue \n boolean proxyRevalidate \n Date getExpirationDate \n long getCorrectedInitialAgeSecs \n boolean isResponseFresh \n long getApparentAgeSecs \n boolean mayReturnStaleWhileRevalidating \n long getContentLengthValue \n boolean hasCacheControlDirective \n boolean contentLengthHeaderMatchesActualLength \n long getStalenessSecs \n boolean hasContentLengthHeader \n long getCorrectedReceivedAgeSecs \n long getFreshnessLifetimeSecs \n long getCurrentAgeSecs \n long getMaxAge \n long getAgeValue \n long getResponseDelaySecs \n boolean mustRevalidate \n Date getDateValue", "output": "boolean function ( final HttpCacheEntry arg0 , final Date arg1 , final float arg2 , final long arg3 ) { return ( getCurrentAgeSecs ( arg0 , arg1 ) < getHeuristicFreshnessLifetimeSecs ( arg0 , arg2 , arg3 ) ) ; }"}, {"instruction": "Generate java code\nreturns true if the underlying map is empty . ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n int calcTotalSize \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "boolean function ( ) { return _map . isEmpty ( ) ; }"}, {"instruction": "Generate java code\nreturn the n'th short down the stack , where 0 is the top element and size -1 is the bottom element . ", "input": " ArrayShortList list \n short pop \n int search \n int size \n short get \n void clear \n short push \n boolean empty", "output": "short function ( int arg0 ) { if ( list . isEmpty ( ) ) { throw new EmptyStackException ( ) ; } return list . get ( list . size ( ) - arg0 - 1 ) ; }"}, {"instruction": "Generate java code\nclone this . ", "input": " C val \n ResidueRing<C> ring \n boolean debug \n int isunit \n Logger logger \n int signum \n boolean isONE \n Residue<C> inverse \n boolean isUnit \n Residue<C> subtract \n Residue<C> gcd \n Residue<C> sum \n int compareTo \n Residue<C>[] egcd \n Residue<C> abs \n int hashCode \n Residue<C> negate \n boolean equals \n boolean isZERO \n String toString \n Residue<C> divide \n Residue<C> multiply \n Residue<C> remainder", "output": "Residue < C > function ( ) { return new Residue < C > ( ring , val ) ; }"}, {"instruction": "Generate java code\nhelper method to get partitionoutgoingbatch based on the index since we may have more then one partitioner as number of partitioners should be very small and this method it used very rarely , so it is ok to loop in order to find right partitioner ", "input": " RecordBatch incoming \n boolean isLastBatch \n Partitioner part \n org.slf4j.Logger logger \n String childThreadPrefix \n GeneralExecuteIface iface \n ControlsInjector injector \n String parentThreadName \n CountDownLatchInjection testCountDownLatch \n OperatorStats stats \n ExecutorService executor \n String tName \n FragmentContext context \n boolean schemaChanged \n CountDownLatch latch \n IOException exp \n List<Partitioner> partitioners \n void partitionBatch \n IOException getException \n List<Partitioner> getPartitioners \n void clear \n void flushOutgoingBatches \n void executeMethodLogic \n void run \n Partitioner getPart \n void initialize \n void execute \n void execute \n void execute", "output": "PartitionOutgoingBatch function ( int arg0 ) { for ( Partitioner loc0 : partitioners ) { PartitionOutgoingBatch loc1 = loc0 . getOutgoingBatch ( arg0 ) ; if ( loc1 != null ) { return loc1 ; } } return null ; }"}, {"instruction": "Generate java code\nsets the main window of the guirunner . ", "input": " ConfigFile selectedFile \n LastOpened lastOpened \n List<IRunnerCtrlListener> listeners \n JButton launchButton \n GUIRunner runner \n JButton startVisBtn \n SeedDetermination det \n SeedDetermination getDetermination \n void removeListener \n void invokeStartVis \n void runSimulator \n void setLastOpened \n void actionPerformed \n ConfigFile getSelectedFile \n void setLaunchButton \n void invokeRunSimulator \n void newFileSelected \n void newFileSelected \n void selectFile \n void setStartVisBtn \n void addListener", "output": "void function ( GUIRunner arg0 ) { this . runner = arg0 ; }"}, {"instruction": "Generate java code\nthis method creates the timer to be used , if one is desired to be used . it will also set the number of seconds for each turn . ", "input": " Player playerTwo \n int gameType \n Facade theFacade \n Rules theRules \n Player passivePlayer \n boolean isTimerRunning \n Player activePlayer \n IMediator mediator \n Timer theTimer \n Player playerOne \n void endGame \n void setPlayerName \n IMediator getMediator \n void selectColors \n void setPlayerColor \n int getGameMode \n void ReceiveMessage \n void endTurn \n void setGameMode \n void RecievePassivePlayer \n void createPlayer \n void RecieveActivePlayer \n Notifier getTimerNotifier \n void requestActive \n void setMediator \n void requestPlayerName \n Player getOppositePlayer \n Facade getFacade \n void startGame \n void SendMessage \n void requestPassive", "output": "void function ( int arg0 , int arg1 ) { if ( arg0 < 0 ) { isTimerRunning = false ; } else { isTimerRunning = true ; theTimer = new Timer ( ) ; } }"}, {"instruction": "Generate java code\nwhether this is a smartmachine or virtualmachine dataset ", "input": " String urn \n boolean isDefault \n Map<String,JsonBall> requirements \n String os \n ImmutableMap.Builder<String,JsonBall> requirements \n Date created \n String name \n String description \n String id \n Type type \n Function<JsonBall,String> unquoteString \n String version \n Builder toBuilder \n String getOs \n String getName \n Builder description \n String getId \n Map<String,String> getRequirementsAsJsonLiterals \n int compareTo \n Builder type \n Builder addRequirement \n String getDescription \n int hashCode \n Builder builder \n Builder id \n String getVersion \n Builder requirements \n Map<String,String> getRequirements \n Builder os \n String apply \n Builder created \n Date getCreated \n Builder version \n Builder urn \n Builder fromDataset \n Builder isDefault \n boolean isDefault \n String getUrn \n Dataset build \n boolean equals \n Builder name \n String toString", "output": "Type function ( ) { return type ; }"}, {"instruction": "Generate java code\ncheck if a replacing cast function is available for the the original function ", "input": " Map<String,String> CAST_FUNC_REPLACEMENT_FROM_NULLABLE_VAR16CHAR \n Map<String,String> CAST_FUNC_REPLACEMENT_FROM_NULLABLE_VARCHAR \n Set<String> CAST_FUNC_REPLACEMENT_NEEDED \n Map<String,String> CAST_FUNC_REPLACEMENT_FROM_NONNULLABLE_VARBINARY \n Map<String,String> CAST_FUNC_REPLACEMENT_FROM_NONNULLABLE_VARCHAR \n Map<String,String> CAST_FUNC_REPLACEMENT_FROM_NONNULLABLE_VAR16CHAR \n Map<String,String> CAST_FUNC_REPLACEMENT_FROM_NULLABLE_VARBINARY \n Map<MinorType,String> TYPE2FUNC \n String getReplacingCastFunction \n String getCastFunc \n String getReplacingCastFunctionFromNonNullable \n String getReplacingCastFunctionFromNullable", "output": "boolean function ( String arg0 , MinorType arg1 ) { return ( arg1 == MinorType . VARCHAR || arg1 == MinorType . VARBINARY || arg1 == MinorType . VAR16CHAR ) && CAST_FUNC_REPLACEMENT_NEEDED . contains ( arg0 ) ; }"}, {"instruction": "Generate java code\ninitiates the following asynchronous state transitions : unrealized - > realizing - > realized - > prefetching - > prefetched realizing - > realized - > prefetching - > prefetched realized - > prefetching - > prefetched prefetching - > prefetched prefetched started - > throws illegalstateexception closed - > throws illegalstateexception ", "input": " SequentialDispatcher dispatcher \n int state \n PropertyChangeSupport propertyChangeSupport \n EventListenerList listenerList \n int targetState \n void removeStateListener \n void doRealized \n void doPrefetching \n void fireStateChanged \n void fireStateChanged \n int getTargetState \n void deallocate \n void start \n void run \n boolean isActive \n void setTargetState \n void removePropertyChangeListener \n void addChangeListener \n void doUnrealized \n void doRealizing \n void removeChangeListener \n void doClosed \n int getState \n void stop \n void doPrefetched \n void doStarted \n void addStateListener \n void addPropertyChangeListener \n void close \n void realize", "output": "void function ( ) { switch ( getState ( ) ) { case CLOSED : throw new IllegalStateException ( \"srini_string\" ) ; case STARTED : throw new IllegalStateException ( \"srini_string\" ) ; } setTargetState ( PREFETCHED ) ; }"}, {"instruction": "Generate java code\ncalled when a given source is about to become the active source . this gives subclasses the abilty to retrieve resources , if appropriate . ", "input": " SourceEntry[] sources \n long size \n long lastByte \n int index \n RandomAccessSource source \n long firstByte \n SourceEntry currentSourceEntry \n int getStartingSourceIndex \n void sourceReleased \n int get \n int get \n long length \n SourceEntry getSourceEntryForOffset \n void close \n long offsetN", "output": "void function ( RandomAccessSource arg0 ) { }"}, {"instruction": "Generate java code\nsend an event to the processor . the event will be queued to be processed after any prior events are processed , once processing actually starts . if an event 's processing causes an exception , it will be added to any previous exceptions as a suppressed exception . once all the currently queued events have been processed , a single exception will be thrown . ", "input": " boolean started \n LinkedList<T> queuedEvents \n boolean isProcessing \n void processEvents \n void start \n void processEvent", "output": "void function ( final T arg0 ) { synchronized ( queuedEvents ) { queuedEvents . addLast ( arg0 ) ; if ( ! started || isProcessing ) { return ; } isProcessing = true ; } processEvents ( ) ; }"}, {"instruction": "Generate java code\nreturns cache data in list form . ", "input": " Node next \n Map<String,Node> cache \n Node head \n Node previous \n Logger LOGGER \n UserAccount userAccount \n Node end \n String userId \n int capacity \n boolean contains \n void set \n UserAccount getLruData \n UserAccount get \n void setHead \n void clear \n void invalidate \n boolean isFull \n void setCapacity \n void remove", "output": "List < UserAccount > function ( ) { List < UserAccount > loc0 = new ArrayList < > ( ) ; Node loc1 = head ; while ( loc1 != null ) { loc0 . add ( loc1 . userAccount ) ; loc1 = loc1 . next ; } return loc0 ; }"}, {"instruction": "Generate java code\nretrieves the name of the cache ", "input": " String PUBLISH_THREAD_NAME \n String cacheName \n int eventQueueLength \n ExecutorService executorService \n Object EVENTQUEUELOCK \n Queue<LoggingEvent> eventQueue \n ICachePublisher cachePublisher \n int capacity \n ExecutorService createExecutorService \n void add \n Future<Boolean> publishCache \n void publish \n PublishContext startPublish \n void flushAndPublishQueue \n void endPublish", "output": "String function ( ) { return cacheName ; }"}, {"instruction": "Generate java code\ngenerate linearlayout with given title ", "input": " double textScale \n ArrayList<MyCard> cardsInPlay \n String TAG \n void addCard \n GridView makeGV \n CardView getCardView \n void newCardGroup \n void clearCards", "output": "LinearLayout function ( Context arg0 , String arg1 , View arg2 , TextView arg3 ) { LinearLayout loc0 = new LinearLayout ( arg0 ) ; loc0 . setOrientation ( LinearLayout . VERTICAL ) ; if ( arg3 == null ) arg3 = new TextView ( arg0 ) ; arg3 . setTextSize ( 10.0f ) ; arg3 . setText ( arg1 ) ; loc0 . addView ( arg3 ) ; loc0 . addView ( arg2 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the next object in the collection . if at the end of the collection , return the first element . ", "input": " Iterator iterator \n Collection collection \n int size \n void reset \n boolean hasNext \n void remove", "output": "Object function ( ) { if ( collection . size ( ) == 0 ) { throw new NoSuchElementException ( \"srini_string\" ) ; } if ( iterator . hasNext ( ) == false ) { reset ( ) ; } return iterator . next ( ) ; }"}, {"instruction": "Generate java code\nsetzt die verwendeten overlayadapter ", "input": " List<OverlayAdapter> adapters \n OverlayAdapter getAdapterAt \n List<OverlayAdapter> getAllAdapters \n Coords getSchematicHostPosition", "output": "void function ( List < OverlayAdapter > arg0 ) { this . adapters = arg0 ; }"}, {"instruction": "Generate java code\nmakes sure that the upcomingrelease is initialized ", "input": " long serialVersionUID \n LinkedHashMap<Integer,ReleaseEntity> releaseMap \n ReleaseMgmtService releaseService \n ResourceDependencyResolverService dependencyResolverService \n Date upcomingReleaseDate \n Integer upcomingReleaseId \n List<ReleaseEntity> getAllReleases \n Date getUpcomingReleaseDate \n LinkedHashMap<Integer,ReleaseEntity> getReleaseMap \n void reset", "output": "Integer function ( ) { if ( upcomingReleaseId == null ) { this . upcomingReleaseId = dependencyResolverService . findMostRelevantRelease ( new TreeSet < ReleaseEntity > ( getAllReleases ( ) ) , new Date ( ) ) . getId ( ) ; } return upcomingReleaseId ; }"}, {"instruction": "Generate java code\nin ehcache we default to minimal puts since this should have minimal to no affect on unclustered users , and has great benefit for clustered users . ", "input": " EhcacheAccessStrategyFactory accessStrategyFactory \n Settings settings \n String NET_SF_EHCACHE_CONFIGURATION_RESOURCE_NAME \n EhCacheMessageLogger LOG \n CacheManager manager \n ProviderMBeanRegistrationHelper mbeanRegistrationHelper \n ClassLoaderService classLoaderService \n CollectionRegion buildCollectionRegion \n Ehcache getCache \n EntityRegion buildEntityRegion \n TimestampsRegion buildTimestampsRegion \n URL loadResource \n NaturalIdRegion buildNaturalIdRegion \n void setClassLoaderService \n QueryResultsRegion buildQueryResultsRegion \n long nextTimestamp \n AccessType getDefaultAccessType", "output": "boolean function ( ) { return true ; }"}, {"instruction": "Generate java code\nreturns an icon stored in the file at the specified path relative to the specified class ", "input": " HashMap m_ClassImageMap \n void clearImages \n Image getImage \n Image getImage \n Image getImage \n Image getImage", "output": "ImageIcon function ( Class arg0 , String arg1 ) { return getIcon ( getImage ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nreturn the current limit of this accountant . ", "input": " Accountant parent \n AtomicLong allocationLimit \n AtomicLong peakAllocation \n long reservation \n boolean ok \n AtomicLong locallyHeldMemory \n void releaseBytes \n void updatePeak \n AllocationOutcome allocateBytes \n boolean forceAllocate \n AllocationOutcome allocate \n void setLimit \n long getPeakMemoryAllocation \n boolean isOk \n long getAllocatedMemory \n void close \n boolean isOverLimit", "output": "long function ( ) { return allocationLimit . get ( ) ; }"}, {"instruction": "Generate java code\nfind a widget , using the given matcher to determine whether a given widget in the hierarchy under the given root is the desired one . ", "input": " int dbComparisons \n int searchType \n Hierarchy hierarchy \n int BFS \n SearchScopeHelper _searchScopeHelper \n List _listeners \n ArrayList list \n int DFS \n int _attempts \n WidgetFinder DEFAULT \n Widget getParent \n Widget getWidgetParent \n Collection getRoots \n Widget findInShellScope \n Collection getWidgets \n void findMatches \n WidgetFinder getDefault \n Widget findInShellScope0 \n void pause \n boolean contains \n void dbPrintWidgets \n void addExceptionListener \n void informExceptionListeners \n Widget find0 \n void printWidgets \n void dispose \n Hierarchy getHierarchy", "output": "Widget function ( Widget arg0 , Matcher arg1 ) { dbComparisons = 0 ; Hierarchy loc0 = arg0 != null ? new SingleWidgetHierarchy ( arg0 ) : getHierarchy ( ) ; return find ( loc0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the document with the buffer contents . whitespace variables are decorated with comments . ", "input": " boolean fUseCodeFormatter \n String COMMENT_END \n List<TypedPosition> fPositions \n IJavaProject fProject \n int fInitialIndentLevel \n String COMMENT_START \n Document fDocument \n TemplateBuffer fBuffer \n String CATEGORY \n String fLineDelimiter \n boolean isWhitespaceVariable \n void removeRangeMarkers \n TemplateBuffer updateBuffer \n boolean isReplacedAreaEmpty \n List<TypedPosition> createRangeMarkers \n void internalFormat \n void indent \n void format \n void format \n void checkState \n void convertLineDelimiters \n void installJavaStuff \n void trimStart", "output": "IDocument function ( ) { checkState ( ) ; return fDocument ; }"}, {"instruction": "Generate java code\ngenerates a field selection based on a list of fields . assumes that a partial path a.b is equivalent to a.b. ", "input": " FieldSelection INVALID_NODE \n ValidityMode mode \n Map<String,FieldSelection> childrenInsensitive \n Map<String,FieldSelection> children \n FieldSelection ALL_VALID \n void add \n boolean isNeverValid \n boolean isAlwaysValid \n void setAlwaysValid \n FieldSelection fixNodes \n FieldSelection getChild \n String toString \n FieldSelection addChild \n boolean containsStar", "output": "FieldSelection function ( List < SchemaPath > arg0 ) { if ( containsStar ( arg0 ) ) { return ALL_VALID ; } else { FieldSelection loc0 = new FieldSelection ( ) ; for ( SchemaPath loc1 : arg0 ) { loc0 . add ( loc1 . getRootSegment ( ) ) ; } return loc0 . fixNodes ( ) ; } }"}, {"instruction": "Generate java code\ncreates the jdbc template bean that we use to invoke sql queries via jdbc . ", "input": " String PROPERTY_NAME_DB_USER \n String PROPERTY_NAME_HIBERNATE_FORMAT_SQL \n String PROPERTY_NAME_DB_URL \n String PROPERTY_NAME_HIBERNATE_HBM2DDL_AUTO \n String PROPERTY_NAME_DB_DRIVER_CLASS \n String PROPERTY_NAME_DB_PASSWORD \n String PROPERTY_NAME_HIBERNATE_SHOW_SQL \n String PROPERTY_NAME_HIBERNATE_NAMING_STRATEGY \n String PROPERTY_NAME_HIBERNATE_DIALECT \n String[] ENTITY_PACKAGES \n LocalContainerEntityManagerFactoryBean entityManagerFactory \n AuditorAware<String> auditorProvider \n DateTimeProvider dateTimeProvider \n JpaTransactionManager transactionManager \n DataSource dataSource", "output": "NamedParameterJdbcTemplate function ( DataSource arg0 ) { return new NamedParameterJdbcTemplate ( arg0 ) ; }"}, {"instruction": "Generate java code\nadds a list of writable . ", "input": " Queue<Writable> queue \n void add \n boolean containsWritable \n Writable poll", "output": "void function ( final List < Writable > arg0 ) { queue . addAll ( arg0 ) ; }"}, {"instruction": "Generate java code\nimplementation used to respond to sasl tokens from server . ", "input": " Logger LOG \n Subject subject \n String jaas_section \n SaslClient saslClient \n byte[] saslResponse \n boolean isComplete", "output": "void function ( Callback [ ] arg0 ) { for ( Callback loc0 : arg0 ) { LOG . info ( \"srini_string\" , loc0 . getClass ( ) ) ; } }"}, {"instruction": "Generate java code\nget the current time for use in a preauth response . if allow_unauth_time is true and the library has been configured to allow it , the current time will be offset using unauthenticated timestamp information received from the kdc in the preauth-required error , if one has been received . otherwise , the timestamp in a preauth-required error will only be used if it is protected by a fast channel . only set allow_unauth_time if using an unauthenticated time offset would not create a security issue . ", "input": " Map<String,Object> credCache \n PrincipalName serverPrincipal \n boolean isRetrying \n Object sessionData \n EncryptionKey asKey \n List<HostAddress> hostAddresses \n EncryptionType chosenEncryptionType \n List<EncryptionType> encryptionTypes \n KOptions requestOptions \n KrbFastRequestState fastRequestState \n KdcReq kdcReq \n KdcOptions kdcOptions \n KdcRep kdcRep \n KdcReqBody reqBody \n byte[] outerRequestBody \n KrbContext context \n PreauthContext preauthContext \n int chosenNonce \n DhClient dhClient \n void setKdcReq \n void setChosenNonce \n void setKdcRep \n KdcReqBody makeReqBody \n KdcOptions getKdcOptions \n EncryptionType getEncType \n void setServerPrincipal \n EncryptionKey getArmorKey \n HostAddresses getHostAddresses \n KerberosTime getTicketTillTime \n void setHostAddresses \n void setContext \n Map<String,Object> getCredCache \n void processResponse \n int getChosenNonce \n void processKdcOptions \n void setEncryptionTypes \n void setFastRequestState \n DhClient getDhClient \n KdcReqBody getReqBody \n void setKdcOptions \n EncryptionKey getClientKey \n void setAsKey \n void preauth \n void cacheValue \n EncryptionType getChosenEncryptionType \n PreauthHandler getPreauthHandler \n EncryptionKey getAsKey \n boolean isRetrying \n void setSessionData \n void setPreauthRequired \n KOptions getPreauthOptions \n void setOuterRequestBody \n void setAllowedPreauth \n KdcRep getKdcRep \n byte[] getOuterRequestBody \n void needAsKey \n KdcReq getKdcReq \n Object getSessionData \n void setChosenEncryptionType \n KrbFastRequestState getFastRequestState \n byte[] decryptWithClientKey \n void process \n void setRequestOptions \n void askQuestion \n PreauthContext getPreauthContext \n void addHost \n PrincipalName getClientPrincipal \n Object getCacheValue \n PrincipalName getServerPrincipal \n int generateNonce \n void setDhClient \n void resetPrequthContxt \n KrbContext getContext \n KOptions getRequestOptions \n long getTicketValidTime \n List<EncryptionType> getEncryptionTypes", "output": "KerberosTime function ( ) { return KerberosTime . now ( ) ; }"}, {"instruction": "Generate java code\nfollowing method is main executor ", "input": " FileLoggerModule fileLoggerModule \n ConsoleLoggerModule consoleLoggerModule \n void unprepare \n void prepare \n void main", "output": "void function ( final String ... arg0 ) { fileLoggerModule . printString ( \"srini_string\" ) ; fileLoggerModule . printErrorString ( \"srini_string\" ) ; consoleLoggerModule . printString ( \"srini_string\" ) ; consoleLoggerModule . printErrorString ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nfilters the given set of asset s by removing all vendor assets . ", "input": " PlaceHolder placeHolder \n Set<Asset> filtersByDomPosition \n String extractRequestKeyFromRequest \n String getExtension \n AssetLocator getAssetLocator \n Set<Asset> filtersByNameAndType \n Set<Asset> filtersByName \n Set<Asset> filtersByType \n String getAssetFinalLocation \n String generateStorageKey \n String extractCacheKeyFromRequest", "output": "Set < Asset > function ( Set < Asset > arg0 ) { Set < Asset > loc0 = new LinkedHashSet < Asset > ( ) ; for ( Asset loc1 : arg0 ) { if ( loc1 . isNotVendor ( ) ) { loc0 . add ( loc1 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nadds new employee ", "input": " UserTransaction tx \n EntityManager em \n void performFailCall \n String failInFirstCall \n Employee createEmployee \n int[] getEmployeeIDsNoEM \n String failAfterCalls \n String failInSecondCall", "output": "void function ( ) { try { tx . begin ( ) ; em . persist ( createEmployee ( \"srini_string\" , \"srini_string\" , 100 ) ) ; tx . commit ( ) ; } catch ( Exception loc0 ) { throw new Exception ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nuses a private key to sign data in a cms signeddata structure and returns the encoded cms signeddata as bytes . selected when public key encryption is used . the econtenttype field for the inner type signeddata when unencrypted is id-pkinit-rkeydata 1.3.6.1.5.2.3.3 and the econtent field contains the der encoding of the type replykeypack . ", "input": " String ID_PKINIT_AUTHDATA \n byte[] getSignedKdcDhKeyInfo \n byte[] getSignedAuthPack", "output": "byte [ ] function ( PrivateKey arg0 , X509Certificate arg1 , ReplyKeyPack arg2 ) { byte [ ] loc0 = KrbCodec . encode ( arg2 ) ; byte [ ] loc1 ; try { loc1 = PkiUtil . getSignedData ( arg0 , arg1 , loc0 , ID_PKINIT_AUTHDATA ) ; } catch ( PkiException loc2 ) { throw new KrbException ( \"srini_string\" , loc2 ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nadds key - > value pair to bson object from specified map ", "input": " Map<String,Object> data \n String ID_KEY \n List<String> fields \n boolean isFieldsOrderImportant \n boolean containsField \n void clear \n ObjectId getId \n Object put \n void remove \n boolean equalObjects \n int size \n Object registerField \n int hashCode \n Object get \n boolean equals \n String toString \n List<String> fields \n BSONObject append", "output": "void function ( Map < String , Object > arg0 ) { for ( Map . Entry < String , Object > loc0 : arg0 . entrySet ( ) ) { put ( loc0 . getKey ( ) , loc0 . getValue ( ) ) ; } }"}, {"instruction": "Generate java code\nescape the user-provided extra string for the ext = '' '' header attribute . hawk escapes the header ext = '' '' attribute differently than it does the extra line in the normalized request string . see https://github.com/hueniverse/hawk/blob/871cc597973110900467bd3dfb84a3c892f678fb/lib/browser.js#l385 . ", "input": " int HAWK_HEADER_VERSION \n long skewSeconds \n String LOG_TAG \n boolean includePayloadHash \n String id \n String HMAC_SHA256_ALGORITHM \n int NONCE_LENGTH_IN_BYTES \n byte[] key \n long getTimestampSeconds \n String getPayloadHashString \n byte[] hmacSha256 \n long now \n String escapeExtraString \n String getBaseContentType \n String getSignature \n byte[] getPayloadHash \n String getRequestString \n Header getAuthHeader \n Header getAuthHeader", "output": "String function ( String arg0 ) { return arg0 . replaceAll ( \"srini_string\" , \"srini_string\" ) . replaceAll ( \"srini_string\" | \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nopen bracket . ", "input": " StringBuilder builder \n StatementBuilder appendBetweenBracket \n StatementBuilder closeBracket \n StatementBuilder appendWithSeparator \n StatementBuilder appendWord \n String toString", "output": "StatementBuilder function ( ) { this . builder . append ( \"srini_string\" ) ; return this ; }"}, {"instruction": "Generate java code\nlazily creates the shared mixer instance and returns it . puts 8 lines into the pool . ", "input": " int volume \n Vector lines \n int loopCount \n int loopStart \n Thread workerThread \n Mixer mixer \n float pan \n int loopEnd \n int sampleRate \n byte[] samples \n void play \n void setLoopPoints \n void stop \n void configureDataLine \n void loop \n void loop \n SourceDataLine aquireLine \n void poolLine \n void run", "output": "Mixer function ( ) { if ( mixer == null ) { mixer = ( Mixer ) AudioSystem . getMixer ( AudioSystem . getMixerInfo ( ) [ 0 ] ) ; SourceDataLine [ ] loc0 = new SourceDataLine [ 16 ] ; for ( int loc1 = 0 ; loc1 < 16 ; loc1 ++ ) { loc0 [ loc1 ] = aquireLine ( ) ; } for ( int loc1 = 0 ; loc1 < 16 ; loc1 ++ ) { poolLine ( loc0 [ loc1 ] ) ; } } return mixer ; }"}, {"instruction": "Generate java code\ndetermine if the given class implements the given interface . ", "input": " PropertyAccessor DIRECT_PROPERTY_ACCESSOR \n Method OBJECT_EQUALS \n Class[] SINGLE_OBJECT_PARAM_SIGNATURE \n Object[] NO_PARAMS \n Method OBJECT_HASHCODE \n Class[] NO_PARAM_SIGNATURE \n PropertyAccessor BASIC_PROPERTY_ACCESSOR \n boolean overridesHashCode \n Getter getGetter \n Getter getter \n Object getConstantValue \n boolean isFinalClass \n boolean overridesEquals \n Method getMethod \n Class classForName \n Class classForName \n Constructor getConstructor \n Constructor<T> getDefaultConstructor \n Method extractHashCodeMethod \n Method extractEqualsMethod \n boolean isPublic \n boolean isPublic \n Class reflectedPropertyClass \n Class reflectedPropertyClass \n boolean isAbstractClass", "output": "boolean function ( Class arg0 , Class arg1 ) { assert arg1 . isInterface ( ) : \"srini_string\" ; return arg1 . isAssignableFrom ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable version of the given non-null shortlistiterator . ", "input": " ShortList EMPTY_SHORT_LIST \n ShortListIterator EMPTY_SHORT_LIST_ITERATOR \n ShortIterator EMPTY_SHORT_ITERATOR \n ShortListIterator getEmptyShortListIterator \n ShortIterator singletonShortIterator \n ShortList unmodifiableShortList \n ShortListIterator singletonShortListIterator \n ShortIterator unmodifiableShortIterator \n ShortList getEmptyShortList \n ShortList singletonShortList \n ShortIterator getEmptyShortIterator", "output": "ShortListIterator function ( ShortListIterator arg0 ) { if ( null == arg0 ) { throw new NullPointerException ( ) ; } return UnmodifiableShortListIterator . wrap ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns a written-back document of object obj as a string . ", "input": " Element curRootNode \n void writeTime \n void writeBack \n void writeBackToXML \n void writeSimpleType \n void writeComplexType", "output": "String function ( String arg0 , BackToXMLWritable arg1 ) { ByteArrayOutputStream loc0 = new ByteArrayOutputStream ( ) ; OutputStreamWriter loc1 = new OutputStreamWriter ( loc0 ) ; try { writeBack ( loc1 , arg0 , arg1 ) ; } catch ( IOException loc2 ) { throw new IllegalStateException ( loc2 ) ; } return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nreturns the id biginteger ", "input": " BigInteger bigInt \n TypesConfig config \n KademliaOverlayKey toKey \n void checkBounds \n int hashCode \n boolean equals \n BigInteger getUniqueValue \n String toBinary \n String toBinary \n String toString \n int compareTo \n byte[] getBytes", "output": "BigInteger function ( ) { return bigInt ; }"}, {"instruction": "Generate java code\ntiming for frame relative to previous frame . ", "input": " int xPosition \n int CMP_VERTICAL \n int yPosition \n boolean isPlayWrapupFrames \n int MODE_INDEXED_COLORS \n int compression_ \n int MSK_HAS_MASK \n int MSK_HAS_TRANSPARENT_COLOR \n int pageHeight \n int pageWidth \n long totalDuration_ \n Vector frames_ \n int transparentColor \n int height \n int nbPalettes_ \n int MODE_HAM8 \n int masking \n int MODE_HAM6 \n int MSK_NONE \n int MSK_LASSO \n int MODE_EHB \n boolean isSwapSpeakers \n PropertyChangeSupport listeners_ \n int nbPlanes \n int MODE_DIRECT_COLORS \n int xAspect \n Vector audioClips_ \n int screenMode \n int jiffies \n int CMP_BYTE_RUN_1 \n int yAspect \n int CMP_NONE \n int width \n ArrayList<ColorCycle> colorCycles \n Hashtable properties_ \n int getNbPlanes \n int getCompression \n void setYPosition \n List<ColorCycle> getColorCycles \n int getColorCyclesCount \n int getFrameCount \n AudioClip getAudioClip \n void setTransparentColor \n int getNbPalettes \n int getXAspect \n void setPageHeight \n int getTransparentColor \n int getJiffies \n int getInterleave \n int getMasking \n void firePropertyChange \n void removePropertyChangeListener \n void setHeight \n void setXAspect \n void setScreenMode \n void setCompression \n void setSwapSpeakers \n void setProperty \n void addFrame \n int getAudioClipCount \n void setXPosition \n int getYPosition \n boolean isPlayWrapupFrames \n SEQFrame getFrame \n int getWidth \n boolean isSwapSpeakers \n void addColorCycle \n void setPageWidth \n int getPageHeight \n int getHeight \n void addAudioClip \n void removeFrame \n int getDeltaOperation \n void addPropertyChangeListener \n Object getProperty \n int getXPosition \n void setMasking \n int getPageWidth \n int getYAspect \n void setYAspect \n void setWidth \n void setNbPlanes \n long getTotalDuration \n int getScreenMode \n void setJiffies", "output": "long function ( int arg0 ) { return ( ( SEQFrame ) frames_ . elementAt ( arg0 ) ) . getRelTime ( ) ; }"}, {"instruction": "Generate java code\ngets integer value form cursor for column index . ", "input": " PlaceHolder placeHolder \n Long getLong \n Character getChar \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n Byte getByte \n Short getShort \n byte[] getByteArray \n Double getDouble \n Boolean getBoolean \n Date getDate \n Date getDate \n Float getFloat \n String getString", "output": "Integer function ( @ NonNull Cursor arg0 , int arg1 ) { if ( arg0 . isNull ( arg1 ) ) { return null ; } return arg0 . getInt ( arg1 ) ; }"}, {"instruction": "Generate java code\nreturns an stubstrategy for a method , given descriptions of the method parameters , exceptions , and return value . parameter and return value descriptions are `` marshaller abbreviated names '' . ", "input": " Class<?> clz \n String reposId \n CDRStreamWriter[] paramWriters \n CDRStreamReader retvalReader \n List<Class<?>> exceptionList \n Class<?> retvalRemoteInterface \n java.lang.reflect.Method readMethod \n Map<String,ExceptionReader> exceptionMap \n Exception readException \n Exception read \n boolean isDeclaredException \n void writeParams \n boolean isNonVoid \n Object convertLocalRetval \n String getReposId \n Object readRetval", "output": "StubStrategy function ( String [ ] arg0 , String [ ] arg1 , String [ ] arg2 , String arg3 , ClassLoader arg4 ) { return new StubStrategy ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; }"}, {"instruction": "Generate java code\nspecifies that the parser produced by this code will expand entity reference nodes . by default the value of this is set to true ", "input": " boolean validating \n boolean namespaceAware \n boolean whitespace \n boolean expandEntityRef \n boolean coalescing \n boolean ignoreComments \n void setCoalescing \n boolean isIgnoringElementContentWhitespace \n void setIgnoringElementContentWhitespace \n boolean isCoalescing \n boolean isNamespaceAware \n void setNamespaceAware \n DocumentBuilderFactory newInstance \n boolean isValidating \n void setAttribute \n Object getAttribute \n boolean isExpandEntityReferences \n DocumentBuilder newDocumentBuilder \n void setValidating \n void setIgnoringComments \n boolean isIgnoringComments", "output": "void function ( boolean arg0 ) { this . expandEntityRef = arg0 ; }"}, {"instruction": "Generate java code\ncreates a new dummy edge to be used in the graph ", "input": " List clusters \n List set \n EdgeList edgeList \n Cluster currentCluster \n List edgesAdded \n int INITIAL_RECURSION_DEPTH \n NodeList nodeList \n DirectedGraph graph \n List encountered \n void joinClusters \n void coalesceRemainingClusters \n String toString \n void visit \n void recursivelyAddToCluster", "output": "Edge function ( Node arg0 , Node arg1 ) { boolean loc0 ; DummyEdgePart loc1 = new DummyEdgePart ( ) ; Edge loc2 = new Edge ( loc1 , arg0 , arg1 ) ; loc2 . weight = 2 ; edgeList . add ( loc2 ) ; arg1 = arg0 ; loc0 = true ; return loc2 ; }"}, {"instruction": "Generate java code\nreturn all columns ' metadata . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n long getRowCount \n List<ColumnMetaData> getRoots \n void readColumnMetaData \n ColumnValues<T> getValues \n ColumnValues<T> getValues \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n ColumnFileMetaData getMetaData \n void readHeader \n void readMagic \n void close", "output": "ColumnMetaData [ ] function ( ) { ColumnMetaData [ ] loc0 = new ColumnMetaData [ columnCount ] ; for ( int loc1 = 0 ; loc1 < columnCount ; loc1 ++ ) loc0 [ loc1 ] = columns [ loc1 ] . metaData ; return loc0 ; }"}, {"instruction": "Generate java code\nbigdecimal parse from reader . ", "input": " java.math.BigDecimal val \n int DEFAULT_PRECISION \n BigDecimal ZERO \n MathContext DEFAULT_CONTEXT \n MathContext context \n BigDecimal ONE \n Random random \n boolean isField \n boolean isCommutative \n BigDecimal gcd \n BigDecimal sum \n int compareTo \n java.math.BigInteger characteristic \n BigDecimal random \n BigDecimal random \n BigDecimal random \n BigDecimal random \n int hashCode \n BigDecimal divide \n BigDecimal copy \n BigDecimal multiply \n int signum \n boolean isONE \n BigDecimal inverse \n BigDecimal valueOf \n BigDecimal valueOf \n boolean isUnit \n BigDecimal subtract \n BigDecimal[] egcd \n BigDecimal abs \n BigDecimal[] divideAndRemainder \n BigDecimal negate \n boolean equals \n BigDecimal clone \n BigDecimal getONE \n BigDecimal getZERO \n BigDecimal fromInteger \n BigDecimal fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigDecimal remainder", "output": "BigDecimal function ( Reader arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns a url pointing to the jar file . ", "input": " String RESOURCE \n String ERRORMSG \n void extractTo \n InputStream getResourceAsStream \n File extractToTempLocation \n void safeClose", "output": "URL function ( ) { final URL loc0 = AgentJar . class . getResource ( RESOURCE ) ; if ( loc0 == null ) { throw new AssertionError ( ERRORMSG ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ncalculates the dominance frontier for a cfg and notifies the blocks in it appropriately . ", "input": " PlaceHolder placeHolder \n LinkedList calcFrontier", "output": "void function ( final FlowGraph arg0 , boolean arg1 ) { if ( ! arg1 ) { DominanceFrontier . calcFrontier ( arg0 . source ( ) , arg0 , arg1 ) ; } else { DominanceFrontier . calcFrontier ( arg0 . sink ( ) , arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\ncreate a simple dialog with an ` ok ' button and a message . ", "input": " PlaceHolder placeHolder \n boolean verifySampleSetup \n boolean resolveConnectionFailure \n void showActivityResultError \n void showAlert", "output": "Dialog function ( Activity arg0 , String arg1 ) { return ( new AlertDialog . Builder ( arg0 ) ) . setMessage ( arg1 ) . setNeutralButton ( android . R . string . ok , null ) . create ( ) ; }"}, {"instruction": "Generate java code\nfinds files with mixed line delimiters . ", "input": " PlaceHolder placeHolder \n void assertNoMixedLineDelimiters \n void assertNoMixedLineDelimiters", "output": "IResource [ ] function ( final IResource arg0 ) { Assert . fail ( \"srini_string\" ) ; return new IResource [ 0 ] ; }"}, {"instruction": "Generate java code\ntests if two types are assign compatible . void types are never compatible . ", "input": " PlaceHolder placeHolder \n boolean canCast \n boolean isArrayCompatible \n boolean isJavaLangObject", "output": "boolean function ( ITypeBinding arg0 , ITypeBinding arg1 ) { TypeEnvironment loc0 = new TypeEnvironment ( false , true ) ; TType loc1 = loc0 . create ( arg1 ) ; TType loc2 = loc0 . create ( arg0 ) ; return loc2 . canAssignTo ( loc1 ) ; }"}, {"instruction": "Generate java code\nimplement a hash code for this comparator that is consistent with #equals object equals . ", "input": " long serialVersionUID \n ComparableComparator instance \n int compare \n boolean equals \n ComparableComparator getInstance", "output": "int function ( ) { return \"srini_string\" . hashCode ( ) ; }"}, {"instruction": "Generate java code\nappends a select clause fragment ", "input": " LockOptions lockOptions \n int guesstimatedBufferSize \n StringBuilder whereClause \n Dialect dialect \n StringBuilder selectClause \n String outerJoinsAfterWhere \n String outerJoinsAfterFrom \n StringBuilder fromClause \n String comment \n StringBuilder orderByClause \n void appendFromClauseFragment \n void appendFromClauseFragment \n void setOuterJoins \n void setLockOptions \n void appendOrderByFragment \n void setComment \n String toStatementString \n boolean isNotEmpty \n boolean isNotEmpty \n String cleanRestrictions \n void setLockMode \n void appendRestrictions", "output": "void function ( String arg0 ) { if ( this . selectClause . length ( ) > 0 ) { this . selectClause . append ( \"srini_string\" ) ; this . guesstimatedBufferSize += 2 ; } this . selectClause . append ( arg0 ) ; this . guesstimatedBufferSize += arg0 . length ( ) ; }"}, {"instruction": "Generate java code\nlog an error with warn log level . ", "input": " Date date \n int LOG_LEVEL_DEBUG \n int level \n Throwable throwable \n List logEntries \n int LOG_LEVEL_OFF \n Object message \n int LOG_LEVEL_WARN \n int LOG_LEVEL_TRACE \n int LOG_LEVEL_ERROR \n int LOG_LEVEL_INFO \n String logName \n String name \n int LOG_LEVEL_FATAL \n int LOG_LEVEL_ALL \n int currentLogLevel \n void debug \n void debug \n void log \n Object getMessage \n boolean isLevelEnabled \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void setLevel \n void fatal \n void fatal \n String getLogName \n int getLevel \n int getLevel \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n void reset \n boolean isTraceEnabled \n Date getDate \n boolean isDebugEnabled \n Throwable getThrowable \n List getLogEntries \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_WARN ) ) { log ( MemoryLog . LOG_LEVEL_WARN , arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nde-register the agent again . ", "input": " String JMX_NAME \n MBeanServer server \n ObjectName name \n placeholderType placeHolder", "output": "Void function ( ) { server . unregisterMBean ( name ) ; return null ; }"}, {"instruction": "Generate java code\nshould this joinsequence use theta-style joining both a from and where component in the rendered sql ? ", "input": " StringBuilder conditions \n JoinSequence next \n SessionFactoryImplementor factory \n boolean isFromPart \n String[] lhsColumns \n String rootAlias \n AssociationType associationType \n List<Join> joins \n Set<String> treatAsDeclarations \n Joinable rootJoinable \n JoinType joinType \n String alias \n Selector selector \n Joinable joinable \n boolean useThetaStyle \n void applyTreatAsDeclarations \n JoinFragment toJoinFragment \n JoinFragment toJoinFragment \n JoinFragment toJoinFragment \n Joinable getJoinable \n boolean isThetaStyle \n boolean isManyToManyRoot \n JoinSequence addCondition \n JoinSequence addCondition \n JoinSequence setRoot \n void addSubclassJoins \n String[] getLHSColumns \n JoinSequence addJoin \n Join getFirstJoin \n JoinType getJoinType \n JoinSequence setNext \n JoinSequence setSelector \n String toString \n String toString \n JoinSequence getFromPart \n JoinSequence copy \n AssociationType getAssociationType \n String getAlias \n boolean isIncluded \n boolean includeSubclasses", "output": "JoinSequence function ( boolean arg0 ) { this . useThetaStyle = arg0 ; return this ; }"}, {"instruction": "Generate java code\ngets the value of the owner property . ", "input": " Owner owner \n Locktype locktype \n Lockscope lockscope \n Lockscope getLockscope \n void setLockscope \n void setLocktype \n Locktype getLocktype \n void setOwner", "output": "Owner function ( ) { return owner ; }"}, {"instruction": "Generate java code\ncreate a widget-relative hover info instance . ", "input": " PlaceHolder placeHolder \n IHoverInfo getAbsolute \n IHoverInfo getAbsolute \n IHoverInfo getRelativeToCenter", "output": "IHoverInfo function ( Widget arg0 , int arg1 , int arg2 ) { return new WidgetRelativeHoverInfo ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nreturns the menu that is current being shown . ", "input": " MenuPopup mMenuPopup \n MenuPanel mMenuPanel \n OnMenuItemLongClickListener mLongClickListener \n GeckoMenu mMenu \n OnDismissListener mDismissListener \n View mAnchor \n GeckoMenuInflater mMenuInflater \n OnMenuItemClickListener mClickListener \n boolean onMenuItemLongClick \n boolean onMenuItemLongClick \n void openMenu \n boolean onDismiss \n void setOnDismissListener \n void show \n void dismiss \n void closeMenu \n void setOnMenuItemLongClickListener \n void inflate \n void showMenu \n MenuInflater getMenuInflater \n void setAnchor \n void setOnMenuItemClickListener \n void initialize \n boolean onMenuItemClick \n boolean onMenuItemClick", "output": "Menu function ( ) { return mMenu ; }"}, {"instruction": "Generate java code\ncalled when the renderer is stopped . the default implementation is a no-op . ", "input": " long MATCH_LONGEST_US \n int STATE_UNPREPARED \n long UNKNOWN_TIME_US \n int STATE_PREPARED \n int STATE_ENABLED \n long END_OF_TRACK_US \n int STATE_STARTED \n int state \n int STATE_RELEASED \n boolean doPrepare \n int prepare \n void onReleased \n void release \n boolean isReady \n void handleMessage \n void start \n int getTrackCount \n long getDurationUs \n void seekTo \n MediaClock getMediaClock \n int getState \n void onStarted \n void stop \n void enable \n void disable \n long getBufferedPositionUs \n void onEnabled \n void maybeThrowError \n MediaFormat getFormat \n void doSomeWork \n void onDisabled \n boolean isEnded", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nremoves the equivalent person from the address book . ", "input": " UniquePersonList allPersons \n UniqueTagList allTags \n boolean containsPerson \n int hashCode \n boolean equals \n void clear \n UniquePersonList getAllPersons \n void removeTag \n UniqueTagList getAllTags \n void syncTagsWithMasterList \n void addTag \n void addPerson \n boolean containsTag \n AddressBook empty", "output": "void function ( ReadOnlyPerson arg0 ) { allPersons . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the undo change of the change performed by this operation . returns null if the change has n't been performed yet or if the change does n't provide a undo . ", "input": " Change fChange \n Change fUndoChange \n boolean fChangeExecutionFailed \n IUndoManager fUndoManager \n boolean fChangeExecuted \n CreateChangeOperation fCreateChangeOperation \n ISchedulingRule fSchedulingRule \n RefactoringStatus fValidationStatus \n String fUndoName \n RefactoringStatus getConditionCheckingStatus \n boolean changeExecutionFailed \n boolean createChange \n Change getChange \n void setUndoManager \n void run \n void executeChange \n void setSchedulingRule \n boolean changeExecuted \n RefactoringStatus getValidationStatus", "output": "Change function ( ) { return fUndoChange ; }"}, {"instruction": "Generate java code\nmark a task as done for now , just delete the task . ", "input": " SimpleDateFormat DATE_FORMAT \n Context context \n TaskService serviceInstance \n void bulkDone \n long insert \n int update \n void scheduleTask \n void unscheduleTask \n TaskService getInstance \n int delete \n void scheduleTasksOnBoot \n PendingIntent buildPendingIntent", "output": "int function ( Long arg0 ) { return context . getContentResolver ( ) . delete ( UriUtils . buildTaskWithId ( arg0 ) , null , null ) ; }"}, {"instruction": "Generate java code\nexpert : declare a count of items to be written to an array column or a column whose parent is an array . ", "input": " byte[] MAGIC_1 \n ColumnFileMetaData metaData \n long size \n byte[] MAGIC_0 \n ColumnOutputBuffer[] columns \n long rowCount \n int columnCount \n byte[] MAGIC \n void writeHeader \n void writeTo \n void writeTo \n long[] computeStarts \n void startRow \n void endRow \n void checkColumns \n int getColumnCount \n void writeRow \n void incrementSize \n ColumnFileMetaData getMetaData \n void writeValue \n long sizeEstimate", "output": "void function ( int arg0 , int arg1 ) { columns [ arg1 ] . writeLength ( arg0 ) ; }"}, {"instruction": "Generate java code\ncheck if the specified node exists . sets no watches . ", "input": " char ZNODE_PATH_SEPARATOR \n Logger LOG \n void createSetData \n String getParent \n boolean setData \n List<String> listChildrenNoWatch \n String joinZNode \n ArrayList<ACL> createACL \n void deleteNodeRecursively \n byte[] getData \n void createWithParents \n void createWithParents", "output": "int function ( ZooKeeper arg0 , String arg1 ) { try { Stat loc0 = arg0 . exists ( arg1 , null ) ; return loc0 != null ? loc0 . getVersion ( ) : - 1 ; } catch ( KeeperException loc0 ) { return - 1 ; } catch ( InterruptedException loc0 ) { Thread . currentThread ( ) . interrupt ( ) ; return - 1 ; } }"}, {"instruction": "Generate java code\nthis method does not return until the display thread is in an `` idle '' state . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "void function ( ) { waitForIdle ( Display . getDefault ( ) ) ; }"}, {"instruction": "Generate java code\nreturn system properties , extended by any properties specified in hibernate.properties . ", "input": " boolean ENABLE_BINARY_STREAMS \n CoreMessageLogger LOG \n Map OBSOLETE_PROPERTIES \n Map<Integer,String> ISOLATION_LEVELS \n Map RENAMED_PROPERTIES \n Properties GLOBAL_PROPERTIES \n BytecodeProvider BYTECODE_PROVIDER_INSTANCE \n boolean JVM_HAS_TIMESTAMP_BUG \n boolean ENABLE_REFLECTION_OPTIMIZER \n void verifyProperties \n boolean useReflectionOptimizer \n BytecodeProvider getBytecodeProvider \n boolean jvmHasTimestampBug \n String isolationLevelToString \n BytecodeProvider buildBytecodeProvider \n BytecodeProvider buildBytecodeProvider \n boolean useStreamsForBinary", "output": "Properties function ( ) { Properties loc0 = new Properties ( ) ; loc0 . putAll ( GLOBAL_PROPERTIES ) ; return loc0 ; }"}, {"instruction": "Generate java code\nsets the array that the arrayiterator should iterate over . if an array has previously been set using the single-arg constructor or this method then that array is discarded in favour of this one . iteration is restarted at the start of the new array . although this can be used to reset iteration , the #reset methodis a more effective choice . ", "input": " int index \n int startIndex \n Object array \n int endIndex \n Object next \n void checkBound \n Object getArray \n void reset \n boolean hasNext \n void remove", "output": "void function ( final Object arg0 ) { this . endIndex = Array . getLength ( arg0 ) ; this . startIndex = 0 ; this . array = arg0 ; this . index = 0 ; }"}, {"instruction": "Generate java code\ntake a path string elements delimited by the ' \\ ' character and break it into tokens . if an element contains the delimeter , it must be escaped . for example : `` edit/find \\ \\ / replace '' tokenizes to `` edit '' , `` find/replace '' . ", "input": " List _items \n char _delimeter \n char _escape \n String _pathString \n StringBuffer _sb \n String[] getItems \n void addItem \n char getChar \n boolean inBounds \n boolean isEscape \n void addChar \n boolean isEscapeCase \n boolean isDelimeter", "output": "String [ ] function ( String arg0 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return new PathTokenizer ( arg0 ) . tokenize ( ) ; }"}, {"instruction": "Generate java code\nremoves a class to transformer mapping in the map . ", "input": " NumberTransformer defaultTransformer \n Map map \n long serialVersionUID \n boolean containsTransformer \n Collection transformers \n double transform \n NumberTransformer getTransformer \n Set classes \n void clear \n boolean containsClass \n Object putTransformer", "output": "Object function ( Class arg0 ) { return map . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the one element . ", "input": " UnivPowerSeries<C> ZERO \n String DEFAULT_NAME \n int truncate \n String var \n int DEFAULT_TRUNCATE \n UnivPowerSeries<C> ONE \n RingFactory<C> coFac \n Random random \n UnivPowerSeries<C> getTAN \n boolean isField \n boolean isCommutative \n UnivPowerSeries<C> getSIN \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> fromPolynomial \n java.math.BigInteger characteristic \n UnivPowerSeries<C> getEXP \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n int hashCode \n boolean equals \n UnivPowerSeries<C> getZERO \n UnivPowerSeries<C> getCOS \n UnivPowerSeries<C> fromInteger \n UnivPowerSeries<C> fromInteger \n String toString \n boolean isAssociative \n UnivPowerSeries<C> copy \n UnivPowerSeries<C> fixPoint", "output": "UnivPowerSeries < C > function ( ) { return ONE ; }"}, {"instruction": "Generate java code\naccess to the intercepted entity name ", "input": " boolean dirty \n SessionImplementor session \n String entityName \n boolean initializing \n Set uninitializedFields \n void dirty \n boolean isInitializing \n boolean isDirty \n Set getUninitializedFields \n void clearDirty \n Object intercept \n boolean isInitialized \n boolean isInitialized \n void setSession \n SessionImplementor getSession", "output": "String function ( ) { return entityName ; }"}, {"instruction": "Generate java code\nreturns the programmer defined property of the receiver with the specified name , or null if it has not been set . data mappings allow programmers to associate arbitrary key-value pairs with locator instances . ", "input": " long serialVersionUID \n int UNASSIGNED \n String nameOrLabel \n int index \n WidgetLocator ancestorInfo \n WidgetLocator parentInfo \n HashMap<String,String> map \n ClassReference classRef \n void setAncestorInfo \n Object getAdapter \n int getIndex \n void setData \n void copyDataTo \n WidgetLocator getParentInfo \n String getWidgetLocatorStringName \n String getNameOrLabel \n WidgetLocator getAncestorInfo \n com.windowtester.runtime.locator.IWidgetLocator[] findAll \n boolean matches \n Map<String,String> getDataMap \n void accept \n void setParentInfo \n Class<?> getTargetClass \n void setIndex \n int hashCode \n boolean equals \n ClassReference getTargetClassRef \n String getTargetClassName \n String toString", "output": "String function ( String arg0 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return getDataMap ( ) . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nnoop is the default behavior , which means that kafka will internally handle partition assignment . if you wish to do manual partition management , you must provide an implementation of this method that will check with kafka for any changes and call the consumerrebalancelistener from subscribe to inform the rest of the system of those changes . ", "input": " long serialVersionUID \n String getTopicsString \n void subscribe", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nsets the bounds for this timeline . a timeline must have sensible bounds . left side must be < = right side . ", "input": " List<TimeLineGraph> graphs \n boolean timerActive \n double rightBound \n boolean isDirty \n double leftBound \n double mostRecentDomainValue \n List<DomainObserver> domainObservers \n GraphCalloutModel graphCalloutModel \n boolean showStreaming \n Timer t \n List<WindowBoundsObserver> windowObservers \n boolean pinLowerBound \n UpdateTicker updateController \n void addDomainObserver \n void onModelDataRefreshTick \n void fireBoundsChangeEvent \n double getLeftBound \n void restartUpdateTimer \n void addWindowBoundsObserver \n double getRightBound \n void refresh \n double getMostRecentDomainValue \n void addGraph \n void setStreaming \n ArrayList<TimeLineGraph> getGraphs \n boolean isStreaming \n GraphCalloutModel getGraphCalloutModel \n void removeWindowBoundsObserver \n void onWindowBoundsChange \n void removeDomainObserver \n int getGraphCount \n void onDomainChange \n void toggleFixBounds \n void timerDispatch", "output": "void function ( double arg0 , double arg1 ) { assert ( arg0 <= arg1 ) ; this . leftBound = arg0 ; this . rightBound = arg1 ; fireBoundsChangeEvent ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ncreate a new user interface context . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "IUIContext function ( Display arg0 ) { IUIContext loc0 = createContext ( IUIContext . class , arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ninverse . l is a list . the inverse of l is returned . the list l is modified . ", "input": " LIST<?> SIL \n Iterator<C> iter \n LinkedList<C> list \n void SFIRST \n LIST<C> LIST1 \n LIST<C> RED3 \n LIST<C> LIST3 \n LIST<C> RED4 \n LIST<C> LIST2 \n C THIRD \n LIST<C> LIST5 \n int LENGTH \n LIST<C> RED2 \n LIST<C> LIST4 \n LIST<C> COMP \n LIST<C> COMP3 \n LIST<C> COMP3 \n int ORDER \n LIST<C> COMP2 \n int EXTENT \n void SRED \n C LELT \n boolean EQUAL \n LIST<C> LIST10 \n boolean isEmpty \n LIST<C> CCONC \n C FIRST \n LIST<C> REDUCT \n C FOURTH \n LIST<C> RED \n LIST<C> CINV \n boolean isNull \n String toString \n C SECOND \n long CLOCK \n LIST<C> CONC", "output": "LIST < C > function ( LIST < C > arg0 ) { if ( isNull ( arg0 ) ) { return arg0 ; } Collections . reverse ( arg0 . list ) ; return arg0 ; }"}, {"instruction": "Generate java code\ndetermine if any open editors are `` dirty '' . ", "input": " PlaceHolder placeHolder \n boolean anyUnsavedChanges0", "output": "boolean function ( ) { final boolean loc0 [ ] = new boolean [ ] { false } ; Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { loc0 [ 0 ] = anyUnsavedChanges0 ( ) ; } } ) ; return loc0 [ 0 ] ; }"}, {"instruction": "Generate java code\ndefault implementation that simply throws a waittimedoutexception . ", "input": " long timeout \n int interval \n boolean isTrue \n void wait \n void wait \n boolean timedOut \n Timer withInterval \n Timer withTimeout \n void pause", "output": "void function ( ICondition arg0 ) { throw new WaitTimedOutException ( Diagnostic . toString ( \"srini_string\" , arg0 ) ) ; }"}, {"instruction": "Generate java code\nthis method returns the list of sub-coordinators , which is maintained by metricstorage . ", "input": " HashMap<BigDecimal,MetricsSubCoordinatorInfo> listOfSubCoordinators \n float exponentialSmoothing \n MetricsEntry ownMetrics \n Logger log \n String smoothingType \n SkyNetNodeInterface skynetNode \n LinkedList<HashMap<String,MetricsAggregate>> metricsHistory \n int historySize \n void setOwnMetrics \n void setListOfSubCoordinators \n LinkedList<HashMap<String,MetricsAggregate>> getMetricsHistory \n MetricsAggregate mergeTwoAggregates \n void setMetricsHistory \n void reset \n MetricsEntry getOwnMetrics \n void addMetricsMapToMetricsHistory \n MetricsEntry aggregateMetrics", "output": "HashMap < BigDecimal , MetricsSubCoordinatorInfo > function ( ) { return listOfSubCoordinators ; }"}, {"instruction": "Generate java code\nsingleton retrieval method . ", "input": " IAnnotationCreator instance \n long serialVersionUID \n JComponent createAnnotationView", "output": "IAnnotationCreator function ( ) { if ( AnnotationCreatorBubble . instance == null ) { AnnotationCreatorBubble . instance = new AnnotationCreatorBubble ( ) ; } return AnnotationCreatorBubble . instance ; }"}, {"instruction": "Generate java code\ngets the number of accounts in the bank . ", "input": " double[] accounts \n void transfer \n double getTotalBalance", "output": "int function ( ) { return accounts . length ; }"}, {"instruction": "Generate java code\nlist all filles . ", "input": " ArrayList<String> files \n MusicPlayer player \n void listFile \n void removeFile \n int getNumberOfFiles \n void listMatching \n int findFirst \n void stopPlaying \n void startPlaying \n void addFile \n void playSampleOf", "output": "void function ( ) { for ( String loc0 : files ) { int loc1 = files . indexOf ( loc0 ) ; System . out . println ( ( loc1 + 1 ) + \"srini_string\" + files . get ( loc1 ) ) ; } }"}, {"instruction": "Generate java code\nreturns the parent tag for this tag . ", "input": " Tag parent \n Map<String,String> css \n List<Tag> children \n String ns \n Map<String,String> attributes \n String tag \n Object lastMarginBottom \n void setLastMarginBottom \n void setCSS \n Map<String,String> getAttributes \n String getName \n Map<String,String> getCSS \n boolean hasChildren \n Tag getChild \n Tag getChild \n String getNameSpace \n Tag recursiveGetChild \n String getTag \n List<Tag> getChildren \n List<Tag> getChildren \n boolean recursiveHasChild \n Object getLastMarginBottom \n Iterator<Tag> iterator \n boolean hasChild \n boolean hasChild \n String toString \n void setParent \n void addChild \n boolean compareTag \n boolean hasParent", "output": "Tag function ( ) { return this . parent ; }"}, {"instruction": "Generate java code\nreturns an environment not linked to a storage instance , butpopulated with current field values . ", "input": " String LOG_TAG \n int getScreenYInMM \n int registerCurrentEnvironment \n String getDistributionString \n String getOSLocale \n void populateEnvironment \n ContentProviderClient getContentProviderClient \n UIType getUIType \n boolean isBlocklistEnabled \n boolean hasHardwareKeyboard \n String getAppLocale \n long getProfileCreationTime \n JSONObject getAddonsJSON \n int getScreenLayoutSize \n int getScreenXInMM \n HealthReportDatabaseStorage getStorage \n int getUIModeType \n boolean isAcceptLangUserSet \n boolean isTelemetryEnabled", "output": "Environment function ( ProfileInformationProvider arg0 , ConfigurationProvider arg1 ) { Environment loc0 = new Environment ( ) { @ Override public int register ( ) { return 0 ; } } ; populateEnvironment ( loc0 , arg0 , arg1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ntrigger removal of a resource to an index note : the actual operation is performed in background ", "input": " int CANCEL_IF_NOT_READY_TO_SEARCH \n SearchEngine fgSearchEngine \n HashMap fIndexes \n HashMap fMap \n int WAIT_UNTIL_READY_TO_SEARCH \n void add \n SearchEngine getSearchEngine \n void search \n boolean search \n IIndex getIndex \n void addRef \n IIndex[] getIndexes \n IFile[] getFiles \n boolean execute \n void queryPrefix", "output": "void function ( String arg0 , IPath arg1 ) { IIndex loc0 = getIndex ( arg1 , false ) ; if ( loc0 != null ) loc0 . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nset this label as a major tick . ", "input": " String m_label \n boolean m_isMajorTick \n double m_value \n double getValue \n String getLabel \n boolean isMajorTick \n void setValue \n void setLabel \n String toString", "output": "void function ( final boolean arg0 ) { this . m_isMajorTick = arg0 ; }"}, {"instruction": "Generate java code\nright groebner base using pairlist class . ", "input": " SolvableGroebnerBase<C> sbb \n boolean debug \n Logger logger \n List<GenSolvablePolynomial<C>> leftGB \n ModuleList<C> leftGB \n boolean isTwosidedGB \n boolean isTwosidedGB \n boolean isLeftGB \n boolean isLeftGB \n boolean isRightGB \n boolean isRightGB \n List<GenSolvablePolynomial<C>> twosidedGB \n ModuleList<C> twosidedGB", "output": "List < GenSolvablePolynomial < C >> function ( int arg0 , List < GenSolvablePolynomial < C >> arg1 ) { if ( arg0 == 0 ) { return sbb . rightGB ( arg0 , arg1 ) ; } throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the component interceptor factory map . ", "input": " BasicComponent component \n Class<?> componentClass \n Map<Method,InterceptorFactory> componentInterceptors \n InterceptorFactory preDestroy \n String componentName \n ServiceName serviceName \n InterceptorFactory postConstruct \n NamespaceContextSelector namespaceContextSelector \n InjectedValue<DeploymentUnit> deploymentUnit \n String getComponentName \n Component getValue \n NamespaceContextSelector getNamespaceContextSelector \n InterceptorFactory getPreDestroy \n void stop \n Class<?> getComponentClass \n boolean requiresInterceptors \n void start \n InjectedValue<DeploymentUnit> getDeploymentUnitInjector \n ServiceName getServiceName \n InterceptorFactory getPostConstruct \n BasicComponent createComponent", "output": "Map < Method , InterceptorFactory > function ( ) { return componentInterceptors ; }"}, {"instruction": "Generate java code\nreads the next byte as an unsigned value . ", "input": " byte[] data \n int limit \n int position \n int readUnsignedInt24 \n int readSynchSafeInt \n int readUnsignedIntToInt \n void setPosition \n int capacity \n void skipBytes \n long readUnsignedInt \n int getPosition \n long readLong \n short readShort \n void setLimit \n int bytesLeft \n int limit \n void reset \n void reset \n void readBytes \n void readBytes \n void readBytes \n int readUnsignedFixedPoint1616 \n int readInt \n long readUnsignedLongToLong \n int readUnsignedShort", "output": "int function ( ) { return ( data [ position ++ ] & 0xFF ) ; }"}, {"instruction": "Generate java code\nset the started status . ", "input": " boolean started_ \n String jndiName_ \n Logger LOG \n Element config_ \n Element getConfiguration \n void stop \n void unbind \n void rebind \n Properties getProperties \n String getJNDIName \n boolean isStarted \n void setConfiguration \n void setJNDIName", "output": "void function ( boolean arg0 ) { started_ = arg0 ; }"}, {"instruction": "Generate java code\nparses the uuid from a pssh atom . the uuid is only parsed if the data is a valid pssh atom . ", "input": " PlaceHolder placeHolder \n byte[] parseSchemeSpecificData \n byte[] buildPsshAtom \n boolean isPsshAtom", "output": "UUID function ( byte [ ] arg0 ) { ParsableByteArray loc0 = new ParsableByteArray ( arg0 ) ; if ( ! isPsshAtom ( loc0 , null ) ) { return null ; } loc0 . setPosition ( Atom . FULL_HEADER_SIZE ) ; return new UUID ( loc0 . readLong ( ) , loc0 . readLong ( ) ) ; }"}, {"instruction": "Generate java code\nwrite the field to a class file . ", "input": " ClassInfo classInfo \n int name \n int modifiers \n int type \n Attribute[] attrs \n ConstantValue constantValue \n void setConstantValue \n int typeIndex \n int nameIndex \n void setNameIndex \n String toString \n void setTypeIndex \n void setModifiers \n int modifiers \n ClassInfo declaringClass \n int constantValue", "output": "void function ( final DataOutputStream arg0 ) { arg0 . writeShort ( modifiers ) ; arg0 . writeShort ( name ) ; arg0 . writeShort ( type ) ; arg0 . writeShort ( attrs . length ) ; for ( int loc0 = 0 ; loc0 < attrs . length ; loc0 ++ ) { arg0 . writeShort ( attrs [ loc0 ] . nameIndex ( ) ) ; arg0 . writeInt ( attrs [ loc0 ] . length ( ) ) ; attrs [ loc0 ] . writeData ( arg0 ) ; } }"}, {"instruction": "Generate java code\nreturns a random entry from the given collection . uses the prng used by the simulator . returns null if the list is empty . ", "input": " PlaceHolder placeHolder \n void filter \n void copyNSortedAndFiltered \n void filterMap \n void copyNSorted \n double getQuantile \n void splitMap \n List<T> getRandomPartFrom \n void copyUntilFull \n List<Tt> transformList", "output": "E function ( Collection < E > arg0 ) { if ( arg0 instanceof List ) return getRandomEntry ( ( List < E > ) arg0 ) ; if ( arg0 . size ( ) == 0 ) return null ; int loc0 = Simulator . getRandom ( ) . nextInt ( arg0 . size ( ) ) ; for ( E loc1 : arg0 ) { if ( loc0 <= 0 ) return loc1 ; loc0 -- ; } return null ; }"}, {"instruction": "Generate java code\nparse product from reader . syntax : p1 ... pn no commas ", "input": " int nCopies \n RingFactory<C> ring \n List<RingFactory<C>> ringList \n Logger logger \n Random random \n void addFactory \n boolean containsFactory \n boolean isField \n int length \n boolean isCommutative \n RingFactory<C> getFactory \n java.math.BigInteger characteristic \n Product<C> random \n Product<C> random \n Product<C> random \n Product<C> random \n Product<C> getAtomic \n int hashCode \n boolean equals \n Product<C> getONE \n Product<C> getZERO \n Product<C> fromInteger \n Product<C> fromInteger \n boolean isAssociative \n String toString \n Product<C> copy", "output": "Product < C > function ( Reader arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\na helper method to create a change that adds an entry to the class path . ", "input": " PlaceHolder placeHolder \n String getAdditionalProposalInfo \n ClasspathFixProposal[] getFixImportProposals \n Change newClasspathChange \n Change createChange \n int getRelevance \n String getDisplayString \n Image getImage \n ClasspathFixProposal[] getContributedFixImportProposals", "output": "Change function ( IJavaProject arg0 , IClasspathEntry arg1 ) { return ClasspathChange . addEntryChange ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nquery if this ring is associative . ", "input": " GenPolynomialRing<C> ring \n int isField \n GenPolynomial<C> modul \n boolean isField \n boolean isCommutative \n AlgebraicNumber<C> interpolate \n AlgebraicNumber<C> parse \n AlgebraicNumber<C> parse \n java.math.BigInteger characteristic \n AlgebraicNumber<C> random \n AlgebraicNumber<C> random \n int hashCode \n boolean equals \n AlgebraicNumber<C> getONE \n AlgebraicNumber<C> getZERO \n AlgebraicNumber<C> fromInteger \n AlgebraicNumber<C> fromInteger \n String toString \n AlgebraicNumber<C> copy \n AlgebraicNumber<C> chineseRemainder", "output": "boolean function ( ) { return ring . isAssociative ( ) ; }"}, {"instruction": "Generate java code\ncreate a condition that tests if the given widget is enabled . ", "input": " Widget widget \n Object getWidget \n IWidgetLocator[] findAll \n boolean matches", "output": "IUICondition function ( boolean arg0 ) { return new IsEnabledCondition ( this , arg0 ) ; }"}, {"instruction": "Generate java code\nget name . ", "input": " boolean isDefault \n String color \n String name \n int id \n String url \n void setName \n String getUrl \n boolean isDefault \n void setColor \n void setId \n String getColor \n int getId \n void setDefault \n void setUrl", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nset the directory into which commited class files should be written . ", "input": " File outputDir \n LinkedList cache \n ClassSource _classSource \n String classpath \n Map openZipFiles \n boolean DEBUG \n boolean USE_SYSTEM_CLASSES \n int CACHE_LIMIT \n boolean verbose \n File outputDir \n ClassInfo loadClassFromStream \n void appendClassPath \n ClassInfo loadClassFromFile \n void setVerbose \n ClassInfo[] loadClassesFromZipFile \n void done \n void prependClassPath \n OutputStream outputStreamFor \n OutputStream outputStreamFor \n void setClassPath \n String getClassPath \n void addToCache \n ClassInfo newClass \n ClassInfo loadClassFromRessource \n ClassInfo loadClass \n void writeEntry", "output": "void function ( final File arg0 ) { outputDir = arg0 ; }"}, {"instruction": "Generate java code\nadd a section without header content . ", "input": " Optional<String> fileName \n long serialVersionUID \n boolean built \n Set<PreprocessorRule> preprocessorRules \n List<Section> sections \n RedPenTokenizer tokenizer \n DocumentBuilder appendSection \n void ensureNotBuilt \n DocumentBuilder setPreprocessorRules \n Section getLastSection \n Section getLastSection \n Set<PreprocessorRule> getPreprocessorRules \n DocumentBuilder setFileName \n Iterator<Section> iterator \n Section getSection \n Section getSection \n DocumentBuilder addSectionHeader \n int size \n DocumentBuilder addSentence \n DocumentBuilder addSentence \n Document build \n int hashCode \n boolean equals \n DocumentBuilder builder \n DocumentBuilder builder \n String toString \n DocumentBuilder addParagraph \n DocumentBuilder addListBlock \n Optional<String> getFileName \n DocumentBuilder addListElement \n DocumentBuilder addListElement", "output": "DocumentBuilder function ( int arg0 ) { ensureNotBuilt ( ) ; addSection ( arg0 , new ArrayList < > ( ) ) ; return this ; }"}, {"instruction": "Generate java code\nreturns an array of sortedmap objects . the sortedmap object key is the columnname and the value is the columnvalue . sortedmap was created using the case_insensitive_order comparator so the key is the case insensitive representation of the columnname . ", "input": " boolean isLimited \n String[] columnNames \n List rowMap \n List rowByIndex \n String[] getColumnNames \n int getRowCount \n Object[][] getRowsByIndex \n boolean isLimitedByMaxRows", "output": "SortedMap [ ] function ( ) { if ( rowMap == null ) { return null ; } return ( SortedMap [ ] ) rowMap . toArray ( new SortedMap [ 0 ] ) ; }"}, {"instruction": "Generate java code\nuse a strategy that validates that a schema can be read by existing schema s according to the avro default schema resolution . ", "input": " SchemaValidationStrategy strategy \n void valid \n SchemaValidatorBuilder canReadStrategy \n SchemaValidator validateAll \n SchemaValidator validateLatest \n SchemaValidatorBuilder mutualReadStrategy \n SchemaValidatorBuilder strategy", "output": "SchemaValidatorBuilder function ( ) { this . strategy = new ValidateCanBeRead ( ) ; return this ; }"}, {"instruction": "Generate java code\nreturns a callable that will retain the stack trace information about where it originated from . ", "input": " Field causeField \n Executor decorate \n ExecutorService decorate \n ScheduledExecutorService decorate \n ListeningExecutorService decorate \n ListeningScheduledExecutorService decorate \n void handleException \n StackTraceElement[] getStackContext \n Throwable findRootCause \n Runnable makeContextRunnable \n List<Callable<T>> makeContextWrappedCollection", "output": "Callable < T > function ( final Callable < T > arg0 ) { return new ContextCallable < T > ( arg0 ) ; }"}, {"instruction": "Generate java code\nadd two durations . ", "input": " long DURATION_SECONDS_MAX \n long DURATION_SECONDS_MIN \n Duration MAX_VALUE \n Duration MIN_VALUE \n Comparator<Duration> COMPARATOR \n int compare \n Duration fromNanos \n boolean isValid \n boolean isValid \n Duration checkValid \n Duration subtract \n Duration parse \n long toSeconds \n Duration fromSeconds \n Comparator<Duration> comparator \n long toNanos \n Duration fromMillis \n Duration fromMicros \n String toString \n long toMillis \n long toMicros \n Duration normalizedDuration", "output": "Duration function ( Duration arg0 , Duration arg1 ) { checkValid ( arg0 ) ; checkValid ( arg1 ) ; return normalizedDuration ( checkedAdd ( arg0 . getSeconds ( ) , arg1 . getSeconds ( ) ) , checkedAdd ( arg0 . getNanos ( ) , arg1 . getNanos ( ) ) ) ; }"}, {"instruction": "Generate java code\ndefault implementation of mouseup simply releases capture . ", "input": " CaptureReleaser releaser \n void handleEvent \n void release \n void setCaptureReleaser \n void onMouseMove \n void onMouseDown", "output": "void function ( Event arg0 ) { release ( ) ; }"}, {"instruction": "Generate java code\nreturns the name of the class represented by this classeditor . ", "input": " boolean dirty \n ClassInfo classInfo \n Type[] interfaces \n Type superclass \n EditorContext context \n ConstantPool constants \n Type type \n boolean DEBUG \n void setInterface \n void setInterfaces \n boolean isStatic \n boolean isSuper \n MethodInfo[] methods \n void commit \n boolean isPrivate \n Type type \n int modifiers \n void setDirty \n void setFinal \n void setSuper \n boolean isDirty \n boolean isProtected \n Type superclass \n int hashCode \n void setProtected \n EditorContext context \n boolean isPublic \n boolean isFinal \n ConstantPool constants \n boolean isInterface \n ClassInfo classInfo \n void setPublic \n Type[] interfaces \n void addInterface \n void addInterface \n void setStatic \n void setType \n void commitOnly \n boolean isAbstract \n void setSuperclass \n boolean equals \n void setAbstract \n String toString \n void visit \n FieldInfo[] fields \n void setPrivate", "output": "String function ( ) { return ( this . classInfo ( ) . name ( ) ) ; }"}, {"instruction": "Generate java code\nget default proximity sensor if it exists . tablet devices e.g. nexus 7 does not support this type of sensor and false will be retured in such cases . ", "input": " String TAG \n SensorManager sensorManager \n RtkUtils.NonThreadSafe nonThreadSafe \n Sensor proximitySensor \n Runnable onSensorStateListener \n boolean lastStateReportIsNear \n void checkIfCalledOnValidThread \n void onSensorChanged \n void stop \n boolean start \n RtkProximitySensor create \n void logProximitySensorInfo \n boolean sensorReportsNearState \n void onAccuracyChanged", "output": "boolean function ( ) { if ( proximitySensor != null ) { return true ; } proximitySensor = sensorManager . getDefaultSensor ( Sensor . TYPE_PROXIMITY ) ; if ( proximitySensor == null ) { return false ; } logProximitySensorInfo ( ) ; return true ; }"}, {"instruction": "Generate java code\nreturns the suffixed result-set column-aliases for columns making up the key for this collection i.e. , its fk to its owner . ", "input": " Map userProvidedAliases \n String[] indexAliases \n String[] keyAliases \n String identifierAlias \n String suffix \n String[] elementAliases \n String getSuffix \n String getSuffixedIdentifierAlias \n String getUserProvidedAlias \n String toString \n String[] getUserProvidedAliases \n String[] getSuffixedIndexAliases \n String[] getSuffixedElementAliases \n String join", "output": "String [ ] function ( ) { return keyAliases ; }"}, {"instruction": "Generate java code\nindicate if property is in testing mode ", "input": " boolean isTesting \n String typeName \n Clob propertyValue \n Clob exampleValue \n boolean isEncrypted \n String propContName \n Integer descriptorId \n String typeContName \n Integer typeId \n Clob defaultValue \n String resourceName \n String fcExternalKey \n String technicalKey \n String mik \n Integer propContextId \n String origin \n Integer cardinalityProperty \n Integer propertyValueTypeId \n String displayName \n String fcOwner \n Integer propertyId \n Integer masterTypeId \n boolean isNullable \n String fcExternalLink \n String validationRegex \n String loadedFor \n boolean isOptional \n String validationLogic \n String descriptorOrigin \n Integer typeContextId \n Clob propertyComment \n ResourceEditPropertyBuilder withDisplayAndTechKeyName \n ResourceEditPropertyBuilder withOrigin \n ResourceEditPropertyBuilder withValidationRegex \n ResourceEditPropertyBuilder withIsEncrypted \n ResourceEditPropertyBuilder withDescriptorOrigin \n Clob convert \n ResourceEditPropertyBuilder withTechnicalKey \n ResourceEditPropertyBuilder withMasterResTypeName \n ResourceEditPropertyBuilder withLoadedFor \n ResourceEditPropertyBuilder withDisplayName \n ResourceEditPropertyBuilder withValue \n ResourceEditPropertyBuilder withFcExternalLink \n ResourceEditPropertyBuilder withDefaultValue \n ResourceEditPropertyBuilder withDescriptorId \n ResourceEditPropertyBuilder withTypeId \n ResourceEditPropertyBuilder withDescriptor \n ResourceEditPropertyBuilder withCardinality \n ResourceEditPropertyBuilder withPropTypeContName \n ResourceEditPropertyBuilder withValidationLogic \n ResourceEditPropertyBuilder withPropertyContextTypeId \n ResourceEditPropertyBuilder withPropertyId \n ResourceEditPropertyBuilder withPropContName \n ResourceEditPropertyBuilder withComment \n ResourceEditPropertyBuilder withFcOwner \n ResourceEditPropertyBuilder withMasterResTypeId \n ResourceEditPropertyBuilder withFcExternalKey \n ResourceEditProperty build \n ResourceEditPropertyBuilder withExampleValue \n ResourceEditPropertyBuilder withResourceName \n ResourceEditPropertyBuilder withPropContextId \n ResourceEditPropertyBuilder withIsNullable", "output": "ResourceEditPropertyBuilder function ( boolean arg0 ) { this . isTesting = arg0 ; return this ; }"}, {"instruction": "Generate java code\nfactory method to create a typed sorted bag . if there are any elements already in the bag being decorated , they are validated . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "SortedBag function ( SortedBag arg0 , Class arg1 ) { return new PredicatedSortedBag ( arg0 , InstanceofPredicate . getInstance ( arg1 ) ) ; }"}, {"instruction": "Generate java code\ndump out a value . ", "input": " PlaceHolder placeHolder \n void encode \n byte[] encode \n void decodeAndDump \n void decodeAndDump \n void decodeAndDump \n Asn1ParseResult parse \n Asn1ParseResult parse \n Asn1Type decode \n Asn1Type decode \n void decode \n void decode \n void parseAndDump \n void parseAndDump \n void parseAndDump", "output": "void function ( Asn1Type arg0 ) { Asn1Dumper loc0 = new Asn1Dumper ( ) ; loc0 . dumpType ( 0 , arg0 ) ; String loc1 = loc0 . loc1 ( ) ; System . out . println ( loc1 ) ; }"}, {"instruction": "Generate java code\ntest method for org.jboss.security.config.securityconfiguration #getcipherkey . ", "input": " PlaceHolder placeHolder \n void testGetCipherAlgorithm \n void testSetIterationCount \n void testGetKeyStoreURL \n void testGetSalt \n void testGetTrustStoreType \n void testGetKeyStoreType \n void testSetTrustStoreURL \n void testSetKeyStoreURL \n void testSetSalt \n void testLoadPassword \n void testSetCipherSpec \n void testGetExternalPasswordCacheInstance \n void testSetKeyStoreType \n void testIsDeepCopySubjectMode \n void testGetKeyStorePass \n WebArchive deployment \n void testSetTrustStorePass \n void testGetTrustStorePass \n void testSetCipherAlgorithm \n void testSetTrustStoreType \n void testGetTrustStoreURL \n void testSetDeepCopySubjectMode \n void testGetCipherSpec \n void testAddApplicationPolicy \n void testGetApplicationPolicy \n void testSetKeyStorePass \n void testRemoveApplicationPolicy \n void testSetCipherKey \n void testGetIterationCount", "output": "void function ( ) { SecurityConfiguration . getCipherKey ( ) ; }"}, {"instruction": "Generate java code\nlocking key state is reported incorrectly . ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean hasMultiClickFrameBug \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isLinux ( ) && Platform . JAVA_VERSION <= 0x1424 ; }"}, {"instruction": "Generate java code\nget the collection of table tables specified in the tablenames with bulk-load if the underlying storageplugin supports . it is not guaranteed that the retrieved tables would have rowtype and statistic being fully populated . specifically , calling table #getrowtype reldatatypefactory or table #getstatistic might incur unsupportedoperationexception being thrown . ", "input": " List<String> schemaPath \n String name \n org.slf4j.Logger logger \n Expression EXPRESSION \n Iterable<String> getSubPartitions \n boolean contentsHaveChangedSince \n String getName \n String getFullSchemaName \n Collection<Function> getFunctions \n void dropView \n Set<String> getTableNames \n Set<String> getSubSchemaNames \n Expression getExpression \n boolean isMutable \n Set<String> getFunctionNames \n Table getTable \n Schema getSubSchema \n Schema getDefaultSchema \n List<Pair<String,? extends Table>> getTablesByNames \n CreateTableEntry createNewTable \n String getTypeName \n boolean createView \n void close \n List<String> getSchemaPath \n boolean showInInformationSchema \n void dropTable", "output": "List < Pair < String , ? extends Table >> function ( final List < String > arg0 ) { return getTablesByNames ( arg0 ) ; }"}, {"instruction": "Generate java code\ncompare the two comparable comparable arguments.this method is equivalent to : comparable obj1 . compareto obj2 ", "input": " long serialVersionUID \n ComparableComparator instance \n int hashCode \n boolean equals \n ComparableComparator getInstance", "output": "int function ( Object arg0 , Object arg1 ) { return ( ( Comparable ) arg0 ) . compareTo ( arg1 ) ; }"}, {"instruction": "Generate java code\nexport objectid to plain byte array ", "input": " byte[] data \n int hashCode \n boolean equals \n boolean isValid \n String toString", "output": "byte [ ] function ( ) { byte [ ] loc0 = new byte [ 12 ] ; System . arraycopy ( data , 0 , loc0 , 0 , 12 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nsets the start point of the subpath . ", "input": " List<Shape> segments \n Point2D startPoint \n boolean closed \n Point2D getStartPoint \n boolean isSinglePointOpen \n void addSegment \n boolean isDegenerate \n boolean isClosed \n boolean isEmpty \n boolean isSinglePointClosed \n List<Point2D> getPiecewiseLinearApproximation \n Point2D getLastPoint \n void setClosed \n List<Shape> getSegments", "output": "void function ( float arg0 , float arg1 ) { this . startPoint = new Point2D . Float ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the top symbol from the stack . ", "input": " Symbol[] stack \n int pos \n ActionHandler symbolHandler \n Symbol popSymbol \n int depth \n void processImplicitActions \n void pushSymbol \n void reset \n void expandStack \n void processTrailingImplicitActions \n Symbol doAction \n void pushProduction \n Symbol advance", "output": "Symbol function ( ) { return stack [ pos - 1 ] ; }"}, {"instruction": "Generate java code\ngets a crl from a certificate ", "input": " PlaceHolder placeHolder \n String getOCSPURL \n String getCRLURL \n String getTSAURL \n String getStringFromGeneralName \n ASN1Primitive getExtensionValue", "output": "CRL function ( X509Certificate arg0 ) { return CertificateUtil . getCRL ( CertificateUtil . getCRLURL ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nget number . ", "input": " String LABEL_SUFFIX \n Joiner JOINER \n String ETAG \n String BODY_FORMAT \n String body \n String title \n Pattern BODY_PATTERN \n List<Label> labels \n String NEW_LINE \n int number \n Pattern ETAG_PATTERN \n Pattern LABEL_PATTERN \n Splitter SPLITTER \n String state \n Map<String,String> getRequestParams \n String getBody \n void readEtag \n Phenotype asPhenotype \n void setTitle \n void setBody \n void setNumber \n Phenotype.Status getPTStatus \n List<Label> getLabels \n String getState \n String getTitle \n void setState \n String describe \n String getIssueTitle \n void setLabels", "output": "int function ( ) { return number ; }"}, {"instruction": "Generate java code\nreturns the depth of the stack . ", "input": " Deque<Map<String,Object>> stack \n int INITIAL_MAP_CAPACITY \n void init \n Set<java.util.Map.Entry<String,Object>> entrySet \n boolean containsKey \n Collection<Object> values \n void clear \n boolean isEmpty \n void push \n boolean containsValue \n Object put \n Object remove \n void pop \n Map<String,Object> top \n int size \n int hashCode \n Object get \n void putAll \n boolean equals \n String toString \n Set<String> keySet", "output": "int function ( ) { return stack . size ( ) ; }"}, {"instruction": "Generate java code\nvalidates that the tags parent is set when adding it as a child ", "input": " PlaceHolder placeHolder \n void validateChildrenNotNull \n void compareFalse \n void compareFalseTagAndNS \n void validateAttributesNotNull \n void validateCssNotNull \n void compareTrueNS \n void validateChildNotSetOnSetParent \n void compareTrue \n void compareFalseNS", "output": "void function ( ) { Tag loc0 = new Tag ( \"srini_string\" ) ; Tag loc1 = new Tag ( \"srini_string\" ) ; loc0 . addChild ( loc1 ) ; Assert . assertEquals ( loc0 , loc1 . getParent ( ) ) ; }"}, {"instruction": "Generate java code\ncompares if the same failures occur ", "input": " Sequence sequenceToSimplify \n List<Integer> removed_indices \n ExecutableSequence eSeq \n MultiVisitor visitor \n List<Integer> compute_indices_in_original_sequence \n List<Check> getFailureChecks \n ExecutableSequence execute_sequence \n int compute_index_in_simplified_sequence \n List<Integer> getRemovedIndices \n int compute_index_in_original_sequence \n ExecutableSequence simplfy_sequence \n int getFailureIndex", "output": "boolean function ( List < Check > arg0 , List < Check > arg1 ) { return true ; }"}, {"instruction": "Generate java code\nreturns the singleton instance of this class . this method is useless for now as all methods are static . it may be used in future if vm-global configuration will be put to the state of the instance . # ", "input": " MathUtil instance \n void assertDouble \n Integer increment \n boolean assertEqual \n boolean isDouble", "output": "MathUtil function ( ) { if ( MathUtil . instance == null ) { MathUtil . instance = new MathUtil ( ) ; } return MathUtil . instance ; }"}, {"instruction": "Generate java code\nadds common classes to the given archive . ", "input": " String TESTOBJECTS_CONFIG \n String MED_EXAMPLE_POLICY_SET \n Logger LOGGER \n String SUBST_SUBJECT_ID \n String TESTOBJECTS_REQUESTS \n String TESTOBJECTS_POLICIES \n String MED_EXAMPLE_POLICY_SET2 \n void addXACMLPoliciesToArchive \n void addJBossDeploymentStructureToArchive", "output": "void function ( final ClassContainer < T > arg0 ) { LOGGER . debug ( \"srini_string\" ) ; arg0 . addClasses ( JBossPDPServiceBean . class , XACMLTestUtils . class ) ; }"}, {"instruction": "Generate java code\ncalculate the greatest common divisor . ", "input": " String PROMPT \n void main", "output": "int function ( int arg0 , int arg1 ) { if ( arg0 < 0 ) { arg0 = - arg0 ; } if ( arg1 < 0 ) { arg1 = - arg1 ; } while ( arg1 != 0 ) { int loc0 = arg0 % arg1 ; arg0 = arg1 ; arg1 = loc0 ; } return arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the iskeyoptional property . ", "input": " String validationPattern \n boolean isValueOptional \n boolean encrypted \n String machineInterpretationKey \n String displayName \n String defaultValue \n String technicalKey \n boolean isKeyOptional \n List<String> tags \n String exampleValue \n void setDefaultValue \n String getExampleValue \n List<String> getTags \n String getValidationPattern \n void setIsKeyOptional \n void setDisplayName \n void setMachineInterpretationKey \n void setExampleValue \n String getDefaultValue \n String getTechnicalKey \n void setEncrypted \n void setTechnicalKey \n String getDisplayName \n boolean isEncrypted \n String getMachineInterpretationKey \n void setValidationPattern \n boolean isIsValueOptional \n void setIsValueOptional", "output": "boolean function ( ) { return isKeyOptional ; }"}, {"instruction": "Generate java code\ncalled when an exception is caught in test execution . ", "input": " IExecutionMonitor monitor \n String DEFAULT_THREAD_NAME \n void runFinishing \n IExecutionMonitor getMonitor \n String getTestThreadName \n TestIdentifier getCurrentTest \n void waitUntilFinished \n void runStarting \n void exec \n void runFinished", "output": "void function ( Throwable arg0 ) { getMonitor ( ) . exceptionCaught ( arg0 ) ; }"}, {"instruction": "Generate java code\nempty the violations list . ", "input": " long numNormalPptExits \n long numEvaluations \n List<Throwable> internalInvariantEvaluationErrors \n long numPptEntries \n List<Violation> violations \n long numExceptionalPptExits \n boolean violationsEmpty \n void violationsAdd \n List<Violation> getViolations", "output": "void function ( ) { violations = new ArrayList < Violation > ( ) ; }"}, {"instruction": "Generate java code\nchildren should override this . the default implementation does nothing . ", "input": " IPropertyDescriptor[] EMPTY_ARRAY \n PropertyChangeSupport pcsDelegate \n long serialVersionUID \n void firePropertyChange \n Object getPropertyValue \n void setPropertyValue \n Object getEditableValue \n IPropertyDescriptor[] getPropertyDescriptors \n void addPropertyChangeListener \n boolean isPropertySet \n void removePropertyChangeListener \n void readObject", "output": "void function ( Object arg0 ) { }"}, {"instruction": "Generate java code\ncreate a join sequence rooted at the given collection . ", "input": " SessionFactoryImplementor sfi \n Map<String,PropertyMapping> collectionPropertyMappingByRole \n QueryableCollection getCollectionPersister \n Type getElementType \n JoinSequence createJoinSequence \n JoinSequence createJoinSequence \n Type findFunctionReturnType \n Type findFunctionReturnType \n PropertyMapping getCollectionPropertyMapping \n AssociationType getElementAssociationType \n String getImportedClassName \n SQLFunction requireSQLFunction \n SessionFactoryImplementor getFactory \n boolean hasPhysicalDiscriminatorColumn \n EntityPersister requireClassPersister \n QueryableCollection requireQueryableCollection \n String[] getCollectionElementColumns \n String[][] generateColumnNames \n String getIdentifierOrUniqueKeyPropertyName \n int getColumnSpan \n String getAssociatedEntityName \n Queryable findQueryableUsingImports \n Queryable findQueryableUsingImports \n boolean isStrictJPAQLComplianceEnabled \n EntityPersister findEntityPersisterByName \n SQLFunction findSQLFunction", "output": "JoinSequence function ( QueryableCollection arg0 , String arg1 ) { JoinSequence loc0 = createJoinSequence ( ) ; loc0 . setRoot ( arg0 , arg1 ) ; loc0 . setUseThetaStyle ( true ) ; return loc0 ; }"}, {"instruction": "Generate java code\nlocate a hibernate @linkplain basictype basic type given one of its registration names . ", "input": " TypeFactory typeFactory \n BasicTypeRegistry basicTypeRegistry \n void registerTypeOverride \n void registerTypeOverride \n void registerTypeOverride \n TypeFactory getTypeFactory \n TypeResolver scope \n Type heuristicType \n Type heuristicType", "output": "BasicType function ( String arg0 ) { return basicTypeRegistry . getRegisteredType ( arg0 ) ; }"}, {"instruction": "Generate java code\nstart synchronizing , calling delegate 's callback methods . ", "input": " SynchronizerDelegate synchronizerDelegate \n String configSyncID \n Repository repositoryA \n RepositorySessionBundle bundleB \n String LOG_TAG \n SynchronizerSession session \n RepositorySessionBundle bundleA \n Repository repositoryB \n void load \n SynchronizerSession getSynchronizerSession \n void onSynchronizeSkipped \n SynchronizerConfiguration save \n void onInitialized \n void onSynchronized \n SynchronizerSession newSynchronizerSession \n void onSynchronizeFailed", "output": "void function ( Context arg0 , SynchronizerDelegate arg1 ) { this . synchronizerDelegate = arg1 ; this . session = newSynchronizerSession ( ) ; this . session . init ( arg0 , bundleA , bundleB ) ; }"}, {"instruction": "Generate java code\ncreate a path string that identifies this tree item with respect to its parent 's e.g. `` java/project '' ", "input": " TreeItemSelector _selector \n TreeItemTester _treeItemTester \n TreeTester _treeTester \n Widget reveal \n Widget reveal \n Widget doClick \n TreeItem findNode", "output": "String function ( TreeItem arg0 ) { String loc0 = TextUtils . escapeSlashes ( arg0 . getText ( ) ) ; for ( TreeItem loc1 = arg0 . getParentItem ( ) ; loc1 != null ; loc1 = loc1 . getParentItem ( ) ) { loc0 = loc1 . getText ( ) + '/' + loc0 ; } return loc0 ; }"}, {"instruction": "Generate java code\nremoves the value at the top of this stack and returns it . ", "input": " ArrayFloatList list \n int search \n int size \n float get \n void clear \n float push \n boolean empty \n float peek \n float peek", "output": "float function ( ) { if ( list . isEmpty ( ) ) { throw new EmptyStackException ( ) ; } return list . removeElementAt ( list . size ( ) - 1 ) ; }"}, {"instruction": "Generate java code\nlength returns the length of this list . ", "input": " SListNode head \n int size \n SListNode tail \n Object nth \n void testAfterInsertEnd \n void testAfterInsertFront \n void insertEnd \n boolean isEmpty \n void insertFront \n String toString \n void main \n void testEmpty", "output": "int function ( ) { return size ; }"}, {"instruction": "Generate java code\ncreates a closure that will invoke a specific method on the closure 's input object by reflection . ", "input": " PlaceHolder placeHolder \n Closure nopClosure \n Closure switchClosure \n Closure switchClosure \n Closure switchClosure \n Closure chainedClosure \n Closure chainedClosure \n Closure chainedClosure \n Closure forClosure \n Closure ifClosure \n Closure whileClosure \n Closure doWhileClosure \n Closure switchMapClosure \n Closure asClosure \n Closure exceptionClosure", "output": "Closure function ( String arg0 , Class [ ] arg1 , Object [ ] arg2 ) { return asClosure ( InvokerTransformer . getInstance ( arg0 , arg1 , arg2 ) ) ; }"}, {"instruction": "Generate java code\ngets the field type at the specified index . ", "input": " PlaceHolder placeHolder \n int size \n int[] getValues \n int hashCode \n int get \n boolean equals \n Period toPeriod \n MutablePeriod toMutablePeriod \n String toString \n String toString \n boolean isSupported \n int indexOf \n DurationFieldType[] getFieldTypes", "output": "DurationFieldType function ( int arg0 ) { return getPeriodType ( ) . getFieldType ( arg0 ) ; }"}, {"instruction": "Generate java code\ngetter for the cell width ", "input": " boolean percentage \n float width \n PdfPCell cell \n boolean add \n boolean process \n PdfPCell getCell \n boolean isContent \n boolean isNestable \n PdfPCell createPdfPCell \n List<Chunk> getChunks \n boolean isPercentage \n int type", "output": "float function ( ) { return width ; }"}, {"instruction": "Generate java code\nsets the current attribute value and adds the attribute if it 's not null to the attribute map . ", "input": " StringBuilder currentEntity \n StringBuilder comment \n String currentTag \n boolean isHtml \n String currentAttr \n char lastChar \n String wsTag \n String storedString \n Map<String,String> attr \n String currentNameSpace \n StringBuilder baos \n StringBuilder currentEntity \n Map<String,String> getAttributes \n void currentAttr \n boolean hasCurrentAttribute \n String getNameSpace \n String whitespaceTag \n void whitespaceTag \n void flushNameSpace \n void setStoredString \n String getCurrentTag \n StringBuilder current \n void currentTag \n void resetBuffer \n void lastChar \n char lastChar \n void namespace \n String getStoredString \n StringBuilder comment", "output": "void function ( final String arg0 ) { if ( null != this . currentAttr ) { if ( isHtml ) { attr . put ( this . currentAttr . toLowerCase ( ) , arg0 ) ; } else { attr . put ( this . currentAttr , arg0 ) ; } this . currentAttr = null ; } }"}, {"instruction": "Generate java code\ncreate an iterator iterator wrappingthe specified floatiterator floatiterator . when the given iterator is null , returns null . ", "input": " FloatIterator _iterator \n Object next \n boolean hasNext \n void remove", "output": "Iterator function ( FloatIterator arg0 ) { return null == arg0 ? null : new FloatIteratorIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the basic block in which this node resides . ", "input": " Node parent \n int valueNumber \n int key \n Node parent \n int valueNumber \n Node copyInto \n void setValueNumber \n void visitChildren \n void cleanupOnly \n void visitForceChildren \n void cleanup \n String toString \n void visit \n void setParent \n int key \n void setKey \n void visitOnly \n boolean hasParent \n void replaceWith \n void replaceWith", "output": "Block function ( ) { Node loc0 = this ; while ( loc0 != null ) { if ( loc0 instanceof Tree ) { return ( ( Tree ) loc0 ) . block ( ) ; } loc0 = loc0 . parent ; } throw new RuntimeException ( this + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nverifies if the class of the elements returned by orderedunorderedlistitem #end is a listitem . ", "input": " List<Element> currentContent \n OrderedUnorderedListItem li \n WorkerContextImpl workerContextImpl \n void init \n void verifyContent \n void verifyIfStackOwner", "output": "void function ( ) { final List < Element > loc0 = li . end ( workerContextImpl , new Tag ( \"srini_string\" ) , currentContent ) ; Assert . assertTrue ( loc0 . get ( 0 ) instanceof ListItem ) ; }"}, {"instruction": "Generate java code\nprior to 1.4.1 , hierarchy events are only sent if listeners are added to a given component . ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean hasMultiClickFrameBug \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . JAVA_VERSION < Platform . JAVA_1_4 ; }"}, {"instruction": "Generate java code\nreturns a string represntation of this stack . ", "input": " ArrayList stack \n int height \n Expr pop \n void set \n Expr pop1 \n int size \n Expr[] pop2 \n Expr get \n boolean isEmpty \n void replace \n void push \n Expr peek \n Expr peek \n int height", "output": "String function ( ) { return stack . toString ( ) ; }"}, {"instruction": "Generate java code\nthe default action executed from the visit methods . this returns the default value provided at the construction time . ", "input": " R defaultValue \n R visitMetricType \n R visitMetricType \n R visitRelationship \n R visitRelationship \n R visitMetadataPack \n R visitMetadataPack \n R visitData \n R visitData \n R visitResourceType \n R visitResourceType \n R visitTenant \n R visitTenant \n R visitUnknown \n R visitUnknown \n R visitEnvironment \n R visitEnvironment \n R visitMetric \n R visitMetric \n R visitResource \n R visitResource \n R visitFeed \n R visitFeed \n R visitOperationType \n R visitOperationType", "output": "R function ( ) { return defaultValue ; }"}, {"instruction": "Generate java code\nchecks if two subsequent characters in a string are are the higher and the lower character in a surrogate pair and therefore eligible for conversion to a utf 32 character . ", "input": " PlaceHolder placeHolder \n String unEscapeURL \n URL toURL \n char[] copyOfRange \n float inchesToPoints \n void skip \n float pointsToMillimeters \n Set<K> getKeySet \n boolean isSurrogateHigh \n float millimetersToInches \n String convertFromUtf32 \n int convertToUtf32 \n int convertToUtf32 \n int convertToUtf32 \n float millimetersToPoints \n float inchesToMillimeters \n String readFileToString \n String readFileToString \n float pointsToInches \n String convertToHex \n boolean checkTrueOrFalse \n boolean isSurrogateLow \n Object[][] addToArray", "output": "boolean function ( final String arg0 , final int arg1 ) { if ( arg1 < 0 || arg1 > arg0 . length ( ) - 2 ) return false ; return isSurrogateHigh ( arg0 . charAt ( arg1 ) ) && isSurrogateLow ( arg0 . charAt ( arg1 + 1 ) ) ; }"}, {"instruction": "Generate java code\nwrites the text to the given file , overwriting the previous file if it existed . ", "input": " Logger LOG \n int BUFFER_SIZE \n String readFully \n String readFully \n int copy \n int copy \n void copy \n void close", "output": "void function ( File arg0 , String arg1 ) { write ( arg0 , arg1 , false ) ; }"}, {"instruction": "Generate java code\nreturns the `` caller block '' for a given `` return block '' . ", "input": " Block entry \n Block exit \n ArrayList paths \n FlowGraph graph \n LocalVariable returnAddress \n void setReturnAddress \n int numPaths \n void setExit \n FlowGraph graph \n void addPath \n LocalVariable returnAddress \n void removePathsContaining \n void removePath \n Block entry \n Block exit \n void print \n Block pathTarget \n Collection paths \n String toString \n void removeAllPaths \n void setEntry", "output": "Block function ( final Block arg0 ) { for ( int loc0 = 0 ; loc0 < paths . size ( ) ; loc0 ++ ) { final Block [ ] loc1 = ( Block [ ] ) paths . get ( loc0 ) ; if ( loc1 [ 1 ] == arg0 ) { return loc1 [ 0 ] ; } } return null ; }"}, {"instruction": "Generate java code\ncomparison with any other object . ", "input": " java.math.BigDecimal val \n int DEFAULT_PRECISION \n BigDecimal ZERO \n MathContext DEFAULT_CONTEXT \n MathContext context \n BigDecimal ONE \n Random random \n boolean isField \n boolean isCommutative \n BigDecimal gcd \n BigDecimal sum \n int compareTo \n java.math.BigInteger characteristic \n BigDecimal random \n BigDecimal random \n BigDecimal random \n BigDecimal random \n int hashCode \n BigDecimal divide \n BigDecimal copy \n BigDecimal multiply \n int signum \n boolean isONE \n BigDecimal inverse \n BigDecimal valueOf \n BigDecimal valueOf \n boolean isUnit \n BigDecimal subtract \n BigDecimal parse \n BigDecimal parse \n BigDecimal[] egcd \n BigDecimal abs \n BigDecimal[] divideAndRemainder \n BigDecimal negate \n BigDecimal clone \n BigDecimal getONE \n BigDecimal getZERO \n BigDecimal fromInteger \n BigDecimal fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigDecimal remainder", "output": "boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof BigDecimal ) ) { return false ; } BigDecimal loc0 = ( BigDecimal ) arg0 ; return val . equals ( loc0 . val ) ; }"}, {"instruction": "Generate java code\ncomputes the bounding rectangle for this line segment . the rectangle has a rotation 0 degrees with respect to the coordinate system that the line system is in . for example , if a line segment is 5 unit long and sits at a 37 degree angle from horizontal , the bounding rectangle will have origin of the lower left hand end point of the segment , with width = 4 and height = 3 . ", "input": " Vector endPoint \n Vector startPoint \n Vector getStartPoint \n LineSegment transformBy \n Vector getEndPoint \n float getLength", "output": "Rectangle2D . Float function ( ) { float loc0 = getStartPoint ( ) . get ( Vector . I1 ) ; float loc1 = getStartPoint ( ) . get ( Vector . I2 ) ; float loc2 = getEndPoint ( ) . get ( Vector . I1 ) ; float loc3 = getEndPoint ( ) . get ( Vector . I2 ) ; return new Rectangle2D . Float ( Math . min ( loc0 , loc2 ) , Math . min ( loc1 , loc3 ) , Math . abs ( loc2 - loc0 ) , Math . abs ( loc3 - loc1 ) ) ; }"}, {"instruction": "Generate java code\nreturns true , if the timespan of the interpolator has elapsed since initialize was called . ", "input": " float endValue \n long startTime \n float startValue \n long timespan \n boolean isFinished \n boolean replaces \n void setTimespan \n void update \n void interpolate \n void finish \n void initialize \n boolean isFinished \n boolean isSequential \n float getFraction", "output": "boolean function ( long arg0 ) { return timespan <= arg0 - startTime ; }"}, {"instruction": "Generate java code\ngets the value of the properties property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the properties property . for example , to add a new item , do as follows : getproperties . add newitem ; objects of the following type s are allowed in the list propertydeclaration ", "input": " List<ProvidedPort> providedPorts \n List<ConsumedPort> consumedPorts \n List<PropertyDeclaration> properties \n List<ConsumedPort> getConsumedPorts \n List<ProvidedPort> getProvidedPorts", "output": "List < PropertyDeclaration > function ( ) { if ( properties == null ) { properties = new ArrayList < PropertyDeclaration > ( ) ; } return this . properties ; }"}, {"instruction": "Generate java code\ncreate an intlistiterator intlistiterator wrappingthe specified listiterator listiterator . when the given iterator is null , returns null . ", "input": " ListIterator _iterator \n int next \n void add \n void set \n int previous \n boolean hasPrevious \n boolean hasNext \n int nextIndex \n int previousIndex \n void remove", "output": "IntListIterator function ( ListIterator arg0 ) { return null == arg0 ? null : new ListIteratorIntListIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\ncreate an bytelistiterator bytelistiterator wrappingthe specified listiterator listiterator . when the given iterator is null , returns null . ", "input": " ListIterator _iterator \n byte next \n void add \n void set \n byte previous \n boolean hasPrevious \n boolean hasNext \n int nextIndex \n int previousIndex \n void remove", "output": "ByteListIterator function ( ListIterator arg0 ) { return null == arg0 ? null : new ListIteratorByteListIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns true if any child iterator has remaining elements . ", "input": " int lastReturned \n Comparator comparator \n ArrayList values \n BitSet valueSet \n ArrayList iterators \n Object next \n boolean set \n Comparator getComparator \n void addIterator \n boolean anyValueSet \n void start \n void clear \n int least \n boolean anyHasNext \n void remove \n void setComparator \n List getIterators \n void setIterator \n void checkNotStarted", "output": "boolean function ( ) { start ( ) ; return anyValueSet ( valueSet ) || anyHasNext ( iterators ) ; }"}, {"instruction": "Generate java code\nreturns the result of rotating this vector around a freely chosen axis and origin ", "input": " VectorXYZ NULL_VECTOR \n double x \n double y \n VectorXYZ X_UNIT \n double z \n VectorXYZ Z_UNIT \n VectorXYZ Y_UNIT \n VectorXZ xz \n VectorXYZ mult \n AxisAlignedBoundingBoxXZ getAxisAlignedBoundingBoxXZ \n double dot \n double distanceToXZ \n double distanceToXZ \n int hashCode \n VectorXYZ normalize \n VectorXYZ xyz \n VectorXYZ rotateX \n VectorXYZ rotateY \n VectorXYZ rotateZ \n VectorXYZ add \n VectorXYZ add \n VectorXYZ add \n double angleTo \n double lengthSquared \n VectorXYZ invert \n double distanceToSquared \n List<VectorXYZ> addYList \n VectorXYZ subtract \n VectorXYZ subtract \n double length \n VectorXYZ cross \n VectorXYZ crossNormalized \n double distanceTo \n double getX \n double getY \n double getZ \n VectorXYZ addY \n boolean equals \n VectorXYZ x \n VectorXYZ y \n String toString \n VectorXYZ z", "output": "VectorXYZ function ( double arg0 , VectorXYZ arg1 , VectorXYZ arg2 ) { VectorXYZ loc0 = this . subtract ( arg1 ) ; loc0 = loc0 . rotateVec ( arg0 , arg2 ) ; loc0 = loc0 . add ( arg1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nstarts the clock . does nothing if the clock is already started . ", "input": " long deltaUs \n long positionUs \n boolean started \n long elapsedRealtimeMinus \n void stop \n long getPositionUs \n void setPositionUs", "output": "void function ( ) { if ( ! started ) { started = true ; deltaUs = elapsedRealtimeMinus ( positionUs ) ; } }"}, {"instruction": "Generate java code\nreturn the relevant classloader to use as a map key for this request . if there is a thread context class loader , return that ; otherwise , return the class loader that loaded this class . ", "input": " Log log \n String DELIMITER \n Map factories \n void addCatalog \n Command getCommand \n void clear \n void setCatalog \n Iterator getNames \n CatalogFactory getInstance \n Catalog getCatalog \n Catalog getCatalog", "output": "ClassLoader function ( ) { ClassLoader loc0 = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loc0 == null ) { loc0 = CatalogFactory . class . getClassLoader ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsets the bookmarks . the list structure is defined in simplebookmark # . ", "input": " PdfCopyFieldsImp fc \n void setViewerPreferences \n void addJavaScript \n void addViewerPreference \n void addDocument \n void addDocument \n void addDocument \n PdfWriter getWriter \n boolean isFullCompression \n void setEncryption \n void setEncryption \n void setEncryption \n void setEncryption \n void setFullCompression \n void close \n void open", "output": "void function ( List < HashMap < String , Object >> arg0 ) { fc . setOutlines ( arg0 ) ; }"}, {"instruction": "Generate java code\nasserts that any string parameter is set . ", "input": " PlaceHolder placeHolder \n void assertSchemaNS \n void assertPrefix \n void assertSpecificLang \n void assertPropName \n void assertArrayName \n void assertStructName \n void assertImplementation", "output": "void function ( Object arg0 ) { if ( arg0 == null ) { throw new XMPException ( \"srini_string\" , XMPError . BADPARAM ) ; } else if ( ( arg0 instanceof String ) && ( ( String ) arg0 ) . length ( ) == 0 ) { throw new XMPException ( \"srini_string\" , XMPError . BADPARAM ) ; } }"}, {"instruction": "Generate java code\ninvokes the underlying listiterator #add object method . ", "input": " ListIterator iterator \n Object next \n void set \n Object previous \n boolean hasPrevious \n boolean hasNext \n ListIterator getListIterator \n int nextIndex \n int previousIndex \n void remove \n void setListIterator", "output": "void function ( Object arg0 ) { getListIterator ( ) . add ( arg0 ) ; }"}, {"instruction": "Generate java code\ntransfers from right to left ", "input": " PlaceHolder placeHolder \n void swap \n void swap", "output": "T [ ] function ( T [ ] arg0 , T [ ] arg1 , int arg2 , boolean arg3 ) { return ArrayTool . transferValues ( arg0 , arg1 , arg2 , arg1 . length , arg3 ) ; }"}, {"instruction": "Generate java code\nupdate entity inside transaction . ", "input": " Object LOCK \n OpenHelper helper \n Map<Class<?>,AbstractModel<?>> modelMap \n Orm orm \n T loadById \n AbstractModel<T> getRepository \n long insert \n boolean update \n boolean delete \n long[] insertInTx \n long[] insertInTx \n long insertInTx \n T rawQuerySingle \n T rawQuerySingle \n int deleteById \n AbstractModel<T> getModelInstanceOrThrow \n Orm getInstance \n int deleteByIdInTx \n int deleteInTx \n int deleteInTx \n boolean deleteInTx \n List<T> rawQuery \n List<T> rawQuery", "output": "boolean function ( @ NonNull Class < T > arg0 , T arg1 ) { AbstractModel < T > loc0 = getModelInstanceOrThrow ( arg0 ) ; return loc0 . updateInTx ( helper . getWritableDatabase ( ) , arg1 ) ; }"}, {"instruction": "Generate java code\nliefert den player ", "input": " JComponent vis_component \n Visualization visualization_api \n UIMainWindow ui \n EventTimeline timeline \n VisDataModel model \n Player player \n void connectModelToUI \n void init \n VisDataModel getModel \n void loadModelBackend \n void deinit \n EventTimeline getTimeline \n void resetView \n void loadModelFrontend \n UIMainWindow getUIMainWindow \n Visualization getVisApi", "output": "Player function ( ) { return player ; }"}, {"instruction": "Generate java code\nhas the iterator any more elements . returns false only if the collection originally had zero elements , or all the elements have been #remove removed . ", "input": " Iterator iterator \n Collection collection \n Object next \n int size \n void reset \n void remove", "output": "boolean function ( ) { return ( collection . size ( ) > 0 ) ; }"}, {"instruction": "Generate java code\nsets the value of iterations ", "input": " long theirs \n long ours \n String description \n int iterations \n int getIterations \n void setOurs \n long getOurAvg \n String toString \n void setDescription \n void setTheirs \n long getTheirs \n String getDescription \n long getOurs \n long getTheirAvg", "output": "void function ( int arg0 ) { this . iterations = arg0 ; }"}, {"instruction": "Generate java code\nthis method returns the number of clauses , of which a query currently consists . ", "input": " int solvedAddend \n SkyNetNodeInfo queryOriginator \n Vector<QueryAddend> addends \n float answerQuality \n int hops \n int queryID \n long timestamp \n String queryType \n void insertAddend \n int getIndexOfSolvedAddend \n int getHops \n void setAnswerQuality \n float getAnswerQuality \n void setHops \n SkyNetNodeInfo getQueryOriginator \n void setQueryID \n void setQueryType \n Vector<QueryAddend> getAllAddends \n long getSize \n int getQueryID \n void addAddend \n long getTimestamp \n String getQueryType \n Query clone \n String toString \n void setAllAddends \n void setSolvedAddend \n QueryAddend removeAddend \n QueryAddend getAddend \n void setTimestamp \n void incrementHops", "output": "int function ( ) { return addends . size ( ) ; }"}, {"instruction": "Generate java code\nsets the number of hosts that take part in the overlay network . if not set , the default value of 1 host is assumed . has to be set before analysis is started and will be ignored else . ", "input": " Logger log \n double numHosts \n boolean started \n Map<Long,Long> sentMaintenance \n Map<Long,Long> sentUser \n void writeTraffic \n void stop \n void start \n void transMsgSent \n void messageSent \n void transMsgReceived", "output": "void function ( final int arg0 ) { if ( ! started ) { numHosts = arg0 ; } }"}, {"instruction": "Generate java code\nreturn the remote protocol . accesses a threadlocal that 's setaround calls to #respond protocol.message , object . ", "input": " Map<MD5,Protocol> protocols \n Logger LOG \n GenericDatumReader<Map<String,ByteBuffer>> META_READER \n List<RPCPlugin> rpcMetaPlugins \n Schema META \n ThreadLocal<Protocol> REMOTE \n SpecificDatumWriter<HandshakeResponse> handshakeWriter \n SpecificDatumReader<HandshakeRequest> handshakeReader \n MD5 localHash \n Protocol local \n GenericDatumWriter<Map<String,ByteBuffer>> META_WRITER \n Protocol handshake \n Object readRequest \n Protocol getLocal \n void writeResponse \n void addRPCPlugin \n List<ByteBuffer> respond \n List<ByteBuffer> respond \n Object respond \n void writeError", "output": "Protocol function ( ) { return REMOTE . get ( ) ; }"}, {"instruction": "Generate java code\nif the child of a structured element is an array , we need to loop over the elements . ", "input": " PdfReader reader \n PrintWriter out \n String xmlName \n void convertToXml \n void convertToXml \n String fixTagName \n void inspectChildDictionary \n void inspectChildDictionary \n void inspectChild \n void parseTag", "output": "void function ( PdfArray arg0 ) { if ( arg0 == null ) return ; for ( int loc0 = 0 ; loc0 < arg0 . size ( ) ; loc0 ++ ) { inspectChild ( arg0 . getDirectObject ( loc0 ) ) ; } }"}, {"instruction": "Generate java code\ncreates a new branch object . ", "input": " int branchNumber \n Map<Branch,Branch> savedBranchInfos \n String methodName \n String className \n int lineNumber \n long serialVersionUID \n boolean branch \n int getLineNumber \n void writeToFile \n String getMethodName \n Set<Branch> readFromFile \n int hashCode \n boolean equals \n Branch getOppositeBranch \n List<Pair<String,String>> readKeyValuePairs \n String toString \n String getClassName \n Branch parse", "output": "Branch function ( String arg0 , String arg1 , int arg2 , int arg3 , boolean arg4 ) { Branch loc0 = new Branch ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; Branch loc1 = savedBranchInfos . get ( loc0 ) ; if ( loc1 == null ) { savedBranchInfos . put ( loc0 , loc0 ) ; loc1 = loc0 ; } return loc1 ; }"}, {"instruction": "Generate java code\nresolve a constant to its actual value . ", "input": " PropertyAccessor DIRECT_PROPERTY_ACCESSOR \n Method OBJECT_EQUALS \n Class[] SINGLE_OBJECT_PARAM_SIGNATURE \n Object[] NO_PARAMS \n Method OBJECT_HASHCODE \n Class[] NO_PARAM_SIGNATURE \n PropertyAccessor BASIC_PROPERTY_ACCESSOR \n boolean overridesHashCode \n Getter getGetter \n Getter getter \n boolean isFinalClass \n boolean overridesEquals \n Method getMethod \n Class classForName \n Class classForName \n Constructor getConstructor \n boolean implementsInterface \n Constructor<T> getDefaultConstructor \n Method extractHashCodeMethod \n Method extractEqualsMethod \n boolean isPublic \n boolean isPublic \n Class reflectedPropertyClass \n Class reflectedPropertyClass \n boolean isAbstractClass", "output": "Object function ( String arg0 ) { Class loc0 ; try { loc0 = classForName ( StringHelper . qualifier ( arg0 ) ) ; } catch ( Throwable loc1 ) { return null ; } try { return loc0 . getField ( StringHelper . unqualify ( arg0 ) ) . get ( null ) ; } catch ( Throwable loc1 ) { return null ; } }"}, {"instruction": "Generate java code\ncauses the currently executing thread to sleep temporarily cease execution for the specified number of milliseconds . the thread does not lose ownership of any monitors . if trace messages associated with the given trace option have been enabled , log the start and end of the sleep cycle along with thread information . if trace options are not enabled , then just sleep . ", "input": " PrintWriter sysOut \n ILog log \n boolean isDebugging \n void setLog \n boolean isDebugging \n void trace \n void trace \n void setDebugging \n boolean isTracing \n void close", "output": "void function ( long arg0 , String arg1 , String arg2 ) { trace ( arg1 , arg2 , \"srini_string\" + arg0 ) ; try { Thread . sleep ( arg0 ) ; } catch ( InterruptedException loc0 ) { } trace ( arg1 , arg2 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the type of the message back . ", "input": " MSG_TYPE msgType \n long getSize \n boolean equals", "output": "MSG_TYPE function ( ) { return this . msgType ; }"}, {"instruction": "Generate java code\norg.jboss.as.weld.deployment.processors.welddeploymentprocessor assembles a basic accessibility graph based onthe deployment structure . here , we complete the graph by examining classloader visibility . this allows additional accessibility edges caused e.g. by the class-path declaration in the manifest file , to be recognized . ", "input": " Set<Metadata<Extension>> extensions \n Map<ClassLoader,BeanDeploymentArchiveImpl> additionalBeanDeploymentArchivesByClassloader \n ServiceRegistry serviceRegistry \n BeanDeploymentArchiveImpl bootstrapClassLoaderBeanDeploymentArchive \n Map<ModuleIdentifier,EEModuleDescriptor> eeModuleDescriptors \n String ADDITIONAL_CLASSES_BDA_SUFFIX \n Module module \n Set<BeanDeploymentArchiveImpl> beanDeploymentArchives \n BeanDeploymentModule rootBeanDeploymentModule \n String BOOTSTRAP_CLASSLOADER_BDA_ID \n Set<ClassLoader> subDeploymentClassLoaders \n Collection<BeanDeploymentArchive> getBeanDeploymentArchives \n Module getModule \n Set<ClassLoader> getSubDeploymentClassLoaders \n void addWeldService \n BeanDeploymentArchiveImpl createAndRegisterAdditionalBeanDeploymentArchive \n BeanDeploymentArchive getBeanDeploymentArchive \n void makeTopLevelBdasVisibleFromStaticModules \n ServiceRegistry getServices \n Iterable<Metadata<Extension>> getExtensions \n BeanDeploymentArchive loadBeanDeploymentArchive", "output": "void function ( Iterable < BeanDeploymentArchiveImpl > arg0 ) { for ( BeanDeploymentArchiveImpl loc0 : arg0 ) { for ( BeanDeploymentArchiveImpl loc1 : arg0 ) { if ( loc0 . isAccessible ( loc1 ) ) { loc0 . addBeanDeploymentArchive ( loc1 ) ; } } } }"}, {"instruction": "Generate java code\ncalled by the default implementation of #writemap to get the sizeof a map . the default implementation is for map . ", "input": " GenericData data \n Schema root \n NullPointerException npe \n void writeWithoutConversion \n Iterator<? extends Object> getArrayElements \n void writeFixed \n void writeEnum \n Object convert \n void writeField \n void error \n void writeMap \n void setSchema \n void writeRecord \n void writeBytes \n void writeArray \n Iterable<Map.Entry<Object,Object>> getMapEntries \n int resolveUnion \n long getArraySize \n void write \n void write \n void writeString \n void writeString \n GenericData getData", "output": "int function ( Object arg0 ) { return ( ( Map ) arg0 ) . size ( ) ; }"}, {"instruction": "Generate java code\nsorts source and adds the first n entries that match filter to dest . if source contains less than n entries , all of them are added to dest . for details , see collectionhelpers #copynsorted collection , collection , comparator , int , except that source is filtered using filter before selecting entries to copy . ", "input": " PlaceHolder placeHolder \n void filter \n void filterMap \n void copyNSorted \n double getQuantile \n void splitMap \n List<T> getRandomPartFrom \n E getRandomEntry \n E getRandomEntry \n void copyUntilFull \n List<Tt> transformList", "output": "void function ( final Collection < T > arg0 , final Collection < T > arg1 , final Predicate < T > arg2 , final Comparator < T > arg3 , final int arg4 ) { final List < T > loc0 = new ArrayList < T > ( arg0 . size ( ) ) ; arg2 ( arg0 , loc0 , arg2 ) ; Collections . sort ( loc0 , arg3 ) ; final Iterator < T > loc1 = loc0 . iterator ( ) ; final int loc2 = arg1 . size ( ) + arg4 ; while ( loc1 . hasNext ( ) && arg1 . size ( ) < loc2 ) { arg1 . add ( loc1 . next ( ) ) ; } }"}, {"instruction": "Generate java code\nreturns an array of string objects . the array represents the names of the columns arranged in the same order as in the getrowsbyindex method . ", "input": " boolean isLimited \n String[] columnNames \n List rowMap \n List rowByIndex \n int getRowCount \n Object[][] getRowsByIndex \n boolean isLimitedByMaxRows \n SortedMap[] getRows", "output": "String [ ] function ( ) { return columnNames ; }"}, {"instruction": "Generate java code\ninformation supplied to enable the matching of an entry with the items that the transfer is intended to settle , such as commercial invoices in an accounts ' receivable system max length : 140 ", "input": " Pattern bicRegex \n PartyIdentification32 createIdParty \n PaymentIdentification1 createPaymentIdentification \n void checkMax70Text \n PartyIdentification32 createParty \n PartyIdentification32 createParty \n RemittanceInformation5 createRmtInf_struct \n void checkMax140Text \n XMLGregorianCalendar createXMLGregorianCalendarDate \n BranchAndFinancialInstitutionIdentification4 createFinInstnId \n XMLGregorianCalendar createXMLGregorianCalendar \n CashAccount16 createAccount \n CashAccount16 createAccount \n ActiveOrHistoricCurrencyAndAmount createAmount \n void checkMax35Text", "output": "RemittanceInformation5 function ( String arg0 ) { checkMax140Text ( arg0 ) ; RemittanceInformation5 loc0 = new RemittanceInformation5 ( ) ; loc0 . getUstrd ( ) . add ( arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nget the number of required pairs removed from the pairlist . ", "input": " ArrayList<GenPolynomial<C>> P \n ArrayList<BitSet> red \n boolean useCriterion4 \n int putCount \n Logger logger \n GenPolynomialRing<C> ring \n boolean oneInGB \n int remCount \n int moduleVars \n Reduction<C> reduction \n TreeMap<ExpVector,LinkedList<Pair<C>>> pairlist \n int putOne \n int putCount \n ArrayList<GenPolynomial<C>> getList \n boolean hasNext \n boolean criterion3 \n int put \n Pair<C> removeNext", "output": "int function ( ) { return remCount ; }"}, {"instruction": "Generate java code\nget the flag to know the character should have a space . ", "input": " boolean needAfterSpace \n SymbolType name \n long serialVersionUID \n char[] invalidChars \n boolean needBeforeSpace \n char value \n char getValue \n boolean isNeedAfterSpace \n char[] getInvalidChars \n SymbolType getType \n int hashCode \n boolean equals \n String toString", "output": "boolean function ( ) { return needBeforeSpace ; }"}, {"instruction": "Generate java code\nreturns the evaluation listeners registered in this configuration ", "input": " JsonProvider jsonProvider \n Collection<EvaluationListener> evaluationListener \n Collection<EvaluationListener> evaluationListeners \n EnumSet<Option> options \n Set<Option> options \n MappingProvider mappingProvider \n Defaults DEFAULTS \n Configuration addEvaluationListeners \n Configuration setEvaluationListeners \n ConfigurationBuilder evaluationListener \n ConfigurationBuilder evaluationListener \n void setDefaults \n Configuration defaultConfiguration \n Configuration jsonProvider \n JsonProvider jsonProvider \n ConfigurationBuilder jsonProvider \n JsonProvider jsonProvider \n Defaults getEffectiveDefaults \n Configuration build \n ConfigurationBuilder builder \n ConfigurationBuilder options \n ConfigurationBuilder options \n Set<Option> options \n Configuration setOptions \n boolean containsOption \n Set<Option> getOptions \n Configuration mappingProvider \n MappingProvider mappingProvider \n ConfigurationBuilder mappingProvider \n MappingProvider mappingProvider \n Configuration addOptions", "output": "Collection < EvaluationListener > function ( ) { return evaluationListeners ; }"}, {"instruction": "Generate java code\nbuilds a jmx compositedata view of our state ", "input": " OpenType[] ITEM_TYPES \n long updateCount \n long fetchCount \n String TABULAR_TYPE_NAME \n String COMPOSITE_TYPE_NAME \n CompositeType COMPOSITE_TYPE \n long loadCount \n String[] ITEM_NAMES \n long recreateCount \n String roleName \n String[] ITEM_DESCRIPTIONS \n String[] INDEX_NAMES \n String COMPOSITE_TYPE_DESCRIPTION \n String TABULAR_TYPE_DESCRIPTION \n String shortName \n TabularType TABULAR_TYPE \n long removeCount \n void add \n String getRoleName \n TabularData newTabularDataInstance \n CollectionStats[] fromTabularData \n long getLoadCount \n String getShortName \n String toString \n long getFetchCount \n long getUpdateCount \n long getRecreateCount \n long getRemoveCount", "output": "CompositeData function ( ) { try { return new CompositeDataSupport ( COMPOSITE_TYPE , ITEM_NAMES , new Object [ ] { roleName , shortName , loadCount , fetchCount , updateCount , removeCount , recreateCount } ) ; } catch ( OpenDataException loc0 ) { throw new RuntimeException ( loc0 ) ; } }"}, {"instruction": "Generate java code\nappend listelement . ", "input": " List<ListElement> listElements \n List<ListElement> getListElements \n ListElement getListElement \n int getNumberOfListElements", "output": "void function ( int arg0 , List < Sentence > arg1 ) { listElements . add ( new ListElement ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nsetup for connection success scenario . ", "input": " String DB_URL \n DbCustomerDao dao \n Customer existingCustomer \n String EXCEPTION_CAUSE \n ExpectedException exception \n void addingShouldResultInSuccess \n void deletionShouldBeFailureAndNotAffectExistingCustomers \n void retrievingAllCustomersFailsWithExceptionAsFeedbackToClient \n void updatingACustomerFailsWithFeedbackToTheClient \n void retrieveShouldReturnNoCustomer \n void createSchema \n void updationShouldBeFailureAndNotAffectExistingCustomers \n void deletionShouldBeSuccessAndCustomerShouldBeNonAccessible \n void addingShouldResultInFailureAndNotAffectExistingCustomers \n void deleteSchema \n void assertCustomerCountIs \n void addingACustomerFailsWithExceptionAsFeedbackToClient \n DataSource mockedDatasource \n void updationShouldBeSuccessAndAccessingTheSameCustomerShouldReturnUpdatedInformation \n void retrievingACustomerByIdFailsWithExceptionAsFeedbackToClient \n int getNonExistingCustomerId \n void deletingACustomerFailsWithExceptionAsFeedbackToTheClient", "output": "void function ( ) { JdbcDataSource loc0 = new JdbcDataSource ( ) ; loc0 . setURL ( DB_URL ) ; dao = new DbCustomerDao ( loc0 ) ; boolean loc1 = dao . add ( existingCustomer ) ; assertTrue ( loc1 ) ; }"}, {"instruction": "Generate java code\nassert that the actual collection contains the expected elements but may contain more . ", "input": " PlaceHolder placeHolder \n int testContains \n int testContains \n boolean testContains \n void fail \n void assertContainsOnly \n void assertContainsOnly \n void assertContainsOnly \n void assertContainsOnly \n boolean testContainsOnly \n boolean testContainsOnly", "output": "void function ( Object [ ] arg0 , Collection < Object > arg1 ) { int loc0 = testContains ( arg0 , arg1 ) ; if ( loc0 != - 1 ) fail ( \"srini_string\" + arg0 [ loc0 ] , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngets items from the stack where the index is zero based and the top of the stack is at an index of size -1 with the bottom of the stack at an index of 0 . ", "input": " ArrayDoubleList list \n double pop \n int search \n int size \n void clear \n double push \n boolean empty \n double peek \n double peek", "output": "double function ( int arg0 ) { return list . get ( arg0 ) ; }"}, {"instruction": "Generate java code\ncardinality of property ", "input": " boolean isTesting \n String typeName \n Clob propertyValue \n Clob exampleValue \n boolean isEncrypted \n String propContName \n Integer descriptorId \n String typeContName \n Integer typeId \n Clob defaultValue \n String resourceName \n String fcExternalKey \n String technicalKey \n String mik \n Integer propContextId \n String origin \n Integer cardinalityProperty \n Integer propertyValueTypeId \n String displayName \n String fcOwner \n Integer propertyId \n Integer masterTypeId \n boolean isNullable \n String fcExternalLink \n String validationRegex \n String loadedFor \n boolean isOptional \n String validationLogic \n String descriptorOrigin \n Integer typeContextId \n Clob propertyComment \n ResourceEditPropertyBuilder withDisplayAndTechKeyName \n ResourceEditPropertyBuilder withOrigin \n ResourceEditPropertyBuilder withValidationRegex \n ResourceEditPropertyBuilder withIsEncrypted \n ResourceEditPropertyBuilder withDescriptorOrigin \n Clob convert \n ResourceEditPropertyBuilder withTechnicalKey \n ResourceEditPropertyBuilder withMasterResTypeName \n ResourceEditPropertyBuilder withLoadedFor \n ResourceEditPropertyBuilder withDisplayName \n ResourceEditPropertyBuilder withValue \n ResourceEditPropertyBuilder withFcExternalLink \n ResourceEditPropertyBuilder withDefaultValue \n ResourceEditPropertyBuilder withDescriptorId \n ResourceEditPropertyBuilder withTypeId \n ResourceEditPropertyBuilder withDescriptor \n ResourceEditPropertyBuilder withPropTypeContName \n ResourceEditPropertyBuilder withValidationLogic \n ResourceEditPropertyBuilder withPropertyContextTypeId \n ResourceEditPropertyBuilder withPropertyId \n ResourceEditPropertyBuilder withPropContName \n ResourceEditPropertyBuilder withComment \n ResourceEditPropertyBuilder withFcOwner \n ResourceEditPropertyBuilder withMasterResTypeId \n ResourceEditPropertyBuilder withFcExternalKey \n ResourceEditProperty build \n ResourceEditPropertyBuilder withIsTesting \n ResourceEditPropertyBuilder withExampleValue \n ResourceEditPropertyBuilder withResourceName \n ResourceEditPropertyBuilder withPropContextId \n ResourceEditPropertyBuilder withIsNullable", "output": "ResourceEditPropertyBuilder function ( Integer arg0 ) { this . cardinalityProperty = arg0 ; return this ; }"}, {"instruction": "Generate java code\ncalculate the red histogram of an image ", "input": " int[] histogram \n float[] RED \n float[] GRAYSCALE \n float[] BLUE \n float[] GREEN \n int[] histogram \n int[] histogram \n int[] histogram \n int[] grayscaleHistogram \n int[] blueHistogram \n int[] greenHistogram", "output": "int [ ] function ( BufferedImage arg0 ) { return histogram ( arg0 , RED ) ; }"}, {"instruction": "Generate java code\nadds negated parameters , by default with the `` and '' connective . these paremeters will be grouped in parentheses in the generated query and negated , e.g. ... not exp1 and exp2 ... ", "input": " String OR \n MutableInteger queryParamCounter \n List<Parameters> negatedParameters \n List<Parameters> subParameters \n String alias \n String connective \n List<String> expressions \n Map<String,Object> localQueryParamValues \n String AND \n void addWhereWithParams \n void addWhere \n void addWhere \n void addWhere \n void addWhere \n void addNotNullRestriction \n boolean isEmpty \n void addNullRestriction \n void addWhereWithParam \n void addWhereWithParam \n void addWhereWithFunction \n Parameters deepCopy \n void build \n Parameters addSubParameters \n void addWhereWithNamedParam \n void addWhereWithNamedParam \n String generateQueryParam \n void append", "output": "Parameters function ( ) { final Parameters loc0 = new Parameters ( alias , AND , queryParamCounter ) ; negatedParameters . add ( loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nconcatenates a pdf document . ", "input": " PdfCopyFieldsImp fc \n void setOutlines \n void setViewerPreferences \n void addJavaScript \n void addViewerPreference \n PdfWriter getWriter \n boolean isFullCompression \n void setEncryption \n void setEncryption \n void setEncryption \n void setEncryption \n void setFullCompression \n void close \n void open", "output": "void function ( PdfReader arg0 ) { fc . addDocument ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the last exception thrown on the event dispatch thread , or null if no such exception has been thrown . ", "input": " AWTEventListener listener \n SystemState state \n void restore \n long getEventDispatchErrorTime", "output": "Throwable function ( ) { return EDTExceptionCatcher . getThrowable ( ) ; }"}, {"instruction": "Generate java code\nsets the value associated with the current key . ", "input": " Iterator iterator \n Map.Entry last \n Map map \n boolean canRemove \n Object next \n Object getKey \n Object getValue \n void reset \n boolean hasNext \n String toString \n void remove", "output": "Object function ( Object arg0 ) { if ( last == null ) { throw new IllegalStateException ( \"srini_string\" ) ; } return last . setValue ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the size in pixels of an attribute dimension ", "input": " PlaceHolder placeHolder \n int getThemeColor \n float convertPixelsToDp \n void setBackground \n void setBackground \n float convertDpToPixel \n int getThemeColorFromAttrOrRes", "output": "int function ( Context arg0 , int arg1 ) { TypedArray loc0 = null ; try { loc0 = arg0 . getTheme ( ) . obtainStyledAttributes ( new int [ ] { arg1 } ) ; return loc0 . getDimensionPixelSize ( 0 , 0 ) ; } finally { if ( loc0 != null ) { loc0 . recycle ( ) ; } } }"}, {"instruction": "Generate java code\nmodule twosided groebner base test . ", "input": " SolvableGroebnerBase<C> sbb \n boolean debug \n Logger logger \n List<GenSolvablePolynomial<C>> leftGB \n ModuleList<C> leftGB \n List<GenSolvablePolynomial<C>> rightGB \n ModuleList<C> rightGB \n boolean isLeftGB \n boolean isLeftGB \n boolean isRightGB \n boolean isRightGB \n List<GenSolvablePolynomial<C>> twosidedGB \n ModuleList<C> twosidedGB", "output": "boolean function ( int arg0 , List < GenSolvablePolynomial < C >> arg1 ) { return sbb . isTwosidedGB ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nnegative value . ", "input": " java.math.BigInteger val \n BigInteger ONE \n BigInteger ZERO \n Random random \n BigInteger IRAND \n boolean isField \n boolean isCommutative \n BigInteger gcd \n BigInteger IPROD \n BigInteger sum \n int compareTo \n BigInteger IABS \n java.math.BigInteger characteristic \n BigInteger random \n BigInteger random \n int hashCode \n BigInteger IDIF \n BigInteger divide \n BigInteger copy \n BigInteger multiply \n BigInteger IGCD \n int signum \n BigInteger ISUM \n boolean isONE \n BigInteger inverse \n java.math.BigInteger getVal \n BigInteger valueOf \n BigInteger valueOf \n boolean isUnit \n BigInteger subtract \n BigInteger IQ \n BigInteger[] IQR \n BigInteger parse \n BigInteger parse \n BigInteger[] egcd \n int ISIGN \n BigInteger abs \n BigInteger IREM \n BigInteger[] divideAndRemainder \n BigInteger negate \n boolean equals \n BigInteger clone \n BigInteger getONE \n BigInteger getZERO \n BigInteger fromInteger \n BigInteger fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n int ICOMP \n BigInteger remainder", "output": "BigInteger function ( BigInteger arg0 ) { if ( arg0 == null ) return null ; return arg0 . negate ( ) ; }"}, {"instruction": "Generate java code\ncompares two canvid and gives the number of common values back . so it gives the number of common parents ", "input": " List<String> VID \n boolean inBetween \n List<String> listCommon \n boolean lower \n boolean closestNeighbour \n void addToVID \n boolean allZero \n void removeFromList \n String einzelnToString \n boolean allOne \n List<String> getVIDList \n String toString \n void setVIDList \n boolean higher", "output": "int function ( CanVID arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < Math . min ( VID . size ( ) , arg0 . getVIDList ( ) . size ( ) ) ; loc1 ++ ) { if ( ! VID . get ( loc1 ) . toString ( ) . equals ( arg0 . getVIDList ( ) . get ( loc1 ) . toString ( ) ) ) break ; loc0 ++ ; } return loc0 ; }"}, {"instruction": "Generate java code\nconvert mixed case to underscores ", "input": " NamingStrategy INSTANCE \n String classToTableName \n String collectionTableName \n String propertyToColumnName \n String logicalColumnName \n String joinKeyColumnName \n String logicalCollectionColumnName \n String logicalCollectionTableName \n String foreignKeyColumnName \n String tableName \n String columnName \n String addUnderscores", "output": "String function ( String arg0 ) { return addUnderscores ( arg0 ) ; }"}, {"instruction": "Generate java code\ntest that javax.validation.validation #builddefaultvalidatorfactory works fine within an ejb ", "input": " StatelessBean slsb \n JavaArchive getDeployment \n void testValidatorInjection \n void testGetValidatorFromValidatorFactory", "output": "void function ( ) { this . slsb . buildDefaultValidatorFactory ( ) ; }"}, {"instruction": "Generate java code\nthe name of the document origin . interpretation is relative to the type , but might be the resource name or file url . ", "input": " String name \n SourceType type \n String UNKNOWN_FILE_PATH \n SourceType getType \n int hashCode \n boolean equals \n String toString", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nreturns the job status for the given job id . the job status includes things like where it 's deployed , and the status of the jobs where it 's deployed , etc. . ", "input": " Logger log \n MasterModel model \n MasterMetrics metrics \n JobValidator JOB_VALIDATOR \n CreateJobResponse post \n Optional<Job> get \n Map<JobId,Job> list \n JobDeleteResponse delete \n Map<JobId,JobStatus> jobStatuses", "output": "Optional < JobStatus > function ( @ PathParam ( \"srini_string\" ) @ Valid final JobId arg0 ) { if ( ! arg0 . isFullyQualified ( ) ) { throw badRequest ( \"srini_string\" ) ; } return Optional . fromNullable ( model . getJobStatus ( arg0 ) ) ; }"}, {"instruction": "Generate java code\npartitionbatch - decorator method to call real partitioner s to process incoming batch uses either threading or not threading approach based on number partitioners ", "input": " RecordBatch incoming \n boolean isLastBatch \n Partitioner part \n org.slf4j.Logger logger \n String childThreadPrefix \n GeneralExecuteIface iface \n ControlsInjector injector \n String parentThreadName \n CountDownLatchInjection testCountDownLatch \n OperatorStats stats \n ExecutorService executor \n String tName \n FragmentContext context \n boolean schemaChanged \n CountDownLatch latch \n IOException exp \n List<Partitioner> partitioners \n PartitionOutgoingBatch getOutgoingBatches \n IOException getException \n List<Partitioner> getPartitioners \n void clear \n void flushOutgoingBatches \n void executeMethodLogic \n void run \n Partitioner getPart \n void initialize \n void execute \n void execute \n void execute", "output": "void function ( final RecordBatch arg0 ) { executeMethodLogic ( new PartitionBatchHandlingClass ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nget cause ", "input": " FailedType failedType \n Throwable cause \n FailedType getFailedType", "output": "Throwable function ( ) { return cause ; }"}, {"instruction": "Generate java code\nreturn the unique identifier of the given plug-in . ", "input": " PlaceHolder placeHolder \n PluginVersionIdentifier getVersion \n PluginVersionIdentifier getVersion \n URL getUrl \n URL getUrl \n String getName \n URL getInstallUrl \n URL getInstallUrl \n String getVersionString \n String getVersionString", "output": "String function ( Plugin arg0 ) { return arg0 . getBundle ( ) . getSymbolicName ( ) ; }"}, {"instruction": "Generate java code\ninitializes resources . this must be called before monitorresources #getresources . this allows us to avoid an evil static initializer that would pollute all the getresources call sites . ", "input": " Resources resources \n String buildInfoView \n String even \n Resources getResources \n CommonCss commonCss \n Css monitorCss \n String odd", "output": "void function ( ) { resources = GWT . create ( Resources . class ) ; }"}, {"instruction": "Generate java code\nreturns the characters in the buffer to the scanner . ", "input": " char[] fContent \n boolean fIsHashCached \n IWordDetector fDetector \n int fLength \n List<WordMatcher> fMatchers \n Map<CharacterBuffer,IToken> fWords \n int UNDEFINED \n CharacterBuffer fBuffer \n int fHashCode \n IToken fDefaultToken \n int fColumn \n void addWord \n void setColumnConstraint \n void clearWords \n void addWordMatcher \n int hashCode \n boolean equals \n boolean equals \n void clear \n int length \n String toString \n IToken evaluate \n IToken evaluate \n void append \n char charAt", "output": "void function ( ICharacterScanner arg0 ) { for ( int loc0 = fBuffer . length ( ) - 1 ; loc0 >= 0 ; loc0 -- ) arg0 . unread ( ) ; }"}, {"instruction": "Generate java code\nmoves pos and lookat to the right in the map plane ", "input": " VectorXYZ pos \n VectorXYZ lookAt \n VectorXYZ up \n void setCamera \n void setCamera \n void moveForward \n void move \n void move \n void roll \n VectorXYZ getUp \n void yaw \n void moveMapUp \n void setPos \n void setPos \n void mapPitch \n VectorXYZ getRight \n void setLookAt \n void setLookAt \n VectorXYZ getViewDirection \n VectorXYZ getPos \n void moveRight \n VectorXYZ getLookAt \n void moveMapForward \n String toString \n void pitch \n void rotateY \n void moveUp", "output": "void function ( double arg0 ) { VectorXYZ loc0 = getRight ( ) ; VectorXZ loc1 = new VectorXZ ( loc0 . x , loc0 . z ) . normalize ( ) ; move ( loc1 . x * arg0 , 0 , loc1 . z * arg0 ) ; }"}, {"instruction": "Generate java code\ncreate an iterator iterator wrappingthe specified doubleiterator doubleiterator . when the given iterator is null , returns null . ", "input": " DoubleIterator _iterator \n Object next \n boolean hasNext \n void remove", "output": "Iterator function ( DoubleIterator arg0 ) { return null == arg0 ? null : new DoubleIteratorIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\nload all releases ", "input": " ReleaseMgmtPersistenceService persistenceService \n Logger log \n PropertyEditor propertyEditor \n EntityManager em \n ResourceDependencyResolverService resourceDependencyResolver \n Map<Integer,ReleaseEntity> loadReleasesForCreatingNewRelease \n ReleaseEntity getDefaultRelease \n Map<ReleaseEntity,Date> getDeployableReleasesForResourceGroupWithLatestDeploymentDate \n List<ReleaseEntity> getDeployableReleasesForResourceGroup \n boolean save \n List<ResourceEntity> getResourcesForRelease \n ReleaseEntity findByName \n void changeReleaseOfResource \n int countReleases \n List<ReleaseEntity> loadReleasesForMgmt \n boolean delete \n DeploymentEntity getLastSuccessfulDeploymentForResourceGroup", "output": "List < ReleaseEntity > function ( boolean arg0 ) { return persistenceService . loadAllReleaseEntities ( arg0 ) ; }"}, {"instruction": "Generate java code\nis this polynomial equal to other . ", "input": " GenPolynomial<GenPolynomial<C>> red \n GenPolynomial<GenPolynomial<C>> green \n GenPolynomial<GenPolynomial<C>> white \n List<GenPolynomial<C>> getRedCoefficients \n boolean isONE \n ExpVector leadingExpVector \n Map.Entry<ExpVector,GenPolynomial<C>> leadingMonomial \n boolean checkInvariant \n ColorPolynomial<C> subtract \n ColorPolynomial<C> subtract \n int length \n boolean isDetermined \n GenPolynomial<GenPolynomial<C>> getPolynomial \n ColorPolynomial<C> sum \n ColorPolynomial<C> sum \n ColorPolynomial<C> abs \n int hashCode \n boolean isZERO \n List<GenPolynomial<C>> getGreenCoefficients \n String toString \n ColorPolynomial<C> divide \n GenPolynomial<GenPolynomial<C>> getEssentialPolynomial \n ColorPolynomial<C> multiply \n ColorPolynomial<C> multiply", "output": "boolean function ( Object arg0 ) { ColorPolynomial < C > loc0 = null ; try { loc0 = ( ColorPolynomial < C > ) arg0 ; } catch ( ClassCastException loc1 ) { return false ; } if ( loc0 == null ) { return false ; } return ( green . equals ( loc0 . green ) && red . equals ( loc0 . red ) && white . equals ( loc0 . white ) ) ; }"}, {"instruction": "Generate java code\na helper method to create a new instance of a type using the default constructor arguments . ", "input": " PlaceHolder placeHolder \n boolean hasAnnotation \n boolean hasMethodWithAnnotation \n Object invokeMethod", "output": "T function ( Class < T > arg0 ) { try { return arg0 . newInstance ( ) ; } catch ( InstantiationException loc0 ) { throw new RuntimeException ( loc0 ) ; } catch ( IllegalAccessException loc0 ) { throw new RuntimeException ( loc0 ) ; } }"}, {"instruction": "Generate java code\nthis method returns the id of the node , that measured or aggregated the metrics , which are currently stored within this class . ", "input": " SkyNetNodeInfo nodeInfo \n HashMap<String,MetricsAggregate> metrics \n long getSize \n IAggregationResult getAggregationResult \n HashMap<String,MetricsAggregate> getMetrics \n int getMapSize \n Set<String> getKeySet", "output": "SkyNetNodeInfo function ( ) { return nodeInfo ; }"}, {"instruction": "Generate java code\ncomparison with any other object . ", "input": " Logger logger \n RingFactory<C> ring \n int isField \n C modul \n Residue<C> random \n Residue<C> random \n int hashCode \n boolean isField \n Residue<C> getONE \n boolean isCommutative \n Residue<C> getZERO \n Residue<C> fromInteger \n Residue<C> fromInteger \n boolean isAssociative \n String toString \n Residue<C> parse \n Residue<C> parse \n Residue<C> copy \n java.math.BigInteger characteristic", "output": "boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof ResidueRing ) ) { return false ; } ResidueRing < C > loc0 = null ; try { loc0 = ( ResidueRing < C > ) arg0 ; } catch ( ClassCastException loc1 ) { } if ( loc0 == null ) { return false ; } if ( ! ring . equals ( loc0 . ring ) ) { return false ; } return modul . equals ( loc0 . modul ) ; }"}, {"instruction": "Generate java code\ncreates war with a secured servlet and basic authentication configured in web.xml deployment descriptor . it uses default security domain . ", "input": " String SD_WITHOUT_LOGIN_PERMISSION \n SimpleSecurityDomain securityDomain \n UndertowDomainMapper applicationSecurityDomain \n String PASSWORD \n String EMPTY_PASSWORD \n String SUCCESSFUL_AUTH_EVENT \n String SUCCESSFUL_PERMISSION_CHECK_EVENT \n URL url \n String UNSUCCESSFUL_PERMISSION_CHECK_EVENT \n String USER \n String UNKNOWN_USER \n String NAME \n String WRONG_PASSWORD \n String UNSUCCESSFUL_AUTH_EVENT \n String SD_DEFAULT \n WebArchive customizedDeployment \n SimpleSecurityDomain createSecurityDomainWithoutPermissionMapper \n WebArchive createWar \n void setup \n void setDefaultEventListenerOfApplicationDomain \n void setEventListenerOfApplicationDomain \n void tearDown", "output": "WebArchive function ( ) { return createWar ( SD_DEFAULT ) ; }"}, {"instruction": "Generate java code\nreturns reflectclass for the specified class name ", "input": " Reflector _parent \n ReflectArray _array \n JdkLoader _classLoader \n ReflectorConfiguration _config \n Reflector parent \n void configuration \n ReflectorConfiguration configuration \n boolean isCollection \n boolean methodCallsSupported \n Object nullValue \n Class[] toNative \n Class toNative \n ReflectClass[] toMeta \n ReflectArray array \n Object deepClone \n ReflectClass forClass \n JdkClass createClass \n ReflectClass forObject \n void setParent", "output": "ReflectClass function ( String arg0 ) { Class loc0 = _classLoader . loadClass ( arg0 ) ; if ( loc0 == null ) { return null ; } return createClass ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns true iff all entries of the input array are > 0 . returns true if the array is non-null , but empty ", "input": " DistributionFactory distributionFactory \n double chiSquare \n double chiSquare \n void checkArray \n DistributionFactory getDistributionFactory \n boolean isNonNegative \n boolean isNonNegative \n boolean isRectangular \n double chiSquareTest \n boolean chiSquareTest \n double chiSquareTest \n boolean chiSquareTest", "output": "boolean function ( double [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0 . length ; loc0 ++ ) { if ( arg0 [ loc0 ] <= 0 ) { return false ; } } return true ; }"}, {"instruction": "Generate java code\nthis method returns a org.springframework.web.method.support.handlermethodargumentresolver that canconstruct org.springframework.data.domain.sort objects by using the request params of theincoming request . ", "input": " PlaceHolder placeHolder \n MappingJackson2HttpMessageConverter jacksonDateTimeConverter \n LocalValidatorFactoryBean validator \n LocaleResolver fixedLocaleResolver \n ExceptionHandlerExceptionResolver restErrorHandler", "output": "SortHandlerMethodArgumentResolver function ( ) { return new SortHandlerMethodArgumentResolver ( ) ; }"}, {"instruction": "Generate java code\ncreate an instance of keyvaluepairlist ", "input": " QName _HistoryHeader_QNAME \n QName _ISDVInfo_QNAME \n QName _KeyValuePairList_QNAME \n QName _LocalizedMessage_QNAME \n QName _BusinessException_QNAME \n QName _Message_QNAME \n QName _CallContext_QNAME \n QName _ValidationException_QNAME \n QName _NotFoundException_QNAME \n QName _ValidationContext_QNAME \n QName _TimePeriod_QNAME \n QName _OpenTimePeriod_QNAME \n QName _LocalizedString_QNAME \n QName _KeyValuePair_QNAME \n QName _TechnicalException_QNAME \n ISDVInfo createISDVInfo \n JAXBElement<ISDVInfo> createISDVInfo \n ValidationException createValidationException \n JAXBElement<ValidationException> createValidationException \n CallContext createCallContext \n JAXBElement<CallContext> createCallContext \n OpenTimePeriod createOpenTimePeriod \n JAXBElement<OpenTimePeriod> createOpenTimePeriod \n LocalizedMessage createLocalizedMessage \n JAXBElement<LocalizedMessage> createLocalizedMessage \n TechnicalException createTechnicalException \n JAXBElement<TechnicalException> createTechnicalException \n TimePeriod createTimePeriod \n JAXBElement<TimePeriod> createTimePeriod \n LocalizedString createLocalizedString \n JAXBElement<LocalizedString> createLocalizedString \n HistoryHeader createHistoryHeader \n JAXBElement<HistoryHeader> createHistoryHeader \n KeyValuePair createKeyValuePair \n JAXBElement<KeyValuePair> createKeyValuePair \n BusinessException createBusinessException \n JAXBElement<BusinessException> createBusinessException \n NotFoundException createNotFoundException \n JAXBElement<NotFoundException> createNotFoundException \n ValidationContext createValidationContext \n JAXBElement<ValidationContext> createValidationContext \n Message createMessage \n JAXBElement<Message> createMessage", "output": "KeyValuePairList function ( ) { return new KeyValuePairList ( ) ; }"}, {"instruction": "Generate java code\nextended greatest common divisor . note : not implemented , throws runtimeexception . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n GenPolynomial<C> num \n int isunit \n GenPolynomial<C> den \n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n GenPolynomial<C> gcd \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C> monic \n Local<C> abs \n int hashCode \n Local<C> negate \n GenPolynomial<C> lcm \n boolean equals \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "Local < C > [ ] function ( Local < C > arg0 ) { throw new RuntimeException ( \"srini_string\" + this . getClass ( ) . getName ( ) ) ; }"}, {"instruction": "Generate java code\ndetermines if fully qualified method name is in this class example methodname : public static string dostuff int , java.lang.object ", "input": " RootInfo traversalObject \n List<MethodInfo> method_infos \n ClassLoader loader \n Map<String,String> staticMap \n String class_name \n Class<?> clazz \n RootInfo traversalClass \n boolean shouldInclude \n void set_method_infos \n void init_traversal \n void initViaReflection \n String toString \n List<MethodInfo> get_method_infos \n void dump", "output": "boolean function ( String arg0 ) { return arg0 . matches ( \"srini_string\" + class_name + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nstart processing events as soon as the queue is n't empty . if the queue is not empty , this method will process all events already in the queue and any event that will be added while the queue is being processed . ", "input": " boolean started \n LinkedList<T> queuedEvents \n boolean isProcessing \n void processEvents \n void sendEvent \n void processEvent", "output": "void function ( ) { synchronized ( queuedEvents ) { if ( started ) { return ; } started = true ; isProcessing = true ; } processEvents ( ) ; }"}, {"instruction": "Generate java code\nlarnacaairport initializer ", "input": " int larnacaAirportNumberOfRunways \n Passenger[] passengersArray \n Airport larnacaAirport \n Plane[] planesArray \n Flight[] flightsArray \n int numberOfPassengers \n int numberOfFlightAttributes \n Runway[] runwaysArray \n int numberOfFlights \n void setLarnacaAirport \n void setPassengersArray \n void setFlightsArray \n Passenger[] getPassengersArray \n Object[][] getArrivalsOrDeparturesList \n void loadFromFile \n void freeUpRunway \n void initializeRunwaysArray \n Plane[] getPlanesArray \n void setRunwaysArray \n Object[][] getFlightData \n void initializePlanesArray \n void setPlanesArray \n void saveToFile \n void initializeFlightsArray \n boolean checkForFreeRunways \n void initializePassengersArray \n Airport getLarnacaAirport \n Object[] getArrivalsOrDeparturesRecord \n String[] getListOfAllFlightCodes \n Runway[] getRunwaysArray \n Flight[] getFlightsArray \n Object[] getFlightsRow", "output": "void function ( ) { getLarnacaAirport ( ) . setName ( \"srini_string\" ) ; getLarnacaAirport ( ) . setCity ( \"srini_string\" ) ; getLarnacaAirport ( ) . setCountry ( \"srini_string\" ) ; getLarnacaAirport ( ) . setCode ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns language targeted by this configuration ", "input": " List<ValidatorConfiguration> validatorConfigs \n SymbolTable symbolTable \n File home \n boolean built \n String lang \n List<Symbol> customSymbols \n Optional<String> variant \n String lang \n boolean secure \n RedPenTokenizer tokenizer \n File base \n List<ValidatorConfiguration> getValidatorConfigs \n RedPenTokenizer getTokenizer \n ConfigurationBuilder addSymbol \n ConfigurationBuilder secure \n ConfigurationBuilder setBaseDir \n void checkBuilt \n File getHome \n int hashCode \n ConfigurationBuilder builder \n ConfigurationBuilder builder \n ConfigurationBuilder setVariant \n ConfigurationBuilder addAvailableValidatorConfigs \n String getKey \n List<String> getDefaultConfigKeys \n ConfigurationBuilder addValidatorConfig \n String getVariant \n File findFile \n boolean secureExists \n boolean isSecure \n SymbolTable getSymbolTable \n void readObject \n void initTokenizer \n Configuration build \n boolean equals \n Configuration clone \n File getBase \n String toString \n ConfigurationBuilder setLanguage", "output": "String function ( ) { return lang ; }"}, {"instruction": "Generate java code\ngets the initial available numer . ", "input": " Map<Integer,String> buyedNumber \n Map<Integer,Integer> winnerNumer \n List<Integer> initialAvailableNumer \n List<Integer> availableNumer \n List<Command> commands \n Map<Integer,Integer> getWinnerNumer \n Map<Integer,String> getBuyedNumber \n List<Integer> getAvailableNumer \n void executeCommand \n List<Command> getCommands", "output": "List < Integer > function ( ) { return initialAvailableNumer ; }"}, {"instruction": "Generate java code\nreturn is other before first ", "input": " int[] retentionMonthly \n int[] browsingFreq \n int[] retentionDaily \n int[] retentionWeekly \n int weekBetween \n String getMonthRetention \n String dayOfweek \n long dateTimeDuration \n String getIntervalSegment \n String format \n String format \n String getWeekRetention \n List<String> getLastestDays \n String getDayRetention \n int getDuration \n String dayOfMonth \n int dayBetween \n boolean isAfter \n String getBrowsingFreq", "output": "boolean function ( String arg0 , String arg1 ) { try { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; Date loc1 = loc0 . parse ( arg0 ) ; Date loc2 = loc0 . parse ( arg1 ) ; return loc2 . before ( loc1 ) ; } catch ( Exception loc0 ) { loc0 . printStackTrace ( ) ; } return false ; }"}, {"instruction": "Generate java code\nfactory to create the predicate . ", "input": " Predicate[] iPredicates \n long serialVersionUID \n boolean evaluate \n Predicate[] getPredicates", "output": "Predicate function ( Collection arg0 ) { Predicate [ ] loc0 = FunctorUtils . validate ( arg0 ) ; return new OnePredicate ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns the bag . ", "input": " List components \n One one \n List manyToMany \n Foo foo \n int count \n Collection bag \n Simple simple \n Many many \n Set composites \n Collection lazyBag \n Collection cascades \n String name \n Set ternarySet \n Glarch glarch \n List oneToMany \n long id \n Map ternaryMap \n void setName \n void setName \n void setCascades \n String getName \n String getName \n void setBag \n void setFoo \n Map getTernaryMap \n long getId \n Glarch getGlarch \n List getOneToMany \n void setComposites \n void setGlarch \n int hashCode \n Many getMany \n Foo getFoo \n List getComponents \n void setId \n int getCount \n Collection getLazyBag \n void setCount \n Set getComposites \n void setComponents \n void setOneToMany \n void setOne \n void setLazyBag \n Simple getSimple \n void setTernaryMap \n void setMany \n void setTernarySet \n void setSimple \n List getManyToMany \n boolean equals \n One getOne \n void setManyToMany \n String toString \n Collection getCascades \n Set getTernarySet", "output": "Collection function ( ) { return bag ; }"}, {"instruction": "Generate java code\nget this widget 's index relative to its parent widget . ", "input": " long serialVersionUID \n HashMap _map \n int UNASSIGNED \n int _index \n WidgetLocator _parentInfo \n Class _cls \n String _nameOrLabel \n IWidgetMatcher _matcher \n void setData \n WidgetLocator getParentInfo \n String getNameOrLabel \n IWidgetLocator[] findAll \n boolean matches \n Map getDataMap \n void setParentInfo \n Class getTargetClass \n void setIndex \n int hashCode \n boolean equals \n String toString \n String getTargetClassName \n String getData", "output": "int function ( ) { return _index ; }"}, {"instruction": "Generate java code\nload all resourcegroups for the given type ", "input": " EntityManager entityManager \n ResourceRepository resourceRepository \n ResourceRelationService resourceRelationService \n ResourceTypeDomainService resourceTypeDomainService \n ForeignableService foreignableService \n ResourceGroupPersistenceService resourceGroupService \n Set<ResourceGroupEntity> getApplicationsFromOtherResourcesInGroup \n ResourceGroupEntity getResourceGroupWithAllResources \n void addResourceTypeRelation \n void removeRelation \n void addRelation \n void removeResourceTypeRelation", "output": "List < ? extends NamedIdentifiable > function ( String arg0 , Integer arg1 ) { ResourceEntity loc0 = resourceRepository . loadWithResourceGroupAndRelatedResourcesForId ( arg1 ) ; return resourceGroupService . loadGroupsForTypeNameExcludeSelected ( arg0 , Collections . singletonList ( loc0 . getResourceGroup ( ) . getId ( ) ) ) ; }"}, {"instruction": "Generate java code\nreturns the trace data is added to . ", "input": " ITrace2D m_trace \n void collectData", "output": "ITrace2D function ( ) { return this . m_trace ; }"}, {"instruction": "Generate java code\ncreates testing web-app module for app1.ear ", "input": " EnterpriseArchive DEPENDENT \n String DEP_APP1 \n Logger LOGGER \n String DEP_APP2 \n EnterpriseArchive DEPENDEE \n String MODULE_WEB \n ManagementClient managementClient \n ArchiveDeployer deployer \n String MODULE_EJB \n Archive<?> getDeployment \n JavaArchive createLogLibrary \n Archive<?> createBeanJar \n LogAccess lookupEJB \n void forceDependeeUndeploy \n void test \n void cleanUp \n void testWithRestart \n void setup", "output": "Archive < ? > function ( ) { return ShrinkWrap . create ( WebArchive . class , MODULE_WEB + \"srini_string\" ) . setWebXML ( InterDeploymentDependenciesEarTestCase . class . getPackage ( ) , \"srini_string\" ) . addClass ( SleeperContextListener . class ) ; }"}, {"instruction": "Generate java code\nsets the constraints . ", "input": " Component component \n GridBagConstraints constraints \n GridBagConstraints getConstraints \n Component getComponent \n void setComponent", "output": "void function ( GridBagConstraints arg0 ) { this . constraints = arg0 ; }"}, {"instruction": "Generate java code\ngets the closures , do not modify the array . ", "input": " Closure[] iClosures \n Predicate[] iPredicates \n long serialVersionUID \n Closure iDefault \n Closure getDefaultClosure \n Closure getInstance \n Closure getInstance \n void execute \n Predicate[] getPredicates", "output": "Closure [ ] function ( ) { return iClosures ; }"}, {"instruction": "Generate java code\nset the output resource file . if not set , no output file will be created . ", "input": " int bufferIndex \n ArrayList<Byte> bytes \n int delayMax \n File inputImage1 \n File inputImage2 \n int delayMin \n boolean createOutputImage \n File outputFile \n SecureRandom random \n boolean createOutputFile \n boolean overwriteOutputFile \n boolean deleteInputFiles \n boolean considerTwoLSB \n File outputImage \n byte buffer \n int delay \n void deleteInputFiles \n void setInputImages \n void setOutputImage \n void overwriteOutputFile \n void addToGroup \n void considerTwoLSB \n ArrayList<Byte> generateRandom \n String encodeISO88591", "output": "void function ( String arg0 ) { outputFile = new File ( arg0 ) ; createOutputFile = true ; }"}, {"instruction": "Generate java code\nreturns the piece at the certain position . ", "input": " int MAX_BOARD_SIZE \n Piece pieces[] \n int KING_PIECE_TYPE \n int SINGLE_PIECE_TYPE \n boolean isOccupied \n void removePiece \n Vector<Piece> getBluePieces \n int sizeOf \n void kingPiece \n int movePiece \n Color getPieceColorAtSpace \n Vector<Piece> getWhitePieces \n boolean boardContainsPiece", "output": "Piece function ( int arg0 ) { Piece loc0 = new SinglePiece ( Color . red ) ; try { if ( isOccupied ( arg0 ) ) { loc0 = pieces [ arg0 ] ; } } catch ( ArrayIndexOutOfBoundsException loc1 ) { } catch ( NullPointerException loc1 ) { } return loc0 ; }"}, {"instruction": "Generate java code\ncalled when a chunk with a generic tag is written . it is useful to pinpoint the chunk location to generate bookmarks , for example . ", "input": " ArrayList<PdfPageEvent> events \n void addPageEvent \n void onSection \n void onParagraph \n void onParagraphEnd \n void onOpenDocument \n void onSectionEnd \n void onEndPage \n void onChapter \n void onCloseDocument \n void onChapterEnd \n void onStartPage", "output": "void function ( PdfWriter arg0 , Document arg1 , Rectangle arg2 , String arg3 ) { PdfPageEvent loc0 ; for ( Object loc1 : events ) { loc0 = ( PdfPageEvent ) loc1 ; loc0 . onGenericTag ( arg0 , arg1 , arg2 , arg3 ) ; } }"}, {"instruction": "Generate java code\nsets the current cluster id . ", "input": " ProcessListener processListener \n FXMLController guiController \n String user \n File fileBiBiGridJar \n File fileSingularityScript \n ProcessBuilder processBuilder \n File fileInput \n String masterIp \n ObservableList<String> flavorChoices \n PropertiesController propertiesController \n String clusterId \n void exit \n String getClusterId \n File getInputFile \n void setMasterIp \n void StopCluster \n PropertiesController getPropertiesController \n String getMasterIp \n void StartCluster \n void setInputFile \n void UnlockSettings \n void UnlockStopButton \n ObservableList<String> getFlavorChoices", "output": "void function ( String arg0 ) { clusterId = arg0 ; }"}, {"instruction": "Generate java code\ncompare the contents of two files : ", "input": " FileFilter CVSFILTER \n void compareResourceTree \n void compareResourceTree \n void compareResourceTree \n void compareResourceTree \n boolean accept", "output": "void function ( IProject arg0 , String arg1 , String arg2 ) { Assert . assertNotNull ( \"srini_string\" , arg0 ) ; Assert . assertNotNull ( \"srini_string\" , arg1 ) ; Assert . assertNotNull ( \"srini_string\" , arg2 ) ; compareFileContents ( arg0 . getFile ( arg1 ) , arg2 ) ; }"}, {"instruction": "Generate java code\nthe current text buffer . ", "input": " StringBuilder currentEntity \n StringBuilder comment \n String currentTag \n boolean isHtml \n String currentAttr \n char lastChar \n String wsTag \n String storedString \n Map<String,String> attr \n String currentNameSpace \n StringBuilder baos \n StringBuilder currentEntity \n Map<String,String> getAttributes \n void putCurrentAttrValue \n void currentAttr \n boolean hasCurrentAttribute \n String getNameSpace \n String whitespaceTag \n void whitespaceTag \n void flushNameSpace \n void setStoredString \n String getCurrentTag \n void currentTag \n void resetBuffer \n void lastChar \n char lastChar \n void namespace \n String getStoredString \n StringBuilder comment", "output": "StringBuilder function ( ) { return baos ; }"}, {"instruction": "Generate java code\na lower bound on the number of elements in the set . returns either the number of elements that have been inserted in the set , or max_size , whichever is less . ", "input": " int num_values \n int[] values \n long serialVersionUID \n void add \n boolean contains \n boolean repNulled \n void addAll \n LimitedSizeIntSet merge \n Object clone \n String toString \n int max_size", "output": "int function ( ) { return num_values ; }"}, {"instruction": "Generate java code\nreturns the non-terminal that is the start symbol for the grammar for the given schema sc . ", "input": " Schema actual \n int hashCode \n boolean equals", "output": "Symbol function ( Schema arg0 ) { return Symbol . root ( generate ( arg0 , new HashMap < LitS , Symbol > ( ) ) ) ; }"}, {"instruction": "Generate java code\ntake a path string elements delimited by the ' \\ ' character and break it into tokens . if an element contains the delimeter , it must be escaped . for example : `` edit/find \\ \\ / replace '' tokenizes to `` edit '' , `` find/replace '' . ", "input": " List _items \n char _delimeter \n char _escape \n String _pathString \n StringBuffer _sb \n String[] getItems \n void addItem \n char getChar \n boolean inBounds \n boolean isEscape \n void addChar \n boolean isEscapeCase \n boolean isDelimeter", "output": "String [ ] function ( String arg0 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return new PathTokenizer ( arg0 ) . tokenize ( ) ; }"}, {"instruction": "Generate java code\nensures that the expression given as a method parameter is true . ", "input": " PlaceHolder placeHolder \n void notNull \n void notEmpty", "output": "void function ( boolean arg0 , String arg1 ) { if ( ! arg0 ) { throw new IllegalArgumentException ( arg1 ) ; } }"}, {"instruction": "Generate java code\nconvenience method to return the text of the filter control . if the text widget is not created , then null is returned . ", "input": " Text fTextControl \n ImageDescriptor fgClearIconDescriptor \n Control fClearButton \n Composite fComposite \n Boolean fgUseNativeSearchField \n ImageDescriptor fgDisabledClearIconDescriptor \n void createControls \n boolean useNativeSearchField \n void createTextControl \n void updateClearButtonVisibility \n Text getFilterControl \n void createClearButton", "output": "String function ( ) { return fTextControl != null ? fTextControl . getText ( ) : null ; }"}, {"instruction": "Generate java code\nreturns whether one of the given categories is contained in this set of group categories ", "input": " List<GroupCategory> fContent \n GroupCategorySet NONE \n boolean contains \n boolean contains \n GroupCategorySet union \n List<GroupCategory> asList \n List<GroupCategory> asList", "output": "boolean function ( List < GroupCategory > arg0 ) { for ( Iterator < GroupCategory > loc0 = arg0 . iterator ( ) ; loc0 . hasNext ( ) ; ) { GroupCategory loc1 = loc0 . next ( ) ; if ( contains ( loc1 ) ) return true ; } return false ; }"}, {"instruction": "Generate java code\nchecks if the space on the board contains a piece . if outside board array bounds , return true . ", "input": " int MAX_BOARD_SIZE \n Piece pieces[] \n int KING_PIECE_TYPE \n int SINGLE_PIECE_TYPE \n void removePiece \n Vector<Piece> getBluePieces \n int sizeOf \n void kingPiece \n int movePiece \n Piece getPieceAt \n Color getPieceColorAtSpace \n Vector<Piece> getWhitePieces \n boolean boardContainsPiece", "output": "boolean function ( int arg0 ) { return ( arg0 >= 1 && arg0 <= 63 && pieces [ arg0 ] == null ) ? false : true ; }"}, {"instruction": "Generate java code\nappends a byte array or part of to the buffer . ", "input": " String encoding \n int length \n byte[] buffer \n InputStream getByteStream \n String getEncoding \n byte byteAt \n int length \n void ensureCapacity \n int charAt", "output": "void function ( byte [ ] arg0 , int arg1 , int arg2 ) { ensureCapacity ( length + arg2 ) ; System . arraycopy ( arg0 , arg1 , buffer , length , arg2 ) ; length += arg2 ; }"}, {"instruction": "Generate java code\nreturn the number of words in the dictionary . this is not necessarily the same as the number of trienodes in the trie . ", "input": " int size \n TrieNode root \n boolean addWord \n List<String> predictCompletions \n boolean isWord \n void printNode \n void printTree", "output": "int function ( ) { return size ; }"}, {"instruction": "Generate java code\nlook for @entity annotation ", "input": " PlaceHolder placeHolder \n boolean isPersistentField \n boolean doDirtyCheckingInline \n boolean hasLazyLoadableAttributes \n boolean isCompositeClass \n boolean isLazyLoadable \n boolean isMappedCollection \n ClassLoader getLoadingClassLoader \n CtField[] order", "output": "boolean function ( CtClass arg0 ) { return arg0 . hasAnnotation ( Entity . class ) ; }"}, {"instruction": "Generate java code\ngets a debugging string version of this converter . ", "input": " PlaceHolder placeHolder \n long getInstantMillis \n boolean isReadableInterval \n PeriodType getPeriodType \n Chronology getChronology \n Chronology getChronology \n int[] getPartialValues \n int[] getPartialValues", "output": "String function ( ) { return \"srini_string\" + ( getSupportedType ( ) == null ? \"srini_string\" : getSupportedType ( ) . getName ( ) ) + \"srini_string\" ; }"}, {"instruction": "Generate java code\ngets the context type . ", "input": " TemplateContextType fContextType \n Comparator<TemplateVariableProposal> fgTemplateVariableProposalComparator \n char[] getCompletionProposalAutoActivationCharacters \n int compare \n int getStart \n IContextInformationValidator getContextInformationValidator \n char[] getContextInformationAutoActivationCharacters \n void setContextType \n ICompletionProposal[] computeCompletionProposals \n IContextInformation[] computeContextInformation \n String getErrorMessage", "output": "TemplateContextType function ( ) { return fContextType ; }"}, {"instruction": "Generate java code\nsole entry point to application , as always . ", "input": " PlaceHolder placeHolder \n void printCapitalized", "output": "void function ( String [ ] arg0 ) { String loc0 ; TextIO . putln ( \"srini_string\" ) ; loc0 = TextIO . getln ( ) ; TextIO . putln ( ) ; TextIO . putln ( \"srini_string\" ) ; printCapitalized ( loc0 ) ; }"}, {"instruction": "Generate java code\nsame as c.isprimitive but faster if this test is done very frequently as it is in randoop . ", "input": " Map<String,Boolean> stringLengthOKCached \n Map<Class<?>,Class<?>> boxedToPrimitiveAndString \n Map<String,Class<?>> typeNameToPrimitiveOrString \n Map<Class<?>,Boolean> isPrimitiveCached \n String OBJECT_REF_PATTERN \n Map<String,Class<?>> typeNameToBoxed \n Map<Class<?>,Class<?>> primitiveAndStringToBoxed \n boolean isBoxedPrimitiveTypeOrString \n boolean isPrimitiveOrStringTypeName \n Class<?> getPrimitiveTypeOrString \n Class<?> boxedType \n Set<Class<?>> getPrimitiveTypesAndString \n String toCodeString \n Class<?> getUnboxType \n boolean stringLengthOK \n boolean isBoxedOrPrimitiveOrStringType \n boolean isPrimitiveOrStringType \n Class<?> primitiveType \n Class<?> getBoxedType \n Set<Class<?>> getBoxedTypesAndString \n boolean looksLikeObjectToString", "output": "boolean function ( Class < ? > arg0 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; Boolean loc0 = isPrimitiveCached . get ( arg0 ) ; if ( loc0 == null ) { loc0 = arg0 . isPrimitive ( ) ; isPrimitiveCached . put ( arg0 , loc0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nremove incorrect values and repaint the panel ", "input": " KenKenGUI gui \n placeholderType placeHolder", "output": "void function ( ActionEvent arg0 ) { if ( gui . isPlaying ( ) ) { this . gui . getPuzzle ( ) . removeIncorrect ( ) ; this . gui . getMainPanel ( ) . getGamePanel ( ) . paintGamePanel ( gui . getPuzzle ( ) ) ; this . gui . initiateCommandHistory ( ) ; } }"}, {"instruction": "Generate java code\ncheck invariants . check if all colored systems are determined and all invariants are met . ", "input": " Logger logger \n boolean debug \n List<Condition<C>> conds \n List<ColoredSystem<C>> list \n PolynomialList<GenPolynomial<C>> cgb \n List<GenPolynomial<GenPolynomial<C>>> getCGB \n int hashCode \n boolean equals \n boolean isDetermined \n String toString \n List<Condition<C>> getConditions", "output": "boolean function ( ) { for ( ColoredSystem < C > loc0 : list ) { if ( ! loc0 . checkInvariant ( ) ) { return false ; } } return true ; }"}, {"instruction": "Generate java code\ngets the value of the technicalkey property . ", "input": " String validationPattern \n boolean isValueOptional \n boolean encrypted \n String machineInterpretationKey \n String displayName \n String defaultValue \n String technicalKey \n boolean isKeyOptional \n List<String> tags \n String exampleValue \n void setDefaultValue \n String getExampleValue \n List<String> getTags \n String getValidationPattern \n boolean isIsKeyOptional \n void setIsKeyOptional \n void setDisplayName \n void setMachineInterpretationKey \n void setExampleValue \n String getDefaultValue \n void setEncrypted \n void setTechnicalKey \n String getDisplayName \n boolean isEncrypted \n String getMachineInterpretationKey \n void setValidationPattern \n boolean isIsValueOptional \n void setIsValueOptional", "output": "String function ( ) { return technicalKey ; }"}, {"instruction": "Generate java code\nhash code . ", "input": " ExpVector e1 \n ExpVector e2 \n ExpVector getFirst \n boolean equals \n boolean equals \n ExpVector getSecond \n String toString \n boolean isMultiple", "output": "int function ( ) { return ( e1 . hashCode ( ) << 16 ) + e2 . hashCode ( ) ; }"}, {"instruction": "Generate java code\nverifies if a given editing owner is equals the foreignable owner or if the the user has super user chuck norris role which can overrule foreignable rules ", "input": " PermissionService permissionService \n boolean isNewObject \n boolean isChuckNorris \n void verifyEditableByOwner \n void verifyDeletableByOwner \n boolean hasOnlyDecorationsChanged", "output": "boolean function ( ForeignableOwner arg0 , ForeignableOwner arg1 ) { return isChuckNorris ( ) || arg1 . isSameOwner ( arg0 ) ; }"}, {"instruction": "Generate java code\nimport lockup data from an xml-file . ", "input": " HashMap<String,String[]> countryLookup \n ArrayList<String> pingErCountry \n ArrayList<String> pingErRegion \n long serialVersionUID \n Logger log \n HashMap<String,String> pingErCountryRegions \n String pingErCountryRegionFilename \n void importPingErCountryRegionFile \n String getGeoIpCountryName \n String getPingErCountryName \n boolean containsPingErCountryOrRegion \n ArrayList<String> getPingErRegions \n void keepCountries \n void addCountryFromGeoIP \n String getPingErCountryRegionFilename \n Element exportToXML \n void assignCountryCodeToPingErData \n Set<String> getCountryCodes \n String getPingErRegionName \n ArrayList<String> getPingErCountrys", "output": "void function ( File arg0 ) { try { SAXReader loc0 = new SAXReader ( false ) ; Document loc1 = loc0 . read ( arg0 ) ; Element loc2 = loc1 . getRootElement ( ) ; importFromXML ( loc2 ) ; } catch ( DocumentException loc0 ) { loc0 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\nreturns the refactoring descriptor proxy . depending on the event , this proxy may refer to an inexisting refactoring and can not be resolved to a refactoring descriptor . clients should also be prepared to receive notifications for unknown refactorings , which are discriminated by their special id refactoringdescriptor #id_unknown ; ", "input": " int UNDONE \n RefactoringDescriptorProxy fProxy \n int fType \n int ABOUT_TO_PERFORM \n IRefactoringHistoryService fService \n int ABOUT_TO_REDO \n int ABOUT_TO_UNDO \n int PERFORMED \n int REDONE \n int getEventType \n IRefactoringHistoryService getHistoryService", "output": "RefactoringDescriptorProxy function ( ) { return fProxy ; }"}, {"instruction": "Generate java code\nsets the color of this rectangle . ", "input": " boolean filled \n double x \n double width \n double y \n Color color \n double height \n int getX \n int getHeight \n int getY \n void grow \n String toString \n int getWidth \n void draw \n void fill \n void translate \n void paintShape", "output": "void function ( Color arg0 ) { color = arg0 ; Canvas . getInstance ( ) . repaint ( ) ; }"}, {"instruction": "Generate java code\nrebind val to name in ctx , and make sure that all intermediate contexts exist ", "input": " PlaceHolder placeHolder \n Context createSubcontext \n void unbind \n void unbind \n boolean isEmpty \n NameNotFoundException nameNotFoundException \n String getLastComponent \n NameAlreadyBoundException nameAlreadyBoundException \n NotContextException notAContextException \n boolean isLastComponentEmpty \n NamingException namingException \n NamingException namingException \n CannotProceedException cannotProceedException \n InvalidNameException emptyNameException \n NamingEnumeration<T> namingEnumeration", "output": "void function ( final Context arg0 , final String arg1 , final Object arg2 ) { final Name loc0 = arg0 . getNameParser ( \"srini_string\" ) . parse ( arg1 ) ; rebind ( arg0 , loc0 , arg2 ) ; }"}, {"instruction": "Generate java code\nan arbitrary number which does not correspond to an active customer id . ", "input": " InMemoryCustomerDao dao \n Customer CUSTOMER \n void addingShouldResultInSuccess \n void deletionShouldBeFailureAndNotAffectExistingCustomers \n void deletionShouldBeSuccessAndCustomerShouldBeNonAccessible \n void addingShouldResultInFailureAndNotAffectExistingCustomers \n void retriveShouldReturnTheCustomer \n void assertCustomerCountIs \n void retrieveShouldReturnNoCustomer \n void setUp \n void updationShouldBeFailureAndNotAffectExistingCustomers \n void updationShouldBeSuccessAndAccessingTheSameCustomerShouldReturnUpdatedInformation", "output": "int function ( ) { return 999 ; }"}, {"instruction": "Generate java code\nstart a transaction in an agency database . no checking is done to ensure the agency exists ; if it does not you will get a hopefully empty db , unless you 've done the same thing previously . ", "input": " DB tx \n TxMaker globalTxMaker \n Map<String,TxMaker> agencyTxMakers \n File dataDirectory \n boolean closed \n void rollback \n List<Stop> restore \n NavigableSet<T> getSet \n DB getSnapshotDb \n Snapshot takeSnapshot \n boolean agencyExists \n void commit \n GlobalTx getGlobalTx \n DB getRawAgencyTx \n BTreeMap<T1,T2> getMap \n File getSnapshotDir \n void finalize \n void rollbackIfOpen", "output": "AgencyTx function ( String arg0 ) { return new AgencyTx ( getRawAgencyTx ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nquotient absolute value . ", "input": " Logger logger \n QuotientRing<C> ring \n boolean debug \n GenPolynomial<C> num \n GenPolynomial<C> den \n int signum \n boolean isONE \n Quotient<C> inverse \n boolean isUnit \n Quotient<C> subtract \n Quotient<C> gcd \n Quotient<C> sum \n int compareTo \n Quotient<C>[] egcd \n Quotient<C> monic \n int hashCode \n Quotient<C> negate \n boolean equals \n Quotient<C> clone \n boolean isZERO \n String toString \n Quotient<C> divide \n Quotient<C> multiply \n Quotient<C> multiply \n Quotient<C> remainder", "output": "Quotient < C > function ( ) { return new Quotient < C > ( ring , num . abs ( ) , den , true ) ; }"}, {"instruction": "Generate java code\noutput a debugging string . ", "input": " PlaceHolder placeHolder \n int getMaximumValueOverall \n String getName \n int getMinimumValueOverall \n int getMaximumShortTextLength \n DateTimeField getField \n DateTimeFieldType getFieldType \n ReadablePartial getReadablePartial \n String getAsString \n int compareTo \n int compareTo \n String getAsText \n String getAsText \n DurationField getDurationField \n String getAsShortText \n String getAsShortText \n int hashCode \n int get \n boolean equals \n int getMaximumValue \n int getMaximumTextLength \n DurationField getRangeDurationField \n int getMinimumValue", "output": "String function ( ) { return \"srini_string\" + getName ( ) + \"srini_string\" ; }"}, {"instruction": "Generate java code\nis null or its size is 0 isempty null = true ; isempty = true ; isempty 1 = false ; ", "input": " CharSequence DEFAULT_JOIN_SEPARATOR \n String join", "output": "boolean function ( Collection < V > arg0 ) { return ( arg0 == null || arg0 . size ( ) == 0 ) ; }"}, {"instruction": "Generate java code\nreturn the context key under which our catalog has beenstored . ", "input": " String catalogKey \n boolean execute \n void setCatalogKey", "output": "String function ( ) { return ( this . catalogKey ) ; }"}, {"instruction": "Generate java code\nbuilds the new person object . ", "input": " String firstName \n String lastName \n Date creationTime \n Person built \n Date modificationTime \n long version \n Long id \n long getVersion \n String getName \n Date getModificationTime \n void prePersist \n void update \n Long getId \n String getLastName \n Builder getBuilder \n Date getCreationTime \n void setId \n String toString \n String getFirstName \n void preUpdate", "output": "Person function ( ) { return built ; }"}, {"instruction": "Generate java code\nreturns the message source mock . ", "input": " String ERROR_MESSAGE \n String FEEDBACK_MESSAGE \n String FLASH_ERROR_MESSAGE \n String VIEW_REDIRECT_PREFIX \n MessageSource messageSourceMock \n String FLASH_FEEDBACK_MESSAGE \n Validator validator \n void assertFeedbackMessage \n void assertFieldErrors \n BindingResult bindAndValidate \n void assertErrorMessage \n void initMessageSourceForErrorMessage \n void setUp \n void assertFlashMessages \n String createExpectedRedirectViewPath \n void setUpTest \n void initMessageSourceForFeedbackMessage", "output": "MessageSource function ( ) { return messageSourceMock ; }"}, {"instruction": "Generate java code\ngets the httpclient to issue request . ", "input": " HttpResponseInterceptor contentEncodingInterceptor \n HttpClient backend \n HttpRequestInterceptor acceptEncodingInterceptor \n HttpHost getHttpHost \n ClientConnectionManager getConnectionManager \n HttpResponse execute \n HttpResponse execute \n HttpResponse execute \n HttpResponse execute \n T execute \n T execute \n T execute \n T execute \n HttpParams getParams", "output": "HttpClient function ( ) { return this . backend ; }"}, {"instruction": "Generate java code\nrotates a vector on the y axis ", "input": " float x \n float z \n float y \n void setLength \n void logVector \n void normalize \n double dot \n void cross \n void cross \n float length \n void copy \n void copy \n void reverse \n double rotToRad \n void rotateX \n void rotateZ", "output": "void function ( Point3D arg0 , double arg1 , double arg2 ) { float loc0 = arg0 . loc0 ; float loc1 = arg0 . loc1 ; arg0 . loc0 = ( float ) ( arg2 * loc0 - arg1 * loc1 ) ; arg0 . loc1 = ( float ) ( arg1 * loc0 + arg2 * loc1 ) ; }"}, {"instruction": "Generate java code\nget a `` preloaded '' mock couchdb suitable to be used as a pull replication target . it 's preloaded in the sense that it is ready serve up mock documents . this ca n't be used to simulate a sync gateway , because it does not support _ bulk_get ", "input": " String PATH_REGEX_ALL_DOCS \n String PATH_REGEX_SESSION_COUCHDB \n String PATH_REGEX_FACEBOOK_AUTH \n String PATH_REGEX_BULK_DOCS \n String PATH_REGEX_CHECKPOINT \n String PATH_REGEX_SESSION \n String PATH_REGEX_CHANGES_NORMAL \n String PATH_REGEX_CHANGES_LONGPOLL \n String PATH_REGEX_BULK_GET \n String PATH_REGEX_CHANGES \n String PATH_REGEX_REVS_DIFF \n String PATH_REGEX_DB \n int batchSize \n BlockingQueue<T> items \n byte[] getUncompressedBody \n MockWebServer getMockWebServer \n boolean isGzip \n boolean hasMoreBatches \n void set404NotFoundJson \n List<T> nextBatch \n void addFake404CheckpointResponse \n String getUtf8Body \n void set200OKJson \n Map<String,Object> getJsonMapFromRequest \n List<MockDocumentGet.MockDocument> getMockDocuments \n void set201OKJson \n Map<String,Object> generateRandomJsonMap \n SmartMockResponse wrap \n boolean shutdown \n boolean shutdown \n boolean shutdown", "output": "MockWebServer function ( MockDispatcher arg0 , int arg1 , int arg2 ) { return new MockPreloadedPullTarget ( arg0 , arg1 , arg2 ) . getMockWebServer ( ) ; }"}, {"instruction": "Generate java code\nrgb 8-bit per channel to ycc 16-bit per channel . ", "input": " int bits \n String name \n int mask \n int getBits \n void RGBtoYUV \n void RGBtoYIQ \n void YUVtoRGB \n String toString \n String toString \n int compareTo \n void YCCtoRGB \n void YCCtoRGB \n int YCCtoRGB \n void YIQtoRGB", "output": "void function ( int arg0 , int [ ] arg1 ) { int loc0 = ( arg0 & 0xff0000 ) >>> 16 ; int loc1 = ( arg0 & 0xff00 ) >>> 8 ; int loc2 = arg0 & 0xff ; int loc3 = 77 * loc0 + 153 * loc1 + 26 * loc2 ; int loc4 = loc0 * 256 - loc3 ; int loc5 = loc2 * 256 - loc3 ; int loc6 = ( loc5 / 2 ) + 128 * 256 ; int loc7 = ( loc4 * 5 / 8 ) + 128 * 256 ; arg1 [ 0 ] = loc3 ; arg1 [ 1 ] = loc6 ; arg1 [ 2 ] = loc7 ; }"}, {"instruction": "Generate java code\ngetowner returns the name of this account 's owner . ", "input": " int number \n int balance \n String name \n int getNumber \n int getKey \n int getBalance \n boolean lessThan \n void deposit \n String toString \n void withdraw", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nnobody get the lock when globalmutex contains nothing ", "input": " int currentReaderCount \n ReadLock readerLock \n Object readerMutex \n WriteLock writerLock \n Set<Object> globalMutex \n Lock writeLock \n void unlock \n void unlock \n void lockInterruptibly \n void lockInterruptibly \n boolean doesWriterOwnThisLock \n void waitUninterruptibly \n Condition newCondition \n Condition newCondition \n Lock readLock \n boolean doesReaderOwnThisLock \n void lock \n void lock \n boolean tryLock \n boolean tryLock \n boolean tryLock \n boolean tryLock", "output": "boolean function ( ) { return globalMutex . isEmpty ( ) ; }"}, {"instruction": "Generate java code\nfail with the specified message and the content of the specified collections ", "input": " PlaceHolder placeHolder \n int testContains \n int testContains \n boolean testContains \n void assertContainsOnly \n void assertContainsOnly \n void assertContainsOnly \n void assertContainsOnly \n void assertContainsOnly \n void assertContains \n boolean testContainsOnly \n boolean testContainsOnly", "output": "void function ( String arg0 , Object [ ] arg1 , Collection arg2 ) { fail ( arg0 , arg1 , arg2 , new Comparator < Object > ( ) { public int compare ( Object arg3 , Object arg4 ) { return arg3 == arg4 ? 0 : - 1 ; } } ) ; }"}, {"instruction": "Generate java code\nlooks up a key code and returns a human readable string . sometimes this is just the key , other times it is the function of the key written out in english . ", "input": " JsIntegerMap<String> keyCodeDescMap \n Handler handler \n int keyCode \n int handlerCount \n JsIntegerMap<Data> handlers \n String description \n int LEFT_ARROW \n int RIGHT_ARROW \n EventListenerRemover remover \n void onKeyDown \n void onKeyUp \n JSOArray<Data> getHotKeyData \n void unregister \n void unregisterAll \n Handler getHandler \n int getKeyCode \n String getDescription \n void register \n EventListenerRemover addEventListeners", "output": "String function ( int arg0 ) { String loc0 = keyCodeDescMap . get ( arg0 ) ; if ( loc0 == null ) { return Character . toString ( ( char ) arg0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsearches the list of induction variables for an induction variable with a given value number . ", "input": " Expr ind_term \n boolean changed \n FlowGraph CFG \n Expr ind_var \n Expr ind_init \n Expr tgt \n boolean DEBUG \n Expr ind_inc \n SSAGraph ssaGraph \n HashMap LocalStore \n HashMap IndStore \n void transform \n Block isMu \n MemExpr get_local \n void Display_store \n void insert_aswrange \n void displaySwizzler", "output": "Object function ( final int arg0 ) { final Iterator loc0 = IndStore . values ( ) . iterator ( ) ; while ( loc0 . hasNext ( ) ) { final Swizzler loc1 = ( Swizzler ) loc0 . next ( ) ; if ( ( loc1 . target ( ) . valueNumber ( ) == arg0 ) || ( loc1 . ind_var ( ) . valueNumber ( ) == arg0 ) ) { return loc1 ; } } return null ; }"}, {"instruction": "Generate java code\nsole entry point to application , as always . ", "input": " PlaceHolder placeHolder \n void printCapitalized", "output": "void function ( String [ ] arg0 ) { String loc0 ; TextIO . putln ( \"srini_string\" ) ; loc0 = TextIO . getln ( ) ; TextIO . putln ( ) ; TextIO . putln ( \"srini_string\" ) ; printCapitalized ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturn the events of interest to this recorder . ", "input": " Resolver resolver \n ActionListener al \n long lastEventTime \n long getLastEventTime \n void recordEvent \n void insertStep \n Step createStep \n void addActionListener \n Step getStep \n void record \n void start \n void terminate \n ActionListener getListener \n Resolver getResolver \n void setStatus", "output": "long function ( ) { return - 1 ; }"}, {"instruction": "Generate java code\nthis method sets a new aggregate of the complexity of the solved queries at a certain level . the complexity is attained by varying the conditions of a query . ", "input": " MetricsAggregate peerVariation \n int counter \n MetricsAggregate conditionVarition \n int getCounter \n void setPeerVariation \n MetricsAggregate getConditionVarition \n MetricsAggregate getPeerVariation \n void setCounter", "output": "void function ( MetricsAggregate arg0 ) { this . conditionVarition = arg0 ; }"}, {"instruction": "Generate java code\nperform the click . this is intended to be overridden in subclasses ", "input": " BasicWidgetSelector _selector \n boolean unspecifiedXY \n Point getXYOffset \n IWidgetLocator click \n IWidgetLocator contextClick", "output": "Widget function ( int arg0 , Widget arg1 , Point arg2 , int arg3 ) { return _selector . click ( arg1 , arg2 . x , arg2 . y , arg3 , arg0 ) ; }"}, {"instruction": "Generate java code\nsets a value in an object ", "input": " PlaceHolder placeHolder \n Object getMapValue \n Iterable<? extends Object> toIterable \n Collection<String> getPropertyKeys \n int length \n boolean isArray \n Object getArrayIndex \n Object getArrayIndex \n void setArrayIndex \n void removeProperty \n boolean isMap \n Object unwrap", "output": "void function ( Object arg0 , Object arg1 , Object arg2 ) { if ( isMap ( arg0 ) ) ( ( Map ) arg0 ) . put ( arg1 . toString ( ) , arg2 ) ; else { throw new JsonPathException ( \"srini_string\" + arg0 != null ? arg0 . getClass ( ) . getName ( ) : \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nget a topology id from the name of a topology ", "input": " PlaceHolder placeHolder \n void disconnect \n void workerHeartbeat \n List<String> assignments \n ErrorInfo lastError \n void addNimbusHost \n List<String> blobstoreInfo \n void updateStorm \n List<String> backpressureTopologies \n void removeStorm \n void setupBackpressure \n void workerBackpressure \n VersionedData<Assignment> assignmentInfoWithVersion \n ClusterWorkerHeartbeat getWorkerHeartbeat \n List<NimbusSummary> nimbuses \n void removeWorkerBackpressure \n List<ProfileRequest> getWorkerProfileRequests \n StormBase stormBase \n void removeKeyVersion \n List<String> activeStorms \n void removeStormBase \n Map<String,StormBase> topologyBases \n void supervisorHeartbeat \n void removeBlobstoreKey \n List<String> blobstore \n void removeWorkerHeartbeat \n List<String> errorTopologies \n Map<String,SupervisorInfo> allSupervisorInfo \n Map<String,SupervisorInfo> allSupervisorInfo \n Integer assignmentVersion \n List<ErrorInfo> errors \n void setupHeatbeats \n Credentials credentials \n List<String> heartbeatStorms \n Map<String,Assignment> topologyAssignments \n List<String> activeKeys \n void setCredentials \n boolean topologyBackpressure \n void setupBlobstore \n LogConfig topologyLogConfig \n void setTopologyLogConfig \n void removeBackpressure \n void setWorkerProfileRequest \n void activateStorm \n void setAssignment \n SupervisorInfo supervisorInfo \n void reportError \n List<ProfileRequest> getTopologyProfileRequests \n void deleteTopologyProfileRequests \n void teardownHeartbeats \n Assignment assignmentInfo \n Map<ExecutorInfo,ExecutorBeat> executorBeats \n List<String> supervisors \n void teardownTopologyErrors", "output": "Optional < String > function ( final String arg0 ) { String loc0 = null ; for ( String loc1 : activeStorms ( ) ) { String loc2 = stormBase ( loc1 , null ) . get_name ( ) ; if ( arg0 . equals ( loc2 ) ) { loc0 = loc1 ; break ; } } return Optional . ofNullable ( loc0 ) ; }"}, {"instruction": "Generate java code\nadds the specified string as an additional reason ", "input": " Invariant inv \n String discardFormat \n String discardString \n DiscardCode discardCode \n String className \n String discardFormat \n void add_implied_vis \n String discardString \n DiscardCode discardCode \n String format \n String className", "output": "void function ( String arg0 ) { discardString += \"srini_string\" + arg0 ; }"}, {"instruction": "Generate java code\nreturn the osc byte stream for this packet . ", "input": " byte[] byteArray \n boolean isByteArrayComputed \n void init \n void computeByteArray \n void computeByteArray", "output": "byte [ ] function ( ) { if ( ! isByteArrayComputed ) computeByteArray ( ) ; return byteArray ; }"}, {"instruction": "Generate java code\nreturn all root components in the current awt hierarchy . ", "input": " Collection EMPTY \n WindowTracker tracker \n Hierarchy defaultHierarchy \n boolean contains \n Container getParent \n Collection getComponents \n Collection findInternalFramesFromIcons \n Hierarchy getDefault \n void dispose \n void setDefault", "output": "Collection function ( ) { return tracker . getRootWindows ( ) ; }"}, {"instruction": "Generate java code\nreturns an absolute path to krb5.conf file . ", "input": " File keyTabFileName \n Logger LOGGER \n String password \n String origKrbDebug \n String origKrb5Conf \n String KRB5_CONF \n File KRB5_CONF_FILE \n String origIbmKrbDebug \n File HTTP_KEYTAB_FILE \n String origIbmJGSSDebug \n String user \n File WORK_DIR \n void createKeytab \n String getPassword \n String getKeyTabFullPath \n List<UserForKeyTab> kerberosUsers \n void createServerKeytab \n String getUser \n File getKeyTabFileName \n void setup \n String getSupportedEncTypes \n void tearDown", "output": "String function ( ) { return KRB5_CONF_FILE . getAbsolutePath ( ) ; }"}, {"instruction": "Generate java code\ncopy bigdecimal element c. ", "input": " java.math.BigDecimal val \n int DEFAULT_PRECISION \n BigDecimal ZERO \n MathContext DEFAULT_CONTEXT \n MathContext context \n BigDecimal ONE \n Random random \n boolean isField \n boolean isCommutative \n BigDecimal gcd \n BigDecimal sum \n int compareTo \n java.math.BigInteger characteristic \n BigDecimal random \n BigDecimal random \n BigDecimal random \n BigDecimal random \n int hashCode \n BigDecimal divide \n BigDecimal multiply \n int signum \n boolean isONE \n BigDecimal inverse \n BigDecimal valueOf \n BigDecimal valueOf \n boolean isUnit \n BigDecimal subtract \n BigDecimal parse \n BigDecimal parse \n BigDecimal[] egcd \n BigDecimal abs \n BigDecimal[] divideAndRemainder \n BigDecimal negate \n boolean equals \n BigDecimal clone \n BigDecimal getONE \n BigDecimal getZERO \n BigDecimal fromInteger \n BigDecimal fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigDecimal remainder", "output": "BigDecimal function ( BigDecimal arg0 ) { return new BigDecimal ( arg0 . val , arg0 . context ) ; }"}, {"instruction": "Generate java code\nthe string encoding used for decoding and encoding . ", "input": " String charset \n int RADIX \n byte ESCAPE_CHAR \n BitSet WWW_FORM_URL \n byte[] encode \n String encode \n String encode \n Object encode \n byte[] decodeUrl \n String getDefaultCharset \n byte[] decode \n String decode \n String decode \n Object decode \n byte[] encodeUrl", "output": "String function ( ) { return this . charset ; }"}, {"instruction": "Generate java code\nexports the given test run session into an xml report file . ", "input": " IPath JUNIT3_CONTAINER_PATH \n String JUNIT_CONTAINER_ID \n IPath JUNIT4_CONTAINER_PATH \n IType[] findTestTypes \n ITestRunSession importTestRunSession \n ITestRunSession importTestRunSession \n void addTestRunListener \n void addTestRunListener \n void removeTestRunListener \n void removeTestRunListener", "output": "void function ( ITestRunSession arg0 , File arg1 ) { JUnitModel . exportTestRunSession ( ( TestRunSession ) arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nfollowing method performs the initialization ", "input": " FileLoggerModule fileLoggerModule \n ConsoleLoggerModule consoleLoggerModule \n void unprepare \n void main \n void execute", "output": "void function ( ) { fileLoggerModule = FileLoggerModule . getSingleton ( ) . prepare ( ) ; consoleLoggerModule = ConsoleLoggerModule . getSingleton ( ) . prepare ( ) ; }"}, {"instruction": "Generate java code\ncreate a new closure that calls each closure in turn , passing the result into the next closure . the ordering is that of the iterator method on the collection . ", "input": " PlaceHolder placeHolder \n Closure nopClosure \n Closure switchClosure \n Closure switchClosure \n Closure switchClosure \n Closure forClosure \n Closure invokerClosure \n Closure invokerClosure \n Closure ifClosure \n Closure whileClosure \n Closure doWhileClosure \n Closure switchMapClosure \n Closure asClosure \n Closure exceptionClosure", "output": "Closure function ( Collection arg0 ) { return ChainedClosure . getInstance ( arg0 ) ; }"}, {"instruction": "Generate java code\nfind the mapping associated with this condition or null if no associated mapping can be found . ", "input": " List _mappings \n IHandler handler \n IConditionMonitor _parent \n ICondition condition \n ConditionMonitor ROOT \n boolean _isProcessing \n ConditionMapping[] _cachedMappings \n void add \n void add \n void removeAll \n int process \n boolean test \n ICondition[] getConditions \n ConditionMonitor getInstance \n void removeHandler", "output": "ConditionMapping function ( ICondition arg0 ) { ConditionMapping loc0 ; synchronized ( _mappings ) { for ( Iterator loc1 = _mappings . iterator ( ) ; loc1 . hasNext ( ) ; ) { loc0 = ( ConditionMapping ) loc1 . next ( ) ; if ( loc0 . arg0 == arg0 ) return loc0 ; } } return null ; }"}, {"instruction": "Generate java code\ncheck to see if a test is running . this can be used to see whether the runtime is executing in the context of a test run or a recording session . ", "input": " ITestIdentifier _runningTest \n TestMonitor _monitor \n void endTestCase \n String getCurrentTestCaseID \n ITestIdentifier getRunningTest \n void logTestStart \n void beginTest \n String getId \n void beginTestCase \n TestMonitor getInstance \n NoRunningTestId noTest \n void setRunningTest", "output": "boolean function ( ) { return _runningTest != noTest ( ) ; }"}, {"instruction": "Generate java code\nget response header , not avaliable now ", "input": " boolean isInCache \n int responseCode \n String responseBody \n Map<String,Object> responseHeaders \n boolean isInitExpiredTime \n int type \n String url \n long expiredTime \n boolean isInCache \n long getExpiresInMillis \n HttpResponse setInCache \n void setResponseHeader \n void setExpiredTime \n String getResponseBody \n void setResponseCode \n void setResponseHeaders \n void setType \n long getExpiredTime \n void setUrl \n String getUrl \n String getExpiresHeader \n long getCacheControlMaxAge \n int getType \n int getResponseCode \n Map<String,Object> getResponseHeaders \n void setResponseBody \n boolean isExpired", "output": "Object function ( String arg0 ) { return responseHeaders == null ? null : responseHeaders . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the data trimmed to the length of the actual payload read , caching the result . ", "input": " byte[] consumedData \n int consumedLength \n String LOGTAG \n ConsumedInputStream readFully \n void safeStreamClose \n byte[] truncateBytes \n byte[] getData", "output": "byte [ ] function ( ) { if ( consumedData . length == consumedLength ) { return consumedData ; } consumedData = truncateBytes ( consumedData , consumedLength ) ; return consumedData ; }"}, {"instruction": "Generate java code\nreturns the hover 's class name . ", "input": " String fModifierString \n String VALUE_SEPARATOR \n String NO_MODIFIER \n IConfigurationElement fElement \n boolean fIsEnabled \n int fStateMask \n String ACTIVATE_PLUG_IN_ATTRIBUTE \n String JAVA_EDITOR_TEXT_HOVER_EXTENSION_POINT \n String ID_ATTRIBUTE \n String LABEL_ATTRIBUTE \n String DISABLED_TAG \n String CLASS_ATTRIBUTE \n String DESCRIPTION_ATTRIBUTE \n String HOVER_TAG \n boolean canActivatePlugIn \n String getLabel \n String getId \n String getModifierString \n String getDescription \n JavaEditorTextHoverDescriptor[] getContributedHovers \n int getStateMask \n void initializeFromPreferences \n int computeStateMask \n int hashCode \n IConfigurationElement getConfigurationElement \n boolean equals \n boolean isEnabled \n JavaEditorTextHoverDescriptor[] createDescriptors \n IJavaEditorTextHover createTextHover", "output": "String function ( ) { return fElement . getAttribute ( CLASS_ATTRIBUTE ) ; }"}, {"instruction": "Generate java code\nan unsafe operation that returns a bytestring that is backed by a subregion of theprovided buffer . ", "input": " PlaceHolder placeHolder \n void unsafeWriteTo", "output": "ByteString function ( byte [ ] arg0 , int arg1 , int arg2 ) { return ByteString . wrap ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nget last section . ", "input": " Optional<String> fileName \n long serialVersionUID \n boolean built \n Set<PreprocessorRule> preprocessorRules \n List<Section> sections \n RedPenTokenizer tokenizer \n DocumentBuilder appendSection \n void ensureNotBuilt \n DocumentBuilder addSection \n DocumentBuilder addSection \n DocumentBuilder setPreprocessorRules \n Set<PreprocessorRule> getPreprocessorRules \n DocumentBuilder setFileName \n Iterator<Section> iterator \n Section getSection \n Section getSection \n DocumentBuilder addSectionHeader \n int size \n DocumentBuilder addSentence \n DocumentBuilder addSentence \n Document build \n int hashCode \n boolean equals \n DocumentBuilder builder \n DocumentBuilder builder \n String toString \n DocumentBuilder addParagraph \n DocumentBuilder addListBlock \n Optional<String> getFileName \n DocumentBuilder addListElement \n DocumentBuilder addListElement", "output": "Section function ( ) { Section loc0 = null ; if ( sections . size ( ) > 0 ) { loc0 = sections . get ( sections . size ( ) - 1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nencodes the given string into a sequence of bytes using the utf-16 charset , storing the result into a new byte array . ", "input": " PlaceHolder placeHolder \n byte[] getBytesUtf16Le \n String newStringUsAscii \n String newStringUtf8 \n byte[] getBytesUnchecked \n byte[] getBytesIso8859_1 \n byte[] getBytesUtf16Be \n IllegalStateException newIllegalStateException \n byte[] getBytesUsAscii \n String newStringIso8859_1 \n String newString \n byte[] getBytesUtf8 \n String newStringUtf16 \n String newStringUtf16Le \n String newStringUtf16Be", "output": "byte [ ] function ( String arg0 ) { return StringUtils . getBytesUnchecked ( arg0 , CharEncoding . UTF_16 ) ; }"}, {"instruction": "Generate java code\nreturn the quadrant of a block of equal size that is adjacent to the given side of this quadrant . ", "input": " PlaceHolder placeHolder \n boolean adjacent \n QuadTreeNode child", "output": "Quadrant function ( int arg0 ) { if ( arg0 == QuadTreeNode . WEST || arg0 == QuadTreeNode . EAST ) { return cSouthEast ; } return cNorthWest ; }"}, {"instruction": "Generate java code\nmethod to test getcoltotal ", "input": " PlaceHolder placeHolder \n void testGetCount \n void testGetLargest \n void testSetMatrix \n void testFillPattern1 \n void testGetTotal \n void testGetColTotal \n void testGetTotalNested", "output": "void function ( String [ ] arg0 ) { testSetMatrix ( ) ; testFillPattern1 ( ) ; testGetCount ( ) ; testGetTotal ( ) ; testGetTotalNested ( ) ; testGetLargest ( ) ; testGetColTotal ( ) ; ( origin / master ) = $missing$ ; }"}, {"instruction": "Generate java code\nsetitem sets this node 's item to `` item '' . if this node is invalid , throws an exception . performance : runs in o 1 time . ", "input": " Object item \n List myList \n ListNode next \n Object item \n ListNode prev \n boolean isValidNode \n void insertAfter \n void remove \n void insertBefore", "output": "void function ( Object arg0 ) { if ( ! isValidNode ( ) ) { throw new InvalidNodeException ( ) ; } this . item = arg0 ; }"}, {"instruction": "Generate java code\nstarts the input task of a device . ", "input": " int latencyTimer \n int usbReceiveBufferSize \n String configFile \n int readTimeout \n Logger logger \n int writeTimeout \n int usbTransmitBufferSize \n int resetPipeRetryCount \n Device[] listDevicesBySerialNumber \n Device[] listDevicesByType \n void configureDevice \n void stopInputTask \n void stopInputTask \n void loadProperties \n void loadProperties \n void initializeProperties \n Device[] listDevices \n Device[] listDevicesByDescription", "output": "void function ( Device arg0 ) { startInputTask ( arg0 . getHandle ( ) ) ; }"}, {"instruction": "Generate java code\nget the end label of the protected block . ", "input": " Label handler \n Label start \n Label end \n Type type \n Label handler \n void setHandler \n Label start \n String toString \n Type type", "output": "Label function ( ) { return end ; }"}, {"instruction": "Generate java code\nreturns the linked list node after this one . ", "input": " TLinkable _next \n TLinkable _previous \n TLinkable getPrevious \n void setNext \n void setPrevious", "output": "TLinkable function ( ) { return _next ; }"}, {"instruction": "Generate java code\ndelegate the call to the internal java.util.concurrent.locks.reentrantreadwritelock instanceand then increment the read lock count held by the thread ", "input": " ThreadLocal<Integer> readLockCount \n ReentrantReadWriteLock delegate \n Lock readLock \n long serialVersionUID \n Lock writeLock \n void checkLoopback \n void decReadLockCount \n void lockInterruptibly \n void lockInterruptibly \n void unlock \n void unlock \n Lock writeLock \n Condition newCondition \n Condition newCondition \n Lock readLock \n boolean tryLock \n boolean tryLock \n boolean tryLock \n boolean tryLock \n void incReadLockCount", "output": "void function ( ) { delegate . readLock ( ) . lock ( ) ; incReadLockCount ( ) ; }"}, {"instruction": "Generate java code\nthis method sets the value of the database column sys_ip_area . end_ip ", "input": " String areaCode \n String IPCODE_UNKNOWN \n String city \n String province \n String edu \n String district \n String company \n Date createTime \n Long endIp \n String owner \n Long startIp \n String country \n boolean isIp \n void setCountry \n Date getCreateTime \n String getCountry \n void setProvince \n long valueOfIpv4 \n String getEdu \n Long getStartIp \n Long getEndIp \n String getOwner \n void setStartIp \n void setOwner \n String getStartIpv4 \n String getEndIpv4 \n String getAreaCode \n String ipv4 \n String getDistrict \n String getProvince \n void setDistrict \n void setCompany \n String getCity \n void setCity \n void setAreaCode \n void setCreateTime \n String getCompany \n void setEdu \n String toString", "output": "void function ( Long arg0 ) { this . endIp = arg0 ; }"}, {"instruction": "Generate java code\nappend a hashcode for a float . ", "input": " int iConstant \n int iTotal \n HashCodeBuilder appendSuper \n int toHashCode", "output": "HashCodeBuilder function ( float arg0 ) { iTotal = iTotal * iConstant + Float . floatToIntBits ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nchecks if this pdfobject is of the type pdfnull . ", "input": " int INDIRECT \n int STRING \n int DICTIONARY \n int NULL \n int NUMBER \n int type \n int NAME \n String NOTHING \n int BOOLEAN \n int ARRAY \n byte[] bytes \n String TEXT_UNICODE \n String TEXT_PDFDOCENCODING \n PRIndirectReference indRef \n int STREAM \n void toPdf \n void setContent \n void setIndRef \n int length \n boolean isStream \n PRIndirectReference getIndRef \n int type \n byte[] getBytes \n boolean isDictionary \n boolean isBoolean \n boolean isName \n boolean isNumber \n boolean isString \n String toString \n boolean canBeInObjStm \n boolean isArray \n boolean isIndirect", "output": "boolean function ( ) { return ( type == NULL ) ; }"}, {"instruction": "Generate java code\ndeletes all the blobs in a container ", "input": " Location mockLocation \n JdbcContainerNameValidator jdbcContainerNameValidator \n JdbcBlobKeyValidator jdbcBlobKeyValidator \n Provider<BlobBuilder> blobBuilders \n JdbcService jdbcService \n BlobEntityToBlob blobEntityToBlob \n void setContainerAccess \n Location getLocation \n ContainerAccess getContainerAccess \n Collection<String> getAllContainerNames \n boolean directoryExists \n String putDirectoryBlob \n Blob getBlob \n Iterable<String> getBlobKeysInsideContainer \n String putBlob \n void setBlobAccess \n boolean createContainerInLocation \n void removeBlob \n boolean blobExists \n void deleteContainer \n StorageMetadata getContainerMetadata \n long countBlobs \n BlobAccess getBlobAccess \n String getSeparator \n boolean containerExists \n void createDirectory \n void deleteDirectory", "output": "void function ( String arg0 ) { jdbcService . deleteBlobsByContainer ( arg0 ) ; }"}, {"instruction": "Generate java code\naccessor for testing only . ", "input": " int num_sets \n int[] this_bits_exception_index \n boolean[] this_bits \n boolean[] this_bits_valid \n boolean debug \n int num_vars \n int[] index \n BitSet[] modbits_arrays \n long serialVersionUID \n int num_samples \n void add \n int split \n BitSet get \n boolean get \n int num_vars \n int num_samples \n void checkRep", "output": "int function ( ) { return num_sets ; }"}, {"instruction": "Generate java code\ntest whether the widget in question is showing . ", "input": " Display _display \n Matcher _matcher \n String toString", "output": "boolean function ( ) { MatchResult loc0 = new WidgetFinder ( ) . find ( _display , _matcher ) ; return loc0 . getType ( ) == WidgetFinder . MATCH ; }"}, {"instruction": "Generate java code\nget the unqualified names of the columns of the owning entity which are to be used in the join . ", "input": " PlaceHolder placeHolder \n String[] getRHSColumnNames \n String getLHSTableName \n String[] toColumns \n String[] getAliasedLHSColumnNames \n String[] getAliasedLHSColumnNames", "output": "String [ ] function ( AssociationType arg0 , int arg1 , OuterJoinLoadable arg2 , Mapping arg3 ) { return getLHSColumnNames ( arg0 , arg1 , 0 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\ncreate the filter controls . ", "input": " Text fTextControl \n ImageDescriptor fgClearIconDescriptor \n Control fClearButton \n Composite fComposite \n Boolean fgUseNativeSearchField \n ImageDescriptor fgDisabledClearIconDescriptor \n boolean useNativeSearchField \n void createTextControl \n void updateClearButtonVisibility \n String getFilterString \n Text getFilterControl \n void createClearButton", "output": "void function ( Composite arg0 ) { createTextControl ( arg0 ) ; createClearButton ( arg0 ) ; updateClearButtonVisibility ( false ) ; }"}, {"instruction": "Generate java code\ngetter for percentage ", "input": " boolean percentage \n float width \n PdfPCell cell \n boolean add \n boolean process \n PdfPCell getCell \n boolean isContent \n boolean isNestable \n PdfPCell createPdfPCell \n float getWidth \n List<Chunk> getChunks \n int type", "output": "boolean function ( ) { return percentage ; }"}, {"instruction": "Generate java code\nis modinteger number a unit . ", "input": " java.math.BigInteger val \n ModIntegerRing ring \n ModInteger MIREM \n java.math.BigInteger getSymmetricVal \n int MISIGN \n ModInteger gcd \n ModInteger sum \n int compareTo \n ModInteger MINEG \n ModInteger MISUM \n int hashCode \n ModInteger MIDIF \n ModInteger divide \n ModInteger multiply \n int signum \n boolean isONE \n ModInteger inverse \n int MICOMP \n java.math.BigInteger getVal \n ModInteger subtract \n ModInteger MIABS \n ModInteger MIINV \n ModInteger[] egcd \n java.math.BigInteger getModul \n ModInteger abs \n ModInteger MIQ \n ModInteger negate \n boolean equals \n ModInteger clone \n boolean isZERO \n String toString \n ModInteger MIPROD \n ModInteger remainder", "output": "boolean function ( ) { if ( isZERO ( ) ) { return false ; } if ( ring . isField ( ) ) { return true ; } java . math . BigInteger loc0 = ring . modul . gcd ( val ) . abs ( ) ; return ( loc0 . equals ( java . math . BigInteger . ONE ) ) ; }"}, {"instruction": "Generate java code\nreturns the record 's header . ", "input": " ByteBuffer myData \n Header myHeader \n Header myConnectionHeader \n SeekableByteChannel myChannel \n int headerLength \n Logger myLogger \n long myDataOffset \n int myDataLength \n void readData \n Header getConnectionHeader \n void setConnectionHeader \n ByteBuffer getData", "output": "Header function ( ) { return myHeader ; }"}, {"instruction": "Generate java code\nreturns a duration corresponding to the the given value in days . ", "input": " Map<String,Object> windowConfiguration \n TimestampExtractor timestampExtractor \n int value \n Logger LOG \n BaseWindowedBolt withWindow \n BaseWindowedBolt withWindow \n BaseWindowedBolt withWindow \n BaseWindowedBolt withWindow \n BaseWindowedBolt withWindow \n BaseWindowedBolt withWindow \n Map<String,Object> getComponentConfiguration \n void prepare \n void declareOutputFields \n Duration hours \n BaseWindowedBolt withWindowLength \n BaseWindowedBolt withWindowLength \n TimestampExtractor getTimestampExtractor \n Duration minutes \n BaseWindowedBolt withLag \n BaseWindowedBolt withTimestampExtractor \n BaseWindowedBolt withWatermarkInterval \n Duration seconds \n BaseWindowedBolt withTumblingWindow \n BaseWindowedBolt withTumblingWindow \n BaseWindowedBolt withSlidingInterval \n BaseWindowedBolt withSlidingInterval \n void cleanup \n int hashCode \n int hashCode \n Count of \n Duration of \n boolean equals \n boolean equals \n BaseWindowedBolt withTimestampField \n Duration days \n String toString \n String toString \n BaseWindowedBolt withLateTupleStream", "output": "Duration function ( int arg0 ) { return new Duration ( arg0 , TimeUnit . DAYS ) ; }"}, {"instruction": "Generate java code\nreturn the class loader to be used for instantiating application objects when a context class loader is not specified . this is determined based upon the following rules : the specified class loader , if any the class loader used to load the calling class . the system class loader . ", "input": " Log log \n Class loadClass \n Class loadClass", "output": "ClassLoader function ( ClassLoader arg0 , Class arg1 ) { if ( arg0 != null ) { return arg0 ; } return getClassLoader ( arg1 ) ; }"}, {"instruction": "Generate java code\nfactory method to create a new product ", "input": " Product product \n int amount \n double price \n void setProduct \n Product getProduct \n String toString \n void setAmount \n void setPrice \n double getPrice \n int getAmount", "output": "Product function ( ) { return new Product ( ) ; }"}, {"instruction": "Generate java code\nindic languages are written from right to left . ", "input": " int MATRA_E \n int LETTER_HA \n int HALANTA \n int MATRA_AI \n int MATRA_HLR \n int MATRA_I \n int LETTER_A \n int LETTER_KA \n int LETTER_AU \n int MATRA_AA \n char[] langTable \n int MATRA_HLRR \n boolean IsSwaraMatra \n String process \n boolean IsSwaraLetter \n void swap \n boolean IsVyanjana", "output": "boolean function ( ) { return false ; }"}, {"instruction": "Generate java code\ncompares two keys or two values , handling null correctly . ", "input": " List<Entry> entries \n V value \n K key \n K getKey \n Set<Map.Entry<K,V>> entrySet \n boolean containsKey \n Collection<V> values \n void clear \n Entry findEntry \n boolean isEmpty \n void main \n boolean containsValue \n V put \n V remove \n V getValue \n int size \n Collection<? extends java.util.Map.Entry<K,V>> getEntries \n V setValue \n V get \n void putAll \n Set<K> keySet", "output": "boolean function ( Object arg0 , Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0 . equals ( arg1 ) ; }"}, {"instruction": "Generate java code\nsets the new serialnumber . ", "input": " long signature1 \n int productID \n String manufacturer \n int vendorID \n long version \n long signature2 \n String productDescription \n String serialNumber \n int MAX_HEADER_LENGTH \n String manufacturerID \n boolean remoteWakeupCapable \n boolean pnpEnabled \n int maxPower \n boolean selfPowered \n boolean isPnpEnabled \n long getSignature2 \n void setProductID \n void setPnpEnabled \n void setManufacturer \n void setMaxPower \n void setProductDescription \n String getManufacturer \n void setSelfPowered \n long getSignature1 \n void setManufacturerID \n boolean isRemoteWakeupCapable \n String getManufacturerID \n void validate \n int getMaxPower \n long getVersion \n void setSignature1 \n String getSerialNumber \n void setVersion \n void setSignature2 \n String getProductDescription \n int getProductID \n boolean isSelfPowered \n void setRemoteWakeupCapable \n void setVendorID \n int getVendorID", "output": "void function ( String arg0 ) { this . serialNumber = arg0 ; }"}, {"instruction": "Generate java code\nreturns the image descriptor of the described category . ", "input": " String fId \n boolean fIsEnabled \n IConfigurationElement fElement \n boolean fNeedsSortingAfterFiltering \n boolean fIsIncluded \n String ICON \n Expression fEnablementExpression \n int fSortOrder \n String fName \n ImageDescriptor fImage \n String fLastError \n CompletionProposalComputerRegistry fRegistry \n boolean fIsSeparateCommand \n boolean isSeparateCommand \n String getName \n void sessionEnded \n void setSortOrder \n void sessionStarted \n Expression getEnablementExpression \n void setSeparateCommand \n String getId \n void setIncluded \n boolean matches \n Bundle getBundle \n int getSortOrder \n void setEnabled \n void checkNotNull \n String getDisplayName \n boolean isEnabled \n boolean hasComputers \n boolean hasComputers \n boolean isSortingAfterFilteringNeeded \n boolean isIncluded \n List<ICompletionProposal> computeCompletionProposals \n List<IContextInformation> computeContextInformation \n String getErrorMessage", "output": "ImageDescriptor function ( ) { return fImage ; }"}, {"instruction": "Generate java code\nget the type of this request , used by each person in the chain of command to see if they should or can handle this particular request ", "input": " RequestType requestType \n boolean handled \n String requestDescription \n void markHandled \n String toString \n boolean isHandled \n String getRequestDescription", "output": "RequestType function ( ) { return requestType ; }"}, {"instruction": "Generate java code\nadds a view dictionary . part of the richmediacontent . ", "input": " PdfDictionary richMediaSettings \n PdfArray configurations \n PdfArray views \n HashMap<String,PdfIndirectReference> assetsmap \n PdfDictionary richMediaContent \n PdfIndirectReference richMediaContentReference \n PdfWriter writer \n PdfAnnotation annot \n PdfIndirectReference addAsset \n PdfIndirectReference addAsset \n PdfIndirectReference getRichMediaContentReference \n PdfAnnotation createAnnotation \n void setActivation \n PdfIndirectReference addConfiguration \n PdfIndirectReference addConfiguration \n void setDeactivation", "output": "PdfIndirectReference function ( PdfDictionary arg0 ) { if ( views == null ) throw new IllegalPdfSyntaxException ( \"srini_string\" ) ; PdfIndirectReference loc0 = writer . addToBody ( arg0 ) . getIndirectReference ( ) ; views . add ( loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nis local one . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n C num \n int isunit \n C den \n int signum \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n Local<C> abs \n int hashCode \n Local<C> negate \n boolean equals \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "boolean function ( ) { return num . equals ( den ) ; }"}, {"instruction": "Generate java code\nreturn the ruleset to be used for configuring our digester parsing rules , creating one if necessary . ", "input": " boolean useContextClassLoader \n RuleSet ruleSet \n Digester digester \n Digester getDigester \n boolean getUseContextClassLoader \n void setRuleSet \n void parse \n void parse \n void setUseContextClassLoader", "output": "RuleSet function ( ) { if ( ruleSet == null ) { ruleSet = new ConfigRuleSet ( ) ; } return ( ruleSet ) ; }"}, {"instruction": "Generate java code\nreads a value attribute on an element . ", "input": " AttributeParser VALUE \n Map<Attribute,String> readRequiredAttributes \n boolean isParseAsElement \n void parseElement \n String readNameAttribute", "output": "String function ( final XMLExtendedStreamReader arg0 ) { return readRequiredAttributes ( arg0 , EnumSet . of ( Attribute . VALUE ) ) . get ( Attribute . VALUE ) ; }"}, {"instruction": "Generate java code\nget the last component of a name . ", "input": " PlaceHolder placeHolder \n Context createSubcontext \n void rebind \n void rebind \n void unbind \n void unbind \n boolean isEmpty \n NameNotFoundException nameNotFoundException \n NameAlreadyBoundException nameAlreadyBoundException \n NotContextException notAContextException \n boolean isLastComponentEmpty \n NamingException namingException \n NamingException namingException \n CannotProceedException cannotProceedException \n InvalidNameException emptyNameException \n NamingEnumeration<T> namingEnumeration", "output": "String function ( final Name arg0 ) { if ( arg0 . size ( ) > 0 ) return arg0 . get ( arg0 . size ( ) - 1 ) ; return \"srini_string\" ; }"}, {"instruction": "Generate java code\nreturns the attribute with the specified name . ", "input": " Map<String,String> fAttributes \n String fProject \n String toString \n String getProject", "output": "String function ( final String arg0 ) { return fAttributes . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the default target of the switch . ", "input": " Label defaultTarget \n int[] values \n Label[] targets \n int lowValue \n boolean hasContiguousValues \n int partition \n int highValue \n int[] values \n void uniq \n void setDefaultTarget \n String toString \n void sort \n Label[] targets \n void quicksort", "output": "Label function ( ) { return defaultTarget ; }"}, {"instruction": "Generate java code\ngetter for text rise ", "input": " boolean knockout \n LineDashPattern lineDashPattern \n BaseColor fillColor \n float wordSpacing \n float leading \n BaseColor strokeColor \n int lineJoinStyle \n float miterLimit \n int lineCapStyle \n float lineWidth \n int renderMode \n PdfName colorSpaceFill \n PdfName colorSpaceStroke \n float fontSize \n float rise \n Matrix ctm \n float horizontalScaling \n float characterSpacing \n CMapAwareDocumentFont font \n float getFontSize \n int getRenderMode \n void setLineDashPattern \n int getLineJoinStyle \n PdfName getColorSpaceStroke \n float getCharacterSpacing \n void setLineWidth \n Matrix getCtm \n void setLineCapStyle \n PdfName getColorSpaceFill \n float getMiterLimit \n float getLineWidth \n float getWordSpacing \n boolean isKnockout \n BaseColor getFillColor \n CMapAwareDocumentFont getFont \n void setMiterLimit \n BaseColor getStrokeColor \n int getLineCapStyle \n float getLeading \n LineDashPattern getLineDashPattern \n float getHorizontalScaling \n void setLineJoinStyle", "output": "float function ( ) { return rise ; }"}, {"instruction": "Generate java code\ndisables the listeners and calls initializewithoutlistenersfrom . listeners are disabled because it is common for listeners to be used for saving launch configurations . if a the configuration is saved during initialization , it is possible for attributes necessary for other options to be erased . ", "input": " List<IOptionChangeListener> fListeners \n boolean fListeneredDisabled \n void removeChangeListener \n void initializeWithoutListenersFrom \n void notifyListeners \n void addChangeListener", "output": "void function ( ILaunchConfiguration arg0 ) { fListeneredDisabled = true ; initializeWithoutListenersFrom ( arg0 ) ; fListeneredDisabled = false ; }"}, {"instruction": "Generate java code\nget removed pair number . ", "input": " boolean useCriterion4 \n GenPolynomial<C> pi \n int i \n GenPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n MiniPair toMiniPair \n void setUseCriterion3 \n boolean equals \n boolean getUseCriterion3 \n void setZero \n boolean isZero \n void setUseCriterion4 \n String toString \n int compareTo \n void pairNumber \n boolean getUseCriterion4", "output": "int function ( ) { return n ; }"}, {"instruction": "Generate java code\ntry to make a date mime rfc 2822/5322 - compliant . it fixes : - `` thu , 10 dec 09 15:08:08 gmt-0700 '' to `` thu , 10 dec 09 15:08:08 -0700 '' 4 digit zone value ca n't be preceded by `` gmt '' we got a report saying ebay sends a date in this format ", "input": " int WARN \n Boolean sDebugLoggingEnabledForTests \n Pattern DATE_CLEANUP_PATTERN_WRONG_TIMEZONE \n int VERBOSE \n int MAX_ENABLED_LOG_LEVEL \n int ERROR \n int DEBUG \n int INFO \n String TAG \n boolean isLoggable \n int d \n int d \n int e \n int e \n int v \n int v \n int w \n int w \n int wtf \n int wtf \n String byteToHex \n StringBuilder byteToHex \n int i \n int i \n boolean buildPreventsDebugLogging \n boolean isDebugLoggingEnabled \n void setDebugLoggingEnabledForTests", "output": "String function ( String arg0 ) { if ( TextUtils . isEmpty ( arg0 ) ) { return arg0 ; } arg0 = DATE_CLEANUP_PATTERN_WRONG_TIMEZONE . matcher ( arg0 ) . replaceFirst ( \"srini_string\" ) ; return arg0 ; }"}, {"instruction": "Generate java code\nanswer the product associated with the receiver ", "input": " IProduct product \n String INDENT \n void printPlatformInfo \n String getInstallationLocation \n void printInfo \n void printPrefPageInfo \n String getPrefPageInfo \n String getPrefPageFeedback \n void printProductInfo \n void printSupportInfo \n String getAuthorNames \n IStatus getLastStatus \n int getCurrentYear", "output": "IProduct function ( ) { return product ; }"}, {"instruction": "Generate java code\nclear cache ", "input": " Node next \n Map<String,Node> cache \n Node head \n Node previous \n Logger LOGGER \n UserAccount userAccount \n Node end \n String userId \n int capacity \n boolean contains \n void set \n UserAccount getLruData \n UserAccount get \n void setHead \n List<UserAccount> getCacheDataInListForm \n void invalidate \n boolean isFull \n void setCapacity \n void remove", "output": "void function ( ) { head = null ; end = null ; cache . clear ( ) ; }"}, {"instruction": "Generate java code\nutility for safely populating an output cryptorecord . ", "input": " boolean deleted \n long sortIndex \n String guid \n String collection \n long lastModified \n long ttl \n long androidID \n boolean equalTimestamps \n String toJSONString \n boolean equalIdentifiers \n byte[] toJSONBytes \n void populatePayload \n boolean equalAndroidIDs \n void initFromPayload \n boolean congruentWith \n boolean equalPayloads \n boolean equals \n void checkGUIDs \n Record copyWithIDs \n boolean congruentAndroidIDs \n CryptoRecord getEnvelope \n boolean equalSortIndices \n void initFromEnvelope", "output": "void function ( CryptoRecord arg0 , String arg1 , String arg2 ) { if ( arg2 == null ) { return ; } arg0 . payload . put ( arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\ntest if the given composed message matches the expected message ", "input": " PrintStream realStdOut \n ByteArrayOutputStream stdOutBuffer \n void testMessageFromElves \n void setUp \n void testMessageFromOrcs \n void tearDown", "output": "void function ( final LetterComposite arg0 , final String arg1 ) { final String [ ] loc0 = arg1 . split ( \"srini_string\" ) ; assertNotNull ( arg0 ) ; assertEquals ( loc0 . length , arg0 . count ( ) ) ; arg0 . print ( ) ; assertEquals ( arg1 , new String ( this . stdOutBuffer . toByteArray ( ) ) . trim ( ) ) ; }"}, {"instruction": "Generate java code\ndeprecated . ", "input": " Map<String,NamedParameterDescriptor> namedDescriptorMap \n OrdinalParameterDescriptor[] ordinalDescriptors \n OrdinalParameterDescriptor[] EMPTY_ORDINALS \n int getOrdinalParameterSourceLocation \n NamedParameterDescriptor getNamedParameterDescriptor \n Type getOrdinalParameterExpectedType \n Type getNamedParameterExpectedType \n OrdinalParameterDescriptor getOrdinalParameterDescriptor \n int getOrdinalParameterCount \n Set<String> getNamedParameterNames", "output": "int [ ] function ( String arg0 ) { return getNamedParameterDescriptor ( arg0 ) . getSourceLocations ( ) ; }"}, {"instruction": "Generate java code\ntest for the existence of the given project . ", "input": " IProject _project \n boolean _exists \n String toString", "output": "boolean function ( ) { return _exists == _project . exists ( ) ; }"}, {"instruction": "Generate java code\nconvert integer array to int array ", "input": " PlaceHolder placeHolder \n String nullStrToEmpty \n Long[] transformLongArray \n long[] transformLongArray \n int compare \n boolean isEquals", "output": "int [ ] function ( Integer [ ] arg0 ) { int [ ] loc0 = new int [ arg0 . length ] ; for ( int loc1 = 0 ; loc1 < arg0 . length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }"}, {"instruction": "Generate java code\nallows for setting of the color using int codes . ", "input": " boolean border \n Position position \n ConsoleSystemInterface si \n int width \n String spaces \n Position inPosition \n int inHeight \n CSIColor foreColor \n int height \n CSIColor borderColor \n int inWidth \n void drawBorder \n void clearBox \n void setBorderColor \n void setBorderColor \n void recalcInnerBounds \n int getForeColor \n int getWidth \n void draw \n void setWidth \n void setHeight \n void setBounds \n void setPosition \n int getHeight \n void setBorder \n boolean hasBorder", "output": "void function ( int arg0 ) { this . foreColor = this . foreColor . getColorFromCode ( arg0 ) ; }"}, {"instruction": "Generate java code\naddoperator runs operator through calculate as soon as it gets it so the stack is always up to date . ", "input": " Stack<Double> operands \n Stack<OperationsInterface> operators \n int size \n void debugPrintStacks \n void clear \n void addGrouping \n double getTotal \n void calculate \n void addOperand", "output": "void function ( Operator arg0 ) { calculate ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the screen brightness for this activity . the screen brightness will change immediately . as soon as the activity terminates , the brightness will return to the system brightness . valid brightnesses range from 0 to 255 . ", "input": " int SCREEN_BRIGHTNESS_MODE_AUTOMATIC \n int SCREEN_BRIGHTNESS_MODE_MANUAL \n String SCREEN_BRIGHTNESS_MODE \n void setAutoBrightnessEnabled \n int getPhoneBrighness \n boolean supportsAutoBrightness \n boolean getAutoBrightnessEnabled \n int getSystemBrightness \n void setPhoneBrightness \n void setSystemBrightness", "output": "void function ( Window arg0 , int arg1 ) { WindowManager . LayoutParams loc0 = arg0 . getAttributes ( ) ; loc0 . screenBrightness = arg1 / 255.0f ; arg0 . setAttributes ( loc0 ) ; }"}, {"instruction": "Generate java code\nconvert a duration to the number of microseconds.the result will be rounded towards 0 to the nearest microseconds . e.g. , if the duration represents -1 nanosecond , it will be rounded to 0 . ", "input": " BigInteger NANOS_PER_SECOND_BIG_INTEGER \n long DURATION_SECONDS_MAX \n long DURATION_SECONDS_MIN \n long TIMESTAMP_SECONDS_MAX \n long NANOS_PER_SECOND \n long TIMESTAMP_SECONDS_MIN \n Timestamp add \n Duration add \n Duration distance \n Duration createDurationFromMicros \n Timestamp subtract \n Duration subtract \n Timestamp createTimestampFromMillis \n BigInteger toBigInteger \n BigInteger toBigInteger \n Duration createDurationFromNanos \n Timestamp createTimestampFromMicros \n Duration createDurationFromMillis \n Duration createDurationFromBigInteger \n Duration parseDuration \n long toNanos \n long toNanos \n Timestamp getEpoch \n Timestamp parseTimestamp \n String toString \n String toString \n long toMillis \n long toMillis \n Duration divide \n Duration divide \n long divide \n Timestamp createTimestampFromNanos \n Timestamp getCurrentTime \n Duration multiply \n Duration multiply \n Duration remainder \n Duration normalizedDuration", "output": "long function ( Duration arg0 ) { return Durations . toMicros ( arg0 ) ; }"}, {"instruction": "Generate java code\nsetter for the line join style . for possible values see pdfcontentbyte ", "input": " boolean knockout \n LineDashPattern lineDashPattern \n BaseColor fillColor \n float wordSpacing \n float leading \n BaseColor strokeColor \n int lineJoinStyle \n float miterLimit \n int lineCapStyle \n float lineWidth \n int renderMode \n PdfName colorSpaceFill \n PdfName colorSpaceStroke \n float fontSize \n float rise \n Matrix ctm \n float horizontalScaling \n float characterSpacing \n CMapAwareDocumentFont font \n float getFontSize \n int getRenderMode \n void setLineDashPattern \n int getLineJoinStyle \n PdfName getColorSpaceStroke \n float getCharacterSpacing \n void setLineWidth \n Matrix getCtm \n void setLineCapStyle \n PdfName getColorSpaceFill \n float getMiterLimit \n float getLineWidth \n float getWordSpacing \n boolean isKnockout \n BaseColor getFillColor \n CMapAwareDocumentFont getFont \n void setMiterLimit \n float getRise \n BaseColor getStrokeColor \n int getLineCapStyle \n float getLeading \n LineDashPattern getLineDashPattern \n float getHorizontalScaling", "output": "void function ( int arg0 ) { this . lineJoinStyle = arg0 ; }"}, {"instruction": "Generate java code\nis this menu a submenu ? ", "input": " SWTHierarchy _hierarchy \n boolean isOrphanedBy \n boolean isContainedBy", "output": "boolean function ( Menu arg0 ) { return arg0 . getParentMenu ( ) != null ; }"}, {"instruction": "Generate java code\nnotifies handler that an active transaction has completed . ", "input": " int activeInvocationCount \n InjectedValue<DeploymentRepository> deploymentRepositoryInjectedValue \n AtomicIntegerFieldUpdater<EJBSuspendHandlerService> activeTransactionCountUpdater \n boolean gracefulTxnShutdown \n ServerActivityCallback listener \n AtomicReferenceFieldUpdater<EJBSuspendHandlerService,ServerActivityCallback> listenerUpdater \n InjectedValue<SuspendController> suspendControllerInjectedValue \n InjectedValue<LocalTransactionContext> localTransactionContextInjectedValue \n int activeTransactionCount \n AtomicIntegerFieldUpdater<EJBSuspendHandlerService> activeInvocationCountUpdater \n boolean suspended \n ServiceName SERVICE_NAME \n void resume \n void beforeCompletion \n void enableGracefulTxnShutdown \n void invocationComplete \n void doneSuspended \n boolean isSuspended \n void decrementTransactionCount \n void start \n InjectedValue<SuspendController> getSuspendControllerInjectedValue \n void suspended \n void transactionCreated \n EJBSuspendHandlerService getValue \n void stop \n InjectedValue<LocalTransactionContext> getLocalTransactionContextInjectedValue \n InjectedValue<DeploymentRepository> getDeploymentRepositoryInjectedValue \n boolean acceptInvocation \n void preSuspend", "output": "void function ( int arg0 ) { decrementTransactionCount ( ) ; }"}, {"instruction": "Generate java code\nsign a hawk request string . ", "input": " int HAWK_HEADER_VERSION \n long skewSeconds \n String LOG_TAG \n boolean includePayloadHash \n String id \n String HMAC_SHA256_ALGORITHM \n int NONCE_LENGTH_IN_BYTES \n byte[] key \n long getTimestampSeconds \n String getPayloadHashString \n byte[] hmacSha256 \n long now \n String escapeExtraString \n String getBaseContentType \n String escapeExtraHeaderAttribute \n byte[] getPayloadHash \n String getRequestString \n Header getAuthHeader \n Header getAuthHeader", "output": "String function ( byte [ ] arg0 , byte [ ] arg1 ) { return Base64 . encodeBase64String ( hmacSha256 ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nadds a test to the suite . ", "input": " String fName \n Vector fTests \n void setName \n int testCount \n void addTestSuite \n String getName \n void addTestMethod \n void run \n boolean isTestMethod \n Test createTest \n Test testAt \n Enumeration tests \n String exceptionToString \n Constructor getTestConstructor \n Test warning \n String toString \n int countTestCases \n boolean isPublicTestMethod \n void runTest", "output": "void function ( Test arg0 ) { fTests . addElement ( arg0 ) ; }"}, {"instruction": "Generate java code\nyields a flat sequence of elements . any iterable4 or iterator4 found in the original sequence is recursively flattened . ", "input": " Object NO_ELEMENT \n Object SKIP \n Iterator4 EMPTY_ITERATOR \n Iterable4 EMPTY_ITERABLE \n Object next \n Iterable4 crossProduct \n Iterable4 crossProduct \n Iterable4 crossProduct \n Iterable4 iterable \n Iterable4 iterable \n Iterator4<Integer> range \n Object current \n Iterator4 iterator \n Iterator4 iterator \n Iterator4 iterator \n Object[] toArray \n Object[] toArray \n Iterable4 enumerate \n String join \n String join \n String join \n Iterator4 copy \n Iterator4 map \n Iterator4 map \n Iterable4 map \n Iterator4 iterate \n Iterator4 singletonIterator \n boolean moveNext \n Iterable4 singletonIterable \n java.util.Iterator<T> platformIterator \n Iterator4 concat \n Iterator4 concat \n Iterable4 concat \n Iterable4 concat \n Iterator4 concat \n Iterable4 concatMap \n boolean any \n Iterator4<T> filter \n Iterable4 filter \n Iterator4 filter \n Iterator4<T> take \n int size \n int size \n Iterable4<T> series \n void reset \n String toString \n String toString \n Iterable4 append", "output": "Iterator4 function ( Iterator4 arg0 ) { return new FlatteningIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\ncomment on propertydescriptor ", "input": " boolean isTesting \n String typeName \n Clob propertyValue \n Clob exampleValue \n boolean isEncrypted \n String propContName \n Integer descriptorId \n String typeContName \n Integer typeId \n Clob defaultValue \n String resourceName \n String fcExternalKey \n String technicalKey \n String mik \n Integer propContextId \n String origin \n Integer cardinalityProperty \n Integer propertyValueTypeId \n String displayName \n String fcOwner \n Integer propertyId \n Integer masterTypeId \n boolean isNullable \n String fcExternalLink \n String validationRegex \n String loadedFor \n boolean isOptional \n String validationLogic \n String descriptorOrigin \n Integer typeContextId \n Clob propertyComment \n ResourceEditPropertyBuilder withDisplayAndTechKeyName \n ResourceEditPropertyBuilder withOrigin \n ResourceEditPropertyBuilder withValidationRegex \n ResourceEditPropertyBuilder withIsEncrypted \n ResourceEditPropertyBuilder withDescriptorOrigin \n Clob convert \n ResourceEditPropertyBuilder withTechnicalKey \n ResourceEditPropertyBuilder withMasterResTypeName \n ResourceEditPropertyBuilder withLoadedFor \n ResourceEditPropertyBuilder withDisplayName \n ResourceEditPropertyBuilder withValue \n ResourceEditPropertyBuilder withFcExternalLink \n ResourceEditPropertyBuilder withDefaultValue \n ResourceEditPropertyBuilder withDescriptorId \n ResourceEditPropertyBuilder withTypeId \n ResourceEditPropertyBuilder withDescriptor \n ResourceEditPropertyBuilder withCardinality \n ResourceEditPropertyBuilder withPropTypeContName \n ResourceEditPropertyBuilder withValidationLogic \n ResourceEditPropertyBuilder withPropertyContextTypeId \n ResourceEditPropertyBuilder withPropertyId \n ResourceEditPropertyBuilder withPropContName \n ResourceEditPropertyBuilder withFcOwner \n ResourceEditPropertyBuilder withMasterResTypeId \n ResourceEditPropertyBuilder withFcExternalKey \n ResourceEditProperty build \n ResourceEditPropertyBuilder withIsTesting \n ResourceEditPropertyBuilder withExampleValue \n ResourceEditPropertyBuilder withResourceName \n ResourceEditPropertyBuilder withPropContextId \n ResourceEditPropertyBuilder withIsNullable", "output": "ResourceEditPropertyBuilder function ( String arg0 ) { this . propertyComment = convert ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\ncreate a condition that tests if the given widget has the expected text . ", "input": " PlaceHolder placeHolder \n String getText", "output": "IUICondition function ( String arg0 ) { return new HasTextCondition ( this , arg0 ) ; }"}, {"instruction": "Generate java code\ncomparison with any other object . ", "input": " Logger logger \n C ideal \n RingFactory<C> ring \n int isField \n Local<C> random \n Local<C> random \n int hashCode \n boolean isField \n Local<C> getONE \n boolean isCommutative \n Local<C> getZERO \n Local<C> fromInteger \n Local<C> fromInteger \n boolean isAssociative \n String toString \n Local<C> parse \n Local<C> parse \n Local<C> copy \n java.math.BigInteger characteristic", "output": "boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof LocalRing ) ) { return false ; } LocalRing < C > loc0 = null ; try { loc0 = ( LocalRing < C > ) arg0 ; } catch ( ClassCastException loc1 ) { } if ( loc0 == null ) { return false ; } if ( ! ring . equals ( loc0 . ring ) ) { return false ; } return ideal . equals ( loc0 . ideal ) ; }"}, {"instruction": "Generate java code\nto be set by the configurator . ", "input": " RandomGenerator rand \n double torusDimensionSize \n int noOfDimensions \n double halfTorusDimensionSize \n double[] rawPos \n double getDistance \n NetPosition getPosition \n void writeBackToXML \n void setNoOfDimensions \n double[] getRawTorusPositionFor \n double[] getRawPos", "output": "void function ( double arg0 ) { this . torusDimensionSize = arg0 ; this . halfTorusDimensionSize = arg0 * 0.5d ; }"}, {"instruction": "Generate java code\nlooks up a handler matching the given request uri . ", "input": " UriPatternMatcher<HttpRequestHandler> matcher \n void unregister \n void register \n String getRequestPath", "output": "HttpRequestHandler function ( final HttpRequest arg0 ) { Args . notNull ( arg0 , \"srini_string\" ) ; return matcher . lookup ( getRequestPath ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nmakes a copy of the internal buffer . ", "input": " int pos \n byte buf[] \n void writeInt \n void writeByte \n byte[] getBuffer \n void writeFloat \n void writeChar \n void writeLong \n void writeBytes \n int size \n void writeCharsAsBytes \n void writeUTF \n void reset \n void writeStringZ \n void writeShort \n void writeChars \n void write \n void write \n void write \n void ensureSpace \n void writeBoolean \n void writeDouble", "output": "byte [ ] function ( ) { byte loc0 [ ] = new byte [ pos ] ; System . arraycopy ( buf , 0 , loc0 , 0 , pos ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn the n'th byte down the stack , where 0 is the top element and size -1 is the bottom element . ", "input": " ArrayByteList list \n byte pop \n int search \n int size \n byte get \n void clear \n byte push \n boolean empty", "output": "byte function ( int arg0 ) { if ( list . isEmpty ( ) ) { throw new EmptyStackException ( ) ; } return list . get ( list . size ( ) - arg0 - 1 ) ; }"}, {"instruction": "Generate java code\nmodinteger remainder . ", "input": " java.math.BigInteger val \n ModIntegerRing ring \n java.math.BigInteger getSymmetricVal \n int MISIGN \n ModInteger gcd \n ModInteger sum \n int compareTo \n ModInteger MINEG \n ModInteger MISUM \n int hashCode \n ModInteger MIDIF \n ModInteger divide \n ModInteger multiply \n int signum \n boolean isONE \n ModInteger inverse \n int MICOMP \n java.math.BigInteger getVal \n boolean isUnit \n ModInteger subtract \n ModInteger MIABS \n ModInteger MIINV \n ModInteger[] egcd \n java.math.BigInteger getModul \n ModInteger abs \n ModInteger MIQ \n ModInteger negate \n boolean equals \n ModInteger clone \n boolean isZERO \n String toString \n ModInteger MIPROD \n ModInteger remainder", "output": "ModInteger function ( ModInteger arg0 , ModInteger arg1 ) { if ( arg0 == null ) return null ; return arg0 . remainder ( arg1 ) ; }"}, {"instruction": "Generate java code\nadds a measured rtt to monitor . if there is still a rtt , it will be replaced , if the new one is smaller ", "input": " int MONITOR \n AverageAccumulator avgPingAttemptsPerNode \n long serialVersionUID \n double latitude \n String city \n String isp \n boolean locatable \n boolean useCountryNames \n int type \n String countryCode \n GnpPosition coordinateRef \n HostMap mapRef \n int HOST \n String area \n int ipAddress \n HashMap<Host,List<Double>> rttToMonitors \n CumulateRTTStrategy currentStrategy \n HashMap<Host,Double> cumulatedRTTs \n int isNotLocatable \n int regionNotFound \n double longitude \n int ccNotFound \n String region \n int cityNotFound \n String countryName \n boolean issetUseCountryNames \n void setUseCountryNames \n void setPositionReference \n int getIpAddress \n int getHostType \n void setLocation \n int hashCode \n String getISP \n String getCountryName \n Set<Host> getMeasuredMonitors \n boolean isLocatable \n String getCity \n void removeRTT \n String getCountryCode \n void printLocatorStats \n double getLongitude \n double getLatitude \n void setHostType \n double getAvgPingAttemptsPerNode \n Double cumulate \n void setRtt \n double getRtt \n String getRegion \n boolean equals \n void setRTTCumulationStrategy \n void cumulateRTTsCond \n String toString \n String getArea \n GnpPosition getGnpPositionReference", "output": "void function ( Host arg0 , double arg1 ) { if ( cumulatedRTTs != null ) throw new IllegalStateException ( \"srini_string\" ) ; List < Double > loc0 = rttToMonitors . get ( arg0 ) ; if ( loc0 == null ) { loc0 = new ArrayList < Double > ( 10 ) ; rttToMonitors . put ( arg0 , loc0 ) ; } loc0 . add ( arg1 ) ; }"}, {"instruction": "Generate java code\nconfigures the fragment to be one that defines encryption data of the specified length . #definesencryptiondata is set to true , #sampleencryptiondatalength is set tothe specified length , and #sampleencryptiondata is resized if necessary such that itis at least this length . ", "input": " boolean definesEncryptionData \n int length \n boolean sampleEncryptionDataNeedsFill \n boolean[] sampleIsSyncFrameTable \n int sampleEncryptionDataLength \n boolean[] sampleHasSubsampleEncryptionTable \n long auxiliaryDataPosition \n long[] sampleDecodingTimeTable \n ParsableByteArray sampleEncryptionData \n int[] sampleSizeTable \n DefaultSampleValues header \n int[] sampleCompositionTimeOffsetTable \n long dataPosition \n long getSamplePresentationTime \n void initTables \n void reset \n void fillEncryptionData \n void fillEncryptionData", "output": "void function ( int arg0 ) { if ( sampleEncryptionData == null || sampleEncryptionData . limit ( ) < arg0 ) { sampleEncryptionData = new ParsableByteArray ( arg0 ) ; } sampleEncryptionDataLength = arg0 ; definesEncryptionData = true ; sampleEncryptionDataNeedsFill = true ; }"}, {"instruction": "Generate java code\nscalar / dot product of this vector with other vector . ", "input": " List<C> val \n Logger logger \n GenVectorModul<C> modul \n int signum \n GenVector<C> leftLinearCombination \n GenVector<C> rightScalarProduct \n GenVector<C> subtract \n GenVector<C> scalarMultiply \n GenVector<C> sum \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n int compareTo \n GenVector<C> leftScalarMultiply \n GenVector<C> abs \n int hashCode \n GenVector<C> negate \n boolean equals \n GenVector<C> clone \n boolean isZERO \n String toString", "output": "C function ( GenVector < C > arg0 ) { C loc0 = modul . coFac . getZERO ( ) ; List < C > loc1 = arg0 . val ; int loc2 = 0 ; for ( C loc3 : val ) { C loc4 = loc3 . multiply ( loc1 . get ( loc2 ++ ) ) ; loc0 = loc0 . sum ( loc4 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns the previous trace point that had to be painted by #paintpoint int , int , int , int , graphics , itracepoint2d . this value will be null if no previous point had to be painted . ", "input": " ITracePoint2D m_previousPoint \n int m_previousY \n int m_previousX \n long serialVersionUID \n boolean m_isEnded \n void discontinue \n void endPaintIteration \n int hashCode \n boolean equals \n void paintPoint \n void startPaintIteration \n int getPreviousX \n int compareTo \n int getPreviousY", "output": "ITracePoint2D function ( ) { return this . m_previousPoint ; }"}, {"instruction": "Generate java code\nindicate if payload size should be estimated and controlled when adding properties default is false . ", "input": " int expiry \n boolean payloadSizeEstimatedWhenAdding \n Logger logger \n JSONObject payload \n int preSendConfiguration \n String DEFAULT_CHARACTER_ENCODING \n String characterEncoding \n void setExpiry \n byte[] getPayloadAsBytes \n int getPreSendConfiguration \n void verifyPayloadIsNotEmpty \n Payload asSimulationOnly \n boolean isEstimatedPayloadSizeAllowedAfterAdding \n int estimatePayloadSizeAfterAdding \n int getExpiry \n void validateMaximumPayloadSize \n int getPayloadSize \n int getMaximumPayloadSize \n void put \n void setCharacterEncoding \n JSONObject getPayload \n void addCustomDictionary \n void addCustomDictionary \n void addCustomDictionary \n boolean isPayloadTooLong \n String getCharacterEncoding \n byte[] getPayloadAsBytesUnchecked \n boolean isPayloadSizeEstimatedWhenAdding \n String toString \n void setPreSendConfiguration", "output": "void function ( boolean arg0 ) { this . payloadSizeEstimatedWhenAdding = arg0 ; }"}, {"instruction": "Generate java code\nreturns the local workercontext , beware : could be a newly initialized one , if xmlworker #close or xmlworker #closelocalwc has been called before . ", "input": " ThreadLocal<WorkerContextImpl> context \n boolean parseHtml \n Pipeline<?> rootpPipe \n void closeLocalWC \n void init \n void endElement \n Tag createTag \n void startElement \n boolean ignoreCdata \n void comment \n void text \n WorkerContextImpl initialValue \n void unknownText \n void close \n Tag getCurrentTag", "output": "WorkerContext function ( ) { return context . get ( ) ; }"}, {"instruction": "Generate java code\nsets the value of the lockscope property . ", "input": " Locktype locktype \n Lockscope lockscope \n Lockscope getLockscope \n void setLocktype \n Locktype getLocktype", "output": "void function ( Lockscope arg0 ) { this . lockscope = arg0 ; }"}, {"instruction": "Generate java code\nsame as call to #isstandardtypecode int ", "input": " CoreMessageLogger LOG \n Map<Integer,String> JDBC_TYPE_MAP \n Map<Integer,String> buildJdbcTypeMap \n String getTypeName", "output": "boolean function ( Integer arg0 ) { return JDBC_TYPE_MAP . containsKey ( arg0 ) ; }"}, {"instruction": "Generate java code\nconvert this step into a string suitable for editing . the default is the xml representation of the step . ", "input": " String description \n Resolver resolver \n Throwable invalidScriptError \n String toXMLString \n Map getAttributes \n String getXMLTag \n void writeObject \n void usage \n void usage \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n Element addContent \n String getDescription \n void parseStepAttributes \n String getUsage \n void readObject \n String getDefaultDescription \n Step createStep \n Step createStep \n void runStep \n ComponentTester resolveTester \n Class resolveClass \n void setScriptError \n String toString \n Resolver getResolver \n Map createAttributeMap", "output": "String function ( ) { return toXMLString ( this ) ; }"}, {"instruction": "Generate java code\nstarts the nio reactor . ", "input": " List<AbstractNioChannel> channels \n NioReactor reactor \n Dispatcher dispatcher \n AbstractNioChannel udpChannel \n void stop \n AbstractNioChannel tcpChannel \n void main", "output": "void function ( ) { reactor = new NioReactor ( dispatcher ) ; LoggingHandler loc0 = new LoggingHandler ( ) ; reactor . registerChannel ( tcpChannel ( 6666 , loc0 ) ) . registerChannel ( tcpChannel ( 6667 , loc0 ) ) . registerChannel ( udpChannel ( 6668 , loc0 ) ) . start ( ) ; }"}, {"instruction": "Generate java code\ntranslate space character into & pct ; 20 to avoid problems with paths that contain spaces on some jvms . ", "input": " String CONFIG_CLASS_RESOURCE \n Log log \n String CONFIG_WEB_RESOURCE \n String RULE_SET \n String CONFIG_ATTR \n void contextInitialized \n void contextDestroyed \n void parseJarResources \n void parseJarResources", "output": "String function ( String arg0 ) { while ( true ) { int loc0 = arg0 . indexOf ( ' ' ) ; if ( loc0 < 0 ) { break ; } arg0 = arg0 . substring ( 0 , loc0 ) + arg0 . substring ( loc0 + 1 ) ; } return ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the label for a url , uri or url part . example is ` http://www.x.xom/s.html#1 ' ", "input": " String CODE_DELIMITERS \n String FILE_PATTERN_DELIMITERS \n String URL_DELIMITERS \n String getJavaCodeString \n String getWorkingSetLabel \n String getJavaElementName \n String getFilePattern \n String getResourceName \n String getResourceName \n String getVersionName \n String getFileName \n String getPathLabel \n String getPathLabel", "output": "String function ( String arg0 ) { return Strings . markLTR ( arg0 , URL_DELIMITERS ) ; }"}, {"instruction": "Generate java code\nblindly decode content and return the result asn1 object . ", "input": " PlaceHolder placeHolder \n void encode \n byte[] encode \n void decodeAndDump \n void decodeAndDump \n void decodeAndDump \n Asn1ParseResult parse \n Asn1ParseResult parse \n void dump \n void parseAndDump \n void parseAndDump \n void parseAndDump", "output": "Asn1Type function ( byte [ ] arg0 ) { return decode ( ByteBuffer . wrap ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nmethod to verify the content of the bundle are correct . this method will not mutate bundle . ", "input": " String BUNDLE_EXTRA_STRING_MESSAGE \n Bundle generateBundle", "output": "boolean function ( Bundle arg0 ) { if ( null == arg0 ) { return false ; } if ( ! arg0 . containsKey ( BUNDLE_EXTRA_STRING_MESSAGE ) ) { return false ; } return true ; }"}, {"instruction": "Generate java code\nreturns the class of type of elements held in this arraydeclarationinfo ", "input": " long serialVersionUID \n List<Class<?>> inputTypesCached \n Class<?> outputTypeCached \n int hashCodeCached \n boolean hashCodeComputed \n String ID \n int length \n Class<?> elementType \n Class<?> getOutputType \n List<Class<?>> getInputTypes \n String toStringShort \n String toParseableString \n StatementKind parse \n Object writeReplace \n ExecutionOutcome execute \n void appendCode \n int hashCode \n boolean equals \n String toStringVerbose \n int getLength \n String toString", "output": "Class < ? > function ( ) { return this . elementType ; }"}, {"instruction": "Generate java code\ncalled after a successful flush ", "input": " CollectionPersister currentPersister \n String role \n boolean fromMerge \n boolean dorecreate \n boolean processed \n Serializable currentKey \n Logger LOG \n CollectionPersister loadedPersister \n boolean reached \n boolean ignore \n Serializable loadedKey \n boolean doremove \n boolean doupdate \n Serializable snapshot \n Serializable getCurrentKey \n void setDoupdate \n CollectionPersister getLoadedPersister \n void afterDeserialize \n void setProcessed \n boolean isDorecreate \n void preFlush \n void resetStoredSnapshot \n boolean isDoremove \n void postInitialize \n void setCurrentKey \n void setLoadedPersister \n boolean wasDereferenced \n boolean isReached \n boolean isDoupdate \n CollectionEntry deserialize \n void dirty \n Serializable getKey \n boolean isIgnore \n String getRole \n boolean isSnapshotEmpty \n Serializable getLoadedKey \n void afterAction \n Serializable getSnapshot \n Collection getOrphans \n void serialize \n void setReached \n void setCurrentPersister \n void setDoremove \n void setRole \n boolean isProcessed \n String toString \n CollectionPersister getCurrentPersister \n void setDorecreate", "output": "void function ( PersistentCollection arg0 ) { if ( isIgnore ( ) ) { ignore = false ; } else if ( ! isProcessed ( ) ) { throw new AssertionFailure ( \"srini_string\" + arg0 . getRole ( ) + \"srini_string\" ) ; } arg0 . setSnapshot ( loadedKey , role , snapshot ) ; }"}, {"instruction": "Generate java code\nreturns the same citations rdd that was specified as argument . ", "input": " PlaceHolder placeHolder \n JavaPairRDD<String,MatchableEntity> convertDocuments", "output": "JavaPairRDD < String , MatchableEntity > function ( JavaPairRDD < String , MatchableEntity > arg0 ) { return arg0 ; }"}, {"instruction": "Generate java code\nadds a line to the pool and makes it available for reuse . if more than 8 lines are in the cache , then the line is closed . ", "input": " int volume \n Vector lines \n int loopCount \n int loopStart \n Thread workerThread \n Mixer mixer \n float pan \n int loopEnd \n int sampleRate \n byte[] samples \n void play \n void setLoopPoints \n void stop \n void configureDataLine \n void loop \n void loop \n SourceDataLine aquireLine \n void run \n Mixer getMixer", "output": "void function ( SourceDataLine arg0 ) { if ( lines . size ( ) < 16 ) { lines . addElement ( arg0 ) ; } else { arg0 . close ( ) ; } }"}, {"instruction": "Generate java code\nget status of a running event . ", "input": " Random rand \n int currentlyRunningSyncEvent \n int MIN_ID \n int MAX_RUNNING_EVENTS \n int MAX_EVENT_TIME \n Map<Integer,Event> eventPool \n int MAX_ID \n void cancel \n void completedEventHandler \n void start \n int generateId \n int create \n int createEvent \n Map<Integer,Event> getEventPool \n int numOfCurrentlyRunningSyncEvent \n int createAsync \n void statusOfAllEvents \n void shutdown", "output": "void function ( int arg0 ) { if ( ! eventPool . containsKey ( arg0 ) ) { throw new EventDoesNotExistException ( arg0 + \"srini_string\" ) ; } eventPool . get ( arg0 ) . status ( ) ; }"}, {"instruction": "Generate java code\nfail . should be used whenever an impossible state is encountered such as the default branch of a switch over all possible values of an enum : such an assertion may save future developers time when they try to add new states ", "input": " PlaceHolder placeHolder \n void equal \n void equal \n void isNotNull \n void isNotNull \n void isTrue \n void isTrue \n void isNull \n void isNull \n void isFalse \n void isFalse", "output": "void function ( ) { isTrue ( false ) ; }"}, {"instruction": "Generate java code\nset a new opponent 's weight . should be negative or zero ", "input": " String teamName \n int weight \n Player player \n String getPlayerNick \n void changeWeight \n int getWeight \n int hashCode \n boolean equals \n Opponent clone \n String toString \n int compareTo \n String getTeamName", "output": "void function ( int arg0 ) { this . weight = arg0 ; }"}, {"instruction": "Generate java code\ncalled on the event dispatching thread not on the worker thread after the construct method has finished and after done or failed has been invoked . the default implementation does nothing . subclasses may override this method to perform completion actions on the event dispatch thread . ", "input": " Throwable error \n T value \n Throwable getError \n T getValue \n void setError \n void setValue \n void start \n void run \n T construct \n void failed \n void done", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nupdates segment tree for given range by given delta ", "input": " PlaceHolder placeHolder \n int rangeMinimumQueryLazy \n int rangeMinimumQueryLazy \n int rangeMinimumQuery \n int rangeMinimumQuery \n int[] createSegmentTree \n void constructMinSegmentTree \n void main \n void updateSegmentTree \n void updateSegmentTree \n void updateSegmentTreeRangeLazy \n void updateSegmentTreeRangeLazy", "output": "void function ( int arg0 [ ] , int arg1 [ ] , int arg2 , int arg3 , int arg4 ) { for ( int loc0 = arg2 ; loc0 <= arg3 ; loc0 ++ ) { arg0 [ loc0 ] += arg4 ; } updateSegmentTreeRange ( arg1 , arg2 , arg3 , arg4 , 0 , arg0 . length - 1 , 0 ) ; }"}, {"instruction": "Generate java code\naccess the last iteration count . ", "input": " double functionValueAccuracy \n boolean resultComputed \n double defaultFunctionValueAccuracy \n UnivariateRealFunction f \n double relativeAccuracy \n double absoluteAccuracy \n double result \n int iterationCount \n int defaultMaximalIterationCount \n int maximalIterationCount \n double defaultAbsoluteAccuracy \n double defaultRelativeAccuracy \n long serialVersionUID \n double getFunctionValueAccuracy \n void setAbsoluteAccuracy \n void verifySequence \n boolean isSequence \n void setResult \n void setRelativeAccuracy \n void resetFunctionValueAccuracy \n int getMaximalIterationCount \n void resetRelativeAccuracy \n double getAbsoluteAccuracy \n void resetAbsoluteAccuracy \n void verifyInterval \n double getResult \n void setMaximalIterationCount \n void resetMaximalIterationCount \n boolean isBracketing \n void clearResult \n void verifyBracketing \n double getRelativeAccuracy \n void setFunctionValueAccuracy", "output": "int function ( ) { if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nobtener las vueltas calculadas , para saber el valor de cada posicion del array podemos usar la variable : public static final int billetes_monedas ", "input": " float precio \n int BILLETE_MINIMO \n int[] aVueltas \n float pago \n float[] BILLETES_MONEDAS \n void calcular \n void imprimirVueltas \n float getPago \n float getPago", "output": "int [ ] function ( ) { return this . aVueltas ; }"}, {"instruction": "Generate java code\ntests that invocation on a service deployed within a . sar , inside a . ear without an application.xml , is successful . ", "input": " JMXConnector connector \n String EAR_WITH_APPLICATION_XML \n ManagementClient managementClient \n String EAR_WITHOUT_APPLICATION_XML \n void closeConnector \n MBeanServerConnection getMBeanServerConnection \n void testSarWithinEar \n EnterpriseArchive getEarWithApplicationDotXml \n void testSarWithinEarWithApplicationXml \n EnterpriseArchive getEarWithoutApplicationDotXml", "output": "void function ( ) { this . testSarWithinEar ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncreates a new sax parser . ", "input": " Logger log \n File file \n boolean enableDateParsing \n Sink sink \n InputStream inputStream \n CompressionMethod compressionMethod \n void setSink \n void run", "output": "SAXParser function ( ) { try { return SAXParserFactory . newInstance ( ) . newSAXParser ( ) ; } catch ( ParserConfigurationException loc0 ) { throw new OsmosisRuntimeException ( \"srini_string\" , loc0 ) ; } catch ( SAXException loc0 ) { throw new OsmosisRuntimeException ( \"srini_string\" , loc0 ) ; } }"}, {"instruction": "Generate java code\nthis method returns an aggregate of the complexity of the solved queries at a certain level . the method returns the complexity , which is attained by varying the amount of searched peers . ", "input": " MetricsAggregate peerVariation \n int counter \n MetricsAggregate conditionVarition \n int getCounter \n void setPeerVariation \n void setConditionVarition \n MetricsAggregate getConditionVarition \n void setCounter", "output": "MetricsAggregate function ( ) { return peerVariation ; }"}, {"instruction": "Generate java code\nverifies that the content of the processobject is processed on content . ", "input": " ElementHandlerPipeline p \n WorkerContextImpl context \n List<Writable> lst \n ProcessObject po \n WritableElement writable \n void runOpen \n void setup \n void runClose", "output": "void function ( ) { p . content ( context , null , null , po ) ; Assert . assertEquals ( writable , lst . get ( 0 ) ) ; }"}, {"instruction": "Generate java code\nadds an interface of a given type to the set of interfaces that the class implements . ", "input": " boolean dirty \n ClassInfo classInfo \n Type[] interfaces \n Type superclass \n EditorContext context \n ConstantPool constants \n Type type \n boolean DEBUG \n void setInterface \n void setInterfaces \n boolean isStatic \n boolean isSuper \n MethodInfo[] methods \n void commit \n boolean isPrivate \n Type type \n int modifiers \n void setDirty \n void setFinal \n void setSuper \n boolean isDirty \n boolean isProtected \n Type superclass \n int hashCode \n void setProtected \n EditorContext context \n boolean isPublic \n boolean isFinal \n ConstantPool constants \n boolean isInterface \n ClassInfo classInfo \n void setPublic \n Type[] interfaces \n void setStatic \n void setType \n void commitOnly \n boolean isAbstract \n void setSuperclass \n boolean equals \n String name \n void setAbstract \n String toString \n void visit \n FieldInfo[] fields \n void setPrivate", "output": "void function ( final Type arg0 ) { final Type [ ] loc0 = new Type [ this . interfaces . length + 1 ] ; for ( int loc1 = 0 ; loc1 < this . interfaces . length ; loc1 ++ ) { loc0 [ loc1 ] = this . interfaces [ loc1 ] ; } loc0 [ loc0 . length - 1 ] = arg0 ; this . setInterfaces ( loc0 ) ; }"}, {"instruction": "Generate java code\nthis method creates a validator object that adds support for bean validation api 1.0 and 1.1 . ", "input": " PlaceHolder placeHolder \n SortHandlerMethodArgumentResolver sortArgumentResolver \n MappingJackson2HttpMessageConverter jacksonDateTimeConverter \n LocaleResolver fixedLocaleResolver \n ExceptionHandlerExceptionResolver restErrorHandler", "output": "LocalValidatorFactoryBean function ( ) { return new LocalValidatorFactoryBean ( ) ; }"}, {"instruction": "Generate java code\nget the base id url or system id from where urls will be resolved . ", "input": " Node node \n String FEATURE \n String baseID \n void setSystemId \n void setNode \n Node getNode", "output": "String function ( ) { return this . baseID ; }"}, {"instruction": "Generate java code\ncreates a parenttree of all parents of a given tag ", "input": " PlaceHolder placeHolder \n List<Tag> getParentTagTree", "output": "List < String > function ( Tag arg0 ) { List < String > loc0 = new ArrayList < String > ( ) ; Tag loc1 = arg0 . getParent ( ) ; while ( loc1 != null && ! ( loc1 . getName ( ) . equals ( HTML . Tag . BODY ) ) ) { loc0 . add ( loc1 . getName ( ) ) ; loc1 = loc1 . getParent ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nonly ", "input": " SodaTest st \n Object childFirst \n Object child \n String toString \n String toString \n void main \n Object[] store", "output": "void function ( ) { Query loc0 = st . query ( ) ; loc0 . descend ( \"srini_string\" ) ; Object [ ] loc1 = store ( ) ; st . expect ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nsubstracts the given value from the internal value . ", "input": " int MIN_VALUE \n int MAX_VALUE \n int m_value \n void add \n void add \n void add \n int getValue \n int hashCode \n int intValue \n boolean equals \n void setValue \n String toString", "output": "void function ( final int arg0 ) { final int loc0 = this . m_value ; this . m_value -= arg0 ; if ( loc0 < this . m_value ) { this . m_value = loc0 ; throw new ArithmeticException ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nsets the value of the outofservicebyrelease property . ", "input": " String fcLink \n String techStack \n String fcKey \n String outOfServiceByRelease \n ApplicationID id \n List<ApplicationReleaseBinding> structure \n String getFcLink \n void setTechStack \n String getTechStack \n String getFcKey \n void setFcKey \n List<ApplicationReleaseBinding> getStructure \n void setFcLink \n void setId \n ApplicationID getId \n String getOutOfServiceByRelease", "output": "void function ( String arg0 ) { this . outOfServiceByRelease = arg0 ; }"}, {"instruction": "Generate java code\nreturn the class loader to be used for instantiating application objects when required . this is determined based upon the following rules : the specified class loader , if any the thread context class loader , if it exists and usecontextclassloader is true the class loader used to load the calling class . the system class loader . ", "input": " Log log \n Class loadClass \n Class loadClass", "output": "ClassLoader function ( ClassLoader arg0 , boolean arg1 , Class arg2 ) { if ( arg0 != null ) { return arg0 ; } if ( arg1 ) { ClassLoader loc0 = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loc0 != null ) { return loc0 ; } } return getClassLoader ( arg2 ) ; }"}, {"instruction": "Generate java code\naccess to the names of all named parameters ", "input": " Map<String,NamedParameterDescriptor> namedDescriptorMap \n OrdinalParameterDescriptor[] ordinalDescriptors \n OrdinalParameterDescriptor[] EMPTY_ORDINALS \n int getOrdinalParameterSourceLocation \n NamedParameterDescriptor getNamedParameterDescriptor \n Type getOrdinalParameterExpectedType \n Type getNamedParameterExpectedType \n int[] getNamedParameterSourceLocations \n OrdinalParameterDescriptor getOrdinalParameterDescriptor \n int getOrdinalParameterCount", "output": "Set < String > function ( ) { return namedDescriptorMap . keySet ( ) ; }"}, {"instruction": "Generate java code\nprogramatical invocation of a dialog field change . ", "input": " String fLabelText \n IDialogFieldListener fDialogFieldListener \n Label fLabel \n boolean fEnabled \n Label getLabelControl \n boolean isOkToUse \n void refresh \n boolean setFocus \n void setEnabled \n void setDialogFieldListener \n Control[] doFillIntoGrid \n Control createEmptySpace \n Control createEmptySpace \n boolean isEnabled \n void setLabelText \n GridData gridDataForLabel \n void updateEnableState \n void postSetFocusOnDialogField \n void assertEnoughColumns \n void assertCompositeNotNull \n int getNumberOfControls", "output": "void function ( ) { if ( fDialogFieldListener != null ) { fDialogFieldListener . dialogFieldChanged ( this ) ; } }"}, {"instruction": "Generate java code\nreturns the ip address mapped to the given hostname . if no mapping exists , the hostname is returned . ", "input": " Map<String,TaskStatus> statuses \n Set<String> waitPorts \n List<String> hosts \n Map<String,String> hostToIp \n Logger log \n HeliosClient client \n Prober prober \n String jobDeployedMessageFormat \n Job job \n void awaitHasContainerId \n List<HostAndPort> addresses \n HostAndPort address \n void awaitUp \n List<String> hosts \n void verifyHealthy \n void verifyHealthy \n void deploy \n void outputDeployedMessage \n Integer port \n Map<String,TaskStatus> statuses \n Job job \n void awaitPort \n void undeploy \n void undeploy", "output": "String function ( String arg0 ) { final String loc0 = hostToIp . get ( arg0 ) ; return loc0 == null ? arg0 : loc0 ; }"}, {"instruction": "Generate java code\nreturns the ones . ", "input": " String name \n List ones \n Holder otherHolder \n String id \n Foo[] fooArray \n Set foos \n Foo[] getFooArray \n void setName \n void setOnes \n String getName \n void setFooArray \n void setFoos \n void setOtherHolder \n void setId \n String getId \n Holder getOtherHolder \n Set getFoos", "output": "List function ( ) { return ones ; }"}, {"instruction": "Generate java code\ntransforms an object into json and returns the json as a byte array . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "byte [ ] function ( Object arg0 ) { ObjectMapper loc0 = new ObjectMapper ( ) ; loc0 . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; return loc0 . writeValueAsBytes ( arg0 ) ; }"}, {"instruction": "Generate java code\nmethode tostring du vector ", "input": " double _size \n double _yDirection \n double _endTopDistance \n double _leftDistance \n double _topDistance \n double _xDirection \n double _endLeftDistance \n double getLeftDistance \n double getXDirection \n Vector restore \n void setYDirection \n void setLeftDistance \n String save \n void _updateDirection \n void _updateEndDistance \n void setXDirection \n double getEndTopDistance \n void setEndTopDistance \n double getSize \n void setSize \n double getYDirection \n double getEndLeftDistance \n boolean equals \n void setEndLeftDistance \n Vector clone \n void setTopDistance \n double getTopDistance", "output": "String function ( ) { return \"srini_string\" + _topDistance + \"srini_string\" + _leftDistance + \"srini_string\" + _endTopDistance + \"srini_string\" + _endLeftDistance + \"srini_string\" ; }"}, {"instruction": "Generate java code\nreturns a set view of the mappings contained in this registry . each element in the returned set is a map.entry . the set is backed by the registry , so changes to the map are reflected in the set , and vice-versa . if the registry is modified while an iteration over the set is in progress , the results of the iteration are undefined . ", "input": " Map _values \n Map _register \n WidgetLocator add \n String getKey \n boolean containsKey \n WidgetLocator get \n WidgetLocator remove \n boolean containsValue", "output": "Set function ( ) { return _register . entrySet ( ) ; }"}, {"instruction": "Generate java code\ntransfers from right to left ", "input": " PlaceHolder placeHolder \n void swap \n void swap", "output": "T [ ] function ( T [ ] arg0 , T [ ] arg1 , int arg2 , int arg3 ) { return ArrayTool . transferValues ( arg0 , arg1 , arg2 , 0 , arg3 ) ; }"}, {"instruction": "Generate java code\nheader in freemarker syntax for function ", "input": " Set<AmwFunctionEntity> overwritingChildFunction \n ResourceEntity resource \n String implementation \n Set<MikEntity> miks \n String name \n Integer id \n AmwFunctionEntity overwrittenParent \n long serialVersionUID \n String COMMASEPARATOR \n ResourceTypeEntity resourceType \n void setName \n String getDecoratedImplementation \n void addOverwritingFunction \n boolean isDefinedOnResource \n void setResource \n void resetOverwriting \n String getFreemarkerFooter \n void removeOverwritingFunction \n boolean isOverwrittenBySubTypeOrResourceFunction \n AmwFunctionEntity getCopy \n Set<String> getMikNames \n String getCommaseparatedMikNames \n Set<AmwFunctionEntity> getOverwritingChildFunction \n boolean isDefinedOnResourceType \n Set<MikEntity> getMiks \n void setResourceType \n boolean isOverwritingResourceTypeFunction \n String toString \n void addMik \n void overwrite \n String getOverwrittenFunctionResourceTypeName", "output": "String function ( ) { return \"srini_string\" + name + \"srini_string\" ; }"}, {"instruction": "Generate java code\nget a device according to his id ", "input": " Object synclock \n Map<String,BasicDevice> devices \n Device addDevice \n void removeDevice", "output": "Device function ( String arg0 ) { if ( ( arg0 == null ) || ( arg0 . trim ( ) . equals ( \"srini_string\" ) ) ) { throw new NullIdException ( ) ; } else { if ( this . devices . containsKey ( arg0 ) ) { return this . devices . get ( arg0 ) ; } else { throw new UnknownDeviceException ( ) ; } } }"}, {"instruction": "Generate java code\nformats time as milliseconds with units . ", "input": " String UNIT_MILLISECONDS \n String UNIT_SECONDS \n String format \n String format \n String format \n String formatToFixedDecimalPoint \n String formatSeconds \n String formatSeconds", "output": "String function ( double arg0 ) { return ( int ) arg0 + UNIT_MILLISECONDS ; }"}, {"instruction": "Generate java code\ncreate a new rawfragmentbatch based on this incoming data batch that is transferred into the provided allocator . also increments the acksender to expect one additional return message . ", "input": " AckSender sender \n FragmentRecordBatch header \n DrillBuf body \n FragmentRecordBatch getHeader", "output": "RawFragmentBatch function ( final BufferAllocator arg0 ) { final DrillBuf loc0 = body == null ? null : body . transferOwnership ( arg0 ) . buffer ; sender . increment ( ) ; return new RawFragmentBatch ( header , loc0 , sender ) ; }"}, {"instruction": "Generate java code\nget a quotient element from a long value . ", "input": " RingFactory<C> ring \n boolean debug \n Logger logger \n Quotient<C> random \n Quotient<C> random \n int hashCode \n boolean isField \n boolean equals \n Quotient<C> getONE \n boolean isCommutative \n Quotient<C> getZERO \n boolean isAssociative \n String toString \n Quotient<C> parse \n Quotient<C> parse \n Quotient<C> copy \n java.math.BigInteger characteristic", "output": "Quotient < C > function ( long arg0 ) { return new Quotient < C > ( this , ring . fromInteger ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturn an list of abis we supported on this device ordered according to preference . use a separate inner class to isolate the version-dependent call where it wo n't cause the whole class to fail preverification . ", "input": " byte[] cachedBuffer \n void reliablyCopyExecutable \n void deleteOrThrow \n FileLocker lockLibsDirectory \n void freeCopyBuffer \n File createLibsDirectory \n File getLibsDirectory \n int findAbiScore \n void dumbDeleteRecrusive \n void fallocateIfSupported \n void fallocate", "output": "String [ ] function ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . LOLLIPOP ) { return new String [ ] { Build . CPU_ABI , Build . CPU_ABI2 } ; } else { return LollipopSysdeps . getSupportedAbis ( ) ; } }"}, {"instruction": "Generate java code\ncreation of h2 db ", "input": " Logger LOGGER \n LocalContainerEntityManagerFactoryBean entityManagerFactory \n JpaTransactionManager transactionManager \n void main \n Properties jpaProperties", "output": "DataSource function ( ) { BasicDataSource loc0 = new BasicDataSource ( ) ; loc0 . setDriverClassName ( \"srini_string\" ) ; loc0 . setUrl ( \"srini_string\" ) ; loc0 . setUsername ( \"srini_string\" ) ; loc0 . setPassword ( \"srini_string\" ) ; return ( DataSource ) loc0 ; }"}, {"instruction": "Generate java code\nget index into children array , that is hit by this planindex ", "input": " int[] childRanges \n int[] childSizes \n int planSpaceSize \n PlanSpaceNode[] children \n PlanSpaceNode[] getChildren \n int lowestRangeHit \n PlanSpaceNode getChild \n int getChildPlanIndex \n int getPlanSpaceSize \n Plan getPlan \n void setChildren \n int highestRangeHit", "output": "int function ( int arg0 ) { int loc0 = 0 ; while ( ( arg0 < lowestRangeHit ( loc0 ) ) || ( arg0 > highestRangeHit ( loc0 ) ) ) { loc0 ++ ; } return loc0 ; }"}, {"instruction": "Generate java code\ncreate a client-server topology , using one hazelcastinstance server and one hazelcastinstance client . the client is the returned as the @bean . ", "input": " String CLUSTER_HOST \n Logger LOG \n String MASTER_SERVER \n HazelcastInstance hazelcastInstance \n int CLUSTER_PORT \n HazelcastInstance singleton \n HazelcastInstance makeClient \n void preDestroy \n HazelcastInstance makeServer \n KeyValueOperations keyValueTemplate", "output": "HazelcastInstance function ( ) { InstanceHelper . makeServer ( \"srini_string\" + Constants . HAZELCAST_INSTANCE_NAME , CLUSTER_PORT ) ; HazelcastInstance loc0 = InstanceHelper . makeClient ( Constants . HAZELCAST_INSTANCE_NAME ) ; LOG . trace ( \"srini_string\" , loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nchecks if given permission is available . if not a checked exception is thrown with error message containing extrainfo part . ", "input": " EntityManager entityManager \n PermissionService permissionService \n ResourceTypeProvider resourceTypeProvider \n boolean hasPermissionToEditPropertiesOfResource \n boolean canCreateAppAndAddToAppServer \n boolean hasPermissionToAddRelation \n boolean hasPermissionToDeploy \n boolean canCopyFromResource \n void checkPermissionAndFireCheckedException \n boolean hasPermissionToDeleteRelation \n boolean hasPermissionToDeleteRelationType \n boolean hasPermissionToRenameResource \n boolean hasPermissionToRemoveDefaultInstanceOfResType \n boolean hasPermission \n boolean hasPermission \n boolean hasPermissionToTemplateModify \n boolean hasPermissionToEditPropertiesByResource \n boolean canCreateResourceInstance \n boolean canCreateResourceInstance \n boolean hasPermissionToRenameResourceType", "output": "void function ( Permission arg0 , String arg1 ) { permissionService . checkPermissionAndFireException ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\npaint a cached formula ", "input": " Image image \n ConcurrentMap<CachedTeXFormula,SoftReference<CachedImage>> cache \n String f \n int inset \n Color fgcolor \n AffineTransform identity \n int width \n int type \n ReferenceQueue queue \n int depth \n int size \n int style \n CachedTeXFormula cachedTf \n int max \n int height \n void removeCachedTeXFormula \n void removeCachedTeXFormula \n void removeCachedTeXFormula \n int[] getCachedTeXFormulaDimensions \n int[] getCachedTeXFormulaDimensions \n int[] getCachedTeXFormulaDimensions \n Image getCachedTeXFormulaImage \n Image getCachedTeXFormulaImage \n Image getCachedTeXFormulaImage \n int hashCode \n boolean equals \n void setDimensions \n void clearCache \n SoftReference<CachedImage> makeImage \n void setMaxCachedObjects \n Object getCachedTeXFormula \n Object getCachedTeXFormula", "output": "Object function ( String arg0 , int arg1 , int arg2 , int arg3 , int arg4 , Color arg5 , Graphics2D arg6 ) { return paintCachedTeXFormula ( new CachedTeXFormula ( arg0 , arg1 , arg2 , arg3 , arg4 , arg5 ) , arg6 ) ; }"}, {"instruction": "Generate java code\nthis method puts treehandler back in its initial state , if the host got off-line or if the peer left the underlying overlay . ", "input": " SkyNetNodeInfo parentCoordinator \n SkyNetNodeInterface skyNetNode \n TreeHandlerDelegator treeHandlerDelegator \n Logger log \n boolean isRoot \n int level \n SkyNetID coordinatorKey \n int branchingFactor \n void calculateResponsibilityIntervalOperationFailed \n void calculateResponsibilityInterval \n boolean isRoot \n void processNextLevelOperationSucceeded \n void lookupParentCoordinator \n void horizontalDispatching \n void calculateNextLevel \n void calculateResponsibilityIntervalOperationSucceeded \n void lookupOperationSucceeded \n void verticalDispatching \n void lookupOperationFailed \n void processNextLevelOperationFailed \n SkyNetNodeInfo getParentCoordinator \n void checkResponsibility \n void processNextLevel", "output": "void function ( ) { isRoot = false ; }"}, {"instruction": "Generate java code\nverifies that lower throws illegalargumentexception if not ", "input": " double functionValueAccuracy \n boolean resultComputed \n double defaultFunctionValueAccuracy \n UnivariateRealFunction f \n double relativeAccuracy \n double absoluteAccuracy \n double result \n int iterationCount \n int defaultMaximalIterationCount \n int maximalIterationCount \n double defaultAbsoluteAccuracy \n double defaultRelativeAccuracy \n long serialVersionUID \n double getFunctionValueAccuracy \n void setAbsoluteAccuracy \n boolean isSequence \n void setResult \n void setRelativeAccuracy \n void resetFunctionValueAccuracy \n int getMaximalIterationCount \n void resetRelativeAccuracy \n double getAbsoluteAccuracy \n int getIterationCount \n void resetAbsoluteAccuracy \n void verifyInterval \n double getResult \n void setMaximalIterationCount \n void resetMaximalIterationCount \n boolean isBracketing \n void clearResult \n void verifyBracketing \n double getRelativeAccuracy \n void setFunctionValueAccuracy", "output": "void function ( double arg0 , double arg1 , double arg2 ) { if ( ! isSequence ( arg0 , arg1 , arg2 ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 + \"srini_string\" + arg2 ) ; } }"}, {"instruction": "Generate java code\nadds a richmediaconfiguration . part of the richmediacontent . ", "input": " PdfDictionary richMediaSettings \n PdfArray configurations \n PdfArray views \n HashMap<String,PdfIndirectReference> assetsmap \n PdfDictionary richMediaContent \n PdfIndirectReference richMediaContentReference \n PdfWriter writer \n PdfAnnotation annot \n PdfIndirectReference addAsset \n PdfIndirectReference addAsset \n PdfIndirectReference getRichMediaContentReference \n PdfAnnotation createAnnotation \n void setActivation \n PdfIndirectReference addView \n PdfIndirectReference addView \n void setDeactivation", "output": "PdfIndirectReference function ( RichMediaConfiguration arg0 ) { if ( configurations == null ) throw new IllegalPdfSyntaxException ( \"srini_string\" ) ; PdfIndirectReference loc0 = writer . addToBody ( arg0 ) . getIndirectReference ( ) ; configurations . add ( loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nparse given files . ", "input": " String VERSION \n SentenceExtractor sentenceExtractor \n Configuration configuration \n List<Validator> validators \n Logger LOG \n void runSectionValidators \n Configuration getConfiguration \n void initializeValidators \n void runDocumentValidators \n int hashCode \n void runSentenceValidators \n boolean equals \n void applyPreprocessorRules \n void applyPreprocessorRules \n String toString \n Map<Document,List<ValidationError>> validate \n List<ValidationError> validate \n List<Validator> getValidators", "output": "List < Document > function ( DocumentParser arg0 , File [ ] arg1 ) { List < Document > loc0 = new ArrayList < > ( ) ; for ( File loc1 : arg1 ) { loc0 . add ( arg0 . parse ( loc1 , sentenceExtractor , configuration . getTokenizer ( ) ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ncan be customized in subclasses . ", "input": " int RETRY_LIMIT \n String[] textForItems \n MenuItemReference[] items \n MenuItemReference getNextMenuItem \n MenuItemReference resolveAndSelect \n StringBuilder getAllItemText \n MenuItemReference resolveAndSelect0 \n void pause", "output": "void function ( MenuItemReference arg0 ) { arg0 . click ( ) ; }"}, {"instruction": "Generate java code\nset the indirect reference ", "input": " int INDIRECT \n int STRING \n int DICTIONARY \n int NULL \n int NUMBER \n int type \n int NAME \n String NOTHING \n int BOOLEAN \n int ARRAY \n byte[] bytes \n String TEXT_UNICODE \n String TEXT_PDFDOCENCODING \n PRIndirectReference indRef \n int STREAM \n void toPdf \n void setContent \n int length \n boolean isStream \n PRIndirectReference getIndRef \n int type \n byte[] getBytes \n boolean isDictionary \n boolean isBoolean \n boolean isName \n boolean isNumber \n boolean isNull \n boolean isString \n String toString \n boolean canBeInObjStm \n boolean isArray \n boolean isIndirect", "output": "void function ( PRIndirectReference arg0 ) { this . indRef = arg0 ; }"}, {"instruction": "Generate java code\nsearchs the stored list of local variables for a local variable with a given value number . ", "input": " Expr ind_term \n boolean changed \n FlowGraph CFG \n Expr ind_var \n Expr ind_init \n Expr tgt \n boolean DEBUG \n Expr ind_inc \n SSAGraph ssaGraph \n HashMap LocalStore \n HashMap IndStore \n void transform \n Block isMu \n void Display_store \n Object get_swizzler \n void insert_aswrange \n void displaySwizzler", "output": "MemExpr function ( final int arg0 ) { final Iterator loc0 = LocalStore . keySet ( ) . iterator ( ) ; while ( loc0 . hasNext ( ) ) { final MemExpr loc1 = ( MemExpr ) loc0 . next ( ) ; if ( loc1 . valueNumber ( ) == arg0 ) { return loc1 ; } } return null ; }"}, {"instruction": "Generate java code\nverifies that the call to content of div returns a nonewlineparagraph . ", "input": " List<Element> currentContent \n Div d \n WorkerContextImpl workerContextImpl \n void init \n void verifyNumberOfParagraphs \n void verifyIfPdfDiv \n void verifyIfStackOwner", "output": "void function ( ) { final List < Element > loc0 = d . loc0 ( workerContextImpl , new Tag ( \"srini_string\" ) , \"srini_string\" ) ; Assert . assertTrue ( loc0 . get ( 0 ) instanceof NoNewLineParagraph ) ; }"}, {"instruction": "Generate java code\nverify if nazgul #getinstance nazgulname returns the correct nazgul multiton instance ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "void function ( ) { for ( final NazgulName loc0 : NazgulName . values ( ) ) { final Nazgul loc1 = Nazgul . getInstance ( loc0 ) ; assertNotNull ( loc1 ) ; assertSame ( loc1 , Nazgul . getInstance ( loc0 ) ) ; assertEquals ( loc0 , loc1 . getName ( ) ) ; } }"}, {"instruction": "Generate java code\nnull-safe check for a context - if the given context is null , it returns the global context . ", "input": " ContextEntity globalContext \n EntityManager entityManager \n Logger log \n ResourceTypeProvider resourceTypeProvider \n Query fetchAllContexts \n List<ContextEntity> getEnvironments \n ContextEntity getContextEntityById \n ContextEntity getGlobalResourceContextEntity", "output": "ContextEntity function ( ContextEntity arg0 ) { if ( arg0 != null ) { return arg0 ; } return getGlobalResourceContextEntity ( ) ; }"}, {"instruction": "Generate java code\nadd a path with a custom schema to the list ofinputs for the map-reduce job . ", "input": " String mappersKey \n String schemaKey \n String toBase64 \n Map<Path,Schema> getInputSchemaMap \n Map<Path,Class<? extends AvroMapper>> getMapperTypeMap \n String fromBase64", "output": "void function ( JobConf arg0 , Path arg1 , Schema arg2 ) { String loc0 = arg1 . toString ( ) + \"srini_string\" + toBase64 ( arg2 . toString ( ) ) ; String loc1 = arg0 . get ( schemaKey ) ; arg0 . set ( schemaKey , loc1 == null ? loc0 : loc1 + \"srini_string\" + loc0 ) ; arg0 . setInputFormat ( DelegatingInputFormat . class ) ; }"}, {"instruction": "Generate java code\nisempty returns true if this list is empty , false otherwise . ", "input": " ListNode head \n int size \n Keyable find \n Enumeration elements \n int length \n void insert \n String toString", "output": "boolean function ( ) { return ( size == 0 ) ; }"}, {"instruction": "Generate java code\nchange la figure passer en parametre ", "input": " ArrayList<MyObserver> _observer \n Figure _message \n void addObserver \n void notifyObs \n void notifyObservers", "output": "void function ( Figure arg0 ) { _message = arg0 ; }"}, {"instruction": "Generate java code\nfrees a hessian 2.0 serializer ", "input": " SerializerFactory _serializerFactory \n SerializerFactory _defaultSerializerFactory \n Logger log \n HessianFreeList<HessianInput> _freeHessianInput \n HessianFreeList<HessianOutput> _freeHessianOutput \n HessianFreeList<Hessian2Input> _freeHessian2Input \n HessianFreeList<Hessian2Output> _freeHessian2Output \n Hessian2Input createHessian2Input \n void freeHessian2StreamingInput \n Hessian2Output createHessian2Output \n Hessian2StreamingOutput createHessian2StreamingOutput \n void setSerializerFactory \n OutputStream createHessian2DebugOutput \n SerializerFactory getSerializerFactory \n Hessian2StreamingInput createHessian2StreamingInput \n void freeHessian2Output \n HessianOutput createHessianOutput \n HessianInput createHessianInput \n void freeHessian2Input", "output": "void function ( Hessian2StreamingOutput arg0 ) { if ( arg0 == null ) { return ; } freeHessian2Output ( arg0 . getHessian2Output ( ) ) ; }"}, {"instruction": "Generate java code\ncreate an instance of limit ", "input": " QName _SyncToken_QNAME \n QName _Dst_QNAME \n QName _SyncLevel_QNAME \n QName _Status_QNAME \n QName _Depth_QNAME \n QName _Responsedescription_QNAME \n QName _Nresults_QNAME \n QName _Timeout_QNAME \n QName _Href_QNAME \n QName _Src_QNAME \n JAXBElement<String> createDst \n Propstat createPropstat \n Supportedlock createSupportedlock \n Propertybehavior createPropertybehavior \n Lockentry createLockentry \n Resourcetype createResourcetype \n Unauthenticated createUnauthenticated \n JAXBElement<String> createSyncToken \n JAXBElement<String> createStatus \n Link createLink \n SyncCollection createSyncCollection \n Location createLocation \n JAXBElement<String> createSyncLevel \n SupportedReportSet createSupportedReportSet \n Lockinfo createLockinfo \n Getcontentlanguage createGetcontentlanguage \n Lockscope createLockscope \n Getcontenttype createGetcontenttype \n Owner createOwner \n Read createRead \n All createAll \n Lockdiscovery createLockdiscovery \n Exclusive createExclusive \n ReadAcl createReadAcl \n JAXBElement<String> createDepth \n WriteContent createWriteContent \n Getetag createGetetag \n Omit createOmit \n Collection createCollection \n Propname createPropname \n Error createError \n ReadCurrentUserPrivilegeSet createReadCurrentUserPrivilegeSet \n Authenticated createAuthenticated \n Bind createBind \n JAXBElement<BigInteger> createNresults \n JAXBElement<String> createHref \n Report createReport \n JAXBElement<String> createTimeout \n Keepalive createKeepalive \n Shared createShared \n Locktype createLocktype \n Remove createRemove \n Write createWrite \n JAXBElement<String> createResponsedescription \n Creationdate createCreationdate \n JAXBElement<String> createSrc \n Activelock createActivelock \n Getcontentlength createGetcontentlength \n Prop createProp \n Displayname createDisplayname \n Response createResponse \n UnBind createUnbind \n SearchRequest createSearch \n Set createSet \n Propertyupdate createPropertyupdate \n Locktoken createLocktoken \n Source createSource \n Propfind createPropfind \n Self createSelf \n Getlastmodified createGetlastmodified \n SupportedReport createSupportedReport \n Unlock createUnlock \n Multistatus createMultistatus \n Allprop createAllprop \n WriteProperties createWriteProperties", "output": "Limit function ( ) { return new Limit ( ) ; }"}, {"instruction": "Generate java code\nsets the parent of this change . requires that this change is n't already connected to a parent . the parent can be null to disconnect this change from a parent . ", "input": " boolean fIsEnabled \n Change fParent \n ChangeDescriptor getDescriptor \n T getAdapter \n Change getParent \n Object[] getAffectedObjects \n String getName \n RefactoringStatus isValid \n Change perform \n Object getModifiedElement \n void setEnabled \n boolean isEnabled \n void initializeValidationData \n void setEnabledShallow \n void dispose", "output": "void function ( Change arg0 ) { if ( arg0 != null ) Assert . isTrue ( fParent == null ) ; fParent = arg0 ; }"}, {"instruction": "Generate java code\nalgebraicnumber greatest common divisor . ", "input": " GenPolynomial<C> val \n AlgebraicNumberRing<C> ring \n int isunit \n int signum \n boolean isONE \n AlgebraicNumber<C> inverse \n GenPolynomial<C> getVal \n boolean isUnit \n AlgebraicNumber<C> subtract \n AlgebraicNumber<C> sum \n int compareTo \n AlgebraicNumber<C>[] egcd \n AlgebraicNumber<C> monic \n AlgebraicNumber<C> abs \n int hashCode \n AlgebraicNumber<C> negate \n boolean equals \n AlgebraicNumber<C> clone \n boolean isZERO \n String toString \n AlgebraicNumber<C> divide \n AlgebraicNumber<C> multiply \n AlgebraicNumber<C> remainder", "output": "AlgebraicNumber < C > function ( AlgebraicNumber < C > arg0 ) { if ( arg0 . isZERO ( ) ) { return this ; } if ( isZERO ( ) ) { return arg0 ; } if ( isUnit ( ) || arg0 . isUnit ( ) ) { return ring . getONE ( ) ; } return new AlgebraicNumber < C > ( ring , val . gcd ( arg0 . val ) ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable version of the given non-null intlist . ", "input": " IntListIterator EMPTY_INT_LIST_ITERATOR \n IntList EMPTY_INT_LIST \n IntIterator EMPTY_INT_ITERATOR \n IntListIterator singletonIntListIterator \n IntListIterator getEmptyIntListIterator \n IntIterator unmodifiableIntIterator \n IntIterator singletonIntIterator \n IntList getEmptyIntList \n IntIterator getEmptyIntIterator \n IntListIterator unmodifiableIntListIterator \n IntList singletonIntList", "output": "IntList function ( IntList arg0 ) { if ( null == arg0 ) { throw new NullPointerException ( ) ; } return UnmodifiableIntList . wrap ( arg0 ) ; }"}, {"instruction": "Generate java code\nstop dispatching item changed events to presenters until start | resume dispatchingitemschanged is called . useful when many menu operations are going to be performed as a batch . ", "input": " int SHOW_AS_ACTION_NEVER \n Drawable mIcon \n MenuItem.OnMenuItemClickListener mMenuItemClickListener \n GeckoActionProvider mActionProvider \n GeckoSubMenu mSubMenu \n boolean mShouldDispatchChanges \n int mActionEnum \n GeckoMenu mMenu \n int mId \n boolean mCheckable \n boolean mChecked \n int mOrder \n OnShowAsActionChangedListener mShowAsActionChangedListener \n int SHOW_AS_ACTION_IF_ROOM \n int SHOW_AS_ACTION_ALWAYS \n boolean mVisible \n boolean mEnabled \n CharSequence mTitleCondensed \n CharSequence mTitle \n boolean mDidChange \n View mActionView \n int mIconRes \n int SHOW_AS_ACTION_IF_ROOM_WITH_TEXT \n MenuItem setActionProvider \n MenuItem setActionProvider \n boolean hasSubMenu \n void startDispatchingChanges \n boolean invoke \n CharSequence getTitleCondensed \n int getGroupId \n CharSequence getTitle \n MenuItem setChecked \n char getAlphabeticShortcut \n MenuItem setOnMenuItemClickListener \n Intent getIntent \n boolean isActionViewExpanded \n MenuItem setVisible \n MenuItem setIntent \n MenuItem setSubMenu \n MenuItem setCheckable \n MenuItem setTitle \n MenuItem setTitle \n MenuItem setNumericShortcut \n boolean isVisible \n boolean isChecked \n MenuItem setTitleCondensed \n void resumeDispatchingChanges \n MenuItem setIcon \n MenuItem setIcon \n MenuItem setEnabled \n MenuItem setShowAsActionFlags \n boolean isEnabled \n MenuItem setActionView \n MenuItem setActionView \n void setOnShowAsActionChangedListener \n void setShowIcon \n MenuItem setOnActionExpandListener \n boolean expandActionView \n GeckoActionProvider getGeckoActionProvider \n boolean collapseActionView \n int getItemId \n View getActionView \n int getActionEnum \n boolean isCheckable \n boolean hasActionProvider \n MenuItem setShortcut \n void setShowAsAction \n void setShowAsAction \n SubMenu getSubMenu \n void onShowAsActionChanged \n MenuItem setAlphabeticShortcut \n ActionProvider getActionProvider \n Drawable getIcon \n boolean isActionItem \n boolean hasActionItemBar \n int getOrder \n char getNumericShortcut \n void initialize \n ContextMenu.ContextMenuInfo getMenuInfo", "output": "void function ( ) { mDidChange = false ; mShouldDispatchChanges = false ; }"}, {"instruction": "Generate java code\nremove bean instance . ", "input": " Map<TypeBeanStateKey,Set<Object>> beans \n Set<Object> instances \n Map<TypeBeanStateKey,List<Callback>> incallbacks \n Map<TypeBeanStateKey,List<Callback>> uncallbacks \n Class<?> type \n void removeUncallback \n void start \n void addCallback \n Set<Object> getValue \n void addInstance \n void addInstance \n void stop \n void invokeCallbacks \n void removeIncallback \n void addUncallback \n void removeCallback \n InstancesService putIfAbsent \n void addIncallback \n Set<Object> getBeans", "output": "void function ( ServiceRegistry arg0 , BeanState arg1 , Object arg2 ) { removeInstance ( arg0 , arg1 , arg2 . getClass ( ) , arg2 ) ; }"}, {"instruction": "Generate java code\ngets the value of the message property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the message property . for example , to add a new item , do as follows : getmessage . add newitem ; objects of the following type s are allowed in the list message ", "input": " ValidationContext validationContext \n List<LocalizedMessage> localizedMessage \n List<Message> message \n void setValidationContext \n List<LocalizedMessage> getLocalizedMessage \n ValidationContext getValidationContext", "output": "List < Message > function ( ) { if ( message == null ) { message = new ArrayList < Message > ( ) ; } return this . message ; }"}, {"instruction": "Generate java code\nwrite the link tag with a reference to the external resource . ", "input": " T canvas \n T favicon \n T script \n T javascript \n T cdata", "output": "T function ( String arg0 ) { return ( T ) canvas . link ( type ( \"srini_string\" ) . href ( arg0 ) . rel ( \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nreturns an iterator over entries in this file . note that this iterator is shared with other users of the file : it does not contain a separate pointer into the file . ", "input": " Schema schema \n List<String> metaKeyList \n long blockCount \n boolean availableBlock \n byte[] data \n DatumReader<D> reader \n long blockRemaining \n Map<String,byte[]> meta \n int blockSize \n ByteBuffer blockBuffer \n byte[] syncBuffer \n byte[] sync \n Codec codec \n boolean flushOnWrite \n BinaryDecoder datumIn \n int offset \n Header header \n BinaryDecoder vin \n DataBlock block \n long numEntries \n D next \n D next \n boolean isFlushOnWrite \n void remove \n Header getHeader \n Codec resolveCodec \n void compressUsing \n boolean hasNextBlock \n ByteBuffer getAsByteBuffer \n long getBlockSize \n int getBlockSize \n void setFlushOnWrite \n DataBlock nextRawBlock \n long getBlockCount \n void writeBlockTo \n void close \n byte[] getData \n void decompressUsing \n void blockFinished \n String getMetaString \n long getMetaLong \n boolean hasNext \n ByteBuffer nextBlock \n Schema getSchema \n long getNumEntries \n List<String> getMetaKeys \n byte[] getMeta \n void initialize \n void initialize", "output": "Iterator < D > function ( ) { return this ; }"}, {"instruction": "Generate java code\nretrieves from the storm configuration the specified named query . ", "input": " PlaceHolder placeHolder \n BatchCQLStatementTupleMapper unLoggedBatch \n CqlMapper.DefaultCqlMapper all \n CQLStatementTupleMapper async \n ContextQuery namedByField \n BatchCQLStatementTupleMapper newBatchStatementBuilder \n BatchCQLStatementTupleMapper counterBatch \n FieldSelector field \n BatchCQLStatementTupleMapper loggedBatch \n BoundCQLStatementMapperBuilder boundQuery \n BoundCQLStatementMapperBuilder boundQuery \n FieldSelector[] fields \n SimpleCQLStatementMapperBuilder simpleQuery \n SimpleCQLStatementMapperBuilder simpleQuery", "output": "ContextQuery function ( final String arg0 ) { return new ContextQuery . BoundQueryContext ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the jni signaure for a member . ", "input": " HashMap<String,String> NATIVE_TYPES \n HashMap<String,String> CLASS_DESCRIPTORS \n HashMap<String,String> NATIVE_ARRAY_TYPES \n boolean isStatic \n String getClassDescriptor \n String getMemberName \n String getNativeParameterType \n boolean isFinal \n String getNativeName \n String getNativeReturnType \n String getUnqualifiedName", "output": "String function ( Member arg0 ) { return arg0 instanceof Field ? getSignature ( ( Field ) arg0 ) : arg0 instanceof Method ? getSignature ( ( Method ) arg0 ) : getSignature ( ( Constructor < ? > ) arg0 ) ; }"}, {"instruction": "Generate java code\nsets the fum . ", "input": " Locale locale \n Fum fum \n Fum getFum \n void setId \n FumCompositeID getId \n Locale getLocale \n void setLocale", "output": "void function ( Fum arg0 ) { this . fum = arg0 ; }"}, {"instruction": "Generate java code\nreturn the list of issued and renewed tokens . ", "input": " PlaceHolder placeHolder \n void add \n Token[] getExpiredTokens \n Token[] getCancelledTokens \n String[] getTokenIdentifiers \n void handlePersistenceOnShutdown \n List<Token> getStorageTokens \n void removeToken \n Token getToken \n Token[] getRenewedTokens \n void update \n void handlePersistence", "output": "Token [ ] function ( ) { return new Token [ 0 ] ; }"}, {"instruction": "Generate java code\ndeletes all text from the clipboard . ", "input": " String LOGTAG \n SynchronousQueue<String> sClipboardQueue \n Context mContext \n void init \n String getClipboardTextImpl \n String getText \n boolean hasText \n void setText", "output": "void function ( ) { setText ( null ) ; }"}, {"instruction": "Generate java code\nget objects that determines search query ", "input": " String m_Url \n String m_Key \n String m_Packing \n String m_Language \n String m_Format \n String getPacking \n String getLanguage \n void setPacking \n String getObjectsInBoxByBBox \n String getObjectById \n String getObjectInBox \n String getObjectsInBoxByLatLon \n String doSendApiRequest \n void setFormat \n String getObjectsInPoint \n String getObjectsInBoxByTile \n String getObjectsInBoxByTile \n String getFormat \n void setLanguage", "output": "String function ( String arg0 , int arg1 ) { return doSendApiRequest ( \"srini_string\" , \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }"}, {"instruction": "Generate java code\nremove the local variable type table attribute lvtt from mg . evidently some changes require this to be updated , but without bcel support that would be hard to do . it should be safe to just delete it since it is optional and really only of use to a debugger . ", "input": " boolean skip_checks \n Type string_array \n void add_line_numbers \n void add_to_start \n void dump_methods \n String get_attribute_name \n String get_attribute_name \n String instruction_descr \n void setup_init_locals \n String get_constant_str \n void empty_method \n void dump_method_declarations \n boolean in_jdk \n boolean in_jdk \n String get_access_flags \n String get_method_declaration \n boolean is_clinit \n boolean is_clinit \n void checkMgen \n String local_var_descr \n boolean is_constructor \n boolean is_constructor \n boolean is_main \n void dump \n void dump \n boolean is_local_variable_type_table \n void checkMgens", "output": "void function ( MethodGen arg0 ) { for ( Attribute loc0 : arg0 . getCodeAttributes ( ) ) { if ( is_local_variable_type_table ( loc0 , arg0 . getConstantPool ( ) ) ) { arg0 . removeCodeAttribute ( loc0 ) ; } } }"}, {"instruction": "Generate java code\nconvenience method for setting a flag . ", "input": " Rational timeStamp \n long sequenceNumber \n EnumSet<BufferFlag> flags \n int NOT_SPECIFIED \n Object data \n int offset \n int length \n Format format \n Object header \n int sampleCount \n int track \n Rational sampleDuration \n void setMetaTo \n void clearFlag \n boolean isFlag \n void clearFlags \n void setDataTo \n Object copy \n void setFlagsTo \n void setFlagsTo", "output": "void function ( BufferFlag arg0 ) { setFlag ( arg0 , true ) ; }"}, {"instruction": "Generate java code\nthe index of the statement that creates this value . ", "input": " Sequence sequence \n long serialVersionUID \n int index \n Variable copyWithIndexUpdated \n String getName \n String getName \n Class<?> getType \n int hashCode \n boolean equals \n String toString \n List<Integer> statementIndexList \n int compareTo \n StatementKind getDeclaringStatement", "output": "int function ( ) { return this . index ; }"}, {"instruction": "Generate java code\ninitializes the main menu background ", "input": " Image background \n Image loadAndResizeSprite \n Image getBackGround", "output": "void function ( ) { this . background = this . loadAndResizeSprite ( \"srini_string\" , 672 , 864 ) ; }"}, {"instruction": "Generate java code\nuse a strategy that validates that a schema can read existing schema s , and vice-versa , according to the avro default schema resolution . ", "input": " SchemaValidationStrategy strategy \n void valid \n SchemaValidatorBuilder canReadStrategy \n SchemaValidator validateAll \n SchemaValidator validateLatest \n SchemaValidatorBuilder canBeReadStrategy \n SchemaValidatorBuilder strategy", "output": "SchemaValidatorBuilder function ( ) { this . strategy = new ValidateMutualRead ( ) ; return this ; }"}, {"instruction": "Generate java code\nreturn true iff this quadrant is adjacent to the boundary of an image in the given direction . ", "input": " PlaceHolder placeHolder \n Quadrant reflect \n QuadTreeNode child", "output": "boolean function ( int arg0 ) { return ( arg0 == QuadTreeNode . SOUTH || arg0 == QuadTreeNode . EAST ) ; }"}, {"instruction": "Generate java code\nreturns an executor that wraps runnables before submission to the passed in executor . ", "input": " Field causeField \n void handleException \n StackTraceElement[] getStackContext \n Throwable findRootCause \n Callable<T> makeContextCallable \n Runnable makeContextRunnable \n List<Callable<T>> makeContextWrappedCollection", "output": "Executor function ( final Executor arg0 ) { return new Executor ( ) { @ Override public void execute ( Runnable arg1 ) { arg0 . execute ( makeContextRunnable ( arg1 ) ) ; } } ; }"}, {"instruction": "Generate java code\naddfish places a fish in cell x , y if the cell is empty . if the cell is already occupied , leave the cell as it is . ", "input": " int EMPTY \n int FISH \n int SHARK \n int starveTime \n int width \n Animal[][] gridData \n int height \n int starveTime \n int[] animalAround \n void sharkUpdate \n void fishUpdate \n void main \n void addShark \n void addShark \n int cellContents \n int[] checkOffGrid \n int sharkFeeding \n Ocean timeStep \n int width \n void emptyUpdate \n int height", "output": "void function ( int arg0 , int arg1 ) { int [ ] loc0 = checkOffGrid ( arg0 , arg1 ) ; if ( gridData [ loc0 [ 0 ] ] [ loc0 [ 1 ] ] == null ) { gridData [ loc0 [ 0 ] ] [ loc0 [ 1 ] ] = new Animal ( 2 ) ; } }"}, {"instruction": "Generate java code\nreturns the iso two-letter country code of this country/region . ", "input": " String code \n String name \n String getName", "output": "String function ( ) { return code ; }"}, {"instruction": "Generate java code\nconverts an array of integer pixels into an image . the array is referenced by the image . ", "input": " PlaceHolder placeHolder \n BufferedImage[] split \n Image createImage \n Image createImage \n BufferedImage toIntImage \n int[] toPixels \n BufferedImage cloneImage \n BufferedImage toBufferedImage \n BufferedImage toBufferedImage \n boolean hasAlpha", "output": "BufferedImage function ( int [ ] arg0 , int arg1 , int arg2 ) { return new BufferedImage ( DirectColorModel . getRGBdefault ( ) , Raster . createWritableRaster ( new SinglePixelPackedSampleModel ( DataBuffer . TYPE_INT , arg1 , arg2 , new int [ ] { 0xff00000 , 0xff00 , 0xff } ) , new DataBufferInt ( arg0 , arg1 * arg2 ) , new Point ( 0 , 0 ) ) , false , null ) ; }"}, {"instruction": "Generate java code\ncreate an instance of link ", "input": " QName _SyncToken_QNAME \n QName _Dst_QNAME \n QName _SyncLevel_QNAME \n QName _Status_QNAME \n QName _Depth_QNAME \n QName _Responsedescription_QNAME \n QName _Nresults_QNAME \n QName _Timeout_QNAME \n QName _Href_QNAME \n QName _Src_QNAME \n JAXBElement<String> createDst \n Propstat createPropstat \n Supportedlock createSupportedlock \n Propertybehavior createPropertybehavior \n Lockentry createLockentry \n Resourcetype createResourcetype \n Unauthenticated createUnauthenticated \n JAXBElement<String> createSyncToken \n JAXBElement<String> createStatus \n SyncCollection createSyncCollection \n Limit createLimit \n Location createLocation \n JAXBElement<String> createSyncLevel \n SupportedReportSet createSupportedReportSet \n Lockinfo createLockinfo \n Getcontentlanguage createGetcontentlanguage \n Lockscope createLockscope \n Getcontenttype createGetcontenttype \n Owner createOwner \n Read createRead \n All createAll \n Lockdiscovery createLockdiscovery \n Exclusive createExclusive \n ReadAcl createReadAcl \n JAXBElement<String> createDepth \n WriteContent createWriteContent \n Getetag createGetetag \n Omit createOmit \n Collection createCollection \n Propname createPropname \n Error createError \n ReadCurrentUserPrivilegeSet createReadCurrentUserPrivilegeSet \n Authenticated createAuthenticated \n Bind createBind \n JAXBElement<BigInteger> createNresults \n JAXBElement<String> createHref \n Report createReport \n JAXBElement<String> createTimeout \n Keepalive createKeepalive \n Shared createShared \n Locktype createLocktype \n Remove createRemove \n Write createWrite \n JAXBElement<String> createResponsedescription \n Creationdate createCreationdate \n JAXBElement<String> createSrc \n Activelock createActivelock \n Getcontentlength createGetcontentlength \n Prop createProp \n Displayname createDisplayname \n Response createResponse \n UnBind createUnbind \n SearchRequest createSearch \n Set createSet \n Propertyupdate createPropertyupdate \n Locktoken createLocktoken \n Source createSource \n Propfind createPropfind \n Self createSelf \n Getlastmodified createGetlastmodified \n SupportedReport createSupportedReport \n Unlock createUnlock \n Multistatus createMultistatus \n Allprop createAllprop \n WriteProperties createWriteProperties", "output": "Link function ( ) { return new Link ( ) ; }"}, {"instruction": "Generate java code\nreturns the full path of the immediate parent of the specified node . null if passed the root node or an invalid node ", "input": " char ZNODE_PATH_SEPARATOR \n Logger LOG \n void createSetData \n int checkExists \n boolean setData \n List<String> listChildrenNoWatch \n String joinZNode \n ArrayList<ACL> createACL \n void deleteNodeRecursively \n byte[] getData \n void createWithParents \n void createWithParents", "output": "String function ( String arg0 ) { int loc0 = arg0 . lastIndexOf ( ZNODE_PATH_SEPARATOR ) ; return loc0 <= 0 ? null : arg0 . substring ( 0 , loc0 ) ; }"}, {"instruction": "Generate java code\nreturns the debug . ", "input": " Object warn \n Object trace \n Object debug \n Throwable lastThrowable \n Object error \n Object info \n Object fatal \n void debug \n void debug \n Object getInfo \n Object getFatal \n Throwable getLastThrowable \n void clear \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n Object getError \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n Object getWarn \n Object getTrace \n boolean isDebugEnabled \n void info \n void info", "output": "Object function ( ) { return debug ; }"}, {"instruction": "Generate java code\nsets the string to be contained . ", "input": " String rowData \n char index \n int indexColor \n void setIndexColor \n char getIndex \n void setIndex \n int getIndexColor \n String getRow", "output": "void function ( String arg0 ) { rowData = arg0 ; }"}, {"instruction": "Generate java code\ncreate a figure info instance . note that by default this info object is lazily populated . if you need an eagerly populated info object , use the ", "input": " IFigure _figure \n FigureInfoState _state \n IWidgetLocator _locatorDelegate \n ClassReference _class \n Object getAdapter \n IFigureReference getParent \n FigureReference eager \n IFigure getWidget \n FigureReference lazy \n EditPart getEditPart \n IFigure getFigure \n IWidgetLocator[] findAll \n boolean matches \n void accept \n IFigureReference[] getChildren \n FigureInfoState getState \n ClassReference getType \n IConnectionInfo[] getConnections \n IWidgetLocator getLocatorDelegate", "output": "FigureReference function ( IFigure arg0 ) { return lazy ( arg0 ) ; }"}, {"instruction": "Generate java code\ncache-aside find user account helper ", "input": " CachingPolicy cachingPolicy \n void initDb \n void initCacheCapacity \n String printCacheContent \n UserAccount find \n void save \n void saveAside \n void initCachingPolicy", "output": "UserAccount function ( String arg0 ) { UserAccount loc0 = CacheStore . get ( arg0 ) ; if ( loc0 != null ) { return loc0 ; } loc0 = DbManager . readFromDb ( arg0 ) ; if ( loc0 != null ) { CacheStore . set ( arg0 , loc0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nthe position when headers/footers should be repeated on each page . ", "input": " Integer normal \n Place place \n Integer repeated \n List<HtmlCell> content \n Integer getNormal \n boolean process \n boolean isContent \n boolean isNestable \n List<HtmlCell> getContent \n List<Chunk> getChunks \n Place getPlace \n int type", "output": "Integer function ( ) { return repeated ; }"}, {"instruction": "Generate java code\nkey methods ", "input": " AuctionEntry entry \n Integer Zero \n Map<String,Seller> sellers \n int getSellerFeedback \n Currency getCurrentTotal \n Seller getSeller \n Currency getMax \n Currency getMaxOrSnipe \n Currency getSnipe \n Currency getCurrentBid \n Currency getShippingInsurance \n int getSellerPositiveFeedback \n Currency getFixedPrice \n Currency getSnipeOrMax \n String getComment \n int safeConvert \n Currency getSnipeTotal", "output": "String function ( ) { return entry . getIdentifier ( ) ; }"}, {"instruction": "Generate java code\nmethod to set the title for the picture frame ", "input": " ImageIcon imageIcon \n JLabel label \n JFrame frame \n DigitalPicture picture \n void setVisible \n void setPicture \n void hide \n void displayImage \n void updateImageAndShowIt \n void updateImage \n void repaint \n void close \n void initFrame", "output": "void function ( String arg0 ) { frame . setTitle ( arg0 ) ; }"}, {"instruction": "Generate java code\nget a read-only list of all the items on the top shelf ", "input": " List<Potion> topShelf \n List<Potion> bottomShelf \n Logger LOGGER \n List<Potion> getBottomShelf \n void enumerate \n void fillShelves", "output": "List < Potion > function ( ) { return Collections . unmodifiableList ( this . topShelf ) ; }"}, {"instruction": "Generate java code\nadd an adapter to be returned by #getadapter class ", "input": " T widget \n Map<Class<?>,Object> adapters \n Object getAdapter \n T getWidget \n WidgetReference<T> create \n WidgetReference<T> create \n String toString \n IWidgetLocator[] findAll \n boolean matches", "output": "void function ( Class < ? > arg0 , Object arg1 ) { if ( adapters == null ) adapters = new HashMap < Class < ? > , Object > ( ) ; adapters . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns a typed sorted bag backed by the given bag . only objects of the specified type can be added to the bag . ", "input": " Bag EMPTY_BAG \n Bag EMPTY_SORTED_BAG \n Bag predicatedBag \n SortedBag synchronizedSortedBag \n SortedBag predicatedSortedBag \n SortedBag transformedSortedBag \n Bag typedBag \n Bag transformedBag \n SortedBag unmodifiableSortedBag \n Bag unmodifiableBag \n Bag synchronizedBag", "output": "SortedBag function ( SortedBag arg0 , Class arg1 ) { return TypedSortedBag . decorate ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the capacity of the array , which may be larger than the limit . ", "input": " byte[] data \n int limit \n int position \n int readUnsignedInt24 \n int readSynchSafeInt \n int readUnsignedIntToInt \n void setPosition \n void skipBytes \n long readUnsignedInt \n int getPosition \n long readLong \n short readShort \n void setLimit \n int bytesLeft \n int limit \n void reset \n void reset \n void readBytes \n void readBytes \n void readBytes \n int readUnsignedFixedPoint1616 \n int readInt \n long readUnsignedLongToLong \n int readUnsignedByte \n int readUnsignedShort", "output": "int function ( ) { return data == null ? 0 : data . length ; }"}, {"instruction": "Generate java code\nput entity in cache with cache lock . ", "input": " ReentrantLock lock \n LongSparseArray<Reference<T>> map \n void unlock \n T get \n void clear \n void lock \n void putNoLock \n T getNoLock \n void remove \n void remove", "output": "void function ( long arg0 , @ NonNull T arg1 ) { lock . lock ( ) ; try { map . put ( arg0 , new WeakReference < T > ( arg1 ) ) ; } finally { lock . unlock ( ) ; } }"}, {"instruction": "Generate java code\nretrieve all springconfig in the registry ", "input": " SpringConfigRegistry INSTANCE \n Map<SpringConfig,String> mSpringConfigMap \n void removeAllSpringConfig \n boolean addSpringConfig \n boolean removeSpringConfig \n SpringConfigRegistry getInstance", "output": "Map < SpringConfig , String > function ( ) { return Collections . unmodifiableMap ( mSpringConfigMap ) ; }"}, {"instruction": "Generate java code\ngets attribute handler cookieattributehandler for thegiven attribute . ", "input": " Map<String,CookieAttributeHandler> attribHandlerMap \n CookieAttributeHandler findAttribHandler \n void registerAttribHandler \n Collection<CookieAttributeHandler> getAttribHandlers", "output": "CookieAttributeHandler function ( final String arg0 ) { final CookieAttributeHandler loc0 = findAttribHandler ( arg0 ) ; if ( loc0 == null ) { throw new IllegalStateException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } else { return loc0 ; } }"}, {"instruction": "Generate java code\nupdates the last republish time by setting it to the current simulation time . a republish takes place if either this or another peer sends the data item to its neighbours . ", "input": " long lastRepublish \n DHTObject value \n ComponentsConfig config \n DHTObject getValue \n boolean hasExpired \n long getLastRepublish \n String toString \n boolean needsRepublish", "output": "void function ( ) { lastRepublish = Simulator . getCurrentTime ( ) ; }"}, {"instruction": "Generate java code\nwrites a complex type , that also implements backtoxmlwritable . ", "input": " Element curRootNode \n void writeTime \n void writeBack \n void writeBackToXML \n String getWrittenBackDoc \n void writeSimpleType", "output": "void function ( String arg0 , BackToXMLWritable arg1 ) { if ( arg1 == null ) return ; Element loc0 = curRootNode . addElement ( arg0 ) ; loc0 . addAttribute ( \"srini_string\" , arg1 . getClass ( ) . getName ( ) ) ; arg1 . writeBackToXML ( new BackWriter ( loc0 ) ) ; }"}, {"instruction": "Generate java code\ncomputes the dotproduct of our sliding windows and weights vectors . todo jaimeyap : i could make this a general purpose dotproduct function , but for now , this is more performant . trivial to add later . ", "input": " int eventDepth \n GraphModel graphModel \n Timer warmDownTimer \n int TICK_TIME \n double blockedTimeInWindow \n double[] weights \n double WINDOW_SLIDE_INCREMENT \n double weightedUtilizationPercent \n double WINDOW_WIDTH \n double maxUtilization \n double[] windowHistory \n double currentWindowStart \n double currentMarker \n double scaledWeightedUtilization \n void updateWeightedUtilization \n double calculateCurrentUtilization \n double getThreadUtilization \n void enterBlocking \n void slideWindowTo \n void run \n void releaseBlocking", "output": "double function ( double [ ] arg0 , double [ ] arg1 ) { assert ( ( arg0 . length == 3 ) && ( arg1 . length == 3 ) ) ; return ( arg0 [ 2 ] * arg1 [ 2 ] ) + ( arg0 [ 1 ] * arg1 [ 1 ] ) + ( arg0 [ 0 ] * arg1 [ 0 ] ) ; }"}, {"instruction": "Generate java code\ntest method for org.jboss.security.config.securityconfiguration #getkeystoreurl . ", "input": " PlaceHolder placeHolder \n void testGetCipherAlgorithm \n void testSetIterationCount \n void testGetSalt \n void testGetTrustStoreType \n void testGetKeyStoreType \n void testSetTrustStoreURL \n void testSetKeyStoreURL \n void testSetSalt \n void testLoadPassword \n void testSetCipherSpec \n void testGetExternalPasswordCacheInstance \n void testSetKeyStoreType \n void testIsDeepCopySubjectMode \n void testGetKeyStorePass \n WebArchive deployment \n void testSetTrustStorePass \n void testGetTrustStorePass \n void testSetCipherAlgorithm \n void testSetTrustStoreType \n void testGetTrustStoreURL \n void testSetDeepCopySubjectMode \n void testGetCipherSpec \n void testAddApplicationPolicy \n void testGetApplicationPolicy \n void testSetKeyStorePass \n void testRemoveApplicationPolicy \n void testSetCipherKey \n void testGetIterationCount \n void testGetCipherKey", "output": "void function ( ) { SecurityConfiguration . getKeyStoreURL ( ) ; }"}, {"instruction": "Generate java code\nsets the current principal name to the invocation context . principal name is stored to the context under the serversecurityinterceptor #delegated_user_key key . ", "input": " PlaceHolder placeHolder \n Object handleInvocationResult", "output": "void function ( EJBClientInvocationContext arg0 ) { Principal loc0 = SecurityContextAssociation . getPrincipal ( ) ; if ( loc0 != null ) { Map < String , Object > loc1 = arg0 . getContextData ( ) ; loc1 . put ( ServerSecurityInterceptor . DELEGATED_USER_KEY , loc0 . getName ( ) ) ; } arg0 . sendRequest ( ) ; }"}, {"instruction": "Generate java code\nfetches the message belonging to the key . ", "input": " String STYLE_NOTPARSED \n String UNSUPPORTED_CHARSET \n String A_SETLOCALGOTO \n String NO_SIBLING \n String OWN_CONTEXT_404 \n String ADD_HEADER \n String A_LOCALGOTO \n String COLSPAN \n String CUSTOMCONTEXT_404_CONTINUE \n ResourceBundle bundle \n String SPACEHACK \n String UNSUPPORTED_CLONING \n String PIPELINE_AUTODOC \n String INVALID_NESTED_TAG \n String META_CC \n String NO_CUSTOM_CONTEXT \n String NO_TAGPROCESSOR \n String STACK_404 \n String HEADER_BM_DISABLED \n String HTML_IMG_RETRIEVE_FAIL \n String A_EXTERNAL \n String ELEMENT_NOT_ADDED_EXC \n String IMG_SRC_NOTCONVERTED \n String HTML_IMG_USE \n String LINK_404 \n String ELEMENT_NOT_ADDED \n LocaleMessages myself \n String META_404 \n LocaleMessages getInstance", "output": "String function ( final String arg0 ) { return bundle . getString ( arg0 ) ; }"}, {"instruction": "Generate java code\ncompare 2 arrays only at the first level ", "input": " boolean[] TRUE \n int PRIME_NUMER \n int SEED \n String[] EMPTY_STRING_ARRAY \n boolean[] FALSE \n int[] EMPTY_INT_ARRAY \n byte[] EMPTY_BYTE_ARRAY \n Object[] EMPTY_OBJECT_ARRAY \n Type[] EMPTY_TYPE_ARRAY \n Class[] EMPTY_CLASS_ARRAY \n boolean[] EMPTY_BOOLEAN_ARRAY \n String[] fillArray \n int[] fillArray \n LockMode[] fillArray \n LockOptions[] fillArray \n int countNonNull \n void main \n List toList \n List toList \n Object[] typecast \n boolean isAllNegative \n String[] slice \n Object[] slice \n int[] toIntArray \n boolean isAllTrue \n int[][] to2DIntArray \n String[] join \n String[] join \n int[] join \n T[] join \n int indexOf \n boolean[] toBooleanArray \n String[][] to2DStringArray \n int getNextBatchSize \n Serializable[] extractNonNull \n String[] toStringArray \n String[] toStringArray \n String[] reverse \n int countTrue \n boolean contains \n boolean isAllFalse \n void addAll \n int[] getBatchSizes \n String toString \n Type[] toTypeArray \n int hash \n int hash \n int hash \n int hash", "output": "boolean function ( Object [ ] arg0 , Object [ ] arg1 ) { if ( arg0 == arg1 ) return true ; if ( arg0 == null || arg1 == null ) return false ; int loc0 = arg0 . loc0 ; if ( loc0 != arg1 . loc0 ) return false ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { if ( ! arg0 [ loc1 ] . equals ( arg1 [ loc1 ] ) ) return false ; } return true ; }"}, {"instruction": "Generate java code\ngets the closure . ", "input": " boolean iDoLoop \n Predicate iPredicate \n Closure iClosure \n long serialVersionUID \n Predicate getPredicate \n boolean isDoLoop \n Closure getInstance \n void execute", "output": "Closure function ( ) { return iClosure ; }"}, {"instruction": "Generate java code\ngets the predicate in use . ", "input": " boolean iDoLoop \n Predicate iPredicate \n Closure iClosure \n long serialVersionUID \n Closure getClosure \n boolean isDoLoop \n Closure getInstance \n void execute", "output": "Predicate function ( ) { return iPredicate ; }"}, {"instruction": "Generate java code\nvalidate that the schemas provided can mutually read data written by each other according to the default avro schema resolution rules . ", "input": " PlaceHolder placeHolder \n void canRead", "output": "void function ( Schema arg0 , Schema arg1 ) { canRead ( arg0 , arg1 ) ; canRead ( arg1 , arg0 ) ; }"}, {"instruction": "Generate java code\ndetermines if an item is a folder . ", "input": " String view \n String pluginId \n String name \n Image icon \n String description \n String id \n String mainType \n IConfigurationElement element \n String getMainType \n Object createItemInstance \n String getName \n String getPluginId \n int hashCode \n boolean equals \n String getId \n String getDescription \n String getView \n Image getIcon", "output": "boolean function ( ) { return ( mainType == null && view == null ) ; }"}, {"instruction": "Generate java code\ncalculate the greatest common divisor . ", "input": " String PROMPT \n void main", "output": "int function ( int arg0 , int arg1 ) { if ( arg0 < 0 ) { arg0 = - arg0 ; } if ( arg1 < 0 ) { arg1 = - arg1 ; } while ( arg1 != 0 ) { int loc0 = arg0 % arg1 ; arg0 = arg1 ; arg1 = loc0 ; } return arg0 ; }"}, {"instruction": "Generate java code\nreturns a memberref for the field ", "input": " ClassEditor editor \n boolean isDeleted \n boolean isDirty \n String name \n FieldInfo fieldInfo \n Type type \n Object constantValue \n boolean isStatic \n NameAndType nameAndType \n boolean isVolatile \n void setTransient \n void commit \n boolean isPrivate \n Type type \n void delete \n void setDirty \n void setFinal \n boolean isDirty \n boolean isProtected \n void setProtected \n void setVolatile \n boolean isPublic \n boolean isFinal \n void setPublic \n String fullName \n boolean isPackage \n void setStatic \n FieldInfo fieldInfo \n ClassEditor declaringClass \n void print \n String name \n String toString \n boolean isTransient \n void setPrivate \n Object constantValue", "output": "MemberRef function ( ) { return ( new MemberRef ( this . declaringClass ( ) . type ( ) , this . nameAndType ( ) ) ) ; }"}, {"instruction": "Generate java code\nliefert die darstellung fuer den null-wert . ", "input": " char zero \n char minus \n String regexp \n Charset charset \n int pointer \n Receiver receiver \n Sender sender \n int length \n BitAmount bits \n boolean[] buffer \n char plus \n char minus \n String getRegExp \n String receive \n char getLastPulseOfReceiver \n String charform \n String read \n void clear \n boolean isEmpty \n char plus \n int getDC \n StringBuilder stringform \n boolean[] bitform \n char getLastPulseOfSender \n char bufferToDecimal \n boolean get \n int getLength \n String getCharsetRegExp \n BitBuffer copy \n void buffer \n boolean isFull \n String send", "output": "char function ( ) { return zero ; }"}, {"instruction": "Generate java code\ncreates a light-weight dialog to present a refactoringstatus tothe user . the following values are returned from the dialogs open method : org.eclipse.jface.dialogs.idialogconstants #ok_id idialogconstants #ok_id : if the user has pressed the continue button . org.eclipse.jface.dialogs.idialogconstants #cancel_id idialogconstants #cancel_id : if the user has pressed the cancel button . org.eclipse.jface.dialogs.idialogconstants #back_id idialogconstants #back_id : if the user has pressed the back button . ", "input": " PlaceHolder placeHolder \n Dialog createRefactoringWizardDialog \n Dialog createRefactoringStatusDialog \n Composite createRefactoringHistoryControl \n Composite createSortableRefactoringHistoryControl \n PerformChangeOperation createUIAwareChangeOperation", "output": "Dialog function ( RefactoringStatus arg0 , Shell arg1 , String arg2 ) { return new RefactoringStatusDialog ( arg0 , arg1 , arg2 , false , true ) ; }"}, {"instruction": "Generate java code\nsets value of the coreconnectionpnames #so_keepalive parameter . ", "input": " PlaceHolder placeHolder \n void setSoReuseaddr \n int getLinger \n void setTcpNoDelay \n void setConnectionTimeout \n void setSoTimeout \n boolean getSoReuseaddr \n boolean getTcpNoDelay \n void setLinger \n int getSocketBufferSize \n void setSocketBufferSize \n int getSoTimeout \n boolean isStaleCheckingEnabled \n void setStaleCheckingEnabled \n boolean getSoKeepalive \n int getConnectionTimeout", "output": "void function ( final HttpParams arg0 , final boolean arg1 ) { Args . notNull ( arg0 , \"srini_string\" ) ; arg0 . setBooleanParameter ( CoreConnectionPNames . SO_KEEPALIVE , arg1 ) ; }"}, {"instruction": "Generate java code\nremoves the mapping for this key from this map if it is present . ", "input": " Map _values \n Map _register \n WidgetLocator add \n String getKey \n Set getEntries \n boolean containsKey \n WidgetLocator get \n boolean containsValue", "output": "WidgetLocator function ( String arg0 ) { WidgetLocator loc0 = get ( arg0 ) ; _values . remove ( loc0 ) ; return ( WidgetLocator ) _register . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nnot used within junit . clients should simply instantiate errorreportingrunner themselves ", "input": " PlaceHolder placeHolder \n Request filterWith \n Request filterWith \n Runner getRunner \n Request method \n Request classes \n Request classes \n Request classWithoutSuiteMethod \n Request sortWith \n Request runner \n Request aClass", "output": "Request function ( Class < ? > arg0 , Throwable arg1 ) { return runner ( new ErrorReportingRunner ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nnull object to empty string nullstrtoempty null = '' '' ; nullstrtoempty '' '' = '' '' ; nullstrtoempty `` aa '' = `` aa '' ; ", "input": " PlaceHolder placeHolder \n Long[] transformLongArray \n long[] transformLongArray \n int compare \n Integer[] transformIntArray \n int[] transformIntArray \n boolean isEquals", "output": "String function ( Object arg0 ) { return ( arg0 == null ? \"srini_string\" : ( arg0 instanceof String ? ( String ) arg0 : arg0 . toString ( ) ) ) ; }"}, {"instruction": "Generate java code\nthis method removes a given contact from the leaf set . ", "input": " PastryNode owningNode \n LinkedList<PastryContact> cwNodes \n LinkedList<PastryContact> ccwNodes \n long lastChanged \n int maxSize \n void cleanSet \n PastryContact getNumericallyClosestContact \n PastryContact getNumericallyClosestContact \n long getLastChanged \n void sortCcw \n boolean isInRange \n void setMaxSize \n boolean put \n int getSize \n Iterator<PastryContact> iterator \n void putAll \n void removeAndSubstitute \n boolean overlaps \n void reset \n void sortCw \n boolean isComplete", "output": "boolean function ( PastryContact arg0 ) { boolean loc0 = false ; if ( cwNodes . contains ( arg0 ) ) loc0 = cwNodes . remove ( arg0 ) ; if ( ccwNodes . contains ( arg0 ) ) loc0 = ccwNodes . remove ( arg0 ) || loc0 ; if ( loc0 ) lastChanged = Simulator . getCurrentTime ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\nkey click method that delegates to swt robot ", "input": " Point pointT \n abbot.swt.Robot _robot \n void doKeyDown \n void doKeyUp \n void mouseMove \n void mouseMove \n void keyUp \n void keyUp \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n int[] extractKeys \n void mouseUp \n void keyClick \n void keyClick \n void keyDown \n void keyDown \n Event createClickEvent \n void enterText", "output": "void function ( final char arg0 ) { final abbot . swt . Robot loc0 = getAbbotRobot ( ) ; Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { loc0 . keyPress ( ( int ) arg0 ) ; loc0 . keyRelease ( ( int ) arg0 ) ; } } ) ; }"}, {"instruction": "Generate java code\ngets the enable state of the dialog field . ", "input": " String fLabelText \n IDialogFieldListener fDialogFieldListener \n Label fLabel \n boolean fEnabled \n Label getLabelControl \n boolean isOkToUse \n void refresh \n boolean setFocus \n void dialogFieldChanged \n void setEnabled \n void setDialogFieldListener \n Control[] doFillIntoGrid \n Control createEmptySpace \n Control createEmptySpace \n void setLabelText \n GridData gridDataForLabel \n void updateEnableState \n void postSetFocusOnDialogField \n void assertEnoughColumns \n void assertCompositeNotNull \n int getNumberOfControls", "output": "boolean function ( ) { return fEnabled ; }"}, {"instruction": "Generate java code\nvalidate that the specified argument character sequence is neither null nor a length of zero no characters ; otherwise throwing an exception with the specified message . validate.notempty mystring , `` the string must not be empty '' ; ", "input": " PlaceHolder placeHolder \n T notNull \n boolean isEmpty \n String unescape \n String concat \n void onlyOneIsTrue \n void isTrue \n boolean onlyOneIsTrueNonThrow \n String hex \n String toString \n String join \n String join \n void closeQuietly \n String escape \n int indexOf", "output": "T function ( T arg0 , String arg1 , Object ... arg2 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( String . format ( arg1 , arg2 ) ) ; } if ( arg0 . length ( ) == 0 ) { throw new IllegalArgumentException ( String . format ( arg1 , arg2 ) ) ; } return arg0 ; }"}, {"instruction": "Generate java code\nsets the component . ", "input": " Component component \n GridBagConstraints constraints \n GridBagConstraints getConstraints \n void setConstraints \n Component getComponent", "output": "void function ( Component arg0 ) { this . component = arg0 ; }"}, {"instruction": "Generate java code\nreturns the editpartfactory that the graphicalviewer will use . ", "input": " GraphicalViewer viewer \n ActionRegistry actionRegistry \n KeyHandler sharedKeyHandler \n IEditorSite editorSite \n GraphicalViewer getViewer \n GraphicalViewer createViewer \n void createGraphicalViewer", "output": "EditPartFactory function ( ) { return new SchemaEditPartFactory ( ) ; }"}, {"instruction": "Generate java code\nreturn the context attribute key under which we will store the request locale . ", "input": " String localeKey \n void setLocaleKey \n boolean execute \n Locale getLocale", "output": "String function ( ) { return ( this . localeKey ) ; }"}, {"instruction": "Generate java code\ngrabs input focus . ", "input": " Composite controlPanel \n Composite parent \n Menu backMenu \n ToolItem pauseItem \n Spinner timerSpinner \n Object[] tabBackground \n GraphicsTab[] tabs \n boolean animate \n ToolBar toolBar \n ToolItem playItem \n GraphicsTab tab \n boolean advanceGraphicsInit \n ResourceBundle RESOURCE_BUNDLE \n ToolItem dbItem \n Canvas canvas \n Vector images \n Listener redrawListener \n MenuItem customMI \n boolean advanceGraphics \n Tree tabList \n Color customColor \n int TIMER \n Image customImage \n Composite tabPanel \n ToolItem backItem \n void createControlPanel \n Listener getRedrawListener \n Image createImage \n void startAnimationTimer \n GraphicsTab[] createTabs \n String getResourceString \n void paintBackground \n void main \n boolean checkAdvancedGraphics \n TreeItem findItemByData \n void createToolBar \n Image loadImage \n Image loadImage \n void redraw \n void setTab \n GraphicsTab getTab \n void createTabPanel \n void dispose \n void createCanvas \n void createTabList", "output": "void function ( ) { tabList . setFocus ( ) ; }"}, {"instruction": "Generate java code\nreturn true iff this quadrant is adjacent to the boundary of an image in the given direction . ", "input": " PlaceHolder placeHolder \n Quadrant reflect \n QuadTreeNode child", "output": "boolean function ( int arg0 ) { return ( arg0 == QuadTreeNode . NORTH || arg0 == QuadTreeNode . WEST ) ; }"}, {"instruction": "Generate java code\nadd an property . ", "input": " String configurationName \n Map<String,String> properties \n String getProperty \n ValidatorConfiguration addAttribute \n String getConfigurationName \n int hashCode \n Map<String,String> getProperties \n String getValidatorClassName \n boolean equals \n ValidatorConfiguration clone \n String toString", "output": "ValidatorConfiguration function ( String arg0 , Object arg1 ) { properties . put ( arg0 , String . valueOf ( arg1 ) ) ; return this ; }"}, {"instruction": "Generate java code\ndoes the given identifier belong to a new instance ? ", "input": " IdentifierValue NONE \n IdentifierValue UNDEFINED \n Logger LOG \n IdentifierValue NULL \n Serializable value \n IdentifierValue ANY \n String toString \n String toString \n String toString \n String toString \n String toString \n Serializable getDefaultValue \n Serializable getDefaultValue \n Serializable getDefaultValue \n Serializable getDefaultValue \n Serializable getDefaultValue", "output": "Boolean function ( Object arg0 ) { LOG . tracev ( \"srini_string\" , value ) ; return arg0 == null || arg0 . equals ( value ) ; }"}, {"instruction": "Generate java code\ntest d1 and d2 for d1 > d2 . if d1 is equal to d2 using the current ratio , this returns false . ", "input": " double max_ratio \n double min_ratio \n boolean off \n boolean isElemMatch \n int compare \n boolean isSubset \n boolean ne \n boolean lt \n boolean gte \n void set_rel_diff \n boolean eq \n boolean lte \n int indexOf \n int indexOf", "output": "boolean function ( double arg0 , double arg1 ) { return ( ( arg0 > arg1 ) && ne ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nmethod used for copying styles from one chunk to another . could be deprecated if the content of a chunk can be overwritten . ", "input": " FontProvider fontProvider \n List<String> BOLD \n CssUtils utils \n boolean isBoldValue \n Font applyFontStyles \n Chunk apply \n FontProvider getFontProvider \n float getWidestWord \n void setFontProvider", "output": "void function ( final Chunk arg0 , final Chunk arg1 ) { arg1 . setFont ( arg0 . getFont ( ) ) ; arg1 . setAttributes ( arg0 . getAttributes ( ) ) ; arg1 . setCharacterSpacing ( arg0 . getCharacterSpacing ( ) ) ; arg1 . setHorizontalScaling ( arg0 . getHorizontalScaling ( ) ) ; arg1 . setHorizontalScaling ( arg0 . getHorizontalScaling ( ) ) ; }"}, {"instruction": "Generate java code\nextract text from a specified page using an extraction strategy . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "String function ( PdfReader arg0 , int arg1 , TextExtractionStrategy arg2 ) { return getTextFromPage ( arg0 , arg1 , arg2 , new HashMap < String , ContentOperator > ( ) ) ; }"}, {"instruction": "Generate java code\ntest a requestdispatcher forward that fails to commit the tx . ", "input": " String STATUS_ACTIVE \n Logger log \n void testIncludeNoCommit \n WebArchive statusDeployment \n void testIncludeCommit \n void testForwardCommit \n void testURL \n WebArchive controlDeployment", "output": "void function ( @ ArquillianResource ( TxControlServlet . class ) URL arg0 ) { testURL ( arg0 , false , false ) ; }"}, {"instruction": "Generate java code\nset the state of the current tag ", "input": " String text \n Charset charset \n StateController controller \n XMLParserMemory memory \n List<XMLParserListener> listeners \n TagState tagState \n ParserMonitor monitor \n State state \n XMLParserMemory memory \n void startElement \n InputStreamReader detectEncoding \n char currentLastChar \n XMLParser removeListener \n void parse \n void parse \n void parse \n void parse \n Charset getCharset \n String current \n void endElement \n void flush \n void parseWithReader \n void unknownData \n String currentTag \n void setMonitor \n String bufferToString \n void setState \n void comment \n StateController selectState \n void text \n XMLParser append \n XMLParser append \n XMLParser append \n void callText \n XMLParser addListener \n int bufferSize", "output": "void function ( final TagState arg0 ) { this . tagState = arg0 ; }"}, {"instruction": "Generate java code\nmake sure that the provided keystore will be reusable . ", "input": " String REVIEW_MESSAGE \n InputStream streamKeystore \n void verifyKeystoreContent \n void verifyKeystoreContent \n KeyStore loadKeystore \n KeyStore loadKeystore \n KeyStore loadKeystore \n char[] getKeystorePasswordForSSL \n void validateKeystoreParameter \n KeystoreException wrapKeystoreException", "output": "Object function ( AppleServer arg0 , Object arg1 ) { if ( arg1 instanceof InputStream ) arg1 = loadKeystore ( arg0 , arg1 , false ) ; return arg1 ; }"}, {"instruction": "Generate java code\nparse a matrix from a reader . ", "input": " int blocksize \n GenMatrix<C> ZERO \n int DEFAULT_BSIZE \n GenMatrix<C> ONE \n Logger logger \n RingFactory<C> coFac \n float density \n int rows \n int cols \n Random random \n float DEFAULT_DENSITY \n GenMatrix<C> randomUpper \n GenMatrix<C> randomUpper \n GenMatrix<C> randomLower \n GenMatrix<C> randomLower \n GenMatrixRing<C> product \n GenMatrix<C> fromList \n boolean isField \n boolean isCommutative \n java.math.BigInteger characteristic \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n int hashCode \n boolean equals \n GenMatrix<C> getONE \n GenMatrix<C> getZERO \n GenMatrix<C> fromInteger \n GenMatrix<C> fromInteger \n String toString \n boolean isAssociative \n GenMatrixRing<C> transpose \n GenMatrix<C> copy", "output": "GenMatrix < C > function ( Reader arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nthis method is used in #parsetemplate string to determine what member specificvariables are expected in a template . ", "input": " String OBJECT_SYSTEM_HASHCODE_VARIABLE \n String[] VARIABLES \n String[] beginning \n String[] OBJECT_RELAED_VARIABLE \n String[] body \n String separator \n Map<String,String> descriptions \n String OBJECT_SUPER_TOSTRING_VARIABLE \n String DEFAULT_TEMPLATE \n String[] ending \n String OTHER_MEMBERS_VARIABLE \n String OBJECT_HASHCODE_VARIABLE \n String[] MEMBER_RELATED_VARIABLE \n String MEMBER_NAME_VARIABLE \n String MEMBER_VALUE_VARIABLE \n String OBJECT_NAME_VARIABLE \n String[] OBJECT_AND_MEMBER_RELATED_VARIABLES \n String[] VARIABLE_DESCRIPTIONS \n String OBJECT_GET_NAME_VARIABLE \n String MEMBER_NAME_PARENTHESIS_VARIABLE \n String[] getObjectAndMemberRelatedVariables \n String[] getBeginning \n String[] getEnding \n void parseTemplate \n String[] getVariables \n ArrayList<String> extractElements \n String[] getBody \n String[] getObjectRelatedVariables \n String getSeparator \n Map<String,String> getVariableDescriptions \n int firstOccuranceOf", "output": "String [ ] function ( ) { return ToStringTemplateParser . MEMBER_RELATED_VARIABLE ; }"}, {"instruction": "Generate java code\nconvert characters in a java string to the escaped form that must be used in . properties files . ", "input": " char[] HEX_DIGITS \n int getHexDigitValue \n String unescapeBackslashes \n boolean containsInvalidEscapeSequence \n char toHex \n boolean containsUnescapedBackslash \n String unescape \n boolean containsEscapedBackslashes", "output": "String function ( String arg0 , boolean arg1 , boolean arg2 , boolean arg3 ) { StringBuffer loc0 = new StringBuffer ( arg0 . loc1 ( ) ) ; int loc1 = arg0 . loc1 ( ) ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { char loc3 = arg0 . charAt ( loc2 ) ; loc0 . append ( escape ( loc3 , arg1 , arg2 , arg3 ) ) ; } return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ncreate a singleton hazelcastinstance server @bean . ", "input": " String CLUSTER_HOST \n Logger LOG \n String MASTER_SERVER \n HazelcastInstance hazelcastInstance \n int CLUSTER_PORT \n HazelcastInstance cluster \n HazelcastInstance cluster \n HazelcastInstance makeClient \n void preDestroy \n HazelcastInstance makeServer \n KeyValueOperations keyValueTemplate", "output": "HazelcastInstance function ( ) { HazelcastInstance loc0 = InstanceHelper . makeServer ( Constants . HAZELCAST_INSTANCE_NAME , CLUSTER_PORT ) ; LOG . trace ( \"srini_string\" , loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns a text only if it is in given language ", "input": " boolean fromContent \n Map<String,Map<String,Integer>> cooccurrences \n boolean fromAbstract \n List<KeywordCandidate> keywordCandidates \n String ILLEGAL_CHARS \n Logger logger \n int DEFAULT_KEYWORDS_NUMBER \n ExtractionOption extractionOption \n Lang lang \n Map<Lang,Set<String>> stopwords \n String content \n void setOption \n boolean isNum \n void countCooccurrences \n String extractTextFromPdf \n List<String> getSupportedLanguages \n void prepareToExtraction \n List<String> choiceKeywords \n List<String> getKeywords \n List<String> getKeywords \n void countMetrics \n void setLang \n void extractKeywordCandidates \n List<String> getAvailableExtractionOptions", "output": "String function ( String arg0 , String arg1 ) { LanguageIdentifierBean loc0 ; try { loc0 = new LanguageIdentifierBean ( ) ; return ( arg1 . equals ( loc0 . classify ( arg0 ) ) ) ? arg0 : \"srini_string\" ; } catch ( CeonGeneralException loc1 ) { throw new IOException ( loc1 ) ; } }"}, {"instruction": "Generate java code\nreset the simulator , so that it can be configured again for another simulation run without to restart the java virtual machine . this is especially usefull for junit tests . ", "input": " Simulator singleton \n Logger log \n long seed \n Monitor monitor \n DefaultConfigurator defaultConfigurator \n long MINUTE_UNIT \n long SECOND_UNIT \n boolean running \n Scheduler scheduler \n long MICROSECOND_UNIT \n long MILLISECOND_UNIT \n boolean finishedWithoutError \n Scenario scenario \n RandomGenerator randomGen \n long HOUR_UNIT \n void setRealTime \n void shutdownSimulation \n long getSeed \n void setFinishAt \n String getSimulatedRealtime \n void checkRunning \n void start \n void setScenario \n boolean isFinishedWithoutError \n void configure \n void scheduleEvent \n String getFormattedTime \n DefaultConfigurator getConfigurator \n void setStatusInterval \n long getEndTime \n RandomGenerator getRandom \n void setMonitor \n Scenario getScenario \n Monitor getMonitor \n void setTimeSkew \n Simulator getInstance \n long getCurrentTime \n Scheduler getScheduler \n void setSeed", "output": "void function ( ) { checkRunning ( ) ; monitor = new DefaultMonitor ( ) ; scenario = null ; scheduler = new Scheduler ( true ) ; seed = 0 ; }"}, {"instruction": "Generate java code\ncreates a parenttree of all parent tag objects of a given tag ", "input": " PlaceHolder placeHolder \n List<String> getParentTree", "output": "List < Tag > function ( final Tag arg0 , final List < Tag > arg1 ) { List < Tag > loc0 = new ArrayList < Tag > ( ) ; Tag loc1 = arg0 . getParent ( ) ; while ( loc1 != null && ! ( loc1 . getName ( ) . equals ( HTML . Tag . HTML ) ) ) { loc0 . add ( loc1 ) ; loc1 = loc1 . getParent ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nrandom vector . ", "input": " GenVector<C> ZERO \n Logger logger \n RingFactory<C> coFac \n float density \n int cols \n List<GenVector<C>> BASIS \n Random random \n float DEFAULT_DENSITY \n GenVector<C> fromList \n int hashCode \n boolean equals \n GenVector<C> getZERO \n GenVector<C> fromInteger \n GenVector<C> fromInteger \n String toString \n GenVector<C> copy \n GenVector<C> parse \n GenVector<C> parse", "output": "GenVector < C > function ( int arg0 , float arg1 ) { return random ( arg0 , arg1 , random ) ; }"}, {"instruction": "Generate java code\ndoes the line start with the given string ? ", "input": " String inlineMarkupDelimiters \n int sectionLevel \n boolean erased \n boolean inBlock \n boolean listStart \n List<Boolean> valid \n char ESCAPED_CHARACTER_VALUE \n List<Integer> offsets \n List<Character> characters \n String text \n List<Boolean> escaped \n int listLevel \n int lineNo \n boolean allSameCharacter \n void setListStart \n void erase \n void erase \n void erase \n boolean isListStart \n String getText \n boolean isValid \n int getOffset \n int length \n boolean isEmpty \n void eraseWithStyle \n boolean isAllSameCharacter \n void setSectionLevel \n void setInBlock \n boolean isErased \n int getSectionLevel \n int eraseEnclosure \n int getListLevel \n int getLineNo \n boolean isInBlock \n String toString \n char rawCharAt \n void setListLevel \n char charAt \n char charAt", "output": "boolean function ( String arg0 ) { for ( int loc0 = 0 ; loc0 < arg0 . length ( ) ; loc0 ++ ) { if ( charAt ( loc0 ) != arg0 . charAt ( loc0 ) ) { return false ; } } return true ; }"}, {"instruction": "Generate java code\ninserts one or more documents . this method is equivalent to a call to the bulkwrite method . the documents will be inserted in the order provided , stopping on the first failed insertion . ", "input": " MongoClient client \n MongoCollection<Document> collection \n Document find \n void update \n void close", "output": "void function ( List < Document > arg0 , boolean arg1 ) { InsertManyOptions loc0 = new InsertManyOptions ( ) ; if ( ! arg1 ) { loc0 . arg1 ( false ) ; } collection . insertMany ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\ncreates a student object using the given studentcontactfile.the studentcontactfile should be an xml file containing the marshaled form of a contact object . ", "input": " PlaceHolder placeHolder \n Instructor readInstructor \n void main \n void writeSession \n Session readSession \n List<Student> readStudents", "output": "Student function ( File arg0 , JAXBContext arg1 ) { Unmarshaller loc0 = arg1 . createUnmarshaller ( ) ; Student loc1 = new Student ( ) ; Contact loc2 = ( Contact ) loc0 . unmarshal ( arg0 ) ; loc1 . setContact ( loc2 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nget key type znode . ", "input": " String ENCRYPTION_KEY_NO_ZNODE_NAME \n String KEY_VERSION_ZNODE_NAME \n String PRINCIPAL_NAME_ZNODE_NAME \n String baseZNode \n String CREATED_TIME_ZNODE_NAME \n String KDC_FLAGS_ZNODE_NAME \n String DISABLED_ZNODE_NAME \n String KEYS_ZNODE_NAME \n String IDENTITIES_ZNODE_NAME \n String KEY_ZNODE_NAME \n String EXPIRE_TIME_ZNODE_NAME \n String KEY_TYPE_ZNODE_NAME \n String LOCKED_ZNODE_NAME \n String getEncryptionKeyTypeZNode \n String getBaseZNode \n String getDisabledZNode \n String getEncryptionKeyNoZNode \n String getEncryptionKeyZNode \n String getLockedZNode \n String getCreatedTimeZNode \n String getExpireTimeZNode \n String getKeyVersionZNode \n String getKeysZNode \n String getIdentitiesZNode \n List<String> getIdentityNames \n String getPrincipalNameZnode \n String getIndentityZNode \n String getKdcFlagsZNode", "output": "String function ( String arg0 , String arg1 ) { return ZKUtil . joinZNode ( getKeysZNode ( arg0 ) , arg1 ) ; }"}, {"instruction": "Generate java code\nreverses all 32 bits of the provided integer value . ", "input": " PlaceHolder placeHolder \n int gcd \n long gcd \n BigInteger gcd \n void main \n int scm \n long scm \n BigInteger scm", "output": "int function ( int arg0 ) { return reverseBits ( arg0 , 32 ) ; }"}, {"instruction": "Generate java code\ndeletes an existing entry in the appropriate properties ", "input": " Properties dvdProperties \n Properties cdProperties \n Properties bookProperties \n void edit \n Properties getProperties \n void create \n void retrieve", "output": "void function ( String arg0 , String arg1 ) { getProperties ( arg0 ) . remove ( arg1 ) ; System . out . println ( arg0 + \"srini_string\" + arg1 + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreads the contents of a file to a string . ", "input": " PlaceHolder placeHolder \n String unEscapeURL \n URL toURL \n char[] copyOfRange \n boolean isSurrogatePair \n boolean isSurrogatePair \n float inchesToPoints \n void skip \n float pointsToMillimeters \n Set<K> getKeySet \n boolean isSurrogateHigh \n float millimetersToInches \n String convertFromUtf32 \n int convertToUtf32 \n int convertToUtf32 \n int convertToUtf32 \n float millimetersToPoints \n float inchesToMillimeters \n float pointsToInches \n String convertToHex \n boolean checkTrueOrFalse \n boolean isSurrogateLow \n Object[][] addToArray", "output": "String function ( final String arg0 ) { return readFileToString ( new File ( arg0 ) ) ; }"}, {"instruction": "Generate java code\ncreates a new criteria ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria lt \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria nin \n Criteria nin \n Criteria and \n Criteria gte \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria eq \n Criteria gt \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n Criteria exists \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( String arg0 , String arg1 , String arg2 ) { Criteria loc0 = new Criteria ( ValueNode . toValueNode ( arg0 ) ) ; loc0 . criteriaType = RelationalOperator . fromString ( arg1 ) ; loc0 . arg2 = ValueNode . toValueNode ( arg2 ) ; return loc0 ; }"}, {"instruction": "Generate java code\na simple main method that prints the version and exits ", "input": " PlaceHolder placeHolder \n String getSpecification \n String getImplementation", "output": "void function ( String [ ] arg0 ) { System . out . println ( \"srini_string\" + getSpecification ( ) ) ; System . out . println ( \"srini_string\" + getImplementation ( ) ) ; }"}, {"instruction": "Generate java code\nend date of the period for which the account statement is issued . ", "input": " BankToCustomerStatementV02 bankToCustomerStatement \n Document document \n GroupHeader42 groupHeader \n AccountStatement2 stmt \n CashAccount16 getRltdAcct \n List<ReportEntry2> getNtry \n String getAddtlStmtInf \n BankToCustomerStatement read \n PartyIdentification32 getMsgRcpt \n Date getCreDtTm \n Date getCreDtTm \n Pagination getMsgPgntn \n String getAddtlInf \n String getId \n BigDecimal getElctrncSeqNb \n Date getFrDt \n TotalTransactions2 getTxsSummry \n List<AccountInterest2> getIntrst \n CashAccount20 getAcct \n String getMsgId \n ReportingSource1Choice getRptgSrc \n List<AccountStatement> getStmt \n CopyDuplicate1Code getCpyDplctInd \n BigDecimal getLglSeqNb \n List<CashBalance3> getBal", "output": "Date function ( ) { return stmt . getFrToDt ( ) . getToDtTm ( ) . toGregorianCalendar ( ) . getTime ( ) ; }"}, {"instruction": "Generate java code\nget paras map ", "input": " Map<String,String> requestProperties \n int readTimeout \n int connectTimeout \n Map<String,String> parasMap \n String url \n Map<String,String> getRequestProperties \n String getUrl \n void setReadTimeout \n void setRequestProperties \n void setConnectTimeout \n void setRequestProperty \n int getReadTimeout \n String getParas \n void setUserAgent \n int getConnectTimeout \n void setParasMap \n String getRequestProperty", "output": "Map < String , String > function ( ) { return parasMap ; }"}, {"instruction": "Generate java code\nreturns a super type hierarchy that contains the given type . the returned hierarchy may actually be based on a subtype of the requested type . therefore , queries such as itypehierarchy #getallclasses or itypehierarchy #getrootinterfaces may return more types than the samequeries on a type hierarchy for just the given type . ", "input": " int CACHE_SIZE \n Map<IType,MethodOverrideTester> fgMethodOverrideTesterCache \n long fLastAccess \n ITypeHierarchy fTypeHierarchy \n int fgCacheHits \n ArrayList<HierarchyCacheEntry> fgHierarchyCache \n int fgCacheMisses \n long getLastAccess \n int getCacheHits \n boolean hasInCache \n void removeHierarchyEntryFromCache \n MethodOverrideTester getMethodOverrideTester \n void addTypeHierarchyToCache \n int getCacheMisses \n ITypeHierarchy findTypeHierarchyInCache \n void markAsAccessed \n void removeMethodOverrideTester \n void typeHierarchyChanged \n void dispose \n String toString", "output": "ITypeHierarchy function ( IType arg0 ) { return getTypeHierarchy ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nempties the contents of the stack . ", "input": " ArrayLongList list \n long pop \n int search \n int size \n long get \n long push \n boolean empty \n long peek \n long peek", "output": "void function ( ) { list . clear ( ) ; }"}, {"instruction": "Generate java code\nunprotected method . ", "input": " PlaceHolder placeHolder \n String role1 \n String role2", "output": "String function ( ) { return RESULT ; }"}, {"instruction": "Generate java code\nset the width for this box . ", "input": " int type \n Box parent \n float height \n boolean DEBUG \n float shift \n Box elderParent \n Color foreground \n float width \n Color markForDEBUG \n Color background \n Color prevColor \n LinkedList<Box> children \n float depth \n void add \n void add \n Box getParent \n void negWidth \n float getDepth \n void setElderParent \n void startDraw \n Box getElderParent \n float getWidth \n void draw \n void setHeight \n float getShift \n void setShift \n int getLastFontId \n float getHeight \n void drawDebug \n void drawDebug \n void endDraw \n void setParent \n void setDepth", "output": "void function ( float arg0 ) { width = arg0 ; }"}, {"instruction": "Generate java code\nsearch for one word in phrase . the search is not case sensitive . this method will check that the given goal is not a substring of a longer string so , for example , `` i know '' does not contain `` no '' . the search begins at the beginning of the string . ", "input": " PlaceHolder placeHolder \n String getRandomResponse \n String getResponse \n String getGreeting", "output": "int function ( String arg0 , String arg1 ) { return findKeyword ( arg0 , arg1 , 0 ) ; }"}, {"instruction": "Generate java code\nbiginteger random . ", "input": " java.math.BigInteger val \n BigInteger ONE \n BigInteger ZERO \n Random random \n boolean isField \n boolean isCommutative \n BigInteger gcd \n BigInteger IPROD \n BigInteger sum \n int compareTo \n BigInteger IABS \n java.math.BigInteger characteristic \n BigInteger random \n BigInteger random \n int hashCode \n BigInteger IDIF \n BigInteger divide \n BigInteger copy \n BigInteger multiply \n BigInteger IGCD \n int signum \n BigInteger ISUM \n boolean isONE \n BigInteger inverse \n java.math.BigInteger getVal \n BigInteger INEG \n BigInteger valueOf \n BigInteger valueOf \n boolean isUnit \n BigInteger subtract \n BigInteger IQ \n BigInteger[] IQR \n BigInteger parse \n BigInteger parse \n BigInteger[] egcd \n int ISIGN \n BigInteger abs \n BigInteger IREM \n BigInteger[] divideAndRemainder \n BigInteger negate \n boolean equals \n BigInteger clone \n BigInteger getONE \n BigInteger getZERO \n BigInteger fromInteger \n BigInteger fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n int ICOMP \n BigInteger remainder", "output": "BigInteger function ( int arg0 ) { return ONE . random ( arg0 , random ) ; }"}, {"instruction": "Generate java code\nget this object as a datetime using isochronology in the same zone . ", "input": " PlaceHolder placeHolder \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n Date toDate \n boolean isEqual \n boolean isEqual \n DateTimeZone getZone \n boolean isSupported \n int compareTo \n boolean isBeforeNow \n Instant toInstant \n boolean isBefore \n boolean isBefore \n boolean isEqualNow \n MutableDateTime toMutableDateTimeISO \n int hashCode \n int get \n int get \n boolean equals \n String toString \n String toString \n boolean isAfter \n boolean isAfter \n DateTime toDateTime \n DateTime toDateTime \n DateTime toDateTime \n boolean isAfterNow", "output": "DateTime function ( ) { return new DateTime ( getMillis ( ) , ISOChronology . getInstance ( getZone ( ) ) ) ; }"}, {"instruction": "Generate java code\nreturn the image associated with the receiver . ", "input": " Image image \n DialogImage ERROR \n DialogImage WARNING \n String printName \n DialogImage INFO \n DialogImage QUESTION \n String toString", "output": "Image function ( ) { return image ; }"}, {"instruction": "Generate java code\ncloses this server . ", "input": " boolean stop \n void processMessage \n void runServer \n void main", "output": "void function ( ) { synchronized ( this ) { stop = true ; this . notify ( ) ; } }"}, {"instruction": "Generate java code\ncreates a new hessian 2.0 deserializer . ", "input": " SerializerFactory _serializerFactory \n SerializerFactory _defaultSerializerFactory \n Logger log \n HessianFreeList<HessianInput> _freeHessianInput \n HessianFreeList<HessianOutput> _freeHessianOutput \n HessianFreeList<Hessian2Input> _freeHessian2Input \n HessianFreeList<Hessian2Output> _freeHessian2Output \n void freeHessian2StreamingInput \n Hessian2Output createHessian2Output \n Hessian2StreamingOutput createHessian2StreamingOutput \n void freeHessian2StreamingOutput \n void setSerializerFactory \n OutputStream createHessian2DebugOutput \n SerializerFactory getSerializerFactory \n Hessian2StreamingInput createHessian2StreamingInput \n void freeHessian2Output \n HessianOutput createHessianOutput \n HessianInput createHessianInput \n void freeHessian2Input", "output": "Hessian2Input function ( InputStream arg0 ) { Hessian2Input loc0 = new Hessian2Input ( arg0 ) ; loc0 . setSerializerFactory ( _serializerFactory ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncreate an instance of activelock ", "input": " QName _SyncToken_QNAME \n QName _Dst_QNAME \n QName _SyncLevel_QNAME \n QName _Status_QNAME \n QName _Depth_QNAME \n QName _Responsedescription_QNAME \n QName _Nresults_QNAME \n QName _Timeout_QNAME \n QName _Href_QNAME \n QName _Src_QNAME \n JAXBElement<String> createDst \n Propstat createPropstat \n Supportedlock createSupportedlock \n Propertybehavior createPropertybehavior \n Lockentry createLockentry \n Resourcetype createResourcetype \n Unauthenticated createUnauthenticated \n JAXBElement<String> createSyncToken \n JAXBElement<String> createStatus \n Link createLink \n SyncCollection createSyncCollection \n Limit createLimit \n Location createLocation \n JAXBElement<String> createSyncLevel \n SupportedReportSet createSupportedReportSet \n Lockinfo createLockinfo \n Getcontentlanguage createGetcontentlanguage \n Lockscope createLockscope \n Getcontenttype createGetcontenttype \n Owner createOwner \n Read createRead \n All createAll \n Lockdiscovery createLockdiscovery \n Exclusive createExclusive \n ReadAcl createReadAcl \n JAXBElement<String> createDepth \n WriteContent createWriteContent \n Getetag createGetetag \n Omit createOmit \n Collection createCollection \n Propname createPropname \n Error createError \n ReadCurrentUserPrivilegeSet createReadCurrentUserPrivilegeSet \n Authenticated createAuthenticated \n Bind createBind \n JAXBElement<BigInteger> createNresults \n JAXBElement<String> createHref \n Report createReport \n JAXBElement<String> createTimeout \n Keepalive createKeepalive \n Shared createShared \n Locktype createLocktype \n Remove createRemove \n Write createWrite \n JAXBElement<String> createResponsedescription \n Creationdate createCreationdate \n JAXBElement<String> createSrc \n Getcontentlength createGetcontentlength \n Prop createProp \n Displayname createDisplayname \n Response createResponse \n UnBind createUnbind \n SearchRequest createSearch \n Set createSet \n Propertyupdate createPropertyupdate \n Locktoken createLocktoken \n Source createSource \n Propfind createPropfind \n Self createSelf \n Getlastmodified createGetlastmodified \n SupportedReport createSupportedReport \n Unlock createUnlock \n Multistatus createMultistatus \n Allprop createAllprop \n WriteProperties createWriteProperties", "output": "Activelock function ( ) { return new Activelock ( ) ; }"}, {"instruction": "Generate java code\nreturns the language names call-back used in this report . ", "input": " ILanguageNames languageNames \n String outputEncoding \n void setOutputEncoding \n void setLanguageNames \n IReportVisitor createVisitor", "output": "ILanguageNames function ( ) { return languageNames ; }"}, {"instruction": "Generate java code\nexecute an authenticated request and return the response . ", "input": " String IF_NONE_MATCH \n String GITHUB \n ObjectMapper mapper \n URL GITHUB_URL \n Repository repository \n String getIssueEndpoint \n void patchIssue \n byte[] buildRequest \n Phenotype readPhenotype \n Repository getRepository \n String buildSearch \n InputStream getStream \n void openIssue \n URI getURI \n Optional<String> searchForIssue \n void checkCode \n String getRepoMethod", "output": "HttpResponse function ( Request arg0 ) { arg0 . addHeader ( \"srini_string\" , \"srini_string\" + repository . getToken ( ) ) ; Response loc0 = arg0 . execute ( ) ; return loc0 . returnResponse ( ) ; }"}, {"instruction": "Generate java code\ngets the current size of the undoqueue . ", "input": " int MAX_QUEUE_SIZE \n Document doc \n UndoableList queue \n int cursor \n void add \n boolean isRedoable \n void prefsTrim \n String getUndoRangeString \n String getRedoName \n void clear \n boolean isEmpty \n String getRedoRangeString \n void destroy \n void redo \n void undo \n String getUndoName \n void trim \n boolean isUndoable \n Undoable get \n void redoAll \n UndoableEdit getIfEdit \n void undoAll", "output": "int function ( ) { return queue . size ( ) ; }"}, {"instruction": "Generate java code\nchecks if some value is valid for a certain key . ", "input": " PdfName NONFULLSCREENPAGEMODE_PREFERENCES[] \n int pageLayoutAndMode \n PdfName DIRECTION_PREFERENCES[] \n int viewerPreferencesMask \n PdfName PRINTSCALING_PREFERENCES[] \n PdfName DUPLEX_PREFERENCES[] \n PdfName PAGE_BOUNDARIES[] \n PdfDictionary viewerPreferences \n PdfName[] VIEWER_PREFERENCES \n PdfDictionary getViewerPreferences \n PdfViewerPreferencesImp getViewerPreferences \n void setViewerPreferences \n int getPageLayoutAndMode \n int getIndex \n void addViewerPreference \n void addToCatalog", "output": "boolean function ( PdfName arg0 , PdfName [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1 . length ; loc0 ++ ) { if ( arg1 [ loc0 ] . equals ( arg0 ) ) { return true ; } } return false ; }"}, {"instruction": "Generate java code\ndispatches an event depending on it 's type . ", "input": " Map<Class<? extends Event>,Handler<? extends Event>> handlers \n void registerHandler", "output": "void function ( E arg0 ) { Handler < E > loc0 = ( Handler < E > ) handlers . get ( arg0 . getClass ( ) ) ; if ( loc0 != null ) { loc0 . onEvent ( arg0 ) ; } }"}, {"instruction": "Generate java code\nreturn the child that represents this quadrant of the given node . ", "input": " PlaceHolder placeHolder \n Quadrant reflect \n boolean adjacent", "output": "QuadTreeNode function ( QuadTreeNode arg0 ) { return arg0 . getNorthEast ( ) ; }"}, {"instruction": "Generate java code\nlength of red and white parts . ", "input": " GenPolynomial<GenPolynomial<C>> red \n GenPolynomial<GenPolynomial<C>> green \n GenPolynomial<GenPolynomial<C>> white \n List<GenPolynomial<C>> getRedCoefficients \n boolean isONE \n ExpVector leadingExpVector \n Map.Entry<ExpVector,GenPolynomial<C>> leadingMonomial \n boolean checkInvariant \n ColorPolynomial<C> subtract \n ColorPolynomial<C> subtract \n boolean isDetermined \n GenPolynomial<GenPolynomial<C>> getPolynomial \n ColorPolynomial<C> sum \n ColorPolynomial<C> sum \n ColorPolynomial<C> abs \n int hashCode \n boolean equals \n boolean isZERO \n List<GenPolynomial<C>> getGreenCoefficients \n String toString \n ColorPolynomial<C> divide \n GenPolynomial<GenPolynomial<C>> getEssentialPolynomial \n ColorPolynomial<C> multiply \n ColorPolynomial<C> multiply", "output": "int function ( ) { int loc0 = red . length ( ) + white . length ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\ninvokes #add object for each element in the given collection . ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n int hashCode \n int calcTotalSize \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "boolean function ( Collection arg0 ) { boolean loc0 = false ; Iterator loc1 = arg0 . iterator ( ) ; while ( loc1 . hasNext ( ) ) { boolean loc2 = add ( loc1 . next ( ) ) ; loc0 = loc0 || loc2 ; } return loc0 ; }"}, {"instruction": "Generate java code\nadvance the animation . ", "input": " GraphicsExample example \n void createControlPanel \n String getText \n String getCategory \n void paint \n void dispose \n boolean isAnimated", "output": "void function ( int arg0 , int arg1 ) { }"}, {"instruction": "Generate java code\ngets all codecs which can decode the specified format . ", "input": " Registry instance \n Codec[] getCodecs \n Codec[] getDecoders \n String[] getCodecClasses \n Codec[] getEncoders \n void unregisterCodec \n void putCodec \n Codec getEncoder \n String[] getDecoderClasses \n void init \n String getExtension \n Codec getCodec \n void putReader \n MovieReader getReader \n MovieReader getReader \n void putFileFormat \n Format[] getWriterFormats \n Format getFileFormat \n Format[] getReaderFormats \n Format[] getFileFormats \n String[] getWriterClasses \n String[] getReaderClasses \n Codec getDecoder \n MovieWriter getWriter \n MovieWriter getWriter \n ArrayList<Format> suggestOutputFormats \n void putWriter \n Registry getInstance", "output": "String [ ] function ( Format arg0 ) { return getCodecClasses ( null , arg0 ) ; }"}, {"instruction": "Generate java code\nget the specified section . ", "input": " Optional<String> fileName \n long serialVersionUID \n boolean built \n Set<PreprocessorRule> preprocessorRules \n List<Section> sections \n RedPenTokenizer tokenizer \n DocumentBuilder appendSection \n void ensureNotBuilt \n DocumentBuilder addSection \n DocumentBuilder addSection \n DocumentBuilder setPreprocessorRules \n Section getLastSection \n Section getLastSection \n Set<PreprocessorRule> getPreprocessorRules \n DocumentBuilder setFileName \n Iterator<Section> iterator \n DocumentBuilder addSectionHeader \n int size \n DocumentBuilder addSentence \n DocumentBuilder addSentence \n Document build \n int hashCode \n boolean equals \n DocumentBuilder builder \n DocumentBuilder builder \n String toString \n DocumentBuilder addParagraph \n DocumentBuilder addListBlock \n Optional<String> getFileName \n DocumentBuilder addListElement \n DocumentBuilder addListElement", "output": "Section function ( int arg0 ) { return sections . get ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets a string from an asn1primitive ", "input": " PlaceHolder placeHolder \n String getOCSPURL \n String getCRLURL \n String getTSAURL \n CRL getCRL \n CRL getCRL \n ASN1Primitive getExtensionValue", "output": "String function ( ASN1Primitive arg0 ) { ASN1TaggedObject loc0 = ( ASN1TaggedObject ) arg0 ; return new String ( ASN1OctetString . getInstance ( loc0 , false ) . getOctets ( ) , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets a chunk with a symbol character . ", "input": " PlaceHolder placeHolder \n char getCorrespondingSymbol \n int index", "output": "Chunk function ( char arg0 , Font arg1 ) { char loc0 = SpecialSymbol . getCorrespondingSymbol ( arg0 ) ; if ( loc0 == ' ' ) { return new Chunk ( String . valueOf ( arg0 ) , arg1 ) ; } Font loc1 = new Font ( FontFamily . SYMBOL , arg1 . getSize ( ) , arg1 . getStyle ( ) , arg1 . getColor ( ) ) ; String loc2 = String . valueOf ( loc0 ) ; return new Chunk ( loc2 , loc1 ) ; }"}, {"instruction": "Generate java code\ncreate an instance of a summarystatistics ", "input": " long serialVersionUID \n double getStandardDeviation \n StatisticalSummary getSummary \n double getMax \n long getN \n void clear \n double getMin \n int hashCode \n boolean equals \n double getVariance \n double getMean \n double getSumsq \n double getSum \n void addValue \n double getGeometricMean", "output": "SummaryStatistics function ( Class arg0 ) { return ( SummaryStatistics ) arg0 . newInstance ( ) ; }"}, {"instruction": "Generate java code\nfactory method to create a set from a map . ", "input": " long serialVersionUID \n Object dummyValue \n Map map \n boolean add \n boolean containsAll \n boolean isEmpty \n void clear \n boolean remove \n Iterator iterator \n boolean contains \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n boolean equals \n Object[] toArray \n Object[] toArray \n boolean retainAll", "output": "Set function ( Map arg0 , Object arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new MapBackedSet ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nget one single phenotype where the field given has the value given . ", "input": " Joiner OR_QUERY_JOINER \n Path path \n SolrClient server \n CoreContainer cores \n boolean autocommit \n String WILDCARD_QSTRING \n String CORE_NAME \n SolrMapper mapper \n boolean up \n String FIELD_IS \n void init \n Phenotype savePhenotype \n String addStatusFilter \n Phenotype getPhenotypeByIssueNumber \n Phenotype getPhenotype \n void commit \n boolean getAutocommit \n List<Phenotype> searchPhenotypes \n void setAutocommit \n List<Phenotype> getPhenotypesByStatus \n List<Phenotype> getPhenotypesByField \n String getNextId \n Phenotype getPhenotypeByHpoId \n boolean deletePhenotype \n Phenotype runQuery \n void checkUp \n void shutdown \n Phenotype getPhenotypeById", "output": "Phenotype function ( String arg0 , String arg1 ) { List < Phenotype > loc0 = getPhenotypesByField ( arg0 , arg1 , true ) ; if ( loc0 . size ( ) == 0 ) { return Phenotype . NULL ; } return loc0 . get ( 0 ) ; }"}, {"instruction": "Generate java code\ndouble the capacity of the internal array . ", "input": " int size \n SimulationEvent[] items \n int collaps \n int size \n boolean more \n void reset \n void insert \n void verify \n String toString \n void heapify \n void decrease \n SimulationEvent remove \n boolean remove \n boolean empty \n SimulationEvent peek", "output": "void function ( ) { SimulationEvent [ ] loc0 = new SimulationEvent [ this . items . length * 2 ] ; System . arraycopy ( this . items , 0 , loc0 , 0 , this . size ) ; this . collaps = this . items . length / 4 ; this . items = loc0 ; }"}, {"instruction": "Generate java code\nrandom node form group ", "input": " double DEFAULT_DOWN_BANDWIDTH \n GnpSubnet subnet \n GnpPosition gnpPosition \n double DEFAULT_UP_BANDWIDTH \n int experimentSize \n double downBandwidth \n double upBandwidth \n PeerDistributionFromBitmap peerDistribution \n GeoLocation geoLoc \n Logger log \n Long idCounter \n Set<Long> usedIds \n IPv4NetID createNewID \n void setDownBandwidth \n void setBandwidthManager \n void setPbaPeriod \n void setExperimentSize \n GnpNetLayer createComponent \n void setLatencyModel \n void setUpBandwidth \n void setBitmapPath", "output": "GnpNetLayer function ( String arg0 ) { IPv4NetID loc0 = createNewID ( ) ; return newNetLayer ( loc0 ) ; }"}, {"instruction": "Generate java code\nget plugin version . ", "input": " PreauthPluginMeta pluginMeta \n KrbContext context \n void init \n void tryFirst \n boolean process \n String getName \n List<EncryptionType> getEncTypes \n void prepareQuestions \n PaDataType[] getPaTypes \n boolean tryAgain \n void destroy \n void setPreauthOptions \n PaFlags getFlags \n PluginRequestContext initRequestContext", "output": "int function ( ) { return pluginMeta . getVersion ( ) ; }"}, {"instruction": "Generate java code\ncalled by requestor #request string , object , callback for two-way messages using callbacks . ", "input": " ReentrantLock channelLock \n void lockChannel \n void writeBuffers \n String getRemoteName \n boolean isConnected \n List<ByteBuffer> readBuffers \n void unlockChannel \n void close \n Protocol getRemote \n void setRemote", "output": "void function ( List < ByteBuffer > arg0 , Callback < List < ByteBuffer >> arg1 ) { try { List < ByteBuffer > loc0 = transceive ( arg0 ) ; arg1 . handleResult ( loc0 ) ; } catch ( IOException loc0 ) { arg1 . handleError ( loc0 ) ; } }"}, {"instruction": "Generate java code\nconverts an input handle back to the corresponding java element . ", "input": " String ATTRIBUTE_SELECTION \n String ATTRIBUTE_ELEMENT \n String ATTRIBUTE_NAME \n String ATTRIBUTE_INPUT \n String ATTRIBUTE_REFERENCES \n RefactoringStatus createInputFatalStatus \n String resourceToHandle \n IResource handleToResource \n RefactoringStatus createInputWarningStatus \n String elementToHandle", "output": "IJavaElement function ( final String arg0 , final String arg1 , final boolean arg2 ) { return handleToElement ( null , arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nbigdecimal random . ", "input": " java.math.BigDecimal val \n int DEFAULT_PRECISION \n BigDecimal ZERO \n MathContext DEFAULT_CONTEXT \n MathContext context \n BigDecimal ONE \n Random random \n boolean isField \n boolean isCommutative \n BigDecimal gcd \n BigDecimal sum \n int compareTo \n java.math.BigInteger characteristic \n int hashCode \n BigDecimal divide \n BigDecimal copy \n BigDecimal multiply \n int signum \n boolean isONE \n BigDecimal inverse \n BigDecimal valueOf \n BigDecimal valueOf \n boolean isUnit \n BigDecimal subtract \n BigDecimal parse \n BigDecimal parse \n BigDecimal[] egcd \n BigDecimal abs \n BigDecimal[] divideAndRemainder \n BigDecimal negate \n boolean equals \n BigDecimal clone \n BigDecimal getONE \n BigDecimal getZERO \n BigDecimal fromInteger \n BigDecimal fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigDecimal remainder", "output": "BigDecimal function ( int arg0 , int arg1 , Random arg2 ) { java . math . BigInteger loc0 = new java . math . BigInteger ( arg0 , arg2 ) ; if ( arg2 . nextBoolean ( ) ) { loc0 = loc0 . negate ( ) ; } int loc1 = arg2 . nextInt ( arg1 ) ; if ( arg2 . nextBoolean ( ) ) { loc1 = - loc1 ; } java . math . BigDecimal loc2 = new java . math . BigDecimal ( loc0 , loc1 , context ) ; return new BigDecimal ( loc2 , context ) ; }"}, {"instruction": "Generate java code\ncreates a list based on an enumeration . as the enumeration is traversed , an arraylist of its values is created . the new list is returned . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "List function ( Enumeration arg0 ) { return IteratorUtils . toList ( new EnumerationIterator ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nlocal identifier , generated by localvariabledeclarationstatement . ", "input": " Class<?> type \n String identifier \n Class<?> getReturnType", "output": "String function ( Class < ? > arg0 ) { return identifier ; }"}, {"instruction": "Generate java code\ncreates a randomaccesssource based on a byte array ", "input": " boolean forceRead \n boolean usePlainRandomAccess \n boolean exclusivelyLockFile \n RandomAccessSource createBestSource \n RandomAccessSource createBestSource \n RandomAccessSource createBestSource \n RandomAccessSourceFactory setExclusivelyLockFile \n RandomAccessSource createRanged \n RandomAccessSourceFactory setForceRead \n RandomAccessSource createByReadingToMemory \n RandomAccessSource createByReadingToMemory \n RandomAccessSourceFactory setUsePlainRandomAccess", "output": "RandomAccessSource function ( byte [ ] arg0 ) { return new ArrayRandomAccessSource ( arg0 ) ; }"}, {"instruction": "Generate java code\nregister a default non-weighted typecode mapping ", "input": " Map<Integer,Map<Long,String>> weighted \n Map<Integer,String> defaults \n String get \n String get \n String replace", "output": "void function ( int arg0 , String arg1 ) { defaults . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nlog a message with error log level . ", "input": " String name \n boolean classAndMethodFound \n Logger logger \n String sourceMethodName \n String sourceClassName \n void debug \n void debug \n void log \n Logger getLogger \n boolean isWarnEnabled \n boolean isFatalEnabled \n void fatal \n void fatal \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isDebugEnabled \n void getClassAndMethod \n void info \n void info", "output": "void function ( Object arg0 ) { log ( Level . SEVERE , String . valueOf ( arg0 ) , null ) ; }"}, {"instruction": "Generate java code\ndelete a directory and its contents . warning : java apis do not let us distinguish directories from symbolic links to directories . consequently , if the directory contains symbolic links to directories , we will attempt to delete the contents of pointed-to directories . ", "input": " byte[] cachedBuffer \n void reliablyCopyExecutable \n void deleteOrThrow \n FileLocker lockLibsDirectory \n void freeCopyBuffer \n File createLibsDirectory \n File getLibsDirectory \n int findAbiScore \n String[] getSupportedAbis \n String[] getSupportedAbis \n void fallocateIfSupported \n void fallocate", "output": "void function ( File arg0 ) { if ( arg0 . isDirectory ( ) ) { for ( File loc0 : arg0 . listFiles ( ) ) { dumbDeleteRecrusive ( loc0 ) ; } } if ( ! arg0 . delete ( ) && arg0 . exists ( ) ) { throw new IOException ( \"srini_string\" + arg0 ) ; } }"}, {"instruction": "Generate java code\ngetter for values ", "input": " ASN1ObjectIdentifier O \n ASN1ObjectIdentifier T \n ASN1ObjectIdentifier SURNAME \n ASN1ObjectIdentifier ST \n ASN1ObjectIdentifier E \n ASN1ObjectIdentifier INITIALS \n int index \n String oid \n ASN1ObjectIdentifier UNIQUE_IDENTIFIER \n ASN1ObjectIdentifier GENERATION \n ASN1ObjectIdentifier EmailAddress \n ASN1ObjectIdentifier OU \n ASN1ObjectIdentifier DC \n Map<String,ArrayList<String>> values \n ASN1ObjectIdentifier C \n ASN1ObjectIdentifier L \n ASN1ObjectIdentifier GIVENNAME \n ASN1ObjectIdentifier UID \n Map<ASN1ObjectIdentifier,String> DefaultSymbols \n StringBuffer buf \n ASN1ObjectIdentifier CN \n ASN1ObjectIdentifier SN \n ASN1Primitive getIssuer \n ASN1Primitive getSubject \n boolean hasMoreTokens \n String nextToken \n String getField \n String toString \n X500Name getSubjectFields \n List<String> getFieldArray \n X500Name getIssuerFields", "output": "Map < String , ArrayList < String >> function ( ) { return values ; }"}, {"instruction": "Generate java code\ngets the data . note : the array will not be cloned . ", "input": " Hashtable<IFFChunk,IFFChunk> propertyChunks \n long size \n byte[] data \n long scan \n int id \n int type \n Vector<IFFChunk> collectionChunks \n void setData \n int getID \n IFFChunk[] getCollectionChunks \n void putPropertyChunk \n IFFChunk getPropertyChunk \n long getSize \n Enumeration propertyChunks \n int getType \n long getScan \n int hashCode \n boolean equals \n void addCollectionChunk \n String toString \n Enumeration collectionChunks", "output": "byte [ ] function ( ) { return data ; }"}, {"instruction": "Generate java code\nreturns true for an instantiated non - `` factory '' splitter . clients also need to check valid . ", "input": " boolean instantiated \n long serialVersionUID \n boolean valid \n String condition \n void instantiateDummy \n boolean test \n DummyInvariant getDummyInvariant \n void makeDummyInvariant \n Splitter instantiate", "output": "boolean function ( ) { return instantiated ; }"}, {"instruction": "Generate java code\nreturns whether the control should make the refactorings checkable . ", "input": " boolean fCheckable \n IProject fProject \n boolean fTime \n boolean isTimeDisplayed \n String getCollectionLabel \n String getYesterdayPattern \n String getLastMonthPattern \n String getLastWeekPattern \n String getWeekPattern \n String getRefactoringPattern \n RefactoringHistoryContentProvider getContentProvider \n String getYearPattern \n String getProjectPattern \n String getWorkspaceCaption \n String getDayPattern \n RefactoringHistoryLabelProvider getLabelProvider \n String getThisMonthPattern \n String getMonthPattern \n String getCommentCaption \n String getThisWeekPattern \n String getTodayPattern \n IProject getProject", "output": "boolean function ( ) { return fCheckable ; }"}, {"instruction": "Generate java code\nparses the direction tag and returns the direction or a default value as radians ", "input": " PlaceHolder placeHolder \n String getValueWithFallback \n float parseMeasure \n float parseWidth \n float parseClearing \n float parseHeight", "output": "double function ( TagGroup arg0 , double arg1 ) { Float loc0 = null ; if ( arg0 . containsKey ( \"srini_string\" ) ) { loc0 = parseAngle ( arg0 . getValue ( \"srini_string\" ) ) ; } if ( loc0 != null ) { return Math . toRadians ( loc0 ) ; } else { return arg1 ; } }"}, {"instruction": "Generate java code\ntests that a ejb with several context and sub classes @resource deploys fine and is injected as expected ", "input": " Logger logger \n SimpleSLSB slsb \n void testInjection \n void testEnvEntryInjection \n void testOptionalEnvEntryInjection \n void testOptionalEnvEntryEncAvailability \n void beforeTest \n WebArchive createWebDeployment \n void testResourceInjectionInEJB \n void testURLInjection \n void testTimerServiceInjection \n void testOrbEnvironment", "output": "void function ( ) { Assert . assertTrue ( \"srini_string\" , this . slsb . validContextInjections ( ) ) ; }"}, {"instruction": "Generate java code\nreturn the count and the quantity label as a properly pluralized string . i.e. 5 , `` item '' == > `` 5 items '' . ", "input": " String NEW_LINE \n String trimMenuText \n String toString", "output": "String function ( int arg0 , String arg1 ) { if ( arg0 == 1 ) { return NumberFormat . getNumberInstance ( ) . format ( arg0 ) + \"srini_string\" + arg1 ; } else { return NumberFormat . getNumberInstance ( ) . format ( arg0 ) + \"srini_string\" + arg1 + \"srini_string\" ; } }"}, {"instruction": "Generate java code\nadds a single author . ", "input": " String IDENTIFIER \n String SUBJECT \n String TYPE \n String CONTRIBUTOR \n String CREATOR \n String RELATION \n String SOURCE \n String DESCRIPTION \n String FORMAT \n String COVERAGE \n String LANGUAGE \n String DATE \n String RIGHTS \n String TITLE \n String PUBLISHER \n void addDescription \n void addTitle \n void setSubject \n void setAuthor \n void addPublisher \n void setTitle \n void setDescription \n void addSubject \n void setPublisher", "output": "void function ( XMPMeta arg0 , String arg1 ) { arg0 . appendArrayItem ( XMPConst . NS_DC , CREATOR , new PropertyOptions ( PropertyOptions . ARRAY_ORDERED ) , arg1 , null ) ; }"}, {"instruction": "Generate java code\ncleanup by closing any open menus ", "input": " Display display \n int DEFAULT_EXEC_WAIT_TIME \n ControlReference<?> getFocusControl \n ShellReference[] getShells \n Color getSystemColor \n ShellReference getActiveShell \n DisplayReference getDefault \n boolean isIdle \n T execute \n T execute \n void execute \n void execute \n Display getDisplay \n ISWTWidgetReference<?>[] findWidgets \n void accept", "output": "void function ( ) { new SWTShowMenuOperation ( null ) . closeAllMenus ( ) . execute ( ) ; }"}, {"instruction": "Generate java code\nreturns the value of the corner thickness ", "input": " int DEFAULT_CORNER_COLOR \n float DEFAULT_GUIDELINE_THICKNESS_PX \n String DEFAULT_BACKGROUND_COLOR_ID \n float DEFAULT_LINE_THICKNESS_DP \n float DEFAULT_CORNER_THICKNESS_DP \n String SEMI_TRANSPARENT \n Paint newBorderPaint \n Paint newGuidelinePaint \n Paint newCornerPaint \n Paint newBackgroundPaint \n float getLineThickness", "output": "float function ( ) { return DEFAULT_CORNER_THICKNESS_DP ; }"}, {"instruction": "Generate java code\ncompares the charsequences o1 and o2 . ", "input": " AvroCharSequenceComparator<CharSequence> INSTANCE \n int compare \n int compareCharacter", "output": "int function ( CharSequence arg0 , CharSequence arg1 ) { for ( int loc0 = 0 ; loc0 < Math . max ( arg0 . length ( ) , arg1 . length ( ) ) ; loc0 ++ ) { int loc1 = compareCharacter ( arg0 , arg1 , loc0 ) ; if ( 0 != loc1 ) { return loc1 ; } } return 0 ; }"}, {"instruction": "Generate java code\nsets the exception from failed execution and executes callback if available . notifies any thread waiting for completion . ", "input": " Exception exception \n int COMPLETED \n AtomicInteger idx \n int state \n Object lock \n Optional<AsyncCallback<T>> callback \n int FAILED \n int RUNNING \n T value \n T getValue \n AsyncResult<T> startProcess \n AsyncResult<T> startProcess \n void setValue \n T endProcess \n void await \n boolean isCompleted", "output": "void function ( Exception arg0 ) { this . exception = arg0 ; this . state = FAILED ; this . callback . ifPresent ( ac -> ac . onComplete ( null , Optional . of ( arg0 ) ) ) ; synchronized ( lock ) { lock . notifyAll ( ) ; } }"}, {"instruction": "Generate java code\ncreate a widget reference locator for this widget . ", "input": " T widget \n Map<Class<?>,Object> adapters \n Object getAdapter \n T getWidget \n void addAdapter \n String toString \n IWidgetLocator[] findAll \n boolean matches", "output": "WidgetReference < T > function ( T arg0 ) { return new WidgetReference < T > ( arg0 ) ; }"}, {"instruction": "Generate java code\nconvenience method for clearing this error bar making it available for new configuration . all errors are set to #error_pixel_none afterwards . ", "input": " int m_negativeYErrorPixel \n int m_negativeXErrorPixel \n int m_positiveYErrorPixel \n int m_positiveXErrorPixel \n ITrace2D m_trace \n long serialVersionUID \n void setTrace \n void setPositiveXErrorPixel \n int getNegativeXErrorPixel \n int hashCode \n boolean equals \n int getPositiveYErrorPixel \n void setNegativeYErrorPixel \n void setPositiveYErrorPixel \n ITrace2D getTrace \n void setNegativeXErrorPixel \n int getPositiveXErrorPixel \n int getNegativeYErrorPixel", "output": "void function ( ) { this . m_negativeXErrorPixel = IErrorBarPixel . ERROR_PIXEL_NONE ; this . m_negativeYErrorPixel = IErrorBarPixel . ERROR_PIXEL_NONE ; this . m_positiveXErrorPixel = IErrorBarPixel . ERROR_PIXEL_NONE ; this . m_positiveYErrorPixel = IErrorBarPixel . ERROR_PIXEL_NONE ; }"}, {"instruction": "Generate java code\ntransforms the input to result by executing a closure . ", "input": " long serialVersionUID \n Closure iClosure \n Closure getClosure \n Transformer getInstance", "output": "Object function ( Object arg0 ) { iClosure . execute ( arg0 ) ; return arg0 ; }"}, {"instruction": "Generate java code\nreturns the way or relation with the tags for this area ", "input": " OSMElement objectWithTags \n List<MapNode> nodes \n PolygonWithHolesXZ polygon \n Collection<MapAreaSegment> areaSegments \n Collection<MapOverlap<?,?>> overlaps \n List<AreaWorldObject> representations \n List<List<MapNode>> holes \n List<MapNode> getBoundaryNodes \n int getLayer \n SimplePolygonXZ getOuterPolygon \n AxisAlignedBoundingBoxXZ getAxisAlignedBoundingBoxXZ \n Collection<MapAreaSegment> getAreaSegments \n TagGroup getTags \n SimplePolygonXZ polygonFromMapNodeLoop \n Collection<MapOverlap<?,?>> getOverlaps \n AreaWorldObject getPrimaryRepresentation \n Collection<List<MapNode>> getHoles \n void addOverlap \n void addRepresentation \n String toString \n PolygonWithHolesXZ convertToPolygon \n List<AreaWorldObject> getRepresentations \n PolygonWithHolesXZ getPolygon", "output": "OSMElement function ( ) { return objectWithTags ; }"}, {"instruction": "Generate java code\nmakes sure that the upcomingrelease is initialized ", "input": " long serialVersionUID \n LinkedHashMap<Integer,ReleaseEntity> releaseMap \n ReleaseMgmtService releaseService \n ResourceDependencyResolverService dependencyResolverService \n Date upcomingReleaseDate \n Integer upcomingReleaseId \n List<ReleaseEntity> getAllReleases \n LinkedHashMap<Integer,ReleaseEntity> getReleaseMap \n void reset \n Integer getUpcomingReleaseId", "output": "Date function ( ) { if ( upcomingReleaseDate == null ) { this . upcomingReleaseDate = dependencyResolverService . findMostRelevantRelease ( new TreeSet < ReleaseEntity > ( getAllReleases ( ) ) , new Date ( ) ) . getInstallationInProductionAt ( ) ; } return upcomingReleaseDate ; }"}, {"instruction": "Generate java code\nthis method exists solely to concentrate usage of javax.ws.rs.core.response #created java.net.uri intoone place until this jira is resolved somehow . ", "input": " PlaceHolder placeHolder \n void createPagingHeader \n InputStream pageToStream \n Response.ResponseBuilder pagedResponse \n Response.ResponseBuilder pagedResponse", "output": "Response . ResponseBuilder function ( AbstractElement arg0 , UriInfo arg1 , String arg2 ) { return Response . status ( CREATED ) . location ( arg1 . getRequestUriBuilder ( ) . segment ( arg2 ) . build ( ) ) . entity ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis method returns the history of measured or aggregated metrics of the last ten metric-updates . ", "input": " HashMap<BigDecimal,MetricsSubCoordinatorInfo> listOfSubCoordinators \n float exponentialSmoothing \n MetricsEntry ownMetrics \n Logger log \n String smoothingType \n SkyNetNodeInterface skynetNode \n LinkedList<HashMap<String,MetricsAggregate>> metricsHistory \n int historySize \n void setOwnMetrics \n void setListOfSubCoordinators \n HashMap<BigDecimal,MetricsSubCoordinatorInfo> getListOfSubCoordinators \n MetricsAggregate mergeTwoAggregates \n void setMetricsHistory \n void reset \n MetricsEntry getOwnMetrics \n void addMetricsMapToMetricsHistory \n MetricsEntry aggregateMetrics", "output": "LinkedList < HashMap < String , MetricsAggregate >> function ( ) { return metricsHistory ; }"}, {"instruction": "Generate java code\nidentical to #intx transactionpayload but also returns the notifications emitted from the transaction.the list of notifications is final and they have already been sent . the caller should not send them again . ", "input": " R result \n TraversalContext<BE,E> context \n List<EntityAndPendingNotifications<BE,?>> sentNotifications \n BE getSingle \n List<EntityAndPendingNotifications<BE,?>> getSentNotifications \n R getResult \n boolean isApplicable \n R inTx \n R inTx \n R inCommittableTx \n R inCommittableTx \n ResultWithNofifications<R,BE> inCommittableTxWithNotifications", "output": "ResultWithNofifications < R , BE > function ( TransactionPayload < R , BE > arg0 ) { return inCommittableTxWithNotifications ( context , TransactionPayload . Committing . committing ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nquotient subtraction . ", "input": " Logger logger \n QuotientRing<C> ring \n boolean debug \n C num \n C den \n int signum \n boolean isONE \n Quotient<C> inverse \n boolean isUnit \n Quotient<C> gcd \n Quotient<C> sum \n int compareTo \n Quotient<C>[] egcd \n Quotient<C> monic \n Quotient<C> abs \n int hashCode \n Quotient<C> negate \n boolean equals \n Quotient<C> clone \n boolean isZERO \n String toString \n Quotient<C> divide \n Quotient<C> multiply \n Quotient<C> remainder", "output": "Quotient < C > function ( Quotient < C > arg0 ) { if ( arg0 == null || arg0 . isZERO ( ) ) { return this ; } C loc0 = num . multiply ( arg0 . den ) ; loc0 = loc0 . subtract ( den . multiply ( arg0 . num ) ) ; C loc1 = den . multiply ( arg0 . den ) ; return new Quotient < C > ( ring , loc0 , loc1 , false ) ; }"}, {"instruction": "Generate java code\nmethod stub . returns false . ", "input": " Reflector _parent \n ReflectArray _array \n JdkLoader _classLoader \n ReflectorConfiguration _config \n Reflector parent \n ReflectClass forName \n void configuration \n ReflectorConfiguration configuration \n boolean isCollection \n Object nullValue \n Class[] toNative \n Class toNative \n ReflectClass[] toMeta \n ReflectArray array \n Object deepClone \n ReflectClass forClass \n JdkClass createClass \n ReflectClass forObject \n void setParent", "output": "boolean function ( ) { return true ; }"}, {"instruction": "Generate java code\nmethods to build visual elements ", "input": " int ELEMENTWIDTH \n JPanel spreadsheet \n SpreadsheetCell[][] cellArray \n JPanel contentPanel \n JLabel EditLabel \n JTextField ErrorBox \n JTextField EditBox \n JFrame jframe \n int ELEMENTHEIGHT \n int currentCellID \n JPanel editPanel \n JPanel errorPanel \n JButton btExit \n int SPREADSHEETSIZE \n JPanel buildSpreadsheet \n int getCurrentCellID \n void setErrorMsg \n JPanel buildEditPanel \n String getCellContents \n JPanel buildErrorPanel \n void setEditLabel \n void setCurrentCellID \n void setEditString", "output": "JPanel function ( ) { contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BorderLayout ( ) ) ; contentPanel . add ( buildEditPanel ( ) , BorderLayout . NORTH ) ; contentPanel . add ( buildSpreadsheet ( ) , BorderLayout . CENTER ) ; contentPanel . add ( buildErrorPanel ( ) , BorderLayout . SOUTH ) ; return contentPanel ; }"}, {"instruction": "Generate java code\nlook up the method specified by either `` method '' or `` methodkey '' and invoke it , returning a boolean value as interpreted by evaluateresult . ", "input": " WeakHashMap methods \n String methodKey \n Class[] DEFAULT_SIGNATURE \n String method \n void setMethod \n String getMethodKey \n boolean evaluateResult \n Class[] getSignature \n Object[] getArguments \n String getMethod \n void setMethodKey \n Method extractMethod", "output": "boolean function ( Context arg0 ) { if ( this . getMethod ( ) == null && this . getMethodKey ( ) == null ) { throw new IllegalStateException ( \"srini_string\" ) ; } Method loc0 = extractMethod ( arg0 ) ; return evaluateResult ( loc0 . invoke ( this , getArguments ( arg0 ) ) ) ; }"}, {"instruction": "Generate java code\nsets how often eviction process should be run for the cached type . ", "input": " long evictionWakeUpInterval \n String cacheName \n Set<String> overridden \n int evictionMaxEntries \n EvictionStrategy evictionStrategy \n long expirationLifespan \n boolean isExposeStatistics \n long expirationMaxIdle \n void setExposeStatistics \n long getExpirationLifespan \n void setExpirationLifespan \n long getEvictionWakeUpInterval \n EvictionStrategy getEvictionStrategy \n void setEvictionStrategy \n void setEvictionMaxEntries \n boolean isExposeStatistics \n String uc \n void applyTo \n void setCacheName \n void setExpirationMaxIdle \n long getExpirationMaxIdle \n String toString \n int getEvictionMaxEntries \n void validateInfinispanConfiguration \n String getCacheName \n void markAsOverriden", "output": "void function ( long arg0 ) { markAsOverriden ( \"srini_string\" ) ; this . evictionWakeUpInterval = arg0 ; }"}, {"instruction": "Generate java code\nfactory method to create a typed bag . if there are any elements already in the bag being decorated , they are validated . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "Bag function ( Bag arg0 , Class arg1 ) { return new PredicatedBag ( arg0 , InstanceofPredicate . getInstance ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nindicates whether the document is a copy , a duplicate , or a duplicate of a copy . codu message is being sent as a copy to a party other than the account owner , for information purposes and the message is a duplicate of a message previously sent . copy message is being sent as a copy to a party other than the account owner , for information purposes dupl message is for information/confirmation purposes . it is a duplicate of a message previously sent . ", "input": " BankToCustomerStatementV02 bankToCustomerStatement \n Document document \n GroupHeader42 groupHeader \n AccountStatement2 stmt \n CashAccount16 getRltdAcct \n List<ReportEntry2> getNtry \n String getAddtlStmtInf \n BankToCustomerStatement read \n PartyIdentification32 getMsgRcpt \n Date getToDt \n Date getCreDtTm \n Date getCreDtTm \n Pagination getMsgPgntn \n String getAddtlInf \n String getId \n BigDecimal getElctrncSeqNb \n Date getFrDt \n TotalTransactions2 getTxsSummry \n List<AccountInterest2> getIntrst \n CashAccount20 getAcct \n String getMsgId \n ReportingSource1Choice getRptgSrc \n List<AccountStatement> getStmt \n BigDecimal getLglSeqNb \n List<CashBalance3> getBal", "output": "CopyDuplicate1Code function ( ) { return stmt . getCpyDplctInd ( ) ; }"}, {"instruction": "Generate java code\nrequires arg ! = null ", "input": " int numer \n int denom \n double approx \n boolean isNegative \n RatNum sub \n RatNum mul \n String debugPrint \n boolean isPositive \n int gcd \n int compareTo \n RatNum parse \n boolean isNaN \n void checkRep \n RatNum div \n RatNum negate \n int hashCode \n boolean equals \n String toString \n String unparse \n double approx", "output": "RatNum function ( RatNum arg0 ) { checkRep ( ) ; return new RatNum ( this . numer * arg0 . denom + arg0 . numer * this . denom , this . denom * arg0 . denom ) ; }"}, {"instruction": "Generate java code\ngets the value from the map entry . ", "input": " Object value \n Object key \n Object getKey \n int hashCode \n Object setValue \n boolean equals \n String toString \n void setKey", "output": "Object function ( ) { return value ; }"}, {"instruction": "Generate java code\nthe exception generated at the server , or null if no such exception has occured ", "input": " Map<String,ByteBuffer> requestCallMeta \n Map<String,ByteBuffer> responseCallMeta \n Object response \n List<ByteBuffer> requestPayload \n List<ByteBuffer> responsePayload \n HandshakeRequest handshakeRequest \n HandshakeResponse handshakeResponse \n Exception error \n Message message \n void setResponseCallMeta \n List<ByteBuffer> getRequestPayload \n void setRequestHandshakeMeta \n Map<String,ByteBuffer> requestHandshakeMeta \n void setRequestPayload \n void setResponsePayload \n Message getMessage \n void setResponse \n void setResponseHandshakeMeta \n void setRequestCallMeta \n void setMessage \n void setHandshakeRequest \n Map<String,ByteBuffer> responseHandshakeMeta \n Map<String,ByteBuffer> requestCallMeta \n boolean isError \n Map<String,ByteBuffer> responseCallMeta \n HandshakeRequest getHandshakeRequest \n Object response \n void setError \n void setHandshakeResponse \n HandshakeResponse getHandshakeResponse \n List<ByteBuffer> getResponsePayload", "output": "Exception function ( ) { return error ; }"}, {"instruction": "Generate java code\nreturns a type object for the class 's superclass . ", "input": " boolean dirty \n ClassInfo classInfo \n Type[] interfaces \n Type superclass \n EditorContext context \n ConstantPool constants \n Type type \n boolean DEBUG \n void setInterface \n void setInterfaces \n boolean isStatic \n boolean isSuper \n MethodInfo[] methods \n void commit \n boolean isPrivate \n Type type \n int modifiers \n void setDirty \n void setFinal \n void setSuper \n boolean isDirty \n boolean isProtected \n int hashCode \n void setProtected \n EditorContext context \n boolean isPublic \n boolean isFinal \n ConstantPool constants \n boolean isInterface \n ClassInfo classInfo \n void setPublic \n Type[] interfaces \n void addInterface \n void addInterface \n void setStatic \n void setType \n void commitOnly \n boolean isAbstract \n void setSuperclass \n boolean equals \n String name \n void setAbstract \n String toString \n void visit \n FieldInfo[] fields \n void setPrivate", "output": "Type function ( ) { return superclass ; }"}, {"instruction": "Generate java code\nequivalent of #texcoordlists list , material , texcoordfunction for a collection of triangle objects . ", "input": " PlaceHolder placeHolder \n List<List<VectorXZ>> texCoordLists", "output": "List < List < VectorXZ >> function ( Collection < TriangleXYZ > arg0 , Material arg1 , TexCoordFunction arg2 ) { List < VectorXYZ > loc0 = new ArrayList < VectorXYZ > ( arg0 . size ( ) * 3 ) ; for ( TriangleXYZ loc1 : arg0 ) { loc0 . add ( loc1 . v1 ) ; loc0 . add ( loc1 . v2 ) ; loc0 . add ( loc1 . v3 ) ; } return texCoordLists ( loc0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\ncompresses the hashtable to the minimum prime size as defined by primefinder that will hold all of the elements currently in the table . if you have done a lot of remove operations and plan to do a lot of queries or insertions or iteration , it is a good idea to invoke this method . doing so will accomplish two things : you 'll free memory allocated to the table but no longer needed because of the remove s. you 'll get better query/insert/iterator performance because there wo n't be any removed slots to skip over when probing for indices in the table . ", "input": " int _size \n int _free \n float _loadFactor \n long serialVersionUID \n int _maxSize \n boolean _autoCompactTemporaryDisable \n float _autoCompactionFactor \n int _autoCompactRemovesRemaining \n float DEFAULT_LOAD_FACTOR \n int DEFAULT_INITIAL_CAPACITY \n void setAutoCompactionFactor \n void writeExternal \n void trimToSize \n boolean isEmpty \n void clear \n void rehash \n float getAutoCompactionFactor \n void reenableAutoCompaction \n int capacity \n int size \n void tempDisableAutoCompaction \n void postInsertHook \n void computeMaxSize \n Object clone \n void readExternal \n void removeAt \n int setUp \n void computeNextAutoCompactionAmount \n void ensureCapacity \n int calculateGrownCapacity", "output": "void function ( ) { rehash ( PrimeFinder . nextPrime ( ( int ) Math . ceil ( size ( ) / _loadFactor ) + 1 ) ) ; computeMaxSize ( capacity ( ) ) ; if ( _autoCompactionFactor != 0 ) { computeNextAutoCompactionAmount ( size ( ) ) ; } }"}, {"instruction": "Generate java code\nget the list of children of the calling object pass a null parent to construct the root ", "input": " WPTreeNode parent \n List<WPTreeNode> children \n WPTreeNode root \n NearbyWords nw \n String word \n String printQueue \n String getWord \n String toString \n List<String> findPath \n WPTreeNode addChild \n List<String> buildPathToRoot", "output": "List < WPTreeNode > function ( ) { return this . children ; }"}, {"instruction": "Generate java code\nsubclasses may override . ", "input": " String reason \n String getReason \n INativeConditionFactory getConditionFactory \n void invalid \n InvalidOSDelegate forReason \n String toString", "output": "IWindowService function ( ) { invalid ( ) ; return null ; }"}, {"instruction": "Generate java code\nsetter for the offset . the offset is relative to the current y position . if you want to underline something , you have to choose a negative offset . ", "input": " float offset \n DrawInterface drawInterface \n void setDrawInterface \n boolean process \n DrawInterface getDrawInterface \n boolean isContent \n boolean isNestable \n float getOffset \n void draw \n List<Chunk> getChunks \n int type", "output": "void function ( final float arg0 ) { this . offset = arg0 ; }"}, {"instruction": "Generate java code\nlist , 2 elements . a and b are objects . l is the list a , b . ", "input": " LIST<?> SIL \n Iterator<C> iter \n LinkedList<C> list \n void SFIRST \n LIST<C> LIST1 \n LIST<C> RED3 \n LIST<C> LIST3 \n LIST<C> RED4 \n C THIRD \n LIST<C> LIST5 \n int LENGTH \n LIST<C> RED2 \n LIST<C> LIST4 \n LIST<C> COMP \n LIST<C> INV \n LIST<C> COMP3 \n LIST<C> COMP3 \n int ORDER \n LIST<C> COMP2 \n int EXTENT \n void SRED \n C LELT \n boolean EQUAL \n LIST<C> LIST10 \n boolean isEmpty \n LIST<C> CCONC \n C FIRST \n LIST<C> REDUCT \n C FOURTH \n LIST<C> RED \n LIST<C> CINV \n boolean isNull \n String toString \n C SECOND \n long CLOCK \n LIST<C> CONC", "output": "LIST < C > function ( C arg0 , C arg1 ) { LIST < C > loc0 = new LIST < C > ( ) ; loc0 . list . addFirst ( arg1 ) ; loc0 . list . addFirst ( arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nget the string representation as ringfactory . ", "input": " RingFactory<C> ring \n boolean debug \n Logger logger \n Quotient<C> random \n Quotient<C> random \n int hashCode \n boolean isField \n boolean equals \n Quotient<C> getONE \n boolean isCommutative \n Quotient<C> getZERO \n Quotient<C> fromInteger \n Quotient<C> fromInteger \n boolean isAssociative \n Quotient<C> parse \n Quotient<C> parse \n Quotient<C> copy \n java.math.BigInteger characteristic", "output": "String function ( ) { return \"srini_string\" + ring . toString ( ) + \"srini_string\" ; }"}, {"instruction": "Generate java code\nintended for aerrorbarpolicyconfigurable only . ", "input": " int m_negativeYErrorPixel \n int m_negativeXErrorPixel \n int m_positiveYErrorPixel \n int m_positiveXErrorPixel \n ITrace2D m_trace \n long serialVersionUID \n void setTrace \n void setPositiveXErrorPixel \n int getNegativeXErrorPixel \n int hashCode \n boolean equals \n int getPositiveYErrorPixel \n void clear \n void setPositiveYErrorPixel \n ITrace2D getTrace \n void setNegativeXErrorPixel \n int getPositiveXErrorPixel \n int getNegativeYErrorPixel", "output": "void function ( final int arg0 ) { this . m_negativeYErrorPixel = arg0 ; }"}, {"instruction": "Generate java code\nclock . returns the current cpu clock reading in milliseconds . intervalls are system dependent . ", "input": " LIST<?> SIL \n Iterator<C> iter \n LinkedList<C> list \n void SFIRST \n LIST<C> LIST1 \n LIST<C> RED3 \n LIST<C> LIST3 \n LIST<C> RED4 \n LIST<C> LIST2 \n C THIRD \n LIST<C> LIST5 \n int LENGTH \n LIST<C> RED2 \n LIST<C> LIST4 \n LIST<C> COMP \n LIST<C> INV \n LIST<C> COMP3 \n LIST<C> COMP3 \n int ORDER \n LIST<C> COMP2 \n int EXTENT \n void SRED \n C LELT \n boolean EQUAL \n LIST<C> LIST10 \n boolean isEmpty \n LIST<C> CCONC \n C FIRST \n LIST<C> REDUCT \n C FOURTH \n LIST<C> RED \n LIST<C> CINV \n boolean isNull \n String toString \n C SECOND \n LIST<C> CONC", "output": "long function ( ) { return java . lang . System . currentTimeMillis ( ) ; }"}, {"instruction": "Generate java code\nreturns entity content as a file if set using #setfile java.io.file method . ", "input": " File file \n boolean gzipCompress \n InputStream stream \n byte[] binary \n String contentEncoding \n boolean chunked \n String text \n List<NameValuePair> parameters \n Serializable serializable \n ContentType contentType \n EntityBuilder setBinary \n String getContentEncoding \n boolean isGzipCompress \n EntityBuilder setStream \n String getText \n void clearContent \n EntityBuilder setContentEncoding \n EntityBuilder chunked \n EntityBuilder setSerializable \n EntityBuilder setParameters \n EntityBuilder setParameters \n Serializable getSerializable \n EntityBuilder setFile \n boolean isChunked \n EntityBuilder gzipCompress \n HttpEntity build \n List<NameValuePair> getParameters \n EntityBuilder create \n ContentType getContentType \n ContentType getContentOrDefault \n byte[] getBinary \n InputStream getStream \n EntityBuilder setContentType \n EntityBuilder setText", "output": "File function ( ) { return file ; }"}, {"instruction": "Generate java code\npushes a value onto the top of this stack . ", "input": " ArrayFloatList list \n float pop \n int search \n int size \n float get \n void clear \n boolean empty \n float peek \n float peek", "output": "float function ( float arg0 ) { list . add ( arg0 ) ; return arg0 ; }"}, {"instruction": "Generate java code\ntests that the given double is not invalid for calculation . it must not be one of : double #nan double #negative_infinity double #positive_infinity ", "input": " MathUtil instance \n void assertDouble \n Integer increment \n boolean assertEqual \n MathUtil getInstance", "output": "boolean function ( final double arg0 ) { return ! ( Double . isInfinite ( arg0 ) || Double . isNaN ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nresets the references for streaming . ", "input": " HessianRemoteResolver resolver \n byte[] _buffer \n void readEnd \n HessianRemoteResolver getRemoteResolver \n int addRef \n String getMethod \n String readHeader \n Object readReply \n void setRef \n void startReply \n void startReplyBody \n int readCall \n double readDouble \n InputStream readInputStream \n Object readRemote \n void skipOptionalCall \n int readInt \n void close \n int readMapStart \n void init \n int readMethodArgLength \n void readListEnd \n boolean readToOutputStream \n Reader getReader \n String readString \n void startCall \n boolean isEnd \n Object readObject \n Object readObject \n void completeCall \n void readMapEnd \n long readUTCDate \n long readLong \n int readListStart \n int readLength \n void setSerializerFactory \n void setRemoteResolver \n String readMethod \n Object readRef \n void completeReply \n byte[] readBytes \n boolean readBoolean \n void readNull \n String readType \n org.w3c.dom.Node readNode", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nget the name of this logical type . this name is set as the schema property `` logicaltype '' . ", "input": " String LOGICAL_TYPE_PROP \n String name \n String[] INCOMPATIBLE_PROPS \n Schema addToSchema \n void validate", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nparses a textual representation of a qualified name into a nameparts representation . explicitly looks for the form catalog.schema.name . ", "input": " Identifier catalogName \n QualifiedNameParser INSTANCE \n Identifier objectName \n String qualifiedText \n Identifier schemaName \n Identifier getSchemaName \n Identifier getCatalogName \n Identifier getObjectName \n int hashCode \n boolean equals \n String toString \n String render \n String unquote", "output": "NameParts function ( String arg0 ) { return parse ( arg0 , null , null ) ; }"}, {"instruction": "Generate java code\nreturns a runnable that will retain the stack trace information about where it originated from . ", "input": " Field causeField \n Executor decorate \n ExecutorService decorate \n ScheduledExecutorService decorate \n ListeningExecutorService decorate \n ListeningScheduledExecutorService decorate \n void handleException \n StackTraceElement[] getStackContext \n Throwable findRootCause \n Callable<T> makeContextCallable \n List<Callable<T>> makeContextWrappedCollection", "output": "Runnable function ( final Runnable arg0 ) { return new ContextRunnable ( arg0 ) ; }"}, {"instruction": "Generate java code\nthe vid address is extended . ", "input": " short[] area \n CanVID vid \n Logger log \n boolean betweenY \n void setArea \n boolean betweenX \n boolean betweenXboth \n void setVid \n void setVID \n boolean atX0Corner \n boolean atY0Corner \n short[] areaToShort \n CanVID getVid \n boolean atX1Corner \n boolean atY1Corner \n boolean betweenYboth \n String toString \n boolean commonCorner \n boolean commonCorner \n void setY0 \n int[] getArea \n void setX0 \n void setY1 \n void setX1", "output": "void function ( String arg0 ) { this . vid . addToVID ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns whether the body of this tag will be escaped or not . ", "input": " Tag parent \n JellyContext context \n boolean hasTrimmed \n Script body \n boolean escapeText \n Boolean shouldTrim \n Tag getParent \n boolean isTrim \n Script getBody \n void setBody \n void invokeBody \n String getBodyText \n String getBodyText \n void setEscapeText \n void setTrim \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n Tag findAncestorWithClass \n void setContext \n void setParent \n JellyContext getContext \n void trimBody", "output": "boolean function ( ) { return escapeText ; }"}, {"instruction": "Generate java code\ndeprecated . ", "input": " Map<String,NamedParameterDescriptor> namedDescriptorMap \n OrdinalParameterDescriptor[] ordinalDescriptors \n OrdinalParameterDescriptor[] EMPTY_ORDINALS \n int getOrdinalParameterSourceLocation \n NamedParameterDescriptor getNamedParameterDescriptor \n Type getNamedParameterExpectedType \n int[] getNamedParameterSourceLocations \n OrdinalParameterDescriptor getOrdinalParameterDescriptor \n int getOrdinalParameterCount \n Set<String> getNamedParameterNames", "output": "Type function ( int arg0 ) { return getOrdinalParameterDescriptor ( arg0 ) . getExpectedType ( ) ; }"}, {"instruction": "Generate java code\nlooks at the top of this stack without removing it . ", "input": " ArrayCharList list \n char pop \n int search \n int size \n char get \n void clear \n char push \n boolean empty", "output": "char function ( ) { if ( list . isEmpty ( ) ) { throw new EmptyStackException ( ) ; } return list . get ( list . size ( ) - 1 ) ; }"}, {"instruction": "Generate java code\ntemporarily exposed since configuration is still around and much code still uses configuration . this allows code to configure the builder and access that to configure configuration object used from hem atm . ", "input": " Map settings \n LoadedConfig aggregatedCfgXml \n List<ProvidedService> providedServices \n ConfigLoader configLoader \n boolean autoCloseRegistry \n String DEFAULT_CFG_RESOURCE_NAME \n List<StandardServiceInitiator> initiators \n BootstrapServiceRegistry bootstrapServiceRegistry \n StandardServiceRegistryBuilder disableAutoClose \n List<StandardServiceInitiator> standardInitiatorList \n StandardServiceRegistryBuilder enableAutoClose \n StandardServiceRegistryBuilder applySetting \n void destroy \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder applySettings \n void applyServiceContributingIntegrators \n StandardServiceRegistryBuilder addService \n StandardServiceRegistry build \n LoadedConfig getAggregatedCfgXml \n StandardServiceRegistryBuilder loadProperties \n StandardServiceRegistryBuilder loadProperties \n BootstrapServiceRegistry getBootstrapServiceRegistry \n void applyServiceContributors \n StandardServiceRegistryBuilder addInitiator", "output": "Map function ( ) { return settings ; }"}, {"instruction": "Generate java code\ngets the topmost y-position of the line . ", "input": " double y1 \n double x1 \n double y2 \n double x2 \n Color color \n int getX \n int getHeight \n void grow \n void setColor \n String toString \n int getWidth \n void draw \n void translate \n void paintShape", "output": "int function ( ) { return ( int ) Math . round ( Math . min ( y1 , y2 ) ) ; }"}, {"instruction": "Generate java code\nliefert das signal , mit dem die letzte ' 1 ' codiert wurde . ", "input": " ZeroBuffer zeroBuffer \n int pointer \n char last \n State state \n boolean[] buffer \n AMI.Medium medium \n State next \n boolean[] receive \n HDB3Receiver.Lookahead lookahead \n void puffern \n boolean[] flush \n int size \n boolean get \n void clear \n void reset \n void buffer \n boolean[] convertToBoolArray", "output": "char function ( ) { return this . last ; }"}, {"instruction": "Generate java code\nthis method should only be used by unit tests . ", "input": " Logger LOGGER \n String FLASH_ERROR_MESSAGE \n String VIEW_REDIRECT_PREFIX \n String FLASH_FEEDBACK_MESSAGE \n MessageSource messageSource \n void addErrorMessage \n String createRedirectViewPath \n void addFeedbackMessage", "output": "void function ( MessageSource arg0 ) { this . messageSource = arg0 ; }"}, {"instruction": "Generate java code\ncalled to start the traffic analysis . messages that are sent prior to invoking this method are not taken into account for analysis . calling this method starts a fresh measurement . the number of the participating hosts has to be set before calling this method . ", "input": " Logger log \n double numHosts \n boolean started \n Map<Long,Long> sentMaintenance \n Map<Long,Long> sentUser \n void writeTraffic \n void stop \n void setNumberOfHosts \n void transMsgSent \n void messageSent \n void transMsgReceived", "output": "void function ( ) { if ( ! started ) { started = true ; sentMaintenance = new HashMap < Long , Long > ( ) ; sentUser = new HashMap < Long , Long > ( ) ; } }"}, {"instruction": "Generate java code\nentry point to run this examples as a java application . ", "input": " Analyzer analyzer \n PrintStream out \n void visitCoverage \n void execute", "output": "void function ( final String [ ] arg0 ) { new ClassInfo ( System . out ) . execute ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis method is used in #parsetemplate string . it returns all variables returned by #getmemberrelatedvariables and #getobjectrelatedvariables sum of sets . ", "input": " String OBJECT_SYSTEM_HASHCODE_VARIABLE \n String[] VARIABLES \n String[] beginning \n String[] OBJECT_RELAED_VARIABLE \n String[] body \n String separator \n Map<String,String> descriptions \n String OBJECT_SUPER_TOSTRING_VARIABLE \n String DEFAULT_TEMPLATE \n String[] ending \n String OTHER_MEMBERS_VARIABLE \n String OBJECT_HASHCODE_VARIABLE \n String[] MEMBER_RELATED_VARIABLE \n String MEMBER_NAME_VARIABLE \n String MEMBER_VALUE_VARIABLE \n String OBJECT_NAME_VARIABLE \n String[] OBJECT_AND_MEMBER_RELATED_VARIABLES \n String[] VARIABLE_DESCRIPTIONS \n String OBJECT_GET_NAME_VARIABLE \n String MEMBER_NAME_PARENTHESIS_VARIABLE \n String[] getBeginning \n String[] getEnding \n void parseTemplate \n String[] getMemberRelatedVariables \n String[] getVariables \n ArrayList<String> extractElements \n String[] getBody \n String[] getObjectRelatedVariables \n String getSeparator \n Map<String,String> getVariableDescriptions \n int firstOccuranceOf", "output": "String [ ] function ( ) { return ToStringTemplateParser . OBJECT_AND_MEMBER_RELATED_VARIABLES ; }"}, {"instruction": "Generate java code\ndraws the obstacle with declared size . ", "input": " int obstacleSize \n int RESET_POSITION \n int gameWidth \n int obstacleHeigth \n int gameHeight \n boolean isUp \n int x \n int y \n int resetPosition \n int MOVE \n void move \n boolean colideDownX \n boolean crashOnObstacle \n void resetObstaclePosition \n boolean colideUpX \n boolean colideDown \n boolean colideUp", "output": "void function ( Graphics arg0 , int arg1 ) { this . obstacleSize = arg1 ; if ( isUp ) { arg0 . setColor ( new Color ( 212 , 129 , 78 ) ) ; arg0 . fill3DRect ( x , y , 150 , gameHeight - arg1 - 150 , true ) ; } else { arg0 . setColor ( new Color ( 212 , 129 , 78 ) ) ; arg0 . fill3DRect ( x , y , 150 , arg1 , true ) ; } }"}, {"instruction": "Generate java code\nreturn the length of time elapsed to run the given runnable . ", "input": " long start \n void reset", "output": "long function ( Runnable arg0 ) { long loc0 = System . currentTimeMillis ( ) ; arg0 . run ( ) ; return System . currentTimeMillis ( ) - loc0 ; }"}, {"instruction": "Generate java code\nestablish a connection to a remote server ", "input": " NioClientSocketChannelFactory clientChannelFactory \n HashedWheelTimer clientScheduleService \n Map storm_conf \n Map<String,IConnection> connections \n void removeClient \n void prepare \n IConnection bind \n void term \n String key", "output": "IConnection function ( String arg0 , String arg1 , int arg2 ) { IConnection loc0 = connections . get ( key ( arg1 , arg2 ) ) ; if ( loc0 != null ) { return loc0 ; } IConnection loc1 = new Client ( storm_conf , clientChannelFactory , clientScheduleService , arg1 , arg2 , this ) ; connections . put ( key ( arg1 , arg2 ) , loc1 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nobtains the connroutepnames #forced_route forced_route parameter value . #no_route will be mapped to null , to allow unsetting in a hierarchy . ", "input": " HttpHost NO_HOST \n HttpRoute NO_ROUTE \n void setLocalAddress \n void setDefaultProxy \n void setForcedRoute \n InetAddress getLocalAddress \n HttpHost getDefaultProxy", "output": "HttpRoute function ( final HttpParams arg0 ) { Args . notNull ( arg0 , \"srini_string\" ) ; HttpRoute loc0 = ( HttpRoute ) arg0 . getParameter ( FORCED_ROUTE ) ; if ( ( loc0 != null ) && NO_ROUTE . equals ( loc0 ) ) { loc0 = null ; } return loc0 ; }"}, {"instruction": "Generate java code\nincrements the failure counter and returns the new value . ", "input": " long lastSeen \n int staleCounter \n KademliaOverlayContact<T> contact \n int getStaleCounter \n int hashCode \n boolean equals \n String toString \n long getLastSeen \n KademliaOverlayContact<T> getContact \n void seen", "output": "int function ( ) { return ++ this . staleCounter ; }"}, {"instruction": "Generate java code\nreturns the current number of entries in the map . ", "input": " int _size \n int[] _values \n int _prime \n int NULL \n Object[] _keys \n int[] PRIMES \n int hashCode \n int get \n void clear \n void resize \n String toString \n int put \n int getBiggestPrime", "output": "int function ( ) { return _size ; }"}, {"instruction": "Generate java code\nsignifies that we are done with this classfileloader ", "input": " File outputDir \n LinkedList cache \n ClassSource _classSource \n String classpath \n Map openZipFiles \n boolean DEBUG \n boolean USE_SYSTEM_CLASSES \n int CACHE_LIMIT \n boolean verbose \n File outputDir \n void setOutputDir \n ClassInfo loadClassFromStream \n void appendClassPath \n ClassInfo loadClassFromFile \n void setVerbose \n ClassInfo[] loadClassesFromZipFile \n void prependClassPath \n OutputStream outputStreamFor \n OutputStream outputStreamFor \n void setClassPath \n String getClassPath \n void addToCache \n ClassInfo newClass \n ClassInfo loadClassFromRessource \n ClassInfo loadClass \n void writeEntry", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ngets the cluster 's tasks input file . ", "input": " ProcessListener processListener \n FXMLController guiController \n String user \n File fileBiBiGridJar \n File fileSingularityScript \n ProcessBuilder processBuilder \n File fileInput \n String masterIp \n ObservableList<String> flavorChoices \n PropertiesController propertiesController \n String clusterId \n void exit \n String getClusterId \n void setMasterIp \n void StopCluster \n PropertiesController getPropertiesController \n String getMasterIp \n void StartCluster \n void setClusterId \n void setInputFile \n void UnlockSettings \n void UnlockStopButton \n ObservableList<String> getFlavorChoices", "output": "File function ( ) { return fileInput ; }"}, {"instruction": "Generate java code\nis this groebner system equal to other . ", "input": " Logger logger \n boolean debug \n List<Condition<C>> conds \n List<ColoredSystem<C>> list \n PolynomialList<GenPolynomial<C>> cgb \n List<GenPolynomial<GenPolynomial<C>>> getCGB \n boolean checkInvariant \n int hashCode \n boolean isDetermined \n String toString \n List<Condition<C>> getConditions", "output": "boolean function ( Object arg0 ) { GroebnerSystem < C > loc0 = null ; try { loc0 = ( GroebnerSystem < C > ) arg0 ; } catch ( ClassCastException loc1 ) { return false ; } if ( loc0 == null ) { return false ; } boolean loc2 = list . equals ( loc0 . list ) ; return loc2 ; }"}, {"instruction": "Generate java code\ntakes a string of `` key = value '' pairs split by \\ n and creates a hash table . ", "input": " boolean mGeckoInfo \n String mLogFile \n int mGeckoTop \n int mScrollHeight \n Solo mSolo \n int mValue \n int mGeckoWidth \n int mHeight \n int mGeckoLeft \n Activity mActivity \n LogLevel mLogLevel \n int mGeckoHeight \n int FRAME_TIME_THRESHOLD \n String mRootPath \n int mPageHeight \n PaintedSurface getPaintedSurface \n int getGeckoHeight \n LayerView getSurfaceView \n int getScrollHeight \n void setLogLevel \n void log \n void log \n void log \n void setupScrollHandling \n void setLogFile \n void getGeckoInfo \n String getFile \n void startCheckerboardRecording \n int getPageHeight \n int getValue \n float stopCheckerboardRecording \n int getGeckoTop \n int getGeckoWidth \n void startFrameRecording \n int getHeight \n Element findElement \n int getGeckoLeft \n int stopFrameRecording \n boolean isEnabled \n void logAllStackTraces", "output": "Map < String , String > function ( String arg0 ) { HashMap < String , String > loc0 = new HashMap < String , String > ( ) ; String [ ] loc1 = arg0 . split ( \"srini_string\" ) ; for ( int loc2 = 0 ; loc2 < loc1 . length ; loc2 ++ ) { String [ ] loc3 = loc1 [ loc2 ] . split ( \"srini_string\" , 2 ) ; loc0 . put ( loc3 [ 0 ] . trim ( ) , loc3 [ 1 ] . trim ( ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nentity instance accessor ", "input": " Object instance \n String entityName \n SessionImplementor session \n EntityPersister persister \n Serializable id \n AfterTransactionCompletionProcess getAfterTransactionCompletionProcess \n EventSource eventSource \n Serializable getId \n int compareTo \n void afterDeserialize \n Serializable[] getPropertySpaces \n BeforeTransactionCompletionProcess getBeforeTransactionCompletionProcess \n EventListenerGroup<T> listenerGroup \n boolean hasPostCommitEventListeners \n DelayedPostInsertIdentifier getDelayedId \n boolean needsAfterTransactionCompletion \n String toString \n String getEntityName \n void beforeExecutions \n SessionImplementor getSession \n EntityPersister getPersister", "output": "Object function ( ) { return instance ; }"}, {"instruction": "Generate java code\nget the heap min without extracting the key ", "input": " Map<T,Integer> nodePosition \n List<Node> allNodes \n int weight \n T key \n void add \n void printPositionMap \n void swap \n void updatePositionMap \n Integer getWeight \n Node extractMinNode \n void printHeap \n void main \n T extractMin \n void decrease \n boolean containsData \n boolean empty", "output": "T function ( ) { return allNodes . get ( 0 ) . key ; }"}, {"instruction": "Generate java code\nget the state of the current tag ", "input": " String text \n Charset charset \n StateController controller \n XMLParserMemory memory \n List<XMLParserListener> listeners \n TagState tagState \n ParserMonitor monitor \n State state \n XMLParserMemory memory \n void startElement \n InputStreamReader detectEncoding \n char currentLastChar \n XMLParser removeListener \n void parse \n void parse \n void parse \n void parse \n Charset getCharset \n String current \n void endElement \n void flush \n void parseWithReader \n void unknownData \n String currentTag \n void setMonitor \n String bufferToString \n void setState \n void comment \n StateController selectState \n void text \n XMLParser append \n XMLParser append \n XMLParser append \n void callText \n XMLParser addListener \n int bufferSize", "output": "TagState function ( ) { return this . tagState ; }"}, {"instruction": "Generate java code\nwe currently have to ensure , that the names of the resources are updated as well - therefore we have to iterate through all of them and change their name . as soon as all queries are adapted , this is not required anymore and can be removed . we execute this logic in the prepersist state because we need to ensure that we could load the resources lazy if required . ", "input": " String ALLRESOURCESBYTYPE_QUERY \n Set<FavoriteResourceEntity> favorites \n String fcExternalKey \n Set<ResourceActivationEntity> resourceActivationEntities \n long serialVersionUID \n ReleaseEntity outOfServiceRelease \n Set<ResourceEntity> resources \n Set<TemplateDescriptorEntity> runtimeTemplateDescriptors \n long v \n String fcExternalLink \n String name \n Integer id \n ResourceTypeEntity resourceType \n ReleaseEntity getNewestRelease \n void setFcExternalLink \n ReleaseEntity getFirstRelease \n String getFcExternalLink \n String getFcExternalKey \n void setResourceType \n void setFcExternalKey \n String toString \n int compareTo \n SortedSet<ReleaseEntity> getReleases \n boolean isAppServerContainer", "output": "void function ( String arg0 ) { for ( ResourceEntity loc0 : getResources ( ) ) { loc0 . updateName ( arg0 ) ; } this . name = arg0 ; }"}, {"instruction": "Generate java code\nreturns the tag position for this element . the method can return null . in this case no tag has been found for this nls element . ", "input": " Region fTagPosition \n String TAG_POSTFIX \n AccessorClassReference fAccessorClassReference \n boolean fIsEclipseNLS \n int TAG_PREFIX_LENGTH \n String TAG_PREFIX \n int fIndex \n int TAG_POSTFIX_LENGTH \n String fValue \n Region fPosition \n String getValue \n Region getPosition \n boolean isEclipseNLS \n boolean hasTag \n void setAccessorClassReference \n AccessorClassReference getAccessorClassReference \n void setValue \n void setTagPosition \n String createTagText \n String getTagText \n String toString", "output": "Region function ( ) { return fTagPosition ; }"}, {"instruction": "Generate java code\ncreate an instance of validationcontext ", "input": " QName _HistoryHeader_QNAME \n QName _ISDVInfo_QNAME \n QName _KeyValuePairList_QNAME \n QName _LocalizedMessage_QNAME \n QName _BusinessException_QNAME \n QName _Message_QNAME \n QName _CallContext_QNAME \n QName _ValidationException_QNAME \n QName _NotFoundException_QNAME \n QName _ValidationContext_QNAME \n QName _TimePeriod_QNAME \n QName _OpenTimePeriod_QNAME \n QName _LocalizedString_QNAME \n QName _KeyValuePair_QNAME \n QName _TechnicalException_QNAME \n ISDVInfo createISDVInfo \n JAXBElement<ISDVInfo> createISDVInfo \n ValidationException createValidationException \n JAXBElement<ValidationException> createValidationException \n CallContext createCallContext \n JAXBElement<CallContext> createCallContext \n OpenTimePeriod createOpenTimePeriod \n JAXBElement<OpenTimePeriod> createOpenTimePeriod \n LocalizedMessage createLocalizedMessage \n JAXBElement<LocalizedMessage> createLocalizedMessage \n TechnicalException createTechnicalException \n JAXBElement<TechnicalException> createTechnicalException \n KeyValuePairList createKeyValuePairList \n JAXBElement<KeyValuePairList> createKeyValuePairList \n TimePeriod createTimePeriod \n JAXBElement<TimePeriod> createTimePeriod \n LocalizedString createLocalizedString \n JAXBElement<LocalizedString> createLocalizedString \n HistoryHeader createHistoryHeader \n JAXBElement<HistoryHeader> createHistoryHeader \n KeyValuePair createKeyValuePair \n JAXBElement<KeyValuePair> createKeyValuePair \n BusinessException createBusinessException \n JAXBElement<BusinessException> createBusinessException \n NotFoundException createNotFoundException \n JAXBElement<NotFoundException> createNotFoundException \n Message createMessage \n JAXBElement<Message> createMessage", "output": "ValidationContext function ( ) { return new ValidationContext ( ) ; }"}, {"instruction": "Generate java code\nchecks if the obstacle that is down intersects with the block . ", "input": " int obstacleSize \n int RESET_POSITION \n int gameWidth \n int obstacleHeigth \n int gameHeight \n boolean isUp \n int x \n int y \n int resetPosition \n int MOVE \n void move \n boolean colideDownX \n boolean crashOnObstacle \n void resetObstaclePosition \n boolean colideUpX \n void draw \n boolean colideUp", "output": "boolean function ( Block arg0 ) { if ( arg0 . y + Block . HEIGHT > y ) { if ( arg0 . x < x && arg0 . x + Block . WIDTH + 3 > x ) { arg0 . y = y - Block . HEIGHT ; return true ; } else if ( arg0 . x > x && x + 150 > arg0 . x ) { arg0 . y = y - Block . HEIGHT ; return true ; } } return false ; }"}, {"instruction": "Generate java code\nset token provider . ", "input": " TokenProvider tokenProvider \n TokenProvider getTokenProvider", "output": "void function ( TokenProvider arg0 ) { KrbRuntime . arg0 = arg0 ; }"}, {"instruction": "Generate java code\nwhen condition checking is performed for a refactoring then the condition check is interpreted as failed if the refactoring status severity return from the condition checking operation is equal or greater than the value returned by this method . ", "input": " IValidationCheckResultQueryFactory fQueryFactory \n String ID_PLUGIN \n void stopped \n boolean proceed \n RefactoringContribution getRefactoringContribution \n void internalSetQueryFactory \n IValidationCheckResultQuery create \n IUndoManager getUndoManager \n IRefactoringHistoryService getHistoryService \n IValidationCheckResultQueryFactory getQueryFactory", "output": "int function ( ) { return RefactoringStatus . WARNING ; }"}, {"instruction": "Generate java code\nreturns the current hibernate session . if a session was previously established during the same request the already established instance is returned otherwise a new instance is retriven from the session factory . ", "input": " SessionFactory sessionFactory \n Configuration configuration \n Log log \n void rollback \n void commit \n void begin \n SessionFactory getSessionFactory", "output": "Session function ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"srini_string\" ) ; } Session loc0 = getSessionFactory ( ) . getCurrentSession ( ) ; if ( ! loc0 . isOpen ( ) ) { loc0 = getSessionFactory ( ) . openSession ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nadd description as a child of the receiver . ", "input": " Annotation[] fAnnotations \n Description EMPTY \n Serializable fUniqueId \n Pattern METHOD_AND_CLASS_NAME_PATTERN \n String fDisplayName \n long serialVersionUID \n Description TEST_MECHANISM \n ArrayList<Description> fChildren \n Class<?> fTestClass \n int testCount \n String getMethodName \n boolean isEmpty \n Description childlessCopy \n Collection<Annotation> getAnnotations \n String methodAndClassNamePatternGroupOrDefault \n ArrayList<Description> getChildren \n String getDisplayName \n boolean isTest \n T getAnnotation \n int hashCode \n boolean equals \n Class<?> getTestClass \n Description createTestDescription \n Description createTestDescription \n Description createTestDescription \n Description createTestDescription \n Description createSuiteDescription \n Description createSuiteDescription \n Description createSuiteDescription \n boolean isSuite \n String toString \n String getClassName \n String formatDisplayName", "output": "void function ( Description arg0 ) { getChildren ( ) . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nparse a string ", "input": " ColorConverter instance \n String usageText \n RGB parseRGB \n RGB parseHtml \n int parseNumber \n ColorConverter getInstance \n Object convert", "output": "RGB function ( String arg0 ) { if ( arg0 . length ( ) <= 1 ) { throw new IllegalArgumentException ( usageText ) ; } if ( arg0 . charAt ( 0 ) == '#' ) { return parseHtml ( arg0 ) ; } else if ( arg0 . indexOf ( ',' ) != - 1 ) { return parseRGB ( arg0 ) ; } else { throw new IllegalArgumentException ( usageText ) ; } }"}, {"instruction": "Generate java code\nsee setnumericalzero ", "input": " double numericalZero \n RealMatrixImpl decompMatrix \n RealMatrixImpl getDecomposition \n void setNumericalZero \n double[] solve \n double[] solve \n void decompose \n double getDeterminant", "output": "double function ( ) { return numericalZero ; }"}, {"instruction": "Generate java code\nmoves both pos and lookat by the given vector ", "input": " VectorXYZ pos \n VectorXYZ lookAt \n VectorXYZ up \n void moveMapRight \n void setCamera \n void setCamera \n void moveForward \n void move \n void move \n void roll \n VectorXYZ getUp \n void yaw \n void moveMapUp \n void setPos \n void setPos \n void mapPitch \n VectorXYZ getRight \n void setLookAt \n void setLookAt \n VectorXYZ getViewDirection \n VectorXYZ getPos \n void moveRight \n VectorXYZ getLookAt \n void moveMapForward \n String toString \n void pitch \n void rotateY \n void moveUp", "output": "void function ( VectorXYZ arg0 ) { pos = pos . add ( arg0 ) ; lookAt = lookAt . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the high value in the range the lookup values . ", "input": " Label defaultTarget \n int[] values \n Label[] targets \n Label defaultTarget \n int lowValue \n boolean hasContiguousValues \n int partition \n int[] values \n void uniq \n void setDefaultTarget \n String toString \n void sort \n Label[] targets \n void quicksort", "output": "int function ( ) { return values [ values . length - 1 ] ; }"}, {"instruction": "Generate java code\nfind a widget , using the given matcher to determine whether a given widget in the hierarchy used by this widgetfinder is the desired one . ", "input": " int dbComparisons \n int searchType \n SWTHierarchy hierarchy \n int BFS \n SearchScopeHelper _searchScopeHelper \n List _listeners \n ArrayList list \n int DFS \n int _attempts \n BasicFinder2 DEFAULT \n Widget getParent \n Widget getWidgetParent \n Collection getRoots \n Widget findInShellScope \n Collection getWidgets \n void findMatches \n BasicFinder2 getDefault \n Widget findInShellScope0 \n void pause \n boolean contains \n void dbPrintWidgets \n void addExceptionListener \n void informExceptionListeners \n Widget find0 \n void printWidgets \n void dispose \n Hierarchy getHierarchy", "output": "Widget function ( Matcher arg0 ) { dbComparisons = 0 ; _attempts = 0 ; return findInShellScope ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the `` style '' of kademlia , for example s/k/l / h. ", "input": " Logger log \n String description \n int clusterIDLength \n String style \n boolean started \n String fileDescr \n String seed \n int BUFFER_CAPACITY \n String filePrefix \n String fileSuffix \n PrintWriter out \n void appendClusterID \n void setOutputFilePrefix \n void stopped \n void start \n void appendNewLine \n void started \n void setDescription \n boolean isStarted \n void setOutputFileSuffix \n void setOutputFile \n void appendSeparator \n void setOutputFileDescr \n void stop \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void setSeed \n String getFileName", "output": "void function ( final String arg0 ) { if ( ! started ) { style = arg0 ; } }"}, {"instruction": "Generate java code\ndispatches an interpolator for the animation thread . this will launch the animation thread if it is not already active . ", "input": " Vector newInterpolators \n int sleep \n EventListenerList listenerList \n Vector activeInterpolators \n Thread animationThread \n boolean isAnimating \n Object lock \n ChangeEvent changeEvent \n void animateStep \n void setLock \n void removeChangeListener \n void stop \n void fireStateChanged \n void start \n void run \n boolean isActive \n boolean isSynchronous \n void addChangeListener", "output": "void function ( Interpolator arg0 ) { synchronized ( newInterpolators ) { newInterpolators . addElement ( arg0 ) ; if ( ! isActive ( ) ) start ( ) ; } }"}, {"instruction": "Generate java code\nget the zero element . ", "input": " UnivPowerSeries<C> ZERO \n String DEFAULT_NAME \n int truncate \n String var \n int DEFAULT_TRUNCATE \n UnivPowerSeries<C> ONE \n RingFactory<C> coFac \n Random random \n UnivPowerSeries<C> getTAN \n boolean isField \n boolean isCommutative \n UnivPowerSeries<C> getSIN \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> fromPolynomial \n java.math.BigInteger characteristic \n UnivPowerSeries<C> getEXP \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n int hashCode \n boolean equals \n UnivPowerSeries<C> getONE \n UnivPowerSeries<C> getCOS \n UnivPowerSeries<C> fromInteger \n UnivPowerSeries<C> fromInteger \n String toString \n boolean isAssociative \n UnivPowerSeries<C> copy \n UnivPowerSeries<C> fixPoint", "output": "UnivPowerSeries < C > function ( ) { return ZERO ; }"}, {"instruction": "Generate java code\nthis method was generated by mybatis generator . this method sets the value of the database column company.dept _ id ", "input": " Integer compId \n Integer deptId \n Integer getCompId \n void setCompId \n Integer getDeptId", "output": "void function ( Integer arg0 ) { this . deptId = arg0 ; }"}, {"instruction": "Generate java code\nadds properties of app , as and node to the map ", "input": " ResourceEntity owner \n String identifier \n ApplicationResolver resolver \n List<AmwFunctionEntity> functions \n List<AppServerRelationProperties> consumed \n List<AppServerRelationProperties> provided \n boolean supportNesting \n Logger log \n SetMultimap<ResourceEntity,GeneratedTemplate> templatesCache \n BasePropertyCollector collector \n AMWTemplateExceptionHandler templateExceptionHandler \n SoftlinkGenerationPackage softlinkPPIGenerationPackage \n ContextEntity context \n Map<String,FreeMarkerProperty> properties \n Map<String,Map<String,AmwResourceTemplateModel>> transformRelated \n Map<String,FreeMarkerProperty> getProperties \n List<AppServerRelationProperties> getProvided \n Map<String,Map<String,AmwResourceTemplateModel>> transformRelatedAndStop \n void setTemplates \n Map<String,Map<String,AmwResourceTemplateModel>> transformRelatedInternal \n Map<String,FreeMarkerProperty> collectResourceProperties \n ResourceEntity getOwner \n AmwResourceTemplateModel getPropertiesWithTemplates \n Map<String,FreeMarkerProperty> collectRelationProperties \n void addResolver \n AmwResourceTemplateModel transformModel \n AppServerRelationProperties addProvidedRelation \n void addRelated \n AppServerRelationProperties addConsumedRelation \n void merge \n void setTemplatesCache \n String toString \n List<AppServerRelationProperties> getConsumed \n AppServerRelationProperties addRelation", "output": "void function ( AmwAppServerNodeModel arg0 , ApplicationResolver arg1 ) { if ( arg1 != null ) { arg1 . transform ( templateExceptionHandler , arg0 ) ; } }"}, {"instruction": "Generate java code\ngets the current key , which is the key returned by the last call to next . ", "input": " Iterator iterator \n Map.Entry last \n Map map \n boolean canRemove \n Object next \n Object getValue \n Object setValue \n void reset \n boolean hasNext \n String toString \n void remove", "output": "Object function ( ) { if ( last == null ) { throw new IllegalStateException ( \"srini_string\" ) ; } return last . getKey ( ) ; }"}, {"instruction": "Generate java code\nchecks whether this class is configured to be used . ", "input": " Set<LoadMetric> enabledMetrics \n void deploy \n void undeploy", "output": "boolean function ( Class arg0 ) { for ( LoadMetric loc0 : enabledMetrics ) { if ( arg0 . isInstance ( loc0 ) ) { return true ; } } return false ; }"}, {"instruction": "Generate java code\nproduct of this matrix with scalar . ", "input": " List<C> val \n Logger logger \n GenMatrixRing<C> ring \n ArrayList<ArrayList<C>> matrix \n int hashValue \n GenMatrix<C> leftLinearCombination \n int signum \n boolean isONE \n GenMatrix<C> inverse \n boolean isUnit \n GenMatrix<C> subtract \n GenMatrix<C> gcd \n GenMatrix<C> sum \n GenMatrix<C> linearCombination \n GenMatrix<C> linearCombination \n GenMatrix<C> linearCombination \n int compareTo \n GenMatrix<C>[] egcd \n GenMatrix<C> leftScalarMultiply \n GenMatrix<C> abs \n int hashCode \n GenMatrix<C> negate \n GenMatrix<C> multiplySimple \n boolean equals \n GenMatrix<C> clone \n boolean isZERO \n GenMatrix<C> divide \n String toString \n GenMatrix<C> transpose \n GenMatrix<C> multiply \n GenMatrix<C> remainder", "output": "GenMatrix < C > function ( C arg0 ) { ArrayList < ArrayList < C >> loc0 = new ArrayList < ArrayList < C >> ( ring . rows ) ; for ( ArrayList < C > loc1 : matrix ) { ArrayList < C > loc2 = new ArrayList < C > ( ring . cols ) ; for ( C loc3 : loc1 ) { C loc4 = loc3 . multiply ( arg0 ) ; loc2 . add ( loc4 ) ; } loc0 . add ( loc2 ) ; } return new GenMatrix < C > ( ring , loc0 ) ; }"}, {"instruction": "Generate java code\nmake a request to the facebook graph api with the given string parameters using an http get default method . see http://developers.facebook.com/docs/api note that this method is asynchronous and the callback will be invoked in a background thread ; operations that affect the ui will need to be posted to the ui thread or an appropriate handler . this method is deprecated . see facebook and com.facebook.request for more info . ", "input": " Facebook fb \n void onFileNotFoundException \n void logout \n void logout \n void onComplete \n void onIOException \n void onMalformedURLException \n void onFacebookError", "output": "void function ( String arg0 , Bundle arg1 , RequestListener arg2 , final Object arg3 ) { request ( arg0 , arg1 , \"srini_string\" , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nmethod setoutputstream . ", "input": " InputStream m_inputStream \n Exception m_scriptCompilationException \n Log log \n Jelly m_jellyEngine \n XMLOutput m_output \n Script m_script \n OutputStream m_outputStream \n boolean m_scriptCompiled \n String m_errorMsg \n JellyContext m_context \n void setErrorMsg \n void setContext \n void compileScriptAndKeep \n void setVariable \n URL resolveURL \n JellyContext getContext \n void registerTagLibrary \n void registerTagLibrary \n boolean execute \n void setScript \n void setScript \n String getErrorMsg", "output": "void function ( OutputStream arg0 ) { m_outputStream = arg0 ; m_output = XMLOutput . createXMLOutput ( new OutputStreamWriter ( m_outputStream ) ) ; }"}, {"instruction": "Generate java code\nuses a private key to sign data in a cms signeddata structure and returns the encoded cms signeddata as bytes . ` signedauthpack ' contains a cms type contentinfo encoded according to rfc3852 . the contenttype field of the type contentinfo is id-signeddata 1.2.840.113549.1.7.2 , and the content field is a signeddata . the econtenttype field for the type signeddata is id-pkinit-authdata 1.3.6.1.5.2.3.1 , and the econtent field contains the der encoding of the type authpack . ", "input": " String ID_PKINIT_AUTHDATA \n byte[] getSignedKdcDhKeyInfo \n byte[] getSignedReplyKeyPack", "output": "byte [ ] function ( PrivateKey arg0 , X509Certificate arg1 , AuthPack arg2 ) { byte [ ] loc0 = KrbCodec . encode ( arg2 ) ; byte [ ] loc1 ; try { loc1 = PkiUtil . getSignedData ( arg0 , arg1 , loc0 , ID_PKINIT_AUTHDATA ) ; } catch ( PkiException loc2 ) { throw new KrbException ( \"srini_string\" , loc2 ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nfactory to create the transformer . if the map is null , a transformer that always returns null is returned . ", "input": " Map iMap \n long serialVersionUID \n Object transform \n Map getMap", "output": "Transformer function ( Map arg0 ) { if ( arg0 == null ) { return ConstantTransformer . NULL_INSTANCE ; } return new MapTransformer ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable intlistiterator containing only the specified element . ", "input": " IntListIterator EMPTY_INT_LIST_ITERATOR \n IntList EMPTY_INT_LIST \n IntIterator EMPTY_INT_ITERATOR \n IntListIterator getEmptyIntListIterator \n IntIterator unmodifiableIntIterator \n IntIterator singletonIntIterator \n IntList getEmptyIntList \n IntIterator getEmptyIntIterator \n IntList unmodifiableIntList \n IntListIterator unmodifiableIntListIterator \n IntList singletonIntList", "output": "IntListIterator function ( int arg0 ) { return singletonIntList ( arg0 ) . listIterator ( ) ; }"}, {"instruction": "Generate java code\nget bitmap by imageurl ", "input": " PlaceHolder placeHolder \n Drawable bitmapToDrawable \n void closeInputStream \n Bitmap drawableToBitmap \n Bitmap byteToBitmap \n byte[] drawableToByte \n Bitmap scaleImage \n byte[] bitmapToByte \n Bitmap scaleImageTo \n Drawable byteToDrawable \n Drawable getDrawableFromUrl \n Drawable getDrawableFromUrl \n InputStream getInputStreamFromUrl \n InputStream getInputStreamFromUrl", "output": "Bitmap function ( String arg0 , int arg1 , Map < String , String > arg2 ) { InputStream loc0 = getInputStreamFromUrl ( arg0 , arg1 , arg2 ) ; Bitmap loc1 = BitmapFactory . decodeStream ( loc0 ) ; closeInputStream ( loc0 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nsee the discussion on #disableautoclose . this method enables the auto-closing . ", "input": " Map settings \n LoadedConfig aggregatedCfgXml \n List<ProvidedService> providedServices \n ConfigLoader configLoader \n boolean autoCloseRegistry \n String DEFAULT_CFG_RESOURCE_NAME \n List<StandardServiceInitiator> initiators \n BootstrapServiceRegistry bootstrapServiceRegistry \n StandardServiceRegistryBuilder disableAutoClose \n List<StandardServiceInitiator> standardInitiatorList \n Map getSettings \n StandardServiceRegistryBuilder applySetting \n void destroy \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder configure \n StandardServiceRegistryBuilder applySettings \n void applyServiceContributingIntegrators \n StandardServiceRegistryBuilder addService \n StandardServiceRegistry build \n LoadedConfig getAggregatedCfgXml \n StandardServiceRegistryBuilder loadProperties \n StandardServiceRegistryBuilder loadProperties \n BootstrapServiceRegistry getBootstrapServiceRegistry \n void applyServiceContributors \n StandardServiceRegistryBuilder addInitiator", "output": "StandardServiceRegistryBuilder function ( ) { this . autoCloseRegistry = true ; return this ; }"}, {"instruction": "Generate java code\ngets the entity manager factory . ", "input": " Database instance \n EntityManagerFactory emf \n void initInstance \n T getElementById \n List<T> getAll \n T create \n T update \n void delete \n void closeConnection", "output": "EntityManagerFactory function ( ) { return emf ; }"}, {"instruction": "Generate java code\nget whether disabled . ", "input": " Entry entry \n PrincipalName getPrincipalName \n int getKdcFlags \n int getKeyVersion \n KerberosTime createKerberosTime \n List<EncryptionKey> getKeys \n KerberosTime getCreatedTime \n KerberosTime getExpireTime \n boolean getLocked", "output": "boolean function ( ) { String loc0 = entry . get ( KerberosAttribute . KRB5_ACCOUNT_DISABLED_AT ) . getString ( ) ; return Boolean . parseBoolean ( loc0 ) ; }"}, {"instruction": "Generate java code\nthis method is used for when a user has clicked on the `` quit '' button on the gui . it handles exiting the game . ", "input": " int playerNumber \n Rules theRules \n String playerName \n Driver theDriver \n Color playerColor \n Move theMove \n GameplayMediator mediator \n int type \n int getNumber \n void setName \n String getName \n void setColor \n int getType \n boolean makeMove \n Color getColor \n String toString", "output": "void function ( String arg0 ) { JOptionPane . showMessageDialog ( null , \"srini_string\" + arg0 , \"srini_string\" , JOptionPane . INFORMATION_MESSAGE ) ; System . exit ( 0 ) ; }"}, {"instruction": "Generate java code\nreturns the url last path component . ", "input": " String SCHEME_HTTPS \n String SCHEME_FILE \n String SCHEME_HTTP \n String originUrl \n String applicationUrl \n String lastPathComponent \n String url \n String getApplicationUrlImpl \n String getUrl \n String getScheme \n String convertToRelativeUrl \n String getOrigin \n String getResourceBase \n String getPath \n String getApplicationUrl \n String extractOriginImpl \n String getUrlWithoutHash \n String getUrlWithoutHash", "output": "String function ( ) { if ( lastPathComponent == null ) { int loc0 = url . lastIndexOf ( '/' ) ; lastPathComponent = url . substring ( loc0 + 1 , url . length ( ) ) ; } return lastPathComponent ; }"}, {"instruction": "Generate java code\nindexing operation . requires : 0 < = index < this.size ", "input": " Vector underlying_terms \n RatTerm[] terms \n void set \n int size \n String printDebug \n boolean equals \n void insert \n String toString \n void addElement \n RatTermVec copy \n void remove", "output": "RatTerm function ( int arg0 ) { return ( RatTerm ) underlying_terms . get ( arg0 ) ; }"}, {"instruction": "Generate java code\ncreate an instance of localizedmessage ", "input": " QName _HistoryHeader_QNAME \n QName _ISDVInfo_QNAME \n QName _KeyValuePairList_QNAME \n QName _LocalizedMessage_QNAME \n QName _BusinessException_QNAME \n QName _Message_QNAME \n QName _CallContext_QNAME \n QName _ValidationException_QNAME \n QName _NotFoundException_QNAME \n QName _ValidationContext_QNAME \n QName _TimePeriod_QNAME \n QName _OpenTimePeriod_QNAME \n QName _LocalizedString_QNAME \n QName _KeyValuePair_QNAME \n QName _TechnicalException_QNAME \n ISDVInfo createISDVInfo \n JAXBElement<ISDVInfo> createISDVInfo \n ValidationException createValidationException \n JAXBElement<ValidationException> createValidationException \n CallContext createCallContext \n JAXBElement<CallContext> createCallContext \n OpenTimePeriod createOpenTimePeriod \n JAXBElement<OpenTimePeriod> createOpenTimePeriod \n TechnicalException createTechnicalException \n JAXBElement<TechnicalException> createTechnicalException \n KeyValuePairList createKeyValuePairList \n JAXBElement<KeyValuePairList> createKeyValuePairList \n TimePeriod createTimePeriod \n JAXBElement<TimePeriod> createTimePeriod \n LocalizedString createLocalizedString \n JAXBElement<LocalizedString> createLocalizedString \n HistoryHeader createHistoryHeader \n JAXBElement<HistoryHeader> createHistoryHeader \n KeyValuePair createKeyValuePair \n JAXBElement<KeyValuePair> createKeyValuePair \n BusinessException createBusinessException \n JAXBElement<BusinessException> createBusinessException \n NotFoundException createNotFoundException \n JAXBElement<NotFoundException> createNotFoundException \n ValidationContext createValidationContext \n JAXBElement<ValidationContext> createValidationContext \n Message createMessage \n JAXBElement<Message> createMessage", "output": "LocalizedMessage function ( ) { return new LocalizedMessage ( ) ; }"}, {"instruction": "Generate java code\nset the root-tags , this matters for margins . by default these are set to < body > and < div > . ", "input": " Charset charset \n TagProcessorFactory tagFactory \n Map<String,Object> memory \n List<Element> ctn \n LinkProvider linkprovider \n boolean autoBookmark \n boolean acceptUnknown \n List<String> roottags \n String BOOKMARK_TREE \n String LAST_MARGIN_BOTTOM \n Rectangle pageSize \n String resourcesRootPath \n LinkedList<StackKeeper> queue \n CssAppliers cssAppliers \n ImageProvider imageProvider \n ImageProvider getImageProvider \n HtmlPipelineContext setTagFactory \n StackKeeper poll \n HtmlPipelineContext setAcceptUnknown \n boolean acceptUnknown \n LinkProvider getLinkProvider \n String getResourcesRootPath \n CssAppliers getCssAppliers \n HtmlPipelineContext charSet \n Charset charSet \n void setLastMarginBottom \n HtmlPipelineContext setImageProvider \n boolean isEmpty \n void setResourcesRootPath \n HtmlPipelineContext setCssApplier \n Map<String,Object> getMemory \n StackKeeper peek \n boolean autoBookmark \n HtmlPipelineContext autoBookmark \n HtmlPipelineContext setLinkProvider \n Float getLastMarginBottom \n Rectangle getPageSize \n List<Element> currentContent \n TagProcessor resolveProcessor \n HtmlPipelineContext clone \n List<String> getRootTags \n void setCssAppliers \n void addFirst \n HtmlPipelineContext setPageSize", "output": "HtmlPipelineContext function ( final List < String > arg0 ) { this . roottags = arg0 ; return this ; }"}, {"instruction": "Generate java code\ncounts the number of releases available . ", "input": " EntityManager entityManager \n Logger log \n List<ReleaseEntity> loadReleaseEntities \n ReleaseEntity getDefaultRelease \n boolean saveReleaseEntity \n ReleaseEntity getById \n List<ResourceEntity> getResourcesForRelease \n List<ReleaseEntity> loadAllReleaseEntities \n ReleaseEntity findByName \n void changeReleaseOfResource \n Order getDefaultOrder \n boolean deleteReleaseEntity", "output": "int function ( ) { CriteriaQuery < Long > loc0 = entityManager . getCriteriaBuilder ( ) . createQuery ( Long . class ) ; loc0 . select ( entityManager . getCriteriaBuilder ( ) . count ( loc0 . from ( ReleaseEntity . class ) ) ) ; Long loc1 = entityManager . createQuery ( loc0 ) . getSingleResult ( ) ; return loc1 != null ? loc1 . intValue ( ) : 0 ; }"}, {"instruction": "Generate java code\nsorts source and adds the first n entries to dest . if source contains less than n entries , all of them are added to dest . if adding an entry to dest does not increase the collection 's size , for example if dest is a set and already contained the inserted contact , an additional entry of source will be added , if available . this guarantees that n new , distinct entries are added to collection dest as long as this can be fulfilled with the contents of source , and as dest does recognise duplicate entries . consequently , this guarantee does not hold for simple lists . both collections may not be null . ", "input": " PlaceHolder placeHolder \n void filter \n void copyNSortedAndFiltered \n void filterMap \n double getQuantile \n void splitMap \n List<T> getRandomPartFrom \n E getRandomEntry \n E getRandomEntry \n void copyUntilFull \n List<Tt> transformList", "output": "void function ( final Collection < ? extends T > arg0 , final Collection < ? super T > arg1 , final Comparator < ? super T > arg2 , final int arg3 ) { final List < ? extends T > loc0 = Collections . list ( Collections . enumeration ( arg0 ) ) ; Collections . sort ( loc0 , arg2 ) ; final Iterator < ? extends T > loc1 = loc0 . iterator ( ) ; final int loc2 = arg1 . size ( ) + arg3 ; while ( loc1 . hasNext ( ) && arg1 . size ( ) < loc2 ) { arg1 . add ( loc1 . next ( ) ) ; } }"}, {"instruction": "Generate java code\ngets a map from task id to component id . ", "input": " StormTopology _topology \n String _stormId \n Map<Integer,String> _taskToComponent \n Map<String,List<Integer>> _componentToTasks \n Map _stormConf \n Map<String,Map<String,Fields>> _componentToStreamToFields \n int maxTopologyMessageTimeout \n String getComponentId \n Map<String,Map<String,Grouping>> getTargets \n Set<String> getComponentIds \n String getStormId \n Set<String> getComponentStreams \n String toJSONString \n StormTopology getRawTopology \n Fields getComponentOutputFields \n Fields getComponentOutputFields \n List<Integer> getComponentTasks \n ComponentCommon getComponentCommon \n Map<GlobalStreamId,Grouping> getSources", "output": "Map < Integer , String > function ( ) { return _taskToComponent ; }"}, {"instruction": "Generate java code\nreturns the save participant descriptor for the given id or null if no such listener is registered . ", "input": " IPostSaveListener[] EMPTY_ARRAY \n Map<String,SaveParticipantDescriptor> fDescriptors \n SaveParticipantDescriptor[] getSaveParticipantDescriptors \n boolean hasSettingsInScope \n boolean isChangedRegionsRequired \n IPostSaveListener[] getEnabledPostSaveListeners \n IPostSaveListener[] getEnabledPostSaveListeners \n void ensureRegistered \n void dispose \n void reloadDescriptors", "output": "SaveParticipantDescriptor function ( String arg0 ) { ensureRegistered ( ) ; return fDescriptors . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nlets the subclass update the target after the initial #filltarget jogltarget . ", "input": " VectorXYZ cameraPos \n VectorXYZ cameraUp \n VectorXYZ cameraLookAt \n boolean targetNeedsReset \n TerrainElevationData eleData \n Projection projection \n Camera camera \n Configuration config \n MapData map \n JOGLTarget target \n void renderTo \n void drawBox \n void fillTarget \n void reset \n void setConversionResults \n void drawBoxAround \n void drawBoxAround \n void setConfiguration \n boolean canBeUsed \n String getDescription \n void drawArrow", "output": "void function ( JOGLTarget arg0 , boolean arg1 ) { }"}, {"instruction": "Generate java code\nnotifies all of this option change-listeners of the given event ", "input": " List<IOptionChangeListener> fListeners \n boolean fListeneredDisabled \n void removeChangeListener \n void initializeWithoutListenersFrom \n void initializeFrom \n void addChangeListener", "output": "void function ( IOptionChangeEvent arg0 ) { if ( ! fListeneredDisabled ) { for ( IOptionChangeListener loc0 : fListeners ) { loc0 . attributeChanged ( arg0 ) ; } } }"}, {"instruction": "Generate java code\nworkaround for session scope ", "input": " long serialVersionUID \n LinkedHashMap<Integer,ReleaseEntity> releaseMap \n ReleaseMgmtService releaseService \n ResourceDependencyResolverService dependencyResolverService \n Date upcomingReleaseDate \n Integer upcomingReleaseId \n List<ReleaseEntity> getAllReleases \n Date getUpcomingReleaseDate \n LinkedHashMap<Integer,ReleaseEntity> getReleaseMap \n Integer getUpcomingReleaseId", "output": "void function ( ) { releaseMap = null ; upcomingReleaseId = null ; upcomingReleaseDate = null ; }"}, {"instruction": "Generate java code\nsole entry point to application , as always . ", "input": " PlaceHolder placeHolder \n void printCapitalized", "output": "void function ( String [ ] arg0 ) { String loc0 ; TextIO . putln ( \"srini_string\" ) ; loc0 = TextIO . getln ( ) ; TextIO . putln ( ) ; TextIO . putln ( \"srini_string\" ) ; printCapitalized ( loc0 ) ; }"}, {"instruction": "Generate java code\ngets document to sign ", "input": " XfaForm xfaForm \n PdfStamper stamper \n String encoding \n String getEncoding \n void createXfaForm \n void setDocument \n void setEncoding", "output": "Document function ( ) { return xfaForm . getDomDocument ( ) ; }"}, {"instruction": "Generate java code\nmake an instance dummyinvariant for this instance of the splitter , if possible on an appropriate slice from ppt . ", "input": " boolean instantiated \n long serialVersionUID \n boolean valid \n boolean instantiated \n String condition \n boolean test \n DummyInvariant getDummyInvariant \n void makeDummyInvariant \n Splitter instantiate", "output": "void function ( PptTopLevel arg0 ) { }"}, {"instruction": "Generate java code\nreturns true if one of the resourcetypes within tree up until root resource type has the same name as one of the comma separated values of the system property ch.puzzle.itc.mobiliar.common.util.configurationservice.configkey #consumable_softlink_resource_types ", "input": " ReleaseLocator releaseLocator \n EntityManager entityManager \n String WS_PPI_TYPE \n Logger log \n ResourceDependencyResolverService resourceDependencyResolverService \n ResourceRepository resourceRepository \n String WS_CPI_TYPE \n List<ResourceEntity> getResourceByGroupName \n ResourceEntity getResourceByNameAndReleaseWithTemplates \n List<ResourceEntity> getAllApplicationsWithResource \n List<ResourceEntity> getResourcesByGroupNameWithRelations \n List<String> extractResourceTypeSystemProperties \n List<ResourceEntity> getBatchJobProvidedResources \n Map<String,String> getAppToAppServerMapping \n boolean hasResourceProvidableSoftlinkType \n boolean hasResourceProvidableSoftlinkType \n ResourceEntity getResourceByGroupNameAndRelease \n boolean isTypeOrHasTypeAsSuperType \n ResourceEntity getResourceByNameAndReleaseWithRelations \n ResourceEntity getResourceWithGroupAndRelatedResources \n List<ResourceEntity> getResourcesByGroupNameWithAllRelationsOrderedByRelease \n ResourceEntity getApplicationServerForApplication \n List<ResourceEntity> getBatchJobConsumedResources", "output": "boolean function ( Integer arg0 ) { return hasResourceConsumableSoftlinkType ( entityManager . find ( ResourceEntity . class , arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns a copy of this set , with the given converter removed . if the converter was not in the set , the original set is returned . ", "input": " Entry[] iSelectEntries \n Converter[] iConverters \n Class<?> iType \n Converter iConverter \n ConverterSet add \n Converter select \n int size \n Converter selectSlow \n void copyInto", "output": "ConverterSet function ( Converter arg0 , Converter [ ] arg1 ) { Converter [ ] loc0 = iConverters ; int loc1 = loc0 . loc1 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { if ( arg0 . equals ( loc0 [ loc2 ] ) ) { return remove ( loc2 , arg1 ) ; } } if ( arg1 != null ) { arg1 [ 0 ] = null ; } return this ; }"}, {"instruction": "Generate java code\nask the monitor to wait until the execution is finished . ", "input": " IExecutionMonitor monitor \n String DEFAULT_THREAD_NAME \n void runFinishing \n IExecutionMonitor getMonitor \n String getTestThreadName \n void exceptionCaught \n TestIdentifier getCurrentTest \n void runStarting \n void exec \n void runFinished", "output": "void function ( ) { getMonitor ( ) . waitUntilFinished ( ) ; }"}, {"instruction": "Generate java code\ncompute the cosine for the given complex argument . ", "input": " PlaceHolder placeHolder \n Complex tan \n Complex sqrt1z \n Complex log \n Complex sinh \n Complex acos \n Complex atan \n Complex cosh \n Complex tanh \n Complex sqrt \n Complex pow \n Complex sin \n Complex asin \n Complex exp", "output": "Complex function ( Complex arg0 ) { if ( arg0 . isNaN ( ) ) { return Complex . NaN ; } double loc0 = arg0 . getReal ( ) ; double loc1 = arg0 . getImaginary ( ) ; return new Complex ( Math . cos ( loc0 ) * MathUtils . cosh ( loc1 ) , - Math . sin ( loc0 ) * MathUtils . sinh ( loc1 ) ) ; }"}, {"instruction": "Generate java code\ncurrently the server responds with an json object wrapped in a json array . we need to strip the array . ", "input": " String POST_VIDEO_DATA \n String GET_PROJECT_DATA \n String GET_VIDEO_DATA \n String host \n String POST_PROJECT_DATA \n String downloadVideo \n VideoData downloadVideoData \n String uploadProjectData \n JSONObject uploadVideoData \n void uploadVideo \n ProjectData downloadProjectData \n String executeMethodWithJSONResponse", "output": "String function ( String arg0 ) { return arg0 . substring ( 1 , arg0 . length ( ) - 1 ) ; }"}, {"instruction": "Generate java code\nreturns escaped absolute path of given file instance . ", "input": " PlaceHolder placeHolder \n String escapePath", "output": "String function ( File arg0 ) { return escapePath ( Objects . requireNonNull ( arg0 , \"srini_string\" ) . getAbsolutePath ( ) ) ; }"}, {"instruction": "Generate java code\nwrite the script tag with code content . no html escaping applied . w3c has recommended that all scripts within an xhtml document be escaped using cdata sections . ", "input": " T canvas \n T stylesheet \n T favicon \n T javascript \n T cdata", "output": "T function ( String arg0 ) { return ( T ) canvas . script ( type ( \"srini_string\" ) ) . cdata ( ) . write ( arg0 , NO_ESCAPE ) . _cdata ( ) . _script ( ) ; }"}, {"instruction": "Generate java code\ndown-grade locks to none for all entities in this context ", "input": " ManagedEntity head \n boolean dirty \n ManagedEntity next \n IdentityHashMap<Object,ManagedEntity> nonEnhancedEntityXref \n Object entityInstance \n ManagedEntity previous \n ManagedEntity tail \n Map.Entry<Object,EntityEntry>[] reentrantSafeEntries \n int count \n Logger log \n EntityEntry entityEntry \n Object entity \n ManagedEntity $$_hibernate_getNextManagedEntity \n Object getKey \n Map.Entry<Object,EntityEntry>[] reentrantSafeEntityEntries \n int getNumberOfManagedEntities \n void $$_hibernate_setNextManagedEntity \n void clear \n ManagedEntity $$_hibernate_getPreviousManagedEntity \n EntityEntry removeEntityEntry \n Object getEntity \n Object getEntity \n void $$_hibernate_setPreviousManagedEntity \n void $$_hibernate_setEntityEntry \n void serialize \n EntityEntry getValue \n EntityEntry getEntityEntry \n EntityEntry getEntityEntry \n EntityEntry getEntityEntry \n void addEntityEntry \n Object $$_hibernate_getEntityInstance \n EntityEntry $$_hibernate_getEntityEntry \n EntityEntry setValue \n boolean hasEntityEntry \n EntityEntryContext deserialize", "output": "void function ( ) { if ( head == null ) { return ; } ManagedEntity loc0 = head ; while ( loc0 != null ) { loc0 . $$_hibernate_getEntityEntry ( ) . setLockMode ( LockMode . NONE ) ; loc0 = loc0 . $$_hibernate_getNextManagedEntity ( ) ; } }"}, {"instruction": "Generate java code\nrun this runnable as a transaction . ", "input": " StackListener stackListener \n CommandStackTransaction UNCHECKED_TRANSACTION \n CommandStack stack \n List<Object> commands \n long TRANSACTION_TIMEOUT \n boolean started \n boolean addEvent \n boolean containsUnfinishedCommmands \n void stop \n void stop \n CommandStackTransaction forStack \n boolean removeEvent \n void stackChanged \n CommandStackTransaction start \n CommandStackTransaction start \n CommandStackTransaction forActiveEditor \n boolean isStarted \n boolean isComplete \n boolean isComplete", "output": "Object function ( UIRunnable arg0 , IUIContext arg1 ) { start ( ) ; try { Object loc0 = arg0 . runWithResult ( ) ; arg1 . wait ( TransactionCompleteCondition . forTransaction ( this ) , TRANSACTION_TIMEOUT ) ; return loc0 ; } finally { stop ( ) ; } }"}, {"instruction": "Generate java code\nsets data , offset , length and header of this buffer to that buffer . note that this method creates copies of the data and header , so that these fields in that buffer can be discarded without affecting the contents of this buffer . fixme - this method does not always create a copy !! ", "input": " Rational timeStamp \n long sequenceNumber \n EnumSet<BufferFlag> flags \n int NOT_SPECIFIED \n Object data \n int offset \n int length \n Format format \n Object header \n int sampleCount \n int track \n Rational sampleDuration \n void setMetaTo \n void clearFlag \n boolean isFlag \n void setFlag \n void setFlag \n void clearFlags \n Object copy \n void setFlagsTo \n void setFlagsTo", "output": "void function ( Buffer arg0 ) { this . offset = arg0 . offset ; this . length = arg0 . length ; this . data = copy ( arg0 . data , this . data ) ; this . header = copy ( arg0 . header , this . header ) ; }"}, {"instruction": "Generate java code\nthis method fetches the regular expression value of the key that you are providing . the regular expressions are stored in the regularexp.properties file . ", "input": " String EMPTY_STRING \n String regularExpPropertyFileLocation \n Properties messagesProperties \n Properties regularExpproperties \n String messagePropertyFileLocation \n String getMessageValue", "output": "String function ( String arg0 ) { if ( arg0 == null || arg0 . isEmpty ( ) ) return EMPTY_STRING ; return regularExpproperties . getProperty ( arg0 ) ; }"}, {"instruction": "Generate java code\nadd one tag processor that handles multiple tags . ", "input": " TagProcessor proc \n String className \n Map<String,FactoryObject> map \n TagProcessor getProcessor \n TagProcessor getProcessor \n TagProcessor load \n TagProcessor load \n void removeProcessor \n String getClassName", "output": "void function ( final String arg0 , final String ... arg1 ) { for ( String loc0 : arg1 ) { addProcessor ( loc0 , arg0 ) ; } }"}, {"instruction": "Generate java code\ncompares object references for equality . ", "input": " PlaceHolder placeHolder \n int computeHashCode", "output": "boolean function ( T arg0 , T arg1 ) { return arg0 == arg1 ; }"}, {"instruction": "Generate java code\nputs the given key and value into this map according to the contract of #put object , object except that the value of an existing key mayonly be updated if allowupdate = true . ", "input": " SortedMap<K,V> kSmallest \n int maxSize \n boolean containsKey \n Collection<V> values \n void clear \n boolean isInRange \n V remove \n boolean containsValue \n K getMinKey \n K getMaxKey \n int size \n K firstKey \n void putAll \n void putAll \n void putAll \n void putAll \n void putAll \n V get \n void setAllValues \n K lastKey \n String toString \n Set<K> keySet", "output": "boolean function ( final K arg0 , final V arg1 , final boolean arg2 ) { if ( ! arg2 && kSmallest . containsKey ( arg0 ) ) { return false ; } return put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nadds all column or formula elements . ", "input": " PlaceHolder placeHolder \n Element addNativelyGeneratedId \n Element addColumn \n Element addColumn \n void addColumn \n void addColumns \n String getModifiedFlagPropertyName \n Element createEntityCommon \n Element addOrModifyColumn \n Element addProperty \n Element addProperty \n Element createEntity \n Element createSubclassEntity \n void changeNamesInColumnElement \n void prefixNamesInPropertyElement \n Element addModifiedFlagProperty \n void addFormula \n ColumnNameIterator getColumnNameIterator \n ColumnNameIterator getColumnNameIterator \n Element createJoin \n void addOrModifyAttribute", "output": "void function ( Element arg0 , Iterator arg1 ) { while ( arg1 . hasNext ( ) ) { final Object loc0 = arg1 . next ( ) ; if ( loc0 instanceof Column ) { addColumn ( arg0 , ( Column ) loc0 ) ; } else if ( loc0 instanceof Formula ) { addFormula ( arg0 , ( Formula ) loc0 ) ; } } }"}, {"instruction": "Generate java code\nprint the message for a log entry to the specified file ", "input": " ILog sysOutLog \n String PRODUCT_ID \n PrintWriter sysOut \n ILog log \n void setLog \n void printLogObject \n void removeLogListener \n void log \n void log \n void log \n void log \n void log \n void logNoHeader \n void logStackTrace \n void printLogStatus \n IStatus createLogStatus \n void printLog \n void close \n void addLogListener \n org.osgi.framework.Bundle getBundle", "output": "void function ( PrintWriter arg0 , String arg1 ) { if ( arg1 != null ) { arg0 . println ( arg1 ) ; } }"}, {"instruction": "Generate java code\ngets the value of the omit property . ", "input": " Keepalive keepalive \n Omit omit \n void setOmit \n void setKeepalive \n Keepalive getKeepalive", "output": "Omit function ( ) { return omit ; }"}, {"instruction": "Generate java code\nprints out the current thread stack to the given stream . ", "input": " ExceptionUtil instance \n ExceptionUtil instance", "output": "void function ( PrintStream arg0 ) { StackTraceElement [ ] loc0 = Thread . currentThread ( ) . getStackTrace ( ) ; String loc1 = StringUtil . arrayToString ( loc0 , \"srini_string\" ) ; arg0 . println ( loc1 ) ; }"}, {"instruction": "Generate java code\nthe vm name of the class . ", "input": " String name \n boolean[] probes \n long id \n void merge \n void merge \n boolean[] getProbes \n void reset \n long getId \n String toString \n void assertCompatibility", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nreturn the native logger instance we are using . ", "input": " String name \n boolean is12 \n Logger logger \n String FQCN \n void warn \n void warn \n void trace \n void trace \n void debug \n void debug \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isWarnEnabled \n boolean isDebugEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void info \n void info", "output": "Logger function ( ) { if ( logger == null ) { logger = Logger . getLogger ( name ) ; } return ( this . logger ) ; }"}, {"instruction": "Generate java code\nnumber of comparators in the current comparatorchain . ", "input": " BitSet orderingBits \n List comparatorChain \n boolean isLocked \n long serialVersionUID \n int compare \n void checkLocked \n void setComparator \n void setComparator \n void setForwardSort \n int hashCode \n void setReverseSort \n boolean isLocked \n boolean equals \n void checkChainIntegrity \n void addComparator \n void addComparator", "output": "int function ( ) { return comparatorChain . size ( ) ; }"}, {"instruction": "Generate java code\nconverts given array to an iterable ", "input": " PlaceHolder placeHolder \n Object getMapValue \n void setProperty \n Collection<String> getPropertyKeys \n int length \n boolean isArray \n Object getArrayIndex \n Object getArrayIndex \n void setArrayIndex \n void removeProperty \n boolean isMap \n Object unwrap", "output": "Iterable < ? extends Object > function ( Object arg0 ) { if ( isArray ( arg0 ) ) return ( ( Iterable ) arg0 ) ; else throw new JsonPathException ( \"srini_string\" + arg0 != null ? arg0 . getClass ( ) . getName ( ) : \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the zero element . ", "input": " java.math.BigDecimal val \n int DEFAULT_PRECISION \n BigDecimal ZERO \n MathContext DEFAULT_CONTEXT \n MathContext context \n BigDecimal ONE \n Random random \n boolean isField \n boolean isCommutative \n BigDecimal gcd \n BigDecimal sum \n int compareTo \n java.math.BigInteger characteristic \n BigDecimal random \n BigDecimal random \n BigDecimal random \n BigDecimal random \n int hashCode \n BigDecimal divide \n BigDecimal copy \n BigDecimal multiply \n int signum \n boolean isONE \n BigDecimal inverse \n BigDecimal valueOf \n BigDecimal valueOf \n boolean isUnit \n BigDecimal subtract \n BigDecimal parse \n BigDecimal parse \n BigDecimal[] egcd \n BigDecimal abs \n BigDecimal[] divideAndRemainder \n BigDecimal negate \n boolean equals \n BigDecimal clone \n BigDecimal getONE \n BigDecimal fromInteger \n BigDecimal fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigDecimal remainder", "output": "BigDecimal function ( ) { return ZERO ; }"}, {"instruction": "Generate java code\nretrieve the name of the team ", "input": " Player[] players \n String name \n int hashCode \n boolean isValid \n boolean equals \n void addTeamToNotPlayedLists \n String toString \n Player[] getPlayers", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nget the power series of the sinus function . ", "input": " UnivPowerSeries<C> ZERO \n String DEFAULT_NAME \n int truncate \n String var \n int DEFAULT_TRUNCATE \n UnivPowerSeries<C> ONE \n RingFactory<C> coFac \n Random random \n UnivPowerSeries<C> getTAN \n boolean isField \n boolean isCommutative \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> fromPolynomial \n java.math.BigInteger characteristic \n UnivPowerSeries<C> getEXP \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n int hashCode \n boolean equals \n UnivPowerSeries<C> getONE \n UnivPowerSeries<C> getZERO \n UnivPowerSeries<C> getCOS \n UnivPowerSeries<C> fromInteger \n UnivPowerSeries<C> fromInteger \n String toString \n boolean isAssociative \n UnivPowerSeries<C> copy \n UnivPowerSeries<C> fixPoint", "output": "UnivPowerSeries < C > function ( ) { return fixPoint ( new PowerSeriesMap < C > ( ) { public UnivPowerSeries < C > map ( UnivPowerSeries < C > arg0 ) { return arg0 . negate ( ) . integrate ( coFac . getONE ( ) ) . integrate ( coFac . getZERO ( ) ) ; } } ) ; }"}, {"instruction": "Generate java code\nlooks up the dhtobject associated with key in the local database . ", "input": " Map<KademliaOverlayKey,KademliaIndexEntry> index \n ComponentsConfig config \n void refreshIndex \n void putInitialDataItem \n Map<KademliaOverlayKey,DHTObject> getEntries \n void put \n Map<KademliaOverlayKey,DHTObject> getEntriesToRepublish", "output": "DHTObject function ( final KademliaOverlayKey arg0 ) { final KademliaIndexEntry loc0 = index . get ( arg0 ) ; if ( loc0 == null ) { return null ; } else if ( loc0 . hasExpired ( ) ) { index . remove ( arg0 ) ; return null ; } return loc0 . getValue ( ) ; }"}, {"instruction": "Generate java code\ngets the sha-1 hash of the completed piece as a byte array ", "input": " TorrentFilePiecesState state \n BitSet slices \n BitSet loadingSlices \n int maxSlices \n int size \n byte[] data \n TimerTask[] loadingTasks \n int SLICE_SIZE \n int index \n byte[] hash \n Timer loadingTimer \n void putSlice \n int getSize \n TorrentFilePiecesState getState \n int getBeginOfSlice \n int getIndex \n void clearSlices \n void setData \n int getLengthOfSlice \n int getNextSlice \n int getNextSlice \n void setState \n ByteBuffer getByteBuffer \n boolean isLoadingSlices", "output": "byte [ ] function ( ) { return hash ; }"}, {"instruction": "Generate java code\nerase the whole line ", "input": " String inlineMarkupDelimiters \n int sectionLevel \n boolean erased \n boolean inBlock \n boolean listStart \n List<Boolean> valid \n char ESCAPED_CHARACTER_VALUE \n List<Integer> offsets \n List<Character> characters \n String text \n List<Boolean> escaped \n int listLevel \n int lineNo \n boolean allSameCharacter \n void setListStart \n boolean isListStart \n String getText \n boolean isValid \n int getOffset \n int length \n boolean isEmpty \n void eraseWithStyle \n boolean isAllSameCharacter \n void setSectionLevel \n void setInBlock \n boolean isErased \n int getSectionLevel \n int eraseEnclosure \n int getListLevel \n int getLineNo \n boolean isInBlock \n String toString \n char rawCharAt \n void setListLevel \n char charAt \n char charAt \n boolean startsWith", "output": "void function ( ) { for ( int loc0 = 0 ; loc0 < valid . size ( ) ; loc0 ++ ) { valid . set ( loc0 , false ) ; } erased = true ; }"}, {"instruction": "Generate java code\ncarbon ", "input": " MacExtensions MacExt \n Rectangle win32_getBounds \n Rectangle win32_getBounds \n MenuItem[] getItems \n Menu[] getMenus \n Menu[] getMenus \n boolean isMacAccessibilityDisabled \n boolean parentIsControl \n void gtk_getBounds \n Rectangle gtk_getBounds \n Rectangle gtk_getBounds \n boolean isSubMenu \n Rectangle motif_getBounds \n Rectangle motif_getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n Rectangle getBounds \n int SendMessage \n int SendMessage", "output": "Rectangle function ( TabItem arg0 ) { Rectangle loc0 = MacExt . getTabItemBounds ( arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ngetter for the roman number generator instance . ", "input": " RomanNumeralGenerator romanNumeralGenerator \n void start \n void main \n void setRomanNumeralGenerator", "output": "RomanNumeralGenerator function ( ) { return romanNumeralGenerator ; }"}, {"instruction": "Generate java code\nstarts the analyzer which starts the statisticgernerationevent ", "input": " long receivedBytes \n int sentMsg \n int receivedMsg \n StatisticGenerationEvent event \n long sentBytes \n Logger log \n double[] getSentBytes \n void netMsgReceive \n void addReceivedMsg \n void stop \n double[] getSentMsg \n double[] getReceivedMsg \n void netMsgSend \n void netMsgDrop \n double[] getReceivedBytes \n void addSentMsg", "output": "void function ( ) { event = new StatisticGenerationEvent ( this ) ; event . writerStarted ( ) ; event . scheduleImmediatly ( ) ; receivedBytes = 0 ; sentBytes = 0 ; receivedMsg = 0 ; sentMsg = 0 ; }"}, {"instruction": "Generate java code\ninitializes this image manager . nothing happens if this method is invoked after a previous initialization . this method is not supposed to be invoked more than once . ", "input": " String T_LCL \n String T_TOOL \n URL iconBaseURL \n ImageRegistry imageRegistry \n String T_OBJ \n String T_VIEW \n String T_OVR \n boolean imagesWereLoaded \n String T_WIZBAN \n ImageDescriptor add \n ImageDescriptor add \n boolean add \n URL makeIconFileURL \n void setImageDescriptors \n ImageDescriptor createImageDescriptor \n void checkImages \n void addImages \n ImageDescriptor getImageDescriptor \n ImageDescriptor getImageDescriptor \n Image getImage \n Image getImage", "output": "void function ( URL arg0 , ImageRegistry arg1 ) { this . iconBaseURL = arg0 ; this . imageRegistry = arg1 ; }"}, {"instruction": "Generate java code\nreturns -1 if the first argument is the default working set , 1 if the second argument is the default working set and if the boolean fisotherworkingsetontop is set , to keep the default working set on top while sorting . ", "input": " boolean fIsOtherWorkingSetOnTop \n Collator fCollator \n placeholderType placeHolder", "output": "int function ( IWorkingSet arg0 , IWorkingSet arg1 ) { if ( fIsOtherWorkingSetOnTop && IWorkingSetIDs . OTHERS . equals ( arg0 . getId ( ) ) ) return - 1 ; if ( fIsOtherWorkingSetOnTop && IWorkingSetIDs . OTHERS . equals ( arg1 . getId ( ) ) ) return 1 ; return fCollator . compare ( arg0 . getLabel ( ) , arg1 . getLabel ( ) ) ; }"}, {"instruction": "Generate java code\nhelper method to copy data based on partition ", "input": " boolean dropAll \n RecordBatch incoming \n int DEFAULT_RECORD_BATCH_SIZE \n int outgoingRecordBatchSize \n int totalRecords \n org.slf4j.Logger logger \n int recordCount \n int start \n SelectionVector2 sv2 \n HashPartitionSender operator \n SelectionVector4 sv4 \n BufferAllocator allocator \n OperatorStats stats \n boolean isLast \n FragmentContext context \n int end \n List<OutgoingRecordBatch> outgoingBatches \n VectorContainer vectorContainer \n AccountingDataTunnel tunnel \n int oppositeMinorFragmentId \n OperatorStats getStats \n void initializeBatch \n List<? extends PartitionOutgoingBatch> getOutgoingBatches \n Iterator<VectorWrapper<?>> iterator \n void setIsLast \n void flush \n int getRecordCount \n void resetBatch \n long getTotalRecords \n void copy \n int doEval \n void doEval \n WritableBatch getWritableBatch \n void clear \n void clear \n void doSetup \n void doSetup \n VectorWrapper<?> getValueAccessorById \n PartitionOutgoingBatch getOutgoingBatch \n BatchSchema getSchema \n void partitionBatch \n void allocateOutgoingRecordBatch \n SelectionVector4 getSelectionVector4 \n SelectionVector2 getSelectionVector2 \n TypedFieldId getValueVectorId \n void setup \n void flushOutgoingBatches \n void terminate \n void updateStats", "output": "void function ( int arg0 ) { int loc0 = doEval ( arg0 ) ; if ( loc0 >= start && loc0 < end ) { OutgoingRecordBatch loc1 = outgoingBatches . get ( loc0 - start ) ; loc1 . copy ( arg0 ) ; } }"}, {"instruction": "Generate java code\nsets the address stored in a localvariable to which this subroutine will return once it is finished . ", "input": " Block entry \n Block exit \n ArrayList paths \n FlowGraph graph \n LocalVariable returnAddress \n int numPaths \n void setExit \n FlowGraph graph \n void addPath \n LocalVariable returnAddress \n void removePathsContaining \n void removePath \n Block entry \n Block exit \n void print \n Block pathTarget \n Block pathSource \n Collection paths \n String toString \n void removeAllPaths \n void setEntry", "output": "void function ( final LocalVariable arg0 ) { this . returnAddress = arg0 ; }"}, {"instruction": "Generate java code\ngetter to find out if the signature is a certification signature . ", "input": " boolean certification \n boolean fillInAllowed \n boolean annotationsAllowed \n PdfName action \n PdfArray fields \n List<FieldLock> fieldLocks \n List<FieldLock> getFieldLocks \n PdfArray getFields \n boolean isFillInAllowed \n PdfName getAction \n String toString \n boolean isAnnotationsAllowed", "output": "boolean function ( ) { return certification ; }"}, {"instruction": "Generate java code\nadds an array of cookie http cookies . cookies are added individually and in the given array order . if any of the given cookies has already expired it will not be added , but existing values will still be removed . ", "input": " long serialVersionUID \n TreeSet<Cookie> cookies \n void addCookie \n boolean clearExpired \n List<Cookie> getCookies \n void clear \n String toString", "output": "void function ( final Cookie [ ] arg0 ) { if ( arg0 != null ) { for ( final Cookie loc0 : arg0 ) { this . addCookie ( loc0 ) ; } } }"}, {"instruction": "Generate java code\ncalled to write a string . may be overridden for alternate string representations . ", "input": " GenericData data \n Schema root \n NullPointerException npe \n void writeWithoutConversion \n Iterator<? extends Object> getArrayElements \n void writeFixed \n void writeEnum \n Object convert \n void writeField \n int getMapSize \n void error \n void writeMap \n void setSchema \n void writeRecord \n void writeBytes \n void writeArray \n Iterable<Map.Entry<Object,Object>> getMapEntries \n int resolveUnion \n long getArraySize \n void write \n void write \n GenericData getData", "output": "void function ( Schema arg0 , Object arg1 , Encoder arg2 ) { writeString ( arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nget the post-construct interceptors for client proxy instances . this method should only be called after all interceptors have been added . ", "input": " Map<Class<?>,Object> privateData \n ViewInstanceFactory viewInstanceFactory \n Set<Method> asyncMethods \n ServiceName viewServiceName \n OrderedItemContainer<InterceptorFactory> clientPreDestroyInterceptors \n List<BindingConfiguration> bindingConfigurations \n Map<Method,Method> viewToComponentMethodMap \n ProxyFactory<?> proxyFactory \n OrderedItemContainer<InterceptorFactory> clientPostConstructInterceptors \n Map<Method,OrderedItemContainer<InterceptorFactory>> clientInterceptors \n ComponentConfiguration componentConfiguration \n List<DependencyConfigurator<ViewService>> dependencies \n Class<?> viewClass \n Map<Method,OrderedItemContainer<InterceptorFactory>> viewInterceptors \n ComponentConfiguration getComponentConfiguration \n Class<?> getViewClass \n Map<Class<?>,Object> getPrivateData \n void addAsyncMethod \n List<DependencyConfigurator<ViewService>> getDependencies \n void addClientInterceptor \n void addClientInterceptor \n void setViewInstanceFactory \n Map<Method,Method> getViewToComponentMethodMap \n List<InterceptorFactory> getViewInterceptors \n List<InterceptorFactory> getClientInterceptors \n Set<Method> getAsyncMethods \n void putPrivateData \n ServiceName getViewServiceName \n ProxyFactory<?> getProxyFactory \n void addClientPostConstructInterceptor \n void addClientPreDestroyInterceptor \n void addViewInterceptor \n void addViewInterceptor \n List<InterceptorFactory> getClientPreDestroyInterceptors \n ViewInstanceFactory getViewInstanceFactory \n List<BindingConfiguration> getBindingConfigurations", "output": "List < InterceptorFactory > function ( ) { return clientPostConstructInterceptors . getSortedItems ( ) ; }"}, {"instruction": "Generate java code\nparse a vector from a reader . ", "input": " GenVector<C> ZERO \n Logger logger \n RingFactory<C> coFac \n float density \n int cols \n List<GenVector<C>> BASIS \n Random random \n float DEFAULT_DENSITY \n GenVector<C> random \n GenVector<C> random \n GenVector<C> random \n GenVector<C> random \n GenVector<C> fromList \n int hashCode \n boolean equals \n GenVector<C> getZERO \n GenVector<C> fromInteger \n GenVector<C> fromInteger \n String toString \n GenVector<C> copy", "output": "GenVector < C > function ( Reader arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns the error message from the computers in this category . ", "input": " String fId \n boolean fIsEnabled \n IConfigurationElement fElement \n boolean fNeedsSortingAfterFiltering \n boolean fIsIncluded \n String ICON \n Expression fEnablementExpression \n int fSortOrder \n String fName \n ImageDescriptor fImage \n String fLastError \n CompletionProposalComputerRegistry fRegistry \n boolean fIsSeparateCommand \n boolean isSeparateCommand \n String getName \n void sessionEnded \n void setSortOrder \n void sessionStarted \n Expression getEnablementExpression \n void setSeparateCommand \n String getId \n ImageDescriptor getImageDescriptor \n void setIncluded \n boolean matches \n Bundle getBundle \n int getSortOrder \n void setEnabled \n void checkNotNull \n String getDisplayName \n boolean isEnabled \n boolean hasComputers \n boolean hasComputers \n boolean isSortingAfterFilteringNeeded \n boolean isIncluded \n List<ICompletionProposal> computeCompletionProposals \n List<IContextInformation> computeContextInformation", "output": "String function ( ) { return fLastError ; }"}, {"instruction": "Generate java code\nreturns a string representing the projpoint in the format : projcoordinate x y z . example : projcoordinate 6241.11 5218.25 12.3 ", "input": " DecimalFormat DECIMAL_FORMAT \n double x \n String DECIMAL_FORMAT_PATTERN \n double y \n double z \n String toShortString \n boolean areZOrdinatesEqual \n boolean hasValidZOrdinate \n int hashCode \n int hashCode \n void setValue \n void setValue \n void setValue \n boolean areYOrdinatesEqual \n boolean equals \n boolean areXOrdinatesEqual \n boolean hasValidXandYOrdinates \n void clearZ", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( \"srini_string\" ) ; loc0 . append ( this . x ) ; loc0 . append ( \"srini_string\" ) ; loc0 . append ( this . y ) ; loc0 . append ( \"srini_string\" ) ; loc0 . append ( this . z ) ; loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nvalidate that the argument condition is true ; otherwise throwing an exception with the specified message . this method is useful when validating according to an arbitrary boolean expression , such as validating a primitive number or using your own custom validation expression . validate.istrue i > 0.0 , `` the value must be greater than zero : % d '' , i ; for performance reasons , the long value is passed as a separate parameter and appended to the exception message only in the case of an error . ", "input": " PlaceHolder placeHolder \n T notNull \n boolean isEmpty \n String unescape \n String concat \n void onlyOneIsTrue \n boolean onlyOneIsTrueNonThrow \n String hex \n String toString \n String join \n String join \n void closeQuietly \n T notEmpty \n String escape \n int indexOf", "output": "void function ( boolean arg0 , String arg1 ) { if ( arg0 == false ) { throw new IllegalArgumentException ( arg1 ) ; } }"}, {"instruction": "Generate java code\nreturns the paths a collection of two-element arrays of blocks that represent the blocks that end in a call to this subroutine and the block that begin with the return address from this subroutine . ", "input": " Block entry \n Block exit \n ArrayList paths \n FlowGraph graph \n LocalVariable returnAddress \n void setReturnAddress \n int numPaths \n void setExit \n FlowGraph graph \n void addPath \n LocalVariable returnAddress \n void removePathsContaining \n void removePath \n Block entry \n Block exit \n void print \n Block pathTarget \n Block pathSource \n String toString \n void removeAllPaths \n void setEntry", "output": "Collection function ( ) { return paths ; }"}, {"instruction": "Generate java code\npower of a to the n-th . ", "input": " boolean debug \n RingFactory<C> fac \n Logger logger \n C modPower \n C modPower \n C positivePower \n C modPositivePower", "output": "C function ( C arg0 , long arg1 ) { return power ( fac , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nresolve the column name/alias to its index ", "input": " ConcurrentHashMap<String,Integer> columnNameToIndexCache \n float LOAD_FACTOR \n placeholderType placeHolder", "output": "Integer function ( String arg0 , ResultSet arg1 ) { final Integer loc0 = columnNameToIndexCache . get ( arg0 ) ; if ( loc0 != null ) { return loc0 ; } else { final Integer loc1 = Integer . valueOf ( arg1 . findColumn ( arg0 ) ) ; columnNameToIndexCache . put ( arg0 , loc1 ) ; return loc1 ; } }"}, {"instruction": "Generate java code\nconvert a duration to the number of seconds . the result will be rounded towards 0 to the nearest second . e.g. , if the duration represents -1 nanosecond , it will be rounded to 0 . ", "input": " long DURATION_SECONDS_MAX \n long DURATION_SECONDS_MIN \n Duration MAX_VALUE \n Duration MIN_VALUE \n Comparator<Duration> COMPARATOR \n Duration add \n int compare \n Duration fromNanos \n boolean isValid \n boolean isValid \n Duration checkValid \n Duration subtract \n Duration parse \n Duration fromSeconds \n Comparator<Duration> comparator \n long toNanos \n Duration fromMillis \n Duration fromMicros \n String toString \n long toMillis \n long toMicros \n Duration normalizedDuration", "output": "long function ( Duration arg0 ) { return checkValid ( arg0 ) . getSeconds ( ) ; }"}, {"instruction": "Generate java code\nis local zero . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n C num \n int isunit \n C den \n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n Local<C> abs \n int hashCode \n Local<C> negate \n boolean equals \n Local<C> clone \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "boolean function ( ) { return num . isZERO ( ) ; }"}, {"instruction": "Generate java code\nreturn the audio resource id of the word . ", "input": " int mAudioResourceId \n String mDefaultTranslation \n int mImageResourceId \n int NO_IMAGE_PROVIDED \n String mMiwokTranslation \n String getDefaultTranslation \n boolean hasImage \n int getImageResourceId \n String getMiwokTranslation", "output": "int function ( ) { return mAudioResourceId ; }"}, {"instruction": "Generate java code\nset the last char ", "input": " StringBuilder currentEntity \n StringBuilder comment \n String currentTag \n boolean isHtml \n String currentAttr \n char lastChar \n String wsTag \n String storedString \n Map<String,String> attr \n String currentNameSpace \n StringBuilder baos \n StringBuilder currentEntity \n Map<String,String> getAttributes \n void putCurrentAttrValue \n void currentAttr \n boolean hasCurrentAttribute \n String getNameSpace \n String whitespaceTag \n void whitespaceTag \n void flushNameSpace \n void setStoredString \n String getCurrentTag \n StringBuilder current \n void currentTag \n void resetBuffer \n void namespace \n String getStoredString \n StringBuilder comment", "output": "void function ( final char arg0 ) { this . lastChar = arg0 ; }"}, {"instruction": "Generate java code\ngets byte value form cursor for column index . ", "input": " PlaceHolder placeHolder \n Long getLong \n Character getChar \n Integer getInt \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n Short getShort \n byte[] getByteArray \n Double getDouble \n Boolean getBoolean \n Date getDate \n Date getDate \n Float getFloat \n String getString", "output": "Byte function ( @ NonNull Cursor arg0 , int arg1 ) { if ( arg0 . isNull ( arg1 ) ) { return null ; } return ( byte ) arg0 . getInt ( arg1 ) ; }"}, {"instruction": "Generate java code\nchecks if the given resources are in sync with the underlying file system . ", "input": " PlaceHolder placeHolder \n boolean isReadOnly \n IStatus addModified \n int getSelectedResourceTypes \n IStatus addOutOfSync \n boolean containsOnlyProjects \n Map<IFile,Long> createModificationStampMap \n void setReadOnly \n IStatus makeCommittable \n IStatus makeCommittable \n boolean containsOnlyNonProjects", "output": "IStatus function ( IResource [ ] arg0 ) { IStatus loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0 . length ; loc1 ++ ) { IResource loc2 = arg0 [ loc1 ] ; if ( ! loc2 . isSynchronized ( IResource . DEPTH_INFINITE ) ) { loc0 = addOutOfSync ( loc0 , loc2 ) ; } } if ( loc0 != null ) return loc0 ; return Status . OK_STATUS ; }"}, {"instruction": "Generate java code\nlog a message with trace log level . ", "input": " Date date \n int LOG_LEVEL_DEBUG \n int level \n Throwable throwable \n List logEntries \n int LOG_LEVEL_OFF \n Object message \n int LOG_LEVEL_WARN \n int LOG_LEVEL_TRACE \n int LOG_LEVEL_ERROR \n int LOG_LEVEL_INFO \n String logName \n String name \n int LOG_LEVEL_FATAL \n int LOG_LEVEL_ALL \n int currentLogLevel \n void debug \n void debug \n void log \n Object getMessage \n boolean isLevelEnabled \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void setLevel \n void fatal \n void fatal \n String getLogName \n int getLevel \n int getLevel \n void warn \n void warn \n boolean isInfoEnabled \n boolean isErrorEnabled \n void reset \n boolean isTraceEnabled \n Date getDate \n boolean isDebugEnabled \n Throwable getThrowable \n List getLogEntries \n void info \n void info", "output": "void function ( Object arg0 ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_TRACE ) ) { log ( MemoryLog . LOG_LEVEL_TRACE , arg0 , null ) ; } }"}, {"instruction": "Generate java code\ngets the predicate being decorated . ", "input": " long serialVersionUID \n Predicate iPredicate \n Predicate getInstance \n boolean evaluate", "output": "Predicate [ ] function ( ) { return new Predicate [ ] { iPredicate } ; }"}, {"instruction": "Generate java code\nreplace the deserialized instance with its associated static object required for proper serialization . ", "input": " String TOGGLE_SPY_LABEL \n IRecorderSemanticEvent DISPOSE \n String PAUSE_LABEL \n IRecorderSemanticEvent RESTART \n IRecorderSemanticEvent TOGGLE_SPY \n long serialVersionUID \n String START_LABEL \n String STOP_LABEL \n IRecorderSemanticEvent PAUSE \n String name \n IRecorderSemanticEvent START \n Map types \n String DISPOSE_LABEL \n String RESTART_LABEL \n IRecorderSemanticEvent STOP \n RecorderMetaEvent get \n String toString \n void accept", "output": "Object function ( ) { return get ( name ) ; }"}, {"instruction": "Generate java code\ndefault implementation that simply calls thread #sleep long . ", "input": " long timeout \n int interval \n boolean isTrue \n void wait \n void wait \n boolean timedOut \n Timer withInterval \n void handleTimeout \n Timer withTimeout", "output": "void function ( int arg0 ) { try { Thread . sleep ( arg0 ) ; } catch ( InterruptedException loc0 ) { } }"}, {"instruction": "Generate java code\nupdates a reading list item with new meta data . ", "input": " String LOGTAG \n ContentObserver contentObserver \n Context context \n OnReadingListEventListener onReadingListEventListener \n boolean fetchInBackground \n ReadingListAccessor readingListAccessor \n BrowserDB db \n void handleReadingListStatusRequest \n void onAddedToReadingList \n void handleEvent \n void onRemovedFromReadingList \n void handleMessage \n void handleRemoveFromList \n void handleReaderModeFaviconRequest \n void uninit \n void disableBackgroundFetches \n void fetchContent \n void onAlreadyInReadingList \n ContentValues getContentValues \n void handleAddToList", "output": "void function ( final NativeJSObject arg0 ) { final ContentResolver loc0 = context . getContentResolver ( ) ; final ContentValues loc1 = getContentValues ( arg0 ) ; ThreadUtils . postToBackgroundThread ( new Runnable ( ) { @ Override public void run ( ) { readingListAccessor . updateReadingListItem ( loc0 , loc1 ) ; } } ) ; }"}, {"instruction": "Generate java code\nreturn the job prefix which is the same as the file name . ", "input": " Logger log \n Path file \n String prefix \n FileChannel channel \n FileLock lock \n JobPrefixFile tryFromExistingFile \n void release \n void deleteIfExists \n JobPrefixFile create \n JobPrefixFile create \n void delete \n void close \n void close", "output": "String function ( ) { return prefix ; }"}, {"instruction": "Generate java code\nasserts that two chars are equal . if they are not an assertionfailederror is thrown with the given message . ", "input": " PlaceHolder placeHolder \n void fail \n void fail \n void assertNull \n void assertNull \n void assertTrue \n void assertTrue \n void assertNotNull \n void assertNotNull \n void failNotSame \n void assertFalse \n void assertFalse \n void assertNotSame \n void assertNotSame \n String format \n void assertSame \n void assertSame \n void failNotEquals \n void failSame", "output": "void function ( String arg0 , char arg1 , char arg2 ) { assertEquals ( arg0 , new Character ( arg1 ) , new Character ( arg2 ) ) ; }"}, {"instruction": "Generate java code\nreturns whether mouse buttons 2/3 are swapped when using robot . ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean hasMultiClickFrameBug \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isOSX ( ) && Platform . JAVA_VERSION >= Platform . JAVA_1_4 && Platform . JAVA_VERSION <= 0x1425 ; }"}, {"instruction": "Generate java code\nthis method returns the value of the database column sys_ip_area . province ", "input": " String areaCode \n String IPCODE_UNKNOWN \n String city \n String province \n String edu \n String district \n String company \n Date createTime \n Long endIp \n String owner \n Long startIp \n String country \n boolean isIp \n void setCountry \n Date getCreateTime \n String getCountry \n void setProvince \n long valueOfIpv4 \n String getEdu \n Long getStartIp \n Long getEndIp \n String getOwner \n void setStartIp \n void setEndIp \n void setOwner \n String getStartIpv4 \n String getEndIpv4 \n String getAreaCode \n String ipv4 \n String getDistrict \n void setDistrict \n void setCompany \n String getCity \n void setCity \n void setAreaCode \n void setCreateTime \n String getCompany \n void setEdu \n String toString", "output": "String function ( ) { return province ; }"}, {"instruction": "Generate java code\nbuild a lobcreator using the given context ", "input": " boolean useContextualLobCreation \n Object[] NO_ARGS \n Class[] NO_ARG_SIG \n CoreMessageLogger LOG \n boolean useContextualLobCreation", "output": "LobCreator function ( LobCreationContext arg0 ) { return useContextualLobCreation ? new ContextualLobCreator ( arg0 ) : NonContextualLobCreator . INSTANCE ; }"}, {"instruction": "Generate java code\nreturns default parameters for debug builds . ", "input": " boolean skip \n boolean runModule \n boolean minify \n boolean dev \n boolean inlineSourceMap \n PackagerParams releaseDefaults \n PackagerParams getPackagerParams \n boolean isSkip \n void minify \n boolean isRunModule \n void dev \n boolean isInlineSourceMap \n boolean isDev \n void runModule \n void skip \n void inlineSourceMap \n boolean isMinify", "output": "PackagerParams function ( ) { PackagerParams loc0 = new PackagerParams ( ) ; loc0 . dev = true ; loc0 . inlineSourceMap = false ; loc0 . minify = false ; loc0 . runModule = true ; loc0 . skip = true ; return loc0 ; }"}, {"instruction": "Generate java code\npass interpreteroutput to capture the repl output ", "input": " Logger logger \n String scriptPath \n Integer rScriptInitializeNotifier \n Integer rRequestNotifier \n String rCmdPath \n Integer rResponseNotifier \n InterpreterOutput initialOutput \n Request rRequestObject \n Map<Integer,ZeppelinR> zeppelinR \n boolean rResponseError \n boolean rScriptRunning \n String type \n SparkVersion sparkVersion \n PipedOutputStream input \n String libPath \n int port \n DefaultExecutor executor \n boolean rScriptInitialized \n SparkOutputStream outputStream \n Object rResponseValue \n Object value \n String stmt \n Object request \n void set \n Request getRequest \n String getS0 \n void setResponse \n void onScriptInitialized \n void onProcessComplete \n void waitForRScriptInitialized \n Object getValue \n void onProcessFailed \n Object eval \n String getType \n Object get \n void createRScript \n String getStmt \n void close \n void open \n ZeppelinR getZeppelinR", "output": "void function ( InterpreterOutput arg0 ) { outputStream . setInterpreterOutput ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis method calculates the score of this query with all the documents and sort the score map in the reverse order of value . ", "input": " Map<Integer,Double> docRankingByW1 \n HashMap<String,Integer> documentNameIdMap \n Map<String,Integer> queryIndex \n List<String> stopWords \n Map<String,Integer> getDocumentNameMap \n Map<Integer,Double> getRankingByW1 \n void indexQuery \n Map<Integer,String> getUrlMap \n void calculateByW1 \n List<String> getQueries \n void listStopWords", "output": "void function ( ) { for ( Integer loc0 : FileUtils . documentIdMap . keySet ( ) ) { calculateByW1 ( loc0 ) ; } this . docRankingByW1 = Util . sortByValue ( docRankingByW1 ) ; documentNameIdMap = FileUtils . documentNameIdMap ; }"}, {"instruction": "Generate java code\ngets a uniformly distributed random value with mean = mu . ", "input": " int DIGEST_MODE \n BufferedReader filePointer \n int CONSTANT_MODE \n int mode \n double mu \n EmpiricalDistribution empiricalDistribution \n URL valuesFileURL \n double sigma \n RandomDataImpl randomData \n int REPLAY_MODE \n int EXPONENTIAL_MODE \n int GAUSSIAN_MODE \n int UNIFORM_MODE \n EmpiricalDistribution getEmpiricalDistribution \n void closeReplayFile \n double getMu \n void setMode \n double getNext \n void fill \n double[] fill \n double getSigma \n void computeDistribution \n void computeDistribution \n void setMu \n void setValuesFileURL \n void setValuesFileURL \n double getNextReplay \n URL getValuesFileURL \n void setSigma \n void resetReplayFile \n double getNextGaussian \n int getMode \n double getNextDigest \n double getNextExponential", "output": "double function ( ) { return randomData . nextUniform ( 0 , 2 * mu ) ; }"}, {"instruction": "Generate java code\nreturns a string describing a method declaration . it contains the access flags public , private , static , etc , the return type , the method name , and the types of each of its arguments . ", "input": " boolean skip_checks \n Type string_array \n void add_line_numbers \n void add_to_start \n void dump_methods \n String get_attribute_name \n String get_attribute_name \n String instruction_descr \n void setup_init_locals \n String get_constant_str \n void empty_method \n void dump_method_declarations \n boolean in_jdk \n boolean in_jdk \n String get_access_flags \n boolean is_clinit \n boolean is_clinit \n void checkMgen \n String local_var_descr \n boolean is_constructor \n boolean is_constructor \n boolean is_main \n void dump \n void dump \n void remove_local_variable_type_tables \n boolean is_local_variable_type_table \n void checkMgens", "output": "String function ( Method arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; Formatter loc1 = new Formatter ( loc0 ) ; loc1 . format ( \"srini_string\" , get_access_flags ( arg0 ) , arg0 . getReturnType ( ) , arg0 . getName ( ) ) ; for ( Type loc2 : arg0 . getArgumentTypes ( ) ) { loc1 . format ( \"srini_string\" , loc2 ) ; } loc1 . format ( \"srini_string\" ) ; return ( loc0 . toString ( ) . replace ( \"srini_string\" , \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\ntest that transformation from second transformer is applied on transformed name obtained from first transformer . ", "input": " String USER3 \n String USER2 \n PropertyFileBasedDomain chainedThreeTransformers \n String USER1 \n String ELYTRON_SECURITY_TRANSFORM_TRANSFORMED \n String PASSWORD1 \n String PREDEFINED_HTTP_SERVER_MECHANISM_FACTORY \n String DEP_SECURITY_DOMAIN_TRANSFORM_TRANSFORMED \n String ELYTRON_SECURITY_TWO \n String PRINCIPAL_TRANSFORMER_TRANSFORM_TRANSFORMED \n String PASSWORD3 \n String ELYTRON_SECURITY_THREE \n String PRINCIPAL_TRANSFORMER_TWO \n String DEP_SECURITY_DOMAIN_TWO \n String ROLE \n String PRINCIPAL_TRANSFORMER_THREE \n String REGEX_TRANSFORMER_A \n String PASSWORD2 \n String REGEX_TRANSFORMED_SECOND \n String REGEX_TRANSFORMED_FIRST \n String REGEX_TRANSFORMER_B \n PropertyFileBasedDomain chainedTwoTransformers \n PropertyFileBasedDomain transformTransformed \n String REGEX_TRANSFORMER_C \n String DEP_SECURITY_DOMAIN_THREE \n WebArchive deploymentThreeTransformersInChain \n void removeSingleConfiguration \n WebArchive deploymentTransformTransformed \n void setup \n PropertyFileBasedDomain prepareSingleConfiguration \n WebArchive deploymentTwoTransformersInChain \n WebArchive createDeployment \n void testTwoTransformersInChain \n void tearDown \n void testThreeTransformersInChain \n URL prepareUrl", "output": "void function ( @ ArquillianResource URL arg0 ) { URL loc0 = prepareUrl ( arg0 ) ; Utils . makeCallWithBasicAuthn ( loc0 , \"srini_string\" , PASSWORD3 , SC_OK ) ; }"}, {"instruction": "Generate java code\nacquires a buffered reader usable to read the contents of a file ", "input": " PlaceHolder placeHolder \n void deleteFile \n void copyFile \n BufferedWriter getWriter \n void main \n boolean fileExists \n String replaceFilename", "output": "BufferedReader function ( String arg0 ) { BufferedReader loc0 = new BufferedReader ( new FileReader ( arg0 ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncalled when a section is written . position will hold the height at which the section will be written to . ", "input": " PlaceHolder placeHolder \n void onParagraph \n void onParagraphEnd \n void onOpenDocument \n void onSectionEnd \n void onEndPage \n void onChapter \n void onGenericTag \n void onCloseDocument \n void onChapterEnd \n void onStartPage", "output": "void function ( PdfWriter arg0 , Document arg1 , float arg2 , int arg3 , Paragraph arg4 ) { }"}, {"instruction": "Generate java code\nbuild a request body out of the phenotype given . ", "input": " String IF_NONE_MATCH \n String GITHUB \n ObjectMapper mapper \n URL GITHUB_URL \n Repository repository \n String getIssueEndpoint \n void patchIssue \n Phenotype readPhenotype \n Repository getRepository \n String buildSearch \n InputStream getStream \n void openIssue \n HttpResponse execute \n URI getURI \n Optional<String> searchForIssue \n void checkCode \n String getRepoMethod", "output": "byte [ ] function ( Phenotype arg0 ) { byte [ ] loc0 = mapper . writeValueAsBytes ( Issue . getRequestParams ( arg0 ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\ntime to live for a contact before it is considered offline ", "input": " int numberOfReplicates \n long timeToLiveForContacts \n int numberOfPingTries \n long timeBetweenRootPings \n long timeBetweenReplicationChecks \n int numberOfReplicationTries \n int minimumNumberOfReplicates \n int getNumberOfPingTries \n int getNumberOfReplicationTries \n void setNumberOfPingTries \n int getNumberOfReplicates \n long getTimeBetweenReplicationChecks \n void setTimeBetweenRootPings \n void setMinimumNumberOfReplicates \n void setNumberOfReplicates \n int getMinimumNumberOfReplicates \n void setTimeToLiveForContacts \n void setTimeBetweenReplicationChecks \n long getTimeBetweenRootPings \n void setNumberOfReplicationTries", "output": "long function ( ) { return Math . max ( timeToLiveForContacts , timeBetweenRootPings ) ; }"}, {"instruction": "Generate java code\nreturns an index about where in the cache different variants for a given resource are stored . this maps `` variant keys '' to `` cache keys '' , where the variant key is derived from the varying request headers , and the cache key is the location in the ch.boye.httpclientandroidlib.client.cache.httpcachestorage where thatparticular variant is stored . the first variant returned is used as the `` parent '' entry to hold this index of the other variants . ", "input": " Date date \n Map<String,String> variantMap \n StatusLine statusLine \n HeaderGroup responseHeaders \n Resource resource \n Date requestDate \n long serialVersionUID \n Date responseDate \n Resource getResource \n Header[] getHeaders \n Header getFirstHeader \n Header[] getAllHeaders \n String getReasonPhrase \n ProtocolVersion getProtocolVersion \n Date getResponseDate \n boolean hasVariants \n Date parseDate \n int getStatusCode \n StatusLine getStatusLine \n Date getDate \n String toString \n Date getRequestDate", "output": "Map < String , String > function ( ) { return Collections . unmodifiableMap ( variantMap ) ; }"}, {"instruction": "Generate java code\nreturns all document sets that were declared in the xml config file . ", "input": " Map<String,IDocumentSet> resources \n Map<IDocumentSet,Boolean> resourcesOfSetPublished \n int resourceOffset \n DocumentSpace inst \n MultiSet<Integer> publishedRanks \n void setUseRanks \n void setResourceSet \n IDocumentSet getResourceSet \n void activateMyPublishedKeys \n int getKeyForLookup \n DocumentSpace getInstance \n Set<Integer> getSomeKeysForPublish \n void deactivateMyPublishedKeys \n void recalculateIfResourcesOfSetPublished", "output": "Collection < IDocumentSet > function ( ) { return Collections . unmodifiableCollection ( resources . values ( ) ) ; }"}, {"instruction": "Generate java code\nget the number of aliases that have specific lock modes defined . ", "input": " Map<String,LockMode> aliasSpecificLockModes \n int NO_WAIT \n LockOptions NONE \n boolean scope \n int SKIP_LOCKED \n LockOptions READ \n LockOptions UPGRADE \n LockMode lockMode \n int timeout \n int WAIT_FOREVER \n LockMode getLockMode \n LockOptions makeCopy \n LockMode getEffectiveLockMode \n LockOptions setLockMode \n Iterator getAliasLockIterator \n LockOptions setAliasSpecificLockMode \n LockMode getAliasSpecificLockMode \n LockOptions setTimeOut \n LockMode findGreatestLockMode \n boolean hasAliasSpecificLockModes \n int getTimeOut \n LockOptions copy \n LockOptions setScope \n boolean getScope", "output": "int function ( ) { if ( aliasSpecificLockModes == null ) { return 0 ; } return aliasSpecificLockModes . size ( ) ; }"}, {"instruction": "Generate java code\ngets the 1.5 compression status . ", "input": " PdfCopyFormsImp fc \n void setOutlines \n void setViewerPreferences \n void copyDocumentFields \n void addJavaScript \n void addViewerPreference \n void addDocument \n void addDocument \n void addDocument \n PdfWriter getWriter \n void setEncryption \n void setEncryption \n void setEncryption \n void setEncryption \n void setFullCompression \n void close \n void open", "output": "boolean function ( ) { return fc . isFullCompression ( ) ; }"}, {"instruction": "Generate java code\nthis method adds a further condition to the set of conditions of this clause . ", "input": " int solvingLevel \n int searchedElements \n Vector<QueryCondition<?>> conditions \n SkyNetNodeInfo solvingPeer \n Vector<SkyNetNodeInfo> matches \n HashMap<BigDecimal,QueryReplyingPeer> replyingPeers \n SkyNetNodeInfo getSolvingPeer \n void addReplyingPeer \n long getSize \n QueryCondition<?> getCondition \n void decrementSearchedElements \n int getSolvingLevel \n void addMatch \n int getNumberOfConditions \n Vector<SkyNetNodeInfo> getMatches \n HashMap<BigDecimal,QueryReplyingPeer> getReplyingPeers \n int getSearchedElements \n String toString", "output": "void function ( QueryCondition < ? > arg0 ) { conditions . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nanswer the feedback information for the product 's preference page ", "input": " IProduct product \n String INDENT \n IProduct getProduct \n void printPlatformInfo \n String getInstallationLocation \n void printInfo \n void printPrefPageInfo \n String getPrefPageInfo \n void printProductInfo \n void printSupportInfo \n String getAuthorNames \n IStatus getLastStatus \n int getCurrentYear", "output": "String function ( ) { return \"srini_string\" ; }"}, {"instruction": "Generate java code\nsets the value of the callcontext property . ", "input": " CallContext callContext \n UpdateRequest update \n String fcOwner \n CallContext getCallContext \n void setUpdate \n UpdateRequest getUpdate \n String getFcOwner \n void setFcOwner", "output": "void function ( CallContext arg0 ) { this . callContext = arg0 ; }"}, {"instruction": "Generate java code\nbuilds a cachedatadescriptionimpl from the mapping model of a collection ", "input": " boolean versioned \n boolean mutable \n Comparator versionComparator \n boolean isMutable \n boolean isVersioned \n Comparator getVersionComparator", "output": "CacheDataDescriptionImpl function ( Collection arg0 ) { return new CacheDataDescriptionImpl ( arg0 . isMutable ( ) , arg0 . getOwner ( ) . isVersioned ( ) , arg0 . getOwner ( ) . isVersioned ( ) ? ( ( VersionType ) arg0 . getOwner ( ) . getVersion ( ) . getType ( ) ) . getComparator ( ) : null ) ; }"}, {"instruction": "Generate java code\nset this widget 's index relative to it 's parent . ", "input": " long serialVersionUID \n HashMap _map \n int UNASSIGNED \n int _index \n WidgetLocator _parentInfo \n Class _cls \n String _nameOrLabel \n IWidgetMatcher _matcher \n int getIndex \n void setData \n WidgetLocator getParentInfo \n String getNameOrLabel \n IWidgetLocator[] findAll \n boolean matches \n Map getDataMap \n void setParentInfo \n Class getTargetClass \n int hashCode \n boolean equals \n String toString \n String getTargetClassName \n String getData", "output": "void function ( int arg0 ) { _index = arg0 ; }"}, {"instruction": "Generate java code\nadds an equality string to the discardstring for each variable in in vis which is different from the leader ", "input": " Invariant inv \n String discardFormat \n String discardString \n DiscardCode discardCode \n String className \n String discardFormat \n String discardString \n void add_implied \n DiscardCode discardCode \n String format \n String className", "output": "void function ( VarInfo [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0 . length ; loc0 ++ ) { if ( inv . ppt . var_infos [ loc0 ] != arg0 [ loc0 ] ) discardString += \"srini_string\" + inv . ppt . var_infos [ loc0 ] + \"srini_string\" + arg0 [ loc0 ] ; } }"}, {"instruction": "Generate java code\nreturns the maximum sum of the sizes of the entries in this cache . ", "input": " int evictionCount \n int putCount \n int hitCount \n int size \n int maxSize \n LinkedHashMap<String,Bitmap> map \n int missCount \n int evictionCount \n void set \n void trimToSize \n void evictAll \n int hitCount \n int putCount \n int size \n Bitmap get \n void clear \n int missCount", "output": "int function ( ) { return maxSize ; }"}, {"instruction": "Generate java code\nenumerate potions ", "input": " List<Potion> topShelf \n List<Potion> bottomShelf \n Logger LOGGER \n List<Potion> getBottomShelf \n List<Potion> getTopShelf \n void fillShelves", "output": "void function ( ) { LOGGER . info ( \"srini_string\" ) ; for ( Potion loc0 : topShelf ) { loc0 . drink ( ) ; } LOGGER . info ( \"srini_string\" ) ; for ( Potion loc0 : bottomShelf ) { loc0 . drink ( ) ; } }"}, {"instruction": "Generate java code\nresidue inverse . ", "input": " GenPolynomial<C> val \n ResidueRing<C> ring \n int isunit \n int signum \n boolean isONE \n boolean isUnit \n Residue<C> subtract \n Residue<C> gcd \n Residue<C> sum \n int compareTo \n Residue<C>[] egcd \n boolean isConstant \n Residue<C> monic \n Residue<C> abs \n int hashCode \n Residue<C> negate \n boolean equals \n Residue<C> clone \n boolean isZERO \n String toString \n Residue<C> divide \n Residue<C> multiply \n Residue<C> remainder", "output": "Residue < C > function ( ) { GenPolynomial < C > loc0 = ring . ideal . inverse ( val ) ; return new Residue < C > ( ring , loc0 , 1 ) ; }"}, {"instruction": "Generate java code\nqueues the change of operations request of a channel , which will change the interested operations of the channel sometime in future . this is a non-blocking method and does not guarantee that the operations have changed when this method returns . ", "input": " int interestedOps \n Logger LOGGER \n Selector selector \n ExecutorService reactorMain \n Queue<Runnable> pendingCommands \n Dispatcher dispatcher \n SelectionKey key \n void dispatchReadEvent \n void stop \n void eventLoop \n NioReactor registerChannel \n void start \n void onChannelWritable \n void onChannelReadable \n void processKey \n void run \n void processPendingCommands \n String toString \n void onChannelAcceptable", "output": "void function ( SelectionKey arg0 , int arg1 ) { pendingCommands . add ( new ChangeKeyOpsCommand ( arg0 , arg1 ) ) ; selector . wakeup ( ) ; }"}, {"instruction": "Generate java code\ntests if the dictionary is empty . ", "input": " int size \n BinaryTreeNode root \n void insertHelper \n BinaryTreeNode findHelper \n int size \n void testFind \n void testRemove \n Entry find \n void makeEmpty \n Entry insert \n BinaryTreeNode findSmallest \n void main \n String toString \n Entry remove", "output": "boolean function ( ) { return size == 0 ; }"}, {"instruction": "Generate java code\nreturns the message format pattern to use for refactorings . arguments : 0 : formatted date 0 : description of refactoring ", "input": " boolean fCheckable \n IProject fProject \n boolean fTime \n boolean isTimeDisplayed \n String getCollectionLabel \n String getYesterdayPattern \n String getLastMonthPattern \n String getLastWeekPattern \n String getWeekPattern \n boolean isCheckableViewer \n RefactoringHistoryContentProvider getContentProvider \n String getYearPattern \n String getProjectPattern \n String getWorkspaceCaption \n String getDayPattern \n RefactoringHistoryLabelProvider getLabelProvider \n String getThisMonthPattern \n String getMonthPattern \n String getCommentCaption \n String getThisWeekPattern \n String getTodayPattern \n IProject getProject", "output": "String function ( ) { return RefactoringUIMessages . RefactoringHistoryControlConfiguration_refactoring_pattern ; }"}, {"instruction": "Generate java code\nreturns the delegate queries . ", "input": " CreateTargetExecutionLog fLog \n ICreateTargetQueries fDelegate \n ICreateTargetQuery createNewPackageQuery \n CreateTargetExecutionLog getCreateTargetExecutionLog", "output": "ICreateTargetQueries function ( ) { return fDelegate ; }"}, {"instruction": "Generate java code\nreturns a boundary based on the bounds in the input file if available , otherwise returns the same as #getdataboundary ", "input": " AxisAlignedBoundingBoxXZ fileBoundary \n AxisAlignedBoundingBoxXZ dataBoundary \n List<MapWaySegment> mapWaySegments \n List<MapArea> mapAreas \n List<MapNode> mapNodes \n VectorXZ getCenter \n AxisAlignedBoundingBoxXZ getDataBoundary \n Iterable<MapElement> getMapElements \n Collection<MapWaySegment> getMapWaySegments \n void calculateDataBoundary \n Iterable<WorldObject> getWorldObjects \n Iterable<T> getWorldObjects \n Collection<MapArea> getMapAreas \n Collection<MapNode> getMapNodes", "output": "AxisAlignedBoundingBoxXZ function ( ) { if ( fileBoundary != null ) { return fileBoundary ; } else { return dataBoundary ; } }"}, {"instruction": "Generate java code\nget the current roll of the device in degrees . ", "input": " float[] magData \n float[] accelData \n Sensor magnetometer \n float roll \n float yaw \n Sensor accelerometer \n Context context \n SensorManagerFactory instance \n SensorManager sensorManager \n float pitch \n float compassBearing \n float FILTER_ALPHA \n Object lock \n GPSTracker locationTracker \n Location getLocation \n void onSensorChanged \n void onPause \n Intent getBatteryMonitor \n float getBatteryLevelPercent \n void registerListeners \n int getSatelliteCount \n void onAccuracyChanged \n float[] lowPassFilter \n void onDestroy \n int getBatteryStatus \n double getLongitude \n void recalculateAccelerometer \n double getAltitude \n double getLatitude \n float getCompassBearing \n double getBearing \n void clearGPSCache \n void onResume \n void initSensor \n float getYaw \n boolean isBatteryCharging \n float getPitch \n void initLocationTracker \n int getBatteryLevel \n List<GpsSatellite> getSatellites \n double getSpeed \n SensorManagerFactory getInstance \n SensorManagerFactory getInstance \n void recalculateMagnetometer", "output": "float function ( ) { return roll ; }"}, {"instruction": "Generate java code\ngets the value of the applicationpredecessors property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the applicationpredecessors property . for example , to add a new item , do as follows : getapplicationpredecessors . add newitem ; objects of the following type s are allowed in the list applicationpredecessorrelation ", "input": " List<ApplicationPredecessorRelation> applicationPredecessors \n List<ApplicationID> removedApplications \n List<Application> applications \n List<Application> getApplications \n List<ApplicationID> getRemovedApplications", "output": "List < ApplicationPredecessorRelation > function ( ) { if ( applicationPredecessors == null ) { applicationPredecessors = new ArrayList < ApplicationPredecessorRelation > ( ) ; } return this . applicationPredecessors ; }"}, {"instruction": "Generate java code\nresidue division . ", "input": " C val \n ResidueRing<C> ring \n boolean debug \n int isunit \n Logger logger \n int signum \n boolean isONE \n Residue<C> inverse \n boolean isUnit \n Residue<C> subtract \n Residue<C> gcd \n Residue<C> sum \n int compareTo \n Residue<C>[] egcd \n Residue<C> abs \n int hashCode \n Residue<C> negate \n boolean equals \n Residue<C> clone \n boolean isZERO \n String toString \n Residue<C> multiply \n Residue<C> remainder", "output": "Residue < C > function ( Residue < C > arg0 ) { return multiply ( arg0 . inverse ( ) ) ; }"}, {"instruction": "Generate java code\ngets the validator error message . ", "input": " String inputInfo \n String outputMessage \n List<String> validatorErrorMessage \n String getInputInfo \n void setValidatorErrorMessage \n String getOutputMessage \n void setInputInfo \n void setOutputMessage", "output": "List < String > function ( ) { return validatorErrorMessage ; }"}, {"instruction": "Generate java code\nthis method ensures both passed domains contain the same value . ", "input": " PlaceHolder placeHolder \n String getDomain \n List<EJBEndpoint> getEjbEndpoints \n String getTransportGuarantee \n String getSecurityDomain \n String getAuthMethod \n SecurityRolesMetaData getSecurityRoles \n boolean isSecureWsdlAccess \n EJBSecurityMetaData getEjbSecurityMetaData \n String getRealmName", "output": "void function ( final String arg0 , final String arg1 ) { final boolean loc0 = ! arg0 . equals ( arg1 ) ; if ( loc0 ) throw WSLogger . ROOT_LOGGER . multipleSecurityDomainsDetected ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nwrites one byte per char ", "input": " int pos \n byte buf[] \n void writeInt \n void writeByte \n byte[] getBuffer \n void writeFloat \n void writeChar \n void writeLong \n void writeBytes \n int size \n byte[] toByteArray \n void writeUTF \n void reset \n void writeStringZ \n void writeShort \n void writeChars \n void write \n void write \n void write \n void ensureSpace \n void writeBoolean \n void writeDouble", "output": "void function ( char arg0 [ ] ) { ensureSpace ( arg0 . length ) ; for ( int loc0 = 0 ; loc0 < arg0 . length ; loc0 ++ ) write ( arg0 [ loc0 ] ) ; }"}, {"instruction": "Generate java code\nchecks that the first and last vertex of the vertex list are equal . ", "input": " List<VectorXZ> vertexLoop \n List<VectorXZ> getVertexCollection \n VectorXZ getCenter \n boolean intersects \n boolean intersects \n boolean intersects \n double getOutlineLength \n SimplePolygonXZ asSimplePolygon \n PolygonXZ reverse \n VectorXZ getVertex \n List<VectorXZ> intersectionPositions \n boolean isEquivalentTo \n List<VectorXZ> getVertexLoop \n LineSegmentXZ getClosestSegment \n int size \n Collection<LineSegmentXZ> intersectionSegments \n TriangleXZ asTriangleXZ \n boolean isSelfIntersecting \n boolean isSelfIntersecting \n PolygonXYZ xyz \n List<VectorXZ> getVertices \n VectorXZ getVertexAfter \n boolean isSimple \n String toString \n VectorXZ getVertexBefore \n List<LineSegmentXZ> getSegments", "output": "void function ( List < VectorXZ > arg0 ) { if ( ! arg0 . get ( 0 ) . equals ( arg0 . get ( arg0 . size ( ) - 1 ) ) ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" + arg0 ) ; } }"}, {"instruction": "Generate java code\ntostring method . ", "input": " int blocksize \n GenMatrix<C> ZERO \n int DEFAULT_BSIZE \n GenMatrix<C> ONE \n Logger logger \n RingFactory<C> coFac \n float density \n int rows \n int cols \n Random random \n float DEFAULT_DENSITY \n GenMatrix<C> randomUpper \n GenMatrix<C> randomUpper \n GenMatrix<C> randomLower \n GenMatrix<C> randomLower \n GenMatrixRing<C> product \n GenMatrix<C> fromList \n boolean isField \n boolean isCommutative \n GenMatrix<C> parse \n GenMatrix<C> parse \n java.math.BigInteger characteristic \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n int hashCode \n boolean equals \n GenMatrix<C> getONE \n GenMatrix<C> getZERO \n GenMatrix<C> fromInteger \n GenMatrix<C> fromInteger \n boolean isAssociative \n GenMatrixRing<C> transpose \n GenMatrix<C> copy", "output": "String function ( ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0 . append ( coFac . getClass ( ) . getSimpleName ( ) ) ; loc0 . append ( \"srini_string\" + rows + \"srini_string\" + cols + \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ngets a hashcode compatible with the equals method . implemented per api documentation of java.util.map.entry #hashcode ", "input": " long serialVersionUID \n Map map \n Object key \n Object getKey \n Object getValue \n Object setValue \n boolean equals \n String toString", "output": "int function ( ) { Object loc0 = getValue ( ) ; return ( getKey ( ) == null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( loc0 == null ? 0 : loc0 . hashCode ( ) ) ; }"}, {"instruction": "Generate java code\ngets the value from the pair . ", "input": " Object value \n Object key \n Object getKey \n String toString", "output": "Object function ( ) { return value ; }"}, {"instruction": "Generate java code\ndoes the status code obtained from the given usertransaction indicate a commit ? ", "input": " PlaceHolder placeHolder \n boolean isRollback \n boolean isRollback \n boolean isRollback \n boolean isMarkedForRollback \n int getStatus \n int getStatus \n boolean isActive \n boolean isActive \n boolean isActive", "output": "boolean function ( UserTransaction arg0 ) { return isCommitted ( getStatus ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns the type of the current token . ", "input": " Reader reader \n Error err \n StreamTokenizer stok \n void set_error_handler \n void quoteChar \n boolean isQString \n void need \n String nextToken \n void tok_error \n void commentChar \n boolean isWord \n String token", "output": "int function ( ) { return stok . ttype ; }"}, {"instruction": "Generate java code\nreturns the names of the document position categories used by the document partitioners created by this object to manage their partition information . if the partitioners do n't use document position categories , the returned result is null . ", "input": " JavaCommentScanner fMultilineCommentScanner \n JavaCommentScanner fSinglelineCommentScanner \n JavaDocScanner fJavaDocScanner \n PreferenceListener fPreferenceListener \n JavaCodeScanner fCodeScanner \n IPreferenceStore fPreferenceStore \n SingleTokenJavaScanner fStringScanner \n String[] LEGAL_CONTENT_TYPES \n JavaColorManager fColorManager \n Preferences fCorePreferenceStore \n RuleBasedScanner getJavaDocScanner \n RuleBasedScanner getSinglelineCommentScanner \n IDocumentPartitioner createDocumentPartitioner \n RuleBasedScanner getStringScanner \n IPreferenceStore getPreferenceStore \n RuleBasedScanner getCodeScanner \n void setupJavaDocumentPartitioner \n void setupJavaDocumentPartitioner \n RuleBasedScanner getMultilineCommentScanner \n void adaptToPreferenceChange \n IPartitionTokenScanner getPartitionScanner \n void propertyChange \n void propertyChange \n void dispose \n boolean affectsBehavior \n IColorManager getColorManager \n Preferences getCorePreferenceStore", "output": "String [ ] function ( ) { return new String [ ] { org . eclipse . jface . text . rules . DefaultPartitioner . CONTENT_TYPES_CATEGORY } ; }"}, {"instruction": "Generate java code\nsame result as calling #normalize after #cross vectorxyz , but avoids creating a temporary vector ", "input": " VectorXYZ NULL_VECTOR \n double x \n double y \n VectorXYZ X_UNIT \n double z \n VectorXYZ Z_UNIT \n VectorXYZ Y_UNIT \n VectorXZ xz \n VectorXYZ mult \n AxisAlignedBoundingBoxXZ getAxisAlignedBoundingBoxXZ \n double dot \n double distanceToXZ \n double distanceToXZ \n int hashCode \n VectorXYZ normalize \n VectorXYZ xyz \n VectorXYZ rotateX \n VectorXYZ rotateY \n VectorXYZ rotateZ \n VectorXYZ add \n VectorXYZ add \n VectorXYZ add \n double angleTo \n double lengthSquared \n VectorXYZ invert \n double distanceToSquared \n List<VectorXYZ> addYList \n VectorXYZ subtract \n VectorXYZ subtract \n double length \n VectorXYZ cross \n double distanceTo \n double getX \n double getY \n double getZ \n VectorXYZ addY \n boolean equals \n VectorXYZ x \n VectorXYZ y \n String toString \n VectorXYZ z \n VectorXYZ rotateVec \n VectorXYZ rotateVec", "output": "VectorXYZ function ( VectorXYZ arg0 ) { double loc0 = this . y * arg0 . loc2 - this . z * arg0 . loc1 ; double loc1 = this . z * arg0 . loc0 - this . x * arg0 . loc2 ; double loc2 = this . x * arg0 . loc1 - this . y * arg0 . loc0 ; double loc3 = sqrt ( loc0 * loc0 + loc1 * loc1 + loc2 * loc2 ) ; return new VectorXYZ ( loc0 / loc3 , loc1 / loc3 , loc2 / loc3 ) ; }"}, {"instruction": "Generate java code\ncodiert die zu sendende eingabe in eine signalfolge . ", "input": " char zero \n char minus \n String regexp \n Charset charset \n int pointer \n Receiver receiver \n Sender sender \n int length \n BitAmount bits \n boolean[] buffer \n char plus \n char minus \n String getRegExp \n String receive \n char getLastPulseOfReceiver \n String charform \n String read \n void clear \n boolean isEmpty \n char plus \n int getDC \n char zero \n StringBuilder stringform \n boolean[] bitform \n char getLastPulseOfSender \n char bufferToDecimal \n boolean get \n int getLength \n String getCharsetRegExp \n BitBuffer copy \n void buffer \n boolean isFull", "output": "String function ( String arg0 ) { if ( arg0 == null ) { return this . sender . flush ( ) ; } else { boolean [ ] loc0 = loc0 ( arg0 ) ; return this . sender . send ( loc0 ) ; } }"}, {"instruction": "Generate java code\nget the drillconfig used for the zookeeper instance . ", "input": " org.slf4j.Logger logger \n File testDir \n String zkUrl \n MiniZooKeeperCluster zkCluster \n DrillConfig config \n void startZookeeper \n void stopZookeeper", "output": "DrillConfig function ( ) { return config ; }"}, {"instruction": "Generate java code\nreturns the time of the last event related to the gesture . ", "input": " String LOGTAG \n Stack<PointerInfo> sPointerInfoFreeList \n LinkedList<PointerInfo> mPointerInfo \n PointF mPrevious \n PointF mCurrent \n int mId \n SimpleScaleGestureListener mListener \n long mLastEventTime \n boolean mScaleResult \n PointF getPrevious \n void onTouchStart \n float getCurrentSpan \n void onScaleEnd \n void sendScaleGesture \n boolean onScale \n void onTouchEvent \n int getActionIndex \n PointerInfo pointerInfoForEventIndex \n float getFocusX \n void onTouchMove \n float getFocusY \n int getId \n float getPreviousSpan \n boolean onScaleBegin \n void populate \n int getPointersDown \n void recycle \n PointerInfo create \n String toString \n void onTouchEnd \n PointF getCurrent \n boolean isInProgress", "output": "long function ( ) { return mLastEventTime ; }"}, {"instruction": "Generate java code\nhandles a successful execution ", "input": " Logger log \n ShakedownTestService shakedownTestService \n void handleUnsuccessfulShakedownTest \n void handleUnsuccessfulShakedownTest", "output": "void function ( ShakedownTestEntity arg0 ) { ShakedownTestEntity loc0 = shakedownTestService . updateShakedownInfo ( arg0 . getId ( ) , arg0 . getTestResult ( ) , shakedownTest_state . success ) ; log . info ( \"srini_string\" + loc0 . getId ( ) + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncreates an instructor object using the given instructorcontactfile.the instructorcontactfile should be an xml file containing the marshaled form of a contact object . ", "input": " PlaceHolder placeHolder \n void main \n void writeSession \n Session readSession \n Student readStudent \n List<Student> readStudents", "output": "Instructor function ( File arg0 , JAXBContext arg1 ) { Unmarshaller loc0 = arg1 . createUnmarshaller ( ) ; Instructor loc1 = new Instructor ( ) ; loc1 . setContact ( ( Contact ) loc0 . unmarshal ( arg0 ) ) ; return loc1 ; }"}, {"instruction": "Generate java code\nname for this key ", "input": " Date created \n String name \n String key \n Date created \n Builder toBuilder \n Builder created \n Builder fromKey \n Date getCreated \n int compareTo \n Key build \n int hashCode \n String get \n boolean equals \n Builder builder \n Builder name \n String toString \n Builder key", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nreturns true iff the function takes opposite signs at the endpoints . ", "input": " double functionValueAccuracy \n boolean resultComputed \n double defaultFunctionValueAccuracy \n UnivariateRealFunction f \n double relativeAccuracy \n double absoluteAccuracy \n double result \n int iterationCount \n int defaultMaximalIterationCount \n int maximalIterationCount \n double defaultAbsoluteAccuracy \n double defaultRelativeAccuracy \n long serialVersionUID \n double getFunctionValueAccuracy \n void setAbsoluteAccuracy \n void verifySequence \n boolean isSequence \n void setResult \n void setRelativeAccuracy \n void resetFunctionValueAccuracy \n int getMaximalIterationCount \n void resetRelativeAccuracy \n double getAbsoluteAccuracy \n int getIterationCount \n void resetAbsoluteAccuracy \n void verifyInterval \n double getResult \n void setMaximalIterationCount \n void resetMaximalIterationCount \n void clearResult \n void verifyBracketing \n double getRelativeAccuracy \n void setFunctionValueAccuracy", "output": "boolean function ( double arg0 , double arg1 , UnivariateRealFunction arg2 ) { return ( arg2 . value ( arg0 ) * arg2 . value ( arg1 ) < 0 ) ; }"}, {"instruction": "Generate java code\nchecks if the actual area has a common x1 corner with the betweenarea ", "input": " short[] area \n CanVID vid \n Logger log \n boolean betweenY \n void setArea \n boolean betweenX \n boolean betweenXboth \n void addToVid \n void setVid \n void setVID \n boolean atX0Corner \n boolean atY0Corner \n short[] areaToShort \n CanVID getVid \n boolean atY1Corner \n boolean betweenYboth \n String toString \n boolean commonCorner \n boolean commonCorner \n void setY0 \n int[] getArea \n void setX0 \n void setY1 \n void setX1", "output": "boolean function ( CanArea arg0 ) { if ( arg0 . getArea ( ) [ 0 ] == area [ 1 ] ) return true ; else return false ; }"}, {"instruction": "Generate java code\ncreate an observereqvalue from its basic parts used when reading from a serialized file . ", "input": " long serialVersionUID \n Method observer \n Object value \n String get_observer_str \n int hashCode \n String toCodeStringPreStatement \n boolean equals \n String toString \n String toCodeString \n boolean evalExceptionMeansFailure \n Object writeReplace \n boolean evaluate \n int getArity \n String toCommentString", "output": "ObserverEqValue function ( Method arg0 , Object arg1 ) { return new ObserverEqValue ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the label string . ", "input": " String m_label \n boolean m_isMajorTick \n double m_value \n double getValue \n boolean isMajorTick \n void setMajorTick \n void setValue \n void setLabel \n String toString", "output": "String function ( ) { return this . m_label ; }"}, {"instruction": "Generate java code\nis trace logging currently enabled ? ", "input": " String name \n Logger logger \n void debug \n void debug \n void log \n Logger getLogger \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isDebugEnabled \n void info \n void info", "output": "boolean function ( ) { return ( getLogger ( ) . isLoggable ( Level . FINEST ) ) ; }"}, {"instruction": "Generate java code\nappends a column separator to the output file . ", "input": " int initialBufferCapacity \n Logger log \n boolean started \n Writer out \n StringBuilder sb \n void stopped \n void stop \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void start \n void appendNewLine \n void started \n boolean isStarted \n void setOutputFile", "output": "void function ( ) { try { sb . append ( ' ' ) ; } catch ( NullPointerException loc0 ) { } }"}, {"instruction": "Generate java code\ncreates builder to build userwithroles . ", "input": " String password \n Set<String> roles \n String name \n Set<String> roles \n String getPassword \n String getName \n UserWithRoles build \n Builder withPassword \n Builder clearRoles \n Builder withRoles \n Builder withRoles \n Builder withName \n Set<String> getRoles", "output": "Builder function ( ) { return new Builder ( ) ; }"}, {"instruction": "Generate java code\nreturns a collection factory for an objectcontainer ", "input": " ObjectContainer _objectContainer \n Set<E> newBigSet \n boolean isClient", "output": "CollectionFactory function ( ObjectContainer arg0 ) { if ( isClient ( arg0 ) ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; } return new CollectionFactory ( arg0 ) ; }"}, {"instruction": "Generate java code\npuffert das erhaltene signal . ", "input": " ZeroBuffer zeroBuffer \n int pointer \n char last \n State state \n AMI.Medium medium \n StringBuilder buffer \n int dc \n State next \n CharSequence read \n String flush \n char getLastPulse \n void clear \n String send \n int getDC", "output": "void function ( char arg0 ) { pointer ++ ; buffer . insert ( pointer , arg0 ) ; }"}, {"instruction": "Generate java code\nset autocommit 1 ; ", "input": " android.database.mysql.natives.Connector __connector \n String DEFAULT_PORT \n String encoding \n HashMap<String,String> config \n void rollback \n void disconnect \n void startTransaction \n String getLastError \n ArrayList<String> fetchCol \n void query \n void commit \n void disableAutocommit \n String fetchOne \n boolean hasMoreRows \n ArrayList<ArrayList<String>> fetchAllArray \n ArrayList<String> fetchRowArray \n int lastInsertId \n ArrayList<HashMap<String,String>> fetchAllHash \n ArrayList<String> fields \n HashMap<String,String> fetchRowHash \n String escape \n void connect \n void forceFreeResult", "output": "void function ( ) { query ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nappend a hashcode for a boolean array . ", "input": " int iConstant \n int iTotal \n HashCodeBuilder appendSuper \n int toHashCode", "output": "HashCodeBuilder function ( boolean [ ] arg0 ) { if ( arg0 == null ) { iTotal = iTotal * iConstant ; } else { for ( boolean loc0 : arg0 ) { append ( loc0 ) ; } } return this ; }"}, {"instruction": "Generate java code\ngets the closure called when true . ", "input": " Predicate iPredicate \n Closure iFalseClosure \n long serialVersionUID \n Closure iTrueClosure \n Predicate getPredicate \n Closure getInstance \n void execute \n Closure getFalseClosure", "output": "Closure function ( ) { return iTrueClosure ; }"}, {"instruction": "Generate java code\noverride to inject . ", "input": " ISemanticEvent[] _selection \n IEventSequenceCommandFactory _commandFactory \n ISemanticEvent[] EMPTY_SELECTION \n List _listeners \n IEventSequence _sequence \n ActionProvider _actionProvider \n List getListeners \n void select \n void sessionStarted \n IAction[] getActions \n void clickDelete \n IEventSequence remove \n ICommandStack getCommandStack \n ISemanticEvent[] getEvents \n boolean canUndo \n SequenceCommandLabelProvider createSequenceLabelProvider \n IEventSequence removeAll \n IEventSequence removeAll \n void undo \n void addListener \n IEventGroup group \n IEventSequence add \n IEventSequence add \n void sessionEnded \n boolean isEmpty \n boolean hasSelection \n ActionProvider getActionProvider \n void removeListener \n IEventSequenceCommandFactory getCommandFactory \n ActionProvider createActionProvider \n ISemanticEvent[] getSelection \n void setSelection \n IEventSequence addAll \n IEventSequence getSequence \n void exec \n void changed", "output": "EventSequenceCommandFactory function ( ) { return new EventSequenceCommandFactory ( getSequence ( ) ) ; }"}, {"instruction": "Generate java code\nreturn the defined properties as an unmodifieable map . ", "input": " Map<String,JsonNode> props \n Set<String> reserved \n Null NULL_VALUE \n JsonNode getJsonProp \n void writeProps \n Map<String,String> getProps \n Map<String,JsonNode> jsonProps \n Map<String,Object> getObjectProps \n void addProp \n void addProp \n void addProp \n String getProp \n Object getObjectProp", "output": "Map < String , JsonNode > function ( ) { return Collections . unmodifiableMap ( props ) ; }"}, {"instruction": "Generate java code\nreturns the size of this document set . ", "input": " boolean configured \n Distribution reorderIntvlDist \n boolean useRanks \n double zipfExp \n long meanReorderIntvl \n RandomGenerator rand \n String name \n ZipfDistribution dist \n int startRank \n Logger log \n List<Integer> keyPopularity \n int size \n void setName \n String getName \n int getKeyForPublish \n void checkConfigure \n void setMeanReorderIntvl \n void setZipfExp \n void configure \n int getSize \n boolean containsResourcesOf \n Distribution getReorderDistribution \n void doReorder \n int getKeyForLookup \n void setBeginRank", "output": "void function ( int arg0 ) { this . size = arg0 ; }"}, {"instruction": "Generate java code\ncreate an absolute hover info instance . ", "input": " PlaceHolder placeHolder \n IHoverInfo getRelativeToCenter \n IHoverInfo getRelative", "output": "IHoverInfo function ( int arg0 , int arg1 ) { return new AbsolutePointHoverInfo ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nloading an example plugin ", "input": " ServletContext servletContext \n void init \n PluginService pluginService \n ConfigFacade configFacade \n void main", "output": "HawtPlugin function ( ) { return new HawtPlugin ( \"srini_string\" , \"srini_string\" , \"srini_string\" , new String [ ] { \"srini_string\" } ) ; }"}, {"instruction": "Generate java code\nreturns a random value exponentially distributed with mu = _ mu . ", "input": " double mu \n ExponentialDistributionImpl distr \n void writeBackToXML \n String toString", "output": "double function ( double arg0 ) { try { ExponentialDistributionImpl loc0 = new ExponentialDistributionImpl ( arg0 ) ; return loc0 . inverseCumulativeProbability ( Simulator . getRandom ( ) . nextDouble ( ) ) ; } catch ( MathException loc0 ) { loc0 . printStackTrace ( ) ; return 0 ; } }"}, {"instruction": "Generate java code\ngets the underlying pdfwriter . ", "input": " PdfCopyFieldsImp fc \n void setOutlines \n void setViewerPreferences \n void addJavaScript \n void addViewerPreference \n void addDocument \n void addDocument \n void addDocument \n boolean isFullCompression \n void setEncryption \n void setEncryption \n void setEncryption \n void setEncryption \n void setFullCompression \n void close \n void open", "output": "PdfWriter function ( ) { return fc ; }"}, {"instruction": "Generate java code\nnormalizes the quoting of identifiers . this form returns a string rather than an identifier to better work with the legacy code in org.hibernate.mapping ", "input": " Database database \n Identifier normalizeIdentifierQuoting \n Identifier normalizeIdentifierQuoting \n Database database \n Identifier determineLogicalName \n MetadataBuildingContext getBuildingContext \n String toDatabaseIdentifierText", "output": "String function ( String arg0 ) { final Identifier loc0 = normalizeIdentifierQuoting ( arg0 ) ; if ( loc0 == null ) { return null ; } return loc0 . render ( database ( ) . getDialect ( ) ) ; }"}, {"instruction": "Generate java code\nconvert bytes into format as : 02020080 ", "input": " char[] HEX_CHARS \n String HEX_CHARS_STR \n byte[] hex2bytesFriendly \n String bytesToHexFriendly \n byte[] hex2bytes", "output": "String function ( byte [ ] arg0 ) { int loc0 = arg0 . length * 2 ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < arg0 . length ; loc2 ++ ) { int loc3 = arg0 [ loc2 ] & 0xFF ; loc1 [ loc2 * 2 ] = HEX_CHARS [ loc3 >>> 4 ] ; loc1 [ loc2 * 2 + 1 ] = HEX_CHARS [ loc3 & 0x0F ] ; } return new String ( loc1 ) ; }"}, {"instruction": "Generate java code\nclear the rotation transformation , if any . ", "input": " boolean centerInside \n float rotationPivotY \n float rotationPivotX \n int resourceId \n int targetHeight \n boolean hasRotationPivot \n List<Transformation> transformations \n float rotationDegrees \n Uri uri \n int targetWidth \n boolean centerCrop \n Builder centerInside \n Builder rotate \n Builder rotate \n Builder clearCenterCrop \n String getName \n boolean needsTransformation \n Builder setUri \n boolean hasCustomTransformations \n boolean hasImage \n boolean needsMatrixTransform \n boolean hasSize \n boolean hasSize \n Builder transform \n Builder clearCenterInside \n Request build \n Builder clearResize \n Builder buildUpon \n Builder resize \n Builder setResourceId \n Builder centerCrop", "output": "Builder function ( ) { rotationDegrees = 0 ; rotationPivotX = 0 ; rotationPivotY = 0 ; hasRotationPivot = false ; return this ; }"}, {"instruction": "Generate java code\nsets the value of the predecessorapplication property . ", "input": " ApplicationID predecessorApplication \n ApplicationID newApplication \n ApplicationID getNewApplication \n ApplicationID getPredecessorApplication \n void setNewApplication", "output": "void function ( ApplicationID arg0 ) { this . predecessorApplication = arg0 ; }"}, {"instruction": "Generate java code\nnotes that a method was inlined ", "input": " String configName \n int nLiveMethods \n Map morphicity \n int nNoPreexist \n int nLiveClasses \n int nInlined \n void noteNoPreexist \n void printSummary \n void noteMorphicity \n void setConfigName \n void noteLiveMethods \n void noteLiveClasses", "output": "void function ( ) { this . nInlined ++ ; }"}, {"instruction": "Generate java code\ntransforms this fluentiterable into a new one containing objects of the type t. ", "input": " Iterable<E> iterable \n FluentIterable<E> filter \n Iterator<E> iterator \n Optional<E> last \n FluentIterable<E> last \n Spliterator<E> spliterator \n void forEach \n int getRemainingElementsCount \n FluentIterable<E> from \n List<E> toList \n FluentIterable<E> fromCopyOf \n Optional<E> first \n FluentIterable<E> first \n List<E> asList", "output": "FluentIterable < T > function ( Function < ? super E , T > arg0 ) { List < T > loc0 = new ArrayList < > ( ) ; Iterator < E > loc1 = loc1 ( ) ; while ( loc1 . hasNext ( ) ) { loc0 . add ( arg0 . apply ( loc1 . next ( ) ) ) ; } return from ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable version of the given non-null floatlist . ", "input": " FloatIterator EMPTY_FLOAT_ITERATOR \n FloatListIterator EMPTY_FLOAT_LIST_ITERATOR \n FloatList EMPTY_FLOAT_LIST \n FloatListIterator getEmptyFloatListIterator \n FloatList getEmptyFloatList \n FloatIterator singletonFloatIterator \n FloatList singletonFloatList \n FloatListIterator unmodifiableFloatListIterator \n FloatIterator getEmptyFloatIterator \n FloatListIterator singletonFloatListIterator \n FloatIterator unmodifiableFloatIterator", "output": "FloatList function ( FloatList arg0 ) { if ( null == arg0 ) { throw new NullPointerException ( ) ; } return UnmodifiableFloatList . wrap ( arg0 ) ; }"}, {"instruction": "Generate java code\nprogram entry point . ", "input": " String DB_URL \n Logger log \n void deleteSchema \n void addCustomers \n DataSource createDataSource \n void createSchema \n void performOperationsUsing \n List<Customer> generateSampleCustomers", "output": "void function ( final String [ ] arg0 ) { final CustomerDao loc0 = new InMemoryCustomerDao ( ) ; performOperationsUsing ( loc0 ) ; final DataSource loc1 = createDataSource ( ) ; createSchema ( loc1 ) ; final CustomerDao loc2 = new DbCustomerDao ( loc1 ) ; performOperationsUsing ( loc2 ) ; deleteSchema ( loc1 ) ; }"}, {"instruction": "Generate java code\nget a quotient element from a biginteger value . ", "input": " RingFactory<C> ring \n boolean debug \n Logger logger \n Quotient<C> random \n Quotient<C> random \n int hashCode \n boolean isField \n boolean equals \n Quotient<C> getONE \n boolean isCommutative \n Quotient<C> getZERO \n boolean isAssociative \n String toString \n Quotient<C> parse \n Quotient<C> parse \n Quotient<C> copy \n java.math.BigInteger characteristic", "output": "Quotient < C > function ( java . math . BigInteger arg0 ) { return new Quotient < C > ( this , ring . fromInteger ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nset the number of clicks associated with this event . ", "input": " long serialVersionUID \n int _button \n int _numClicks \n IWidgetIdentifier hierarchyInfo \n boolean _checked \n String _cls \n String cls \n String _toString \n int button \n IWidgetIdentifier _hierarchyInfo \n int _index \n boolean _requiresLocationInfo \n int x \n int _x \n int y \n int _y \n String toString \n void setY \n void setX \n int getIndex \n IWidgetIdentifier getHierarchyInfo \n int getClicks \n boolean isContext \n void accept \n String getItemClass \n int getButton \n void setRequiresLocationInfo \n int getX \n int getY \n boolean requiresLocationInfo \n int hashCode \n void setIndex \n boolean equals \n void setChecked \n String toString \n void setHierarchyInfo \n boolean getChecked", "output": "void function ( int arg0 ) { _numClicks = arg0 ; }"}, {"instruction": "Generate java code\nreturns the hash code of the underlying map . ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int calcTotalSize \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "int function ( ) { return _map . hashCode ( ) ; }"}, {"instruction": "Generate java code\ninvokes the underlying listiterator #set object method . ", "input": " ListIterator iterator \n void add \n Object next \n Object previous \n boolean hasPrevious \n boolean hasNext \n ListIterator getListIterator \n int nextIndex \n int previousIndex \n void remove \n void setListIterator", "output": "void function ( Object arg0 ) { getListIterator ( ) . set ( arg0 ) ; }"}, {"instruction": "Generate java code\nrandom vector . ", "input": " GenVector<C> ZERO \n Logger logger \n RingFactory<C> coFac \n float density \n int cols \n List<GenVector<C>> BASIS \n Random random \n float DEFAULT_DENSITY \n GenVector<C> fromList \n int hashCode \n boolean equals \n GenVector<C> getZERO \n GenVector<C> fromInteger \n GenVector<C> fromInteger \n String toString \n GenVector<C> copy \n GenVector<C> parse \n GenVector<C> parse", "output": "GenVector < C > function ( int arg0 ) { return random ( arg0 , density , random ) ; }"}, {"instruction": "Generate java code\nconfigure a job 's combiner implementation . ", "input": " String COMBINER \n String MAP_OUTPUT_SCHEMA \n String INPUT_SCHEMA \n String MAPPER \n String TEXT_PREFIX \n String CONF_DATA_MODEL \n String BINARY_PREFIX \n String OUTPUT_SCHEMA \n String INPUT_IS_REFLECT \n String MAP_OUTPUT_IS_REFLECT \n String REDUCER \n String OUTPUT_CODEC \n void configureAvroShuffle \n GenericData createDataModel \n Schema getOutputSchema \n void setInputSequenceFile \n void configureAvroInput \n void setDataModelClass \n void setInputSchema \n void setInputReflect \n void setOutputSchema \n void configureAvroOutput \n Class<? extends GenericData> getDataModelClass \n void setMapOutputSchema \n GenericData newDataModelInstance \n Schema getInputSchema \n void setMapperClass \n void setReducerClass \n Schema getMapOutputSchema \n void setReflect \n GenericData createInputDataModel \n void setMapOutputReflect \n void setOutputCodec \n GenericData createMapOutputDataModel \n void setOutputMeta \n void setOutputMeta \n void setOutputMeta", "output": "void function ( JobConf arg0 , Class < ? extends AvroReducer > arg1 ) { arg0 . set ( COMBINER , arg1 . getName ( ) ) ; arg0 . setCombinerClass ( HadoopCombiner . class ) ; }"}, {"instruction": "Generate java code\nafter evicting or deleting an entity , we do n't need to know the query that was used to load it anymore do n't call this after loading the entity , since we might still need to load its collections ", "input": " Map<String,LinkedHashMap<CollectionEntry,PersistentCollection>> batchLoadableCollections \n Logger LOG \n Map<String,LinkedHashSet<EntityKey>> batchLoadableEntityKeys \n PersistenceContext context \n Map<EntityKey,SubselectFetch> subselectsByEntityKey \n SubselectFetch getSubselect \n void removeBatchLoadableCollection \n Serializable[] getCollectionBatch \n void addBatchLoadableEntityKey \n void clear \n void addSubselect \n void removeBatchLoadableEntityKey \n Serializable[] getEntityBatch \n void addBatchLoadableCollection \n boolean isCached \n boolean isCached", "output": "void function ( EntityKey arg0 ) { subselectsByEntityKey . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\ncreate a widget state map from this display . ", "input": " Map _map \n IWidgetState get \n IWidgetState put \n IWidgetState put", "output": "WidgetStateMap function ( Display arg0 ) { WidgetStateMap loc0 = new WidgetStateMap ( ) ; WidgetCollector loc1 = new WidgetCollector ( arg0 ) ; Widget [ ] loc2 = loc1 . getWidgets ( ) ; for ( int loc3 = 0 ; loc3 < loc2 . length ; loc3 ++ ) { loc0 . put ( loc2 [ loc3 ] ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ncheck if an object is equal to this variable . a stricter comparison than comparing indices will break hashtable lookups since a variable could have a name assigned to it after its first use . ", "input": " String name \n int index \n Type type \n int hashCode \n String name \n int index \n String toString \n Type type", "output": "boolean function ( final Object arg0 ) { return ( arg0 != null ) && ( arg0 instanceof LocalVariable ) && ( ( ( LocalVariable ) arg0 ) . index == index ) ; }"}, {"instruction": "Generate java code\ndispatch a mousemove event that moves the mouse to this x , y coordinate . ", "input": " Point pointT \n abbot.swt.Robot _robot \n void robotKeyClick \n void doKeyDown \n void doKeyUp \n void keyUp \n void keyUp \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n int[] extractKeys \n void mouseUp \n void keyClick \n void keyClick \n void keyDown \n void keyDown \n Event createClickEvent \n void enterText", "output": "void function ( int arg0 , int arg1 ) { Event loc0 = new Event ( ) ; loc0 . type = SWT . MouseMove ; loc0 . arg0 = arg0 ; loc0 . arg1 = arg1 ; new SWTPushEventOperation ( loc0 ) . execute ( ) ; }"}, {"instruction": "Generate java code\nadd key-value pair to map , both key and value need not null or empty ", "input": " String DEFAULT_KEY_AND_VALUE_PAIR_SEPARATOR \n String DEFAULT_KEY_AND_VALUE_SEPARATOR \n K getKeyByValue \n boolean putMapNotNullKeyAndValue \n Map<String,String> parseKeyAndValueToMap \n Map<String,String> parseKeyAndValueToMap \n Map<String,String> parseKeyAndValueToMap \n String toJson \n boolean putMapNotNullKey \n boolean isEmpty \n boolean putMapNotEmptyKey", "output": "boolean function ( Map < String , String > arg0 , String arg1 , String arg2 ) { if ( arg0 == null || StringUtils . isEmpty ( arg1 ) || StringUtils . isEmpty ( arg2 ) ) { return false ; } arg0 . put ( arg1 , arg2 ) ; return true ; }"}, {"instruction": "Generate java code\nset the label default status . ", "input": " boolean isDefault \n String color \n String name \n int id \n String url \n void setName \n String getUrl \n boolean isDefault \n String getName \n void setColor \n void setId \n String getColor \n int getId \n void setUrl", "output": "void function ( boolean arg0 ) { this . isDefault = arg0 ; }"}, {"instruction": "Generate java code\nreturns number of days from today until next alarmclock ", "input": " int column_alert \n int column_id \n ContentObserver mContentObserver \n int column_vibrate \n boolean vibrate \n String message \n int daysOfWeek \n Uri ALARM_URI \n int column_message \n int minute \n int column_hour \n int hour \n int column_minutes \n int column_daysofweek \n ContentResolver mContentResolver \n int id \n String audio \n Calendar nearestAlarmDate \n Calendar getNearestAlarmDate \n Uri getRecordUri \n Record getAlarmById \n Intent startNightClock \n int hashCode \n Calendar calculateNextAlarm \n boolean equals \n Intent changeAlarmSettings \n Intent changeAlarmSettings \n void finalize \n Record getNearestEnabledAlarm \n Record getNearestEnabledAlarm", "output": "int function ( Calendar arg0 , int arg1 ) { if ( arg1 == 0 ) return - 1 ; int loc0 = ( arg0 . get ( Calendar . DAY_OF_WEEK ) + 5 ) % 7 ; int loc1 , loc2 ; for ( loc2 = 0 ; loc2 < 7 ; loc2 ++ ) { loc1 = ( loc0 + loc2 ) % 7 ; if ( ( arg1 & ( 1 << loc1 ) ) > 0 ) { break ; } } return loc2 ; }"}, {"instruction": "Generate java code\ninsert a new entry into the routeset . this method does not check whether this routeset is the right one to add the contact . this should be checked prior to the insertion by the routing table . ", "input": " LinkedHashSet<PastryContact> entries \n RequestRouteSetOperation reqOp \n RouteSet OWNER_SET \n boolean removeEntry \n int getSize \n boolean contains \n Iterator<PastryContact> iterator \n RouteSet getNewInstance \n String toString \n boolean isUpdating \n void startUpdateOperation", "output": "boolean function ( PastryContact arg0 ) { return entries . add ( arg0 ) ; }"}, {"instruction": "Generate java code\ntests if the dictionary is empty . ", "input": " int entryNum \n List[] hashArray \n int numCollisions \n int findBuckets \n int size \n Entry find \n void makeEmpty \n Entry insert \n void main \n int compFunction \n int findPrimes \n Entry remove", "output": "boolean function ( ) { if ( entryNum == 0 ) { return true ; } else { return false ; } }"}, {"instruction": "Generate java code\nset of roles to be assigned to the user . ", "input": " String password \n Set<String> roles \n String name \n Set<String> roles \n String getPassword \n String getName \n UserWithRoles build \n Builder builder \n Builder withPassword \n Builder clearRoles \n Builder withRoles \n Builder withRoles \n Builder withName", "output": "Set < String > function ( ) { return roles ; }"}, {"instruction": "Generate java code\ndecode the given string . ", "input": " byte INVALID \n byte EQUAL \n byte[] ascii \n byte WHITESPACE \n byte[] base64 \n byte[] encode \n byte[] encode \n String encode", "output": "String function ( String arg0 ) { return new String ( decode ( arg0 . getBytes ( ) ) ) ; }"}, {"instruction": "Generate java code\nsets the signature date . ", "input": " XpathConstructor xpathConstructor \n Certificate signCertificate \n PdfStamper stamper \n String mimeType \n String description \n PdfStamperImp writer \n XmlLocator xmlLocator \n Calendar signDate \n java.util.Calendar getSignDate \n XmlLocator getXmlLocator \n String getMimeType \n void setMimeType \n void setStamper \n void setDescription \n PdfStamper getStamper \n String getDescription \n void setCertificate \n Certificate getCertificate \n XpathConstructor getXpathConstructor \n PdfStamperImp getWriter \n void setXmlLocator \n void setXpathConstructor \n void close", "output": "void function ( java . util . Calendar arg0 ) { this . signDate = arg0 ; }"}, {"instruction": "Generate java code\ncreate an instance of propertyupdate ", "input": " QName _SyncToken_QNAME \n QName _Dst_QNAME \n QName _SyncLevel_QNAME \n QName _Status_QNAME \n QName _Depth_QNAME \n QName _Responsedescription_QNAME \n QName _Nresults_QNAME \n QName _Timeout_QNAME \n QName _Href_QNAME \n QName _Src_QNAME \n JAXBElement<String> createDst \n Propstat createPropstat \n Supportedlock createSupportedlock \n Propertybehavior createPropertybehavior \n Lockentry createLockentry \n Resourcetype createResourcetype \n Unauthenticated createUnauthenticated \n JAXBElement<String> createSyncToken \n JAXBElement<String> createStatus \n Link createLink \n SyncCollection createSyncCollection \n Limit createLimit \n Location createLocation \n JAXBElement<String> createSyncLevel \n SupportedReportSet createSupportedReportSet \n Lockinfo createLockinfo \n Getcontentlanguage createGetcontentlanguage \n Lockscope createLockscope \n Getcontenttype createGetcontenttype \n Owner createOwner \n Read createRead \n All createAll \n Lockdiscovery createLockdiscovery \n Exclusive createExclusive \n ReadAcl createReadAcl \n JAXBElement<String> createDepth \n WriteContent createWriteContent \n Getetag createGetetag \n Omit createOmit \n Collection createCollection \n Propname createPropname \n Error createError \n ReadCurrentUserPrivilegeSet createReadCurrentUserPrivilegeSet \n Authenticated createAuthenticated \n Bind createBind \n JAXBElement<BigInteger> createNresults \n JAXBElement<String> createHref \n Report createReport \n JAXBElement<String> createTimeout \n Keepalive createKeepalive \n Shared createShared \n Locktype createLocktype \n Remove createRemove \n Write createWrite \n JAXBElement<String> createResponsedescription \n Creationdate createCreationdate \n JAXBElement<String> createSrc \n Activelock createActivelock \n Getcontentlength createGetcontentlength \n Prop createProp \n Displayname createDisplayname \n Response createResponse \n UnBind createUnbind \n SearchRequest createSearch \n Set createSet \n Locktoken createLocktoken \n Source createSource \n Propfind createPropfind \n Self createSelf \n Getlastmodified createGetlastmodified \n SupportedReport createSupportedReport \n Unlock createUnlock \n Multistatus createMultistatus \n Allprop createAllprop \n WriteProperties createWriteProperties", "output": "Propertyupdate function ( ) { return new Propertyupdate ( ) ; }"}, {"instruction": "Generate java code\nreturns the number of bytes available for reading from the current position . ", "input": " int markPosition \n ParsableByteArray buffer \n int readPosition \n int writePosition \n int capacity \n int drainToOutput \n void read \n boolean readAllowingEndOfInput \n boolean ensureLoaded \n void returnToMark \n void reset \n ParsableByteArray getParsableByteArray \n void skip \n boolean readInternal \n void mark", "output": "int function ( ) { return writePosition - readPosition ; }"}, {"instruction": "Generate java code\nremoves a previously registered listener . ", "input": " SequentialDispatcher dispatcher \n int state \n PropertyChangeSupport propertyChangeSupport \n EventListenerList listenerList \n int targetState \n void removeStateListener \n void doRealized \n void doPrefetching \n void fireStateChanged \n void fireStateChanged \n int getTargetState \n void prefetch \n void deallocate \n void start \n void run \n boolean isActive \n void setTargetState \n void addChangeListener \n void doUnrealized \n void doRealizing \n void removeChangeListener \n void doClosed \n int getState \n void stop \n void doPrefetched \n void doStarted \n void addStateListener \n void addPropertyChangeListener \n void close \n void realize", "output": "void function ( PropertyChangeListener arg0 ) { propertyChangeSupport . addPropertyChangeListener ( arg0 ) ; }"}, {"instruction": "Generate java code\nfilters the desired asset s on their assetdomposition . if no dom position is provided , all assets required in the current page will be returned . ", "input": " HttpServletRequest request \n Logger LOG \n AssetDomPosition assetDomPosition \n Context context \n Set<Alert> alerts \n Set<Asset> getFilteredAssets \n Set<Asset> perform \n Set<AssetStorageUnit> collectAssetStorageUnits", "output": "AssetQuery function ( AssetDomPosition arg0 ) { this . assetDomPosition = arg0 ; return this ; }"}, {"instruction": "Generate java code\ncheck authorization for `` show databases '' command . a hiveaccesscontrolexception is thrownfor illegal access . ", "input": " HiveAuthorizer authorizerV2 \n org.slf4j.Logger logger \n boolean authzEnabled \n void authorizeReadTable \n void authorizeShowTables \n void authorize", "output": "void function ( ) { if ( ! authzEnabled ) { return ; } authorize ( HiveOperationType . SHOWDATABASES , Collections . < HivePrivilegeObject > emptyList ( ) , Collections . < HivePrivilegeObject > emptyList ( ) , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nparses the jerry object to an announcement object ", "input": " SimpleDateFormat DATE_FORMAT \n Date parseDate \n List<Announcement> getAnnouncements \n List<Announcement> parseAnnouncements", "output": "Announcement function ( Jerry arg0 ) { String loc0 = arg0 . $ ( Constants . ANNOUNCEMENT_DATE ) . text ( ) ; Date loc1 = parseDate ( loc0 ) ; String loc2 = arg0 . $ ( Constants . ANNOUNCEMENT_TITLE ) . text ( ) ; String loc3 = arg0 . $ ( Constants . ANNOUNCEMENT_BODY ) . html ( ) ; return new Announcement ( loc3 , loc2 , loc1 ) ; }"}, {"instruction": "Generate java code\nwhat is the most recent thing that happened to this particular auction ? ", "input": " EventStatus mNullEvent \n String mTitle \n String mIdentifier \n Integer mEntryId \n List<EventStatus> mAllEvents \n void setLastStatus \n String getAllStatuses \n void save \n int getStatusCount", "output": "String function ( ) { if ( mAllEvents . isEmpty ( ) ) { return ( mNullEvent . toString ( ) ) ; } else { return mAllEvents . get ( mAllEvents . size ( ) - 1 ) . toString ( ) ; } }"}, {"instruction": "Generate java code\ntransform a given cache into a cache that ignores return values for operations returning previous values , i.e. advancedcache #put object , object , adding an extra flag . ", "input": " PlaceHolder placeHolder \n AdvancedCache asyncWriteCache \n boolean isClustered \n AdvancedCache localCache \n AdvancedCache failSilentWriteCache \n AdvancedCache failSilentWriteCache \n boolean isSynchronousCache \n T withinTx \n T withinTx \n boolean isInvalidationCache \n AdvancedCache failSilentReadCache \n void broadcastEvictAll", "output": "AdvancedCache function ( AdvancedCache arg0 , Flag arg1 ) { return arg0 . withFlags ( Flag . SKIP_CACHE_LOAD , Flag . SKIP_REMOTE_LOOKUP , arg1 ) ; }"}, {"instruction": "Generate java code\nget list of full polynomials . ", "input": " Condition<C> condition \n boolean debug \n Logger logger \n List<ColorPolynomial<C>> list \n OrderedCPairlist<C> pairlist \n List<GenPolynomial<C>> getRedCoefficients \n List<GenPolynomial<C>> getConditionNonZero \n boolean checkInvariant \n int hashCode \n boolean equals \n ColoredSystem<C> clone \n boolean isDetermined \n List<GenPolynomial<C>> getGreenCoefficients \n String toString \n ColoredSystem<C> reDetermine \n List<GenPolynomial<C>> getConditionZero \n List<GenPolynomial<GenPolynomial<C>>> getEssentialPolynomialList", "output": "List < GenPolynomial < GenPolynomial < C >>> function ( ) { List < GenPolynomial < GenPolynomial < C >>> loc0 = new ArrayList < GenPolynomial < GenPolynomial < C >>> ( ) ; for ( ColorPolynomial < C > loc1 : list ) { loc0 . add ( loc1 . getPolynomial ( ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ncalled on the server during the rpc handshake ", "input": " PlaceHolder placeHolder \n void serverSendResponse \n void clientStartConnect \n void clientFinishConnect \n void clientSendRequest \n void serverReceiveRequest \n void clientReceiveResponse", "output": "void function ( RPCContext arg0 ) { }"}, {"instruction": "Generate java code\nset parser state to singlequotedattrvaluestate . ", "input": " State closeStarComment \n State selfClosing \n State tagAttributes \n State unquoted \n State unknown \n State inTag \n State cdata \n State previousState \n State doctype \n State tagEncountered \n State singleQuoted \n XMLParser parser \n State xml \n State specialChar \n State doubleQuoted \n State closingTag \n State comment \n State attrValue \n State starComment \n State currentState \n State closeComment \n State processingInstruction \n XMLParser closeStarComment \n XMLParser selfClosing \n XMLParser tagAttributes \n XMLParser unquotedAttr \n XMLParser attributeValue \n XMLParser doubleQuotedAttr \n XMLParser previousState \n XMLParser unknown \n XMLParser inTag \n XMLParser cdata \n XMLParser doctype \n XMLParser tagEncountered \n XMLParser specialChar \n XMLParser setState \n XMLParser closingTag \n XMLParser comment \n XMLParser starComment \n XMLParser processingInstructions \n XMLParser closeComment", "output": "XMLParser function ( ) { return setState ( singleQuoted ) ; }"}, {"instruction": "Generate java code\nchecks whether given object is of interest to this interest instance . ", "input": " Class<E> entityType \n Action<C,E> action \n Interest<C,E> having \n Builder<T> in \n int hashCode \n boolean equals \n Class<E> getEntityType \n Action<C,E> getAction \n String toString \n Interest<C,E> being", "output": "boolean function ( Action < ? , ? > arg0 , Object arg1 ) { return this . action == arg0 && arg1 != null && entityType . isAssignableFrom ( arg1 . getClass ( ) ) ; }"}, {"instruction": "Generate java code\nclone clones the current game board into a new object ", "input": " int EMPTY \n int blackChips \n int[][] grid \n int whiteChips \n int DIMENSION \n int WHITE \n int BLACK \n void setContent \n int getContent \n String toString \n int numberOfChips \n int numberOfChips \n int[][] currentBoard", "output": "Board function ( ) { Board loc0 = new Board ( ) ; for ( int loc1 = 0 ; loc1 < DIMENSION ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < DIMENSION ; loc2 ++ ) { loc0 . grid [ loc1 ] [ loc2 ] = this . getContent ( loc1 , loc2 ) ; } } loc0 . whiteChips = whiteChips ; loc0 . blackChips = blackChips ; return loc0 ; }"}, {"instruction": "Generate java code\na describer used for stateful event descrptions ", "input": " PlaceHolder placeHolder \n void notifyStart \n void notifyDispose \n void notifyDisplayNotFound \n void notifyPause \n void notifyAssertionHookAdded \n void notifyControllerStart \n void notifyWrite \n void notifyTrace \n void notifySpyModeToggle \n void notifyStop \n void notifyError \n void notifyRestart", "output": "void function ( IUISemanticEvent arg0 ) { System . out . println ( \"srini_string\" + arg0 ) ; }"}, {"instruction": "Generate java code\nsetter for property mu . ", "input": " int DIGEST_MODE \n BufferedReader filePointer \n int CONSTANT_MODE \n int mode \n double mu \n EmpiricalDistribution empiricalDistribution \n URL valuesFileURL \n double sigma \n RandomDataImpl randomData \n int REPLAY_MODE \n int EXPONENTIAL_MODE \n int GAUSSIAN_MODE \n int UNIFORM_MODE \n EmpiricalDistribution getEmpiricalDistribution \n double getNextUniform \n void closeReplayFile \n double getMu \n void setMode \n double getNext \n void fill \n double[] fill \n double getSigma \n void computeDistribution \n void computeDistribution \n void setValuesFileURL \n void setValuesFileURL \n double getNextReplay \n URL getValuesFileURL \n void setSigma \n void resetReplayFile \n double getNextGaussian \n int getMode \n double getNextDigest \n double getNextExponential", "output": "void function ( double arg0 ) { this . mu = arg0 ; }"}, {"instruction": "Generate java code\ncalled on the event dispatching thread not on the worker thread after the construct method has returned without throwing an error . the default implementation does nothing . subclasses may override this method to perform done actions on the event dispatch thread . ", "input": " Throwable error \n T value \n Throwable getError \n T getValue \n void setError \n void setValue \n void start \n void run \n void finished \n T construct \n void failed", "output": "void function ( T arg0 ) { }"}, {"instruction": "Generate java code\njust sticks all the strings together with ' / ' contract : user must ensure that each param is not empty . ", "input": " String DOT \n String SLASH_STRING \n char DOT_CHAR \n char SLASH_CHAR \n void safeJoin \n void assertNotEmpty \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n String dotAppend \n String dotAppend", "output": "String function ( String arg0 , String arg1 ) { return new StringBuffer ( arg0 ) . append ( SLASH_STRING ) . append ( arg1 ) . toString ( ) ; }"}, {"instruction": "Generate java code\nadds the conformance . ", "input": " String CONFORMANCE \n String PART \n void setPart", "output": "void function ( XMPMeta arg0 , String arg1 ) { arg0 . setProperty ( XMPConst . NS_PDFA_ID , PdfAProperties . CONFORMANCE , arg1 ) ; }"}, {"instruction": "Generate java code\nthe avg time to execute this query ", "input": " long executionMaxTime \n String[] ITEM_DESCRIPTIONS \n long cacheHitCount \n String query \n String TABULAR_TYPE_NAME \n long cachePutCount \n CompositeType COMPOSITE_TYPE \n long cacheMissCount \n String[] INDEX_NAMES \n long executionAvgTime \n long executionMinTime \n String COMPOSITE_TYPE_NAME \n OpenType[] ITEM_TYPES \n long executionCount \n String[] ITEM_NAMES \n String COMPOSITE_TYPE_DESCRIPTION \n long executionRowCount \n TabularType TABULAR_TYPE \n String TABULAR_TYPE_DESCRIPTION \n void add \n long getCachePutCount \n TabularData newTabularDataInstance \n long getExecutionCount \n long getCacheMissCount \n long getExecutionRowCount \n long getCacheHitCount \n long getExecutionMinTime \n QueryStats[] fromTabularData \n String toString \n CompositeData toCompositeData \n String getQuery \n long getExecutionMaxTime", "output": "long function ( ) { return executionAvgTime ; }"}, {"instruction": "Generate java code\ncloses the current subpath . ", "input": " List<Subpath> subpaths \n String START_PATH_ERR_MSG \n Point2D currentPoint \n Point2D getCurrentPoint \n void curveTo \n void curveTo \n boolean isEmpty \n Subpath getLastSubpath \n List<Subpath> getSubpaths \n void lineTo \n void addSubpath \n void addSubpaths \n List<Integer> replaceCloseWithLine \n void closeAllSubpaths \n void rectangle \n void curveFromTo \n void moveTo", "output": "void function ( ) { Subpath loc0 = getLastSubpath ( ) ; loc0 . setClosed ( true ) ; Point2D loc1 = loc0 . getStartPoint ( ) ; moveTo ( ( float ) loc1 . getX ( ) , ( float ) loc1 . getY ( ) ) ; }"}, {"instruction": "Generate java code\nrecursive slow solution . ", "input": " PlaceHolder placeHolder \n void main", "output": "int function ( int arg0 [ ] , int arg1 ) { if ( arg1 == 0 ) { return arg0 [ 0 ] ; } else if ( arg1 == 1 ) { return Math . max ( arg0 [ 0 ] , arg0 [ 1 ] ) ; } return Math . max ( this . maxSum ( arg0 , arg1 - 2 ) + arg0 [ arg1 ] , this . maxSum ( arg0 , arg1 - 1 ) ) ; }"}, {"instruction": "Generate java code\ncomparison with any other object . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n GenPolynomial<C> num \n int isunit \n GenPolynomial<C> den \n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n GenPolynomial<C> gcd \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n Local<C> monic \n Local<C> abs \n int hashCode \n Local<C> negate \n GenPolynomial<C> lcm \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof Local ) ) { return false ; } Local < C > loc0 = null ; try { loc0 = ( Local < C > ) arg0 ; } catch ( ClassCastException loc1 ) { } if ( loc0 == null ) { return false ; } return ( 0 == compareTo ( loc0 ) ) ; }"}, {"instruction": "Generate java code\ntest tag #haschild string , string . ", "input": " Tag childsChild \n String CHILD2 \n Tag child1NoChildren \n String CHILD1 \n Tag root \n String CHILDS_CHILD \n String ROOTSTR \n Tag child2WithChild \n void getChildRecursive \n void hasChildRecursive \n void hasChildren \n void getChild \n void setUp \n void hasParent", "output": "void function ( ) { Assert . assertTrue ( root . hasChild ( CHILD1 , \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\ngets the start date of this event ", "input": " Date _end \n Date _start \n String _title \n String _id \n String _description \n String getTitle \n int hashCode \n boolean equals \n String getId \n String toString \n String getDescription \n Date getEnd", "output": "Date function ( ) { return _start ; }"}, {"instruction": "Generate java code\nstops event . ", "input": " Random rand \n int currentlyRunningSyncEvent \n int MIN_ID \n int MAX_RUNNING_EVENTS \n int MAX_EVENT_TIME \n Map<Integer,Event> eventPool \n int MAX_ID \n void completedEventHandler \n void start \n int generateId \n int create \n int createEvent \n Map<Integer,Event> getEventPool \n int numOfCurrentlyRunningSyncEvent \n int createAsync \n void statusOfAllEvents \n void shutdown \n void status", "output": "void function ( int arg0 ) { if ( ! eventPool . containsKey ( arg0 ) ) { throw new EventDoesNotExistException ( arg0 + \"srini_string\" ) ; } if ( arg0 == currentlyRunningSyncEvent ) { currentlyRunningSyncEvent = - 1 ; } eventPool . get ( arg0 ) . stop ( ) ; eventPool . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the value of the quotausedbytes property . ", "input": " Owner owner \n PrincipalURL principalURL \n Creationdate creationdate \n Getlastmodified getlastmodified \n Getcontentlanguage getcontentlanguage \n Getetag getetag \n Getcontentlength getcontentlength \n SupportedReportSet supportedReportSet \n Acl acl \n PrincipalCollectionSet principalCollectionSet \n Resourcetype resourcetype \n List<Element> any \n QuotaUsedBytes quotaUsedBytes \n Lockdiscovery lockdiscovery \n QuotaAvailableBytes quotaAvailableBytes \n Getcontenttype getcontenttype \n Displayname displayname \n Supportedlock supportedlock \n Group group \n PrincipalCollectionSet getPrincipalCollectionSet \n Creationdate getCreationdate \n void setCreationdate \n void setQuotaAvailableBytes \n Getcontentlength getGetcontentlength \n Displayname getDisplayname \n void setGetcontenttype \n void setAcl \n Owner getOwner \n Getlastmodified getGetlastmodified \n Supportedlock getSupportedlock \n void setLockdiscovery \n void setOwner \n SupportedReportSet getSupportedReportSet \n void setSupportedReportSet \n void setSupportedlock \n void setPrincipalCollectionSet \n QuotaUsedBytes getQuotaUsedBytes \n Acl getAcl \n void setPrincipalURL \n PrincipalURL getPrincipalURL \n void setGetetag \n Resourcetype getResourcetype \n Getcontentlanguage getGetcontentlanguage \n void setResourcetype \n Getetag getGetetag \n void setGroup \n Getcontenttype getGetcontenttype \n Group getGroup \n void setGetcontentlanguage \n Lockdiscovery getLockdiscovery \n void setGetlastmodified \n QuotaAvailableBytes getQuotaAvailableBytes \n void setDisplayname \n void setGetcontentlength \n List<Element> getAny", "output": "void function ( QuotaUsedBytes arg0 ) { this . quotaUsedBytes = arg0 ; }"}, {"instruction": "Generate java code\ncalled by a server to deserialize a request , compute and serialize a response or error . ", "input": " Map<MD5,Protocol> protocols \n Logger LOG \n GenericDatumReader<Map<String,ByteBuffer>> META_READER \n List<RPCPlugin> rpcMetaPlugins \n Schema META \n ThreadLocal<Protocol> REMOTE \n SpecificDatumWriter<HandshakeResponse> handshakeWriter \n SpecificDatumReader<HandshakeRequest> handshakeReader \n MD5 localHash \n Protocol local \n GenericDatumWriter<Map<String,ByteBuffer>> META_WRITER \n Protocol handshake \n Object readRequest \n Protocol getLocal \n void writeResponse \n void addRPCPlugin \n Protocol getRemote \n void writeError", "output": "List < ByteBuffer > function ( List < ByteBuffer > arg0 ) { return respond ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nget a java class from its name . ", "input": " PlaceHolder placeHolder \n ClassLoader getDefaultClassLoader \n boolean isPresent \n Object getNewInstance", "output": "Class < ? > function ( String arg0 ) { try { return Class . forName ( arg0 ) ; } catch ( ClassNotFoundException loc0 ) { Thread loc1 = Thread . currentThread ( ) ; ClassLoader loc2 = loc1 . getContextClassLoader ( ) ; return Class . forName ( arg0 , false , loc2 ) ; } }"}, {"instruction": "Generate java code\nperform validation of the filter state . this is used to verify the state of the filter after its enablement and before its use . ", "input": " String MARKER \n Map<String,Object> parameters \n String filterName \n FilterDefinition definition \n Filter setParameterList \n Filter setParameterList \n String getName \n Map<String,?> getParameters \n Filter setParameter \n void afterDeserialize \n FilterDefinition getFilterDefinition \n Object getParameter", "output": "void function ( ) { for ( final String loc0 : definition . getParameterNames ( ) ) { if ( parameters . get ( loc0 ) == null ) { throw new HibernateException ( \"srini_string\" + getName ( ) + \"srini_string\" + loc0 + \"srini_string\" ) ; } } }"}, {"instruction": "Generate java code\nget the list of iterators unmodifiable ", "input": " Iterator lastUsedIterator \n boolean isLocked \n Iterator currentIterator \n List iteratorChain \n int currentIteratorIndex \n Object next \n void checkLocked \n int size \n void addIterator \n boolean isLocked \n void lockChain \n boolean hasNext \n void setIterator \n void updateCurrentIterator \n void remove", "output": "List function ( ) { return UnmodifiableList . decorate ( iteratorChain ) ; }"}, {"instruction": "Generate java code\nleert den puffer . ", "input": " ZeroBuffer zeroBuffer \n int pointer \n char last \n State state \n AMI.Medium medium \n StringBuilder buffer \n int dc \n State next \n CharSequence read \n String flush \n char getLastPulse \n void buffer \n String send \n int getDC", "output": "void function ( ) { pointer = - 1 ; }"}, {"instruction": "Generate java code\nreturns an image stored in the file at the specified path ", "input": " HashMap m_ClassImageMap \n void clearImages \n ImageIcon getIcon \n ImageIcon getIcon \n ImageIcon getIcon \n ImageIcon getIcon", "output": "Image function ( String arg0 ) { return getImage ( \"srini_string\" , arg0 ) ; }"}, {"instruction": "Generate java code\nrgb in the range 0,1 to ycc in the range y = 0,1 , cb =[ -0.5,0.5 , cr =[ -0.5,0.5 ", "input": " int bits \n String name \n int mask \n int getBits \n void RGBtoYUV \n void RGBtoYIQ \n void YUVtoRGB \n String toString \n String toString \n int compareTo \n void YCCtoRGB \n void YCCtoRGB \n int YCCtoRGB \n void YIQtoRGB", "output": "void function ( float [ ] arg0 , float [ ] arg1 ) { float loc0 = max ( 0f , min ( 1f , arg0 [ 0 ] ) ) ; float loc1 = max ( 0f , min ( 1f , arg0 [ 1 ] ) ) ; float loc2 = max ( 0f , min ( 1f , arg0 [ 2 ] ) ) ; float loc3 = 0.3f * loc0 + 0.6f * loc1 + 0.1f * loc2 ; float loc4 = loc0 - loc3 ; float loc5 = loc2 - loc3 ; float loc6 = ( loc5 / 2f ) ; float loc7 = ( loc4 / 1.6f ) ; arg1 [ 0 ] = loc3 ; arg1 [ 1 ] = loc6 ; arg1 [ 2 ] = loc7 ; }"}, {"instruction": "Generate java code\nread a hashmap from a parcel , class of key and value can parcelable both ", "input": " PlaceHolder placeHolder \n void writeHashMap \n Map<String,String> readHashMapStringAndString \n void writeHashMapStringAndString \n Map<String,V> readHashMapStringKey \n boolean readBoolean \n void writeHashMapStringKey \n void writeBoolean", "output": "Map < K , V > function ( Parcel arg0 , ClassLoader arg1 ) { if ( arg0 == null ) { return null ; } int loc0 = arg0 . readInt ( ) ; if ( loc0 == - 1 ) { return null ; } Map < K , V > loc1 = new HashMap < K , V > ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 . put ( ( K ) arg0 . readParcelable ( arg1 ) , ( V ) arg0 . readParcelable ( arg1 ) ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nto test the behavior outside of the as i.e. org.jboss.as.naming.initialcontext is not used . ", "input": " URL webAppURL \n LdapServer ldapServer \n boolean removeBouncyCastle \n ManagementClient mgmtClient \n DirectoryService directoryService \n Logger LOGGER \n void testLdap \n void setup \n void testDir \n void tearDown \n WebArchive deployment", "output": "void function ( String [ ] arg0 ) { LDAPServerSetupTask loc0 = new LDAPServerSetupTask ( ) ; loc0 . setup ( null , null ) ; loc0 . tearDown ( null , null ) ; }"}, {"instruction": "Generate java code\nexecutes org.jclouds.crypto.pems #publickeyspecfromopenssh com.google.common.io.inputsupplier on thestring which was openssh base64 encoded id_rsa . pub ", "input": " Map<String,ECParameterSpec> CURVES \n String NISTP384 \n Map<Integer,String> CURVE_SIZES \n String ECDSA_SHA2_PREFIX \n ECParameterSpec nistp521 \n String NISTP521 \n ECParameterSpec nistp384 \n String NISTP256 \n ECParameterSpec nistp256 \n byte[] keyBlob \n String getCurveName \n String encodeAsOpenSSH \n byte[] readLengthFirst \n String fingerprintPublicKey \n byte[] encodeECPoint \n String hexColonDelimited \n String fingerprint \n ECPoint decodeECPoint \n int getCurveSize \n void writeLengthFirst \n byte[] removeLeadingZeroes", "output": "ECPublicKeySpec function ( String arg0 ) { try { return publicKeySpecFromOpenSSH ( ByteSource . wrap ( arg0 . getBytes ( Charsets . UTF_8 ) ) ) ; } catch ( IOException loc0 ) { throw propagate ( loc0 ) ; } }"}, {"instruction": "Generate java code\nreturns an unmodifiable floatlist containing only the specified element . ", "input": " FloatIterator EMPTY_FLOAT_ITERATOR \n FloatListIterator EMPTY_FLOAT_LIST_ITERATOR \n FloatList EMPTY_FLOAT_LIST \n FloatListIterator getEmptyFloatListIterator \n FloatList getEmptyFloatList \n FloatIterator singletonFloatIterator \n FloatListIterator unmodifiableFloatListIterator \n FloatIterator getEmptyFloatIterator \n FloatListIterator singletonFloatListIterator \n FloatList unmodifiableFloatList \n FloatIterator unmodifiableFloatIterator", "output": "FloatList function ( float arg0 ) { FloatList loc0 = new ArrayFloatList ( 1 ) ; loc0 . add ( arg0 ) ; return UnmodifiableFloatList . wrap ( loc0 ) ; }"}, {"instruction": "Generate java code\nchecks the last token against the given tags ? ", "input": " LinkedList<Integer> fSentenceBreaks \n String fDelimiter \n int WHITE_SPACE_TOKEN \n int fOffset \n int fNext \n int fPredecessor \n int fPrevious \n boolean fStartsSentence \n String fLastToken \n String fContent \n boolean fIsIgnoringSingleLetters \n int fSuccessor \n BreakIterator fWordIterator \n String next \n int getBegin \n boolean isSingleLetter \n boolean hasNext \n boolean isWhitespace \n int nextSentence \n void skipTokens \n int getEnd \n void remove \n boolean isUrlToken \n void setIgnoreSingleLetters \n String nextToken \n boolean isAlphaNumeric \n void nextBreak \n boolean startsSentence", "output": "boolean function ( final String [ ] arg0 ) { return isToken ( fLastToken , arg0 ) ; }"}, {"instruction": "Generate java code\nconvert a timestamp to the number of milliseconds elapsed from the epoch . the result will be rounded down to the nearest millisecond . e.g. , if the timestamp represents `` 1969-12-31t23:59:59 .999999999 z '' , it will be rounded to -1 millisecond . ", "input": " BigInteger NANOS_PER_SECOND_BIG_INTEGER \n long DURATION_SECONDS_MAX \n long DURATION_SECONDS_MIN \n long TIMESTAMP_SECONDS_MAX \n long NANOS_PER_SECOND \n long TIMESTAMP_SECONDS_MIN \n Timestamp add \n Duration add \n Duration distance \n Duration createDurationFromMicros \n Timestamp subtract \n Duration subtract \n Timestamp createTimestampFromMillis \n BigInteger toBigInteger \n BigInteger toBigInteger \n Duration createDurationFromNanos \n Timestamp createTimestampFromMicros \n Duration createDurationFromMillis \n Duration createDurationFromBigInteger \n Duration parseDuration \n long toNanos \n long toNanos \n Timestamp getEpoch \n Timestamp parseTimestamp \n String toString \n String toString \n Duration divide \n Duration divide \n long divide \n Timestamp createTimestampFromNanos \n Timestamp getCurrentTime \n Duration multiply \n Duration multiply \n long toMicros \n long toMicros \n Duration remainder \n Duration normalizedDuration", "output": "long function ( Timestamp arg0 ) { return Timestamps . toMillis ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the output message . ", "input": " String inputInfo \n String outputMessage \n List<String> validatorErrorMessage \n List<String> getValidatorErrorMessage \n String getInputInfo \n void setValidatorErrorMessage \n String getOutputMessage \n void setInputInfo", "output": "void function ( String arg0 ) { this . outputMessage = arg0 ; }"}, {"instruction": "Generate java code\nreplacement operation . requires : t ! = null & & 0 e.g. given a rattermvec v = t2 , t3 , t4 , the statement `` v.set t5 , 1 ; '' will make v_post = t2 , t5 , t4 . ", "input": " Vector underlying_terms \n RatTerm[] terms \n int size \n String printDebug \n boolean equals \n RatTerm get \n void insert \n String toString \n void addElement \n RatTermVec copy \n void remove", "output": "void function ( RatTerm arg0 , int arg1 ) { underlying_terms . setElementAt ( arg0 , arg1 ) ; terms = ( RatTerm [ ] ) underlying_terms . toArray ( new RatTerm [ ] { } ) ; }"}, {"instruction": "Generate java code\nreturn the singleton catalogfactory instancefor the relevant classloader . for applications that use a thread context class loader such as web applications running inside a servet container , this will return a separate instance for each application , even if this class is loaded from a shared parent class loader . ", "input": " Log log \n String DELIMITER \n Map factories \n void addCatalog \n Command getCommand \n void clear \n void setCatalog \n ClassLoader getClassLoader \n Iterator getNames \n Catalog getCatalog \n Catalog getCatalog", "output": "CatalogFactory function ( ) { CatalogFactory loc0 = null ; ClassLoader loc1 = getClassLoader ( ) ; synchronized ( factories ) { loc0 = ( CatalogFactory ) factories . get ( loc1 ) ; if ( loc0 == null ) { loc0 = new CatalogFactoryBase ( ) ; factories . put ( loc1 , loc0 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\ntests that the viewinterfaces #getpotentialviewinterfaces class returns the correctimplementation class for groovy class implementing messagelistener interface . ", "input": " PlaceHolder placeHolder \n void testJavaClass", "output": "void function ( ) { Set loc0 = ViewInterfaces . getPotentialViewInterfaces ( TestGroovyMessageListener . class ) ; Assert . assertEquals ( \"srini_string\" , 1 , loc0 . size ( ) ) ; Assert . assertEquals ( \"srini_string\" , MessageListener . class , loc0 . iterator ( ) . next ( ) ) ; }"}, {"instruction": "Generate java code\nadd a resolver at the beginning of the underlying resolver list . the resolver added by this method is at higher priority than any other existing resolvers . ", "input": " CoreMessageLogger LOG \n List<DialectResolver> resolvers \n void addResolver \n Dialect resolveDialect", "output": "void function ( DialectResolver arg0 ) { resolvers . add ( 0 , arg0 ) ; }"}, {"instruction": "Generate java code\nget the qualified prefixed by alias names of the columns of the owning entity which are to be used in the join ", "input": " PlaceHolder placeHolder \n String[] getRHSColumnNames \n String getLHSTableName \n String[] getLHSColumnNames \n String[] getLHSColumnNames \n String[] toColumns", "output": "String [ ] function ( AssociationType arg0 , String arg1 , int arg2 , OuterJoinLoadable arg3 , Mapping arg4 ) { return getAliasedLHSColumnNames ( arg0 , arg1 , arg2 , 0 , arg3 , arg4 ) ; }"}, {"instruction": "Generate java code\nwill construct underlying dom element if it is not already constructed . ", "input": " List<LazyEventListenerAttacher<?>> listenerAttachers \n String cssClassName \n ManagesEventListeners listenerManager \n Element element \n boolean isCreated \n void addClassName \n void addClickListener \n void hookListeners \n void addMouseOverListener \n Element createElement \n String getClassName \n void manageEventListener \n void setClassName", "output": "Element function ( ) { if ( element == null ) { element = createElement ( ) ; element . setClassName ( cssClassName ) ; hookListeners ( ) ; } return element ; }"}, {"instruction": "Generate java code\nset the i-th slot to the given outcome . ", "input": " Sequence owner \n List<ExecutionOutcome> theList \n int size \n ExecutionOutcome get", "output": "void function ( int arg0 , ExecutionOutcome arg1 ) { if ( arg0 < 0 || arg0 >= theList . size ( ) ) throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; if ( arg1 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; theList . set ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ncreates a new tag object from the given parameters . ", "input": " ThreadLocal<WorkerContextImpl> context \n boolean parseHtml \n Pipeline<?> rootpPipe \n void closeLocalWC \n void init \n void endElement \n void startElement \n WorkerContext getLocalWC \n boolean ignoreCdata \n void comment \n void text \n WorkerContextImpl initialValue \n void unknownText \n void close \n Tag getCurrentTag", "output": "Tag function ( String arg0 , final Map < String , String > arg1 , final String arg2 ) { if ( parseHtml ) { arg0 = arg0 . toLowerCase ( ) ; } Tag loc0 = new Tag ( arg0 , arg1 , arg2 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncreates a org.apache.drill.jdbc.nonclosableconnection connection and caches it.the returned org.apache.drill.jdbc.nonclosableconnection connection does not support java.sql.connection #close . consumer must call #close to close the cached connections . ", "input": " ConnectionFactory delegate \n Logger logger \n Map<ConnectionInfo,Connection> cache \n void closeConnections", "output": "Connection function ( ConnectionInfo arg0 ) { Connection loc0 = cache . get ( arg0 ) ; if ( loc0 == null ) { loc0 = delegate . getConnection ( arg0 ) ; cache . put ( arg0 , loc0 ) ; } return new NonClosableConnection ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns a line-by-line interator for this file . ", "input": " String lineSep \n Pattern entry_stop_re \n String first_line \n BufferedReader reader \n Pattern include_re \n Pattern comment_re \n String body \n String filename \n Stack<ReaderInfo> readers \n String pushback_line \n long line_number \n Pattern entry_start_re \n boolean short_entry \n String next \n String get_filename \n void set_entry_start_stop \n void set_entry_start_stop \n void putback \n Entry get_entry \n boolean hasNext \n void main \n String get_description \n String readLine \n void remove \n String get_next_line \n long get_line_number", "output": "Iterator < String > function ( ) { return this ; }"}, {"instruction": "Generate java code\nverify if the getters of a rainbowfish return the expected values ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "void function ( ) { final RainbowFish loc0 = new RainbowFish ( \"srini_string\" , 1 , 2 , 3 ) ; assertEquals ( \"srini_string\" , loc0 . getName ( ) ) ; assertEquals ( 1 , loc0 . getAge ( ) ) ; assertEquals ( 2 , loc0 . getLengthMeters ( ) ) ; assertEquals ( 3 , loc0 . getWeightTons ( ) ) ; }"}, {"instruction": "Generate java code\nreturns the current player 's number ", "input": " PlayerNum number \n boolean inCheck \n boolean playing \n boolean human \n void setInCheck \n boolean inCheck \n boolean playing \n boolean human \n void removePlayer", "output": "PlayerNum function ( ) { return number ; }"}, {"instruction": "Generate java code\nreturns java flag ", "input": " char character \n int flag \n List<RegexFlag> regexFlags \n Map<Character,RegexFlag> characterToRegexFlagMap \n boolean supported \n int compare \n void registerRegexFlag \n String regexFlagsToString \n char getCharacter \n boolean isSupported \n int stringToRegexFlags", "output": "int function ( ) { return flag ; }"}, {"instruction": "Generate java code\nget a product element from a long value . ", "input": " int nCopies \n RingFactory<C> ring \n List<RingFactory<C>> ringList \n Logger logger \n Random random \n void addFactory \n boolean containsFactory \n boolean isField \n int length \n boolean isCommutative \n Product<C> parse \n Product<C> parse \n RingFactory<C> getFactory \n java.math.BigInteger characteristic \n Product<C> random \n Product<C> random \n Product<C> random \n Product<C> random \n Product<C> getAtomic \n int hashCode \n boolean equals \n Product<C> getONE \n Product<C> getZERO \n boolean isAssociative \n String toString \n Product<C> copy", "output": "Product < C > function ( long arg0 ) { return fromInteger ( new java . math . BigInteger ( \"srini_string\" + arg0 ) ) ; }"}, {"instruction": "Generate java code\nreads the contents of a file to a string . ", "input": " PlaceHolder placeHolder \n String unEscapeURL \n URL toURL \n char[] copyOfRange \n boolean isSurrogatePair \n boolean isSurrogatePair \n float inchesToPoints \n void skip \n float pointsToMillimeters \n Set<K> getKeySet \n boolean isSurrogateHigh \n float millimetersToInches \n String convertFromUtf32 \n int convertToUtf32 \n int convertToUtf32 \n int convertToUtf32 \n float millimetersToPoints \n float inchesToMillimeters \n float pointsToInches \n String convertToHex \n boolean checkTrueOrFalse \n boolean isSurrogateLow \n Object[][] addToArray", "output": "String function ( final File arg0 ) { byte [ ] loc0 = new byte [ ( int ) arg0 . length ( ) ] ; FileInputStream loc1 = new FileInputStream ( arg0 ) ; loc1 . read ( loc0 ) ; return new String ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturn the default value for a given configkey ", "input": " boolean secretValue \n String envName \n String defaultValue \n String value \n String getPropertyValue \n String getProperty \n String getProperty \n Integer getPropertyAsInt \n Integer getPropertyAsInt \n Boolean getPropertyAsBoolean \n Boolean getPropertyAsBoolean", "output": "String function ( ConfigKey arg0 ) { return arg0 . getDefaultValue ( ) ; }"}, {"instruction": "Generate java code\ntest method for com.itextpdf.text.html.webcolors #getrgbcolor java.lang.string . ", "input": " String RGB_PERCENT \n String RGB_OUT_OF_RANGE \n String RGB_MISSING_COLOR_VALUES \n String dumpColor \n void testGetRGBColorInPercentBlue \n void testGetRGBColorValueOutOfRange \n void testGetRGBColorChannelsMissingBlue \n void moreColorTest \n void testGetRGBColorInPercentRed \n void testGetRGBColorInPercentAlpha \n void goodColorTests \n void testGetRGBColorChannelsMissingRed \n void testGetRGBColorChannelsMissingGreen \n void badColorTests \n void testGetRGBColorNegativeValue", "output": "void function ( ) { assertEquals ( 84 , WebColors . getRGBColor ( RGB_PERCENT ) . getGreen ( ) ) ; }"}, {"instruction": "Generate java code\ngiven an operator type , this method returns an array of metric names indexable by metric id . ", "input": " String[][] OPERATOR_METRICS \n void register", "output": "String [ ] function ( final int arg0 ) { return OPERATOR_METRICS [ arg0 ] ; }"}, {"instruction": "Generate java code\ninvokes the underlying map #keyset method . ", "input": " Map map \n Set entrySet \n boolean containsKey \n Collection values \n void clear \n boolean isEmpty \n boolean containsValue \n Object put \n Object remove \n int size \n int hashCode \n boolean equals \n Object get \n void putAll", "output": "Set function ( ) { return map . keySet ( ) ; }"}, {"instruction": "Generate java code\nadd a node corresponding to an intersection at a geographic point if the location is already in the graph or null , this method does not change the graph . ", "input": " PlaceHolder placeHolder \n int getNumEdges \n Set<GeographicPoint> getVertices \n List<GeographicPoint> dijkstra \n List<GeographicPoint> dijkstra \n List<GeographicPoint> aStarSearch \n List<GeographicPoint> aStarSearch \n void main \n int getNumVertices \n void addEdge \n List<GeographicPoint> bfs \n List<GeographicPoint> bfs", "output": "boolean function ( GeographicPoint arg0 ) { return false ; }"}, {"instruction": "Generate java code\nthis gets called whenever a session is invalidated because of user logout or timed out . ", "input": " DrillbitContext drillbitContext \n org.slf4j.Logger logger \n IdentityService identityService \n IdentityService getIdentityService \n DrillClient createDrillClient \n void setIdentityService \n boolean validate", "output": "void function ( UserIdentity arg0 ) { final DrillUserPrincipal loc0 = ( DrillUserPrincipal ) arg0 . getUserPrincipal ( ) ; try { loc0 . close ( ) ; } catch ( final Exception loc1 ) { logger . error ( \"srini_string\" , loc1 ) ; } }"}, {"instruction": "Generate java code\ngets the entry value . ", "input": " boolean modifiable \n Object value \n Object key \n Object getKey \n int hashCode \n Object setValue \n boolean equals", "output": "Object function ( ) { return value ; }"}, {"instruction": "Generate java code\nmark the deployment as a cdi one . ", "input": " AttachmentKey<Boolean> ATTACHMENT_KEY \n boolean cdiAnnotationsPresent", "output": "void function ( final DeploymentUnit arg0 ) { if ( arg0 . getParent ( ) != null ) { arg0 . getParent ( ) . putAttachment ( ATTACHMENT_KEY , true ) ; } else { arg0 . putAttachment ( ATTACHMENT_KEY , true ) ; } }"}, {"instruction": "Generate java code\nreturns content encoding of the entity , if set . ", "input": " File file \n boolean gzipCompress \n InputStream stream \n byte[] binary \n String contentEncoding \n boolean chunked \n String text \n List<NameValuePair> parameters \n Serializable serializable \n ContentType contentType \n EntityBuilder setBinary \n boolean isGzipCompress \n EntityBuilder setStream \n String getText \n void clearContent \n EntityBuilder setContentEncoding \n EntityBuilder chunked \n EntityBuilder setSerializable \n File getFile \n EntityBuilder setParameters \n EntityBuilder setParameters \n Serializable getSerializable \n EntityBuilder setFile \n boolean isChunked \n EntityBuilder gzipCompress \n HttpEntity build \n List<NameValuePair> getParameters \n EntityBuilder create \n ContentType getContentType \n ContentType getContentOrDefault \n byte[] getBinary \n InputStream getStream \n EntityBuilder setContentType \n EntityBuilder setText", "output": "String function ( ) { return contentEncoding ; }"}, {"instruction": "Generate java code\npreprocess the specified file . if no changes were necessary , the the file is not modified . ", "input": " boolean found \n Pattern pattern \n File currentFile \n String replacement \n List<LineProcessor> lineProcessors \n void startProcess \n String process0 \n void endProcess \n File getCurrentFile \n void reset \n void reset \n void reset \n void reset \n boolean processAll \n String processLine \n boolean processIfExists", "output": "boolean function ( File arg0 ) { currentFile = arg0 ; String loc0 = process0 ( arg0 ) ; currentFile = null ; if ( loc0 == null ) return false ; FileWriter loc1 = new FileWriter ( arg0 ) ; try { loc1 . write ( loc0 ) ; } finally { loc1 . close ( ) ; } return true ; }"}, {"instruction": "Generate java code\nreturns whether two variables are comparable . ", "input": " Logger debug \n int IMPLICIT \n int NONE \n VarComparability makeComparabilitySameIndices \n VarComparability makeAlias \n VarComparability makeAlias \n VarComparability indexType \n VarComparability string_length_type \n boolean equality_set_ok \n boolean alwaysComparable \n VarComparability parse \n VarComparability elementType", "output": "boolean function ( VarInfo arg0 , VarInfo arg1 ) { return comparable ( arg0 . comparability , arg1 . comparability ) ; }"}, {"instruction": "Generate java code\nreturns the sum of the sizes of the entries in this cache . ", "input": " int evictionCount \n int putCount \n int hitCount \n int size \n int maxSize \n LinkedHashMap<String,Bitmap> map \n int missCount \n int evictionCount \n void set \n void trimToSize \n void evictAll \n int hitCount \n int putCount \n Bitmap get \n void clear \n int maxSize \n int missCount", "output": "int function ( ) { return size ; }"}, {"instruction": "Generate java code\nreturns the junit test suite for this package . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "Test function ( ) { TestSuite loc0 = new TestSuite ( \"srini_string\" ) ; loc0 . addTest ( TestTreeSetGreedy . loc0 ( ) ) ; loc0 . addTest ( TestRingBufferArrayFast . loc0 ( ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncreate a new taskmanger with only those tasks in milestone ", "input": " String lineSep \n Date assigned_date \n String notes \n String milestone \n OutputFormat format \n String comment_re \n List<Task> tasks \n String include_re \n String description \n Float completed \n String usage_string \n Float duration \n boolean verbose \n String filename \n String task \n String milestone \n long line_number \n boolean completed \n String responsible \n String responsible \n boolean open \n String all_vals \n void add \n String toString_milestone_html \n String toString_milestone_html \n TaskManager completed_only \n String toString_short_ascii \n String toString_short_ascii \n String toString_short_html \n String toString_short_html \n TaskManager responsible_match \n TaskManager open_only \n void main \n String short_str", "output": "TaskManager function ( String arg0 ) { TaskManager loc0 = new TaskManager ( ) ; if ( arg0 == null ) return loc0 ; for ( Task loc1 : tasks ) { if ( arg0 . equalsIgnoreCase ( loc1 . arg0 ) ) loc0 . add ( loc1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ntest of equals method , of class student . ", "input": " PlaceHolder placeHolder \n void gendervalueTest \n void nameTest \n void namevalueTest \n void testsameiddifferentnameEquals \n void nameStudentTest \n void gradeTest \n void idvalueTest \n void testToString \n void genderTest \n void idTest \n void testsamenamedifferentidEquals \n void gradevalueTest \n void testdifferentiddifferentnameEquals", "output": "void function ( ) { System . out . println ( \"srini_string\" ) ; Student loc0 = new Student ( ) ; loc0 . setName ( \"srini_string\" ) ; loc0 . setId ( \"srini_string\" ) ; Student loc1 = new Student ( ) ; loc1 . setName ( \"srini_string\" ) ; loc1 . setId ( \"srini_string\" ) ; assertEquals ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nreturns the contents of the text widgets in the dialog in a string array . ", "input": " ResourceBundle resAddressBook \n Shell shell \n String[] values \n String[] labels \n String[] getLabels \n String getTitle \n void createTextWidgets \n void setValues \n void createControlButtons \n void setTitle \n void addTextListener \n void setLabels \n String[] open", "output": "String [ ] function ( ) { return values ; }"}, {"instruction": "Generate java code\ngets the maximum number of allowed persistent connections . ", "input": " int leased \n int max \n int pending \n int available \n String toString \n int getPending \n int getAvailable \n int getLeased", "output": "int function ( ) { return this . max ; }"}, {"instruction": "Generate java code\nreturns true if the element has already been created . ", "input": " List<LazyEventListenerAttacher<?>> listenerAttachers \n String cssClassName \n ManagesEventListeners listenerManager \n Element element \n void addClassName \n void addClickListener \n Element getElement \n void hookListeners \n void addMouseOverListener \n Element createElement \n String getClassName \n void manageEventListener \n void setClassName", "output": "boolean function ( ) { return element != null ; }"}, {"instruction": "Generate java code\ntest method for com.flatironschool.javacs.mylinearmap #containskey java.lang.object . ", "input": " Map<String,Integer> map \n void testContainsValue \n void testClear \n void testKeySet \n void testGet \n void testIsEmpty \n void testRemove \n void testSize \n void setUp \n void testPut \n void testPutAll \n void testValues", "output": "void function ( ) { assertThat ( map . containsKey ( \"srini_string\" ) , is ( true ) ) ; assertThat ( map . containsKey ( null ) , is ( true ) ) ; assertThat ( map . containsKey ( \"srini_string\" ) , is ( false ) ) ; }"}, {"instruction": "Generate java code\nget kdc flags znode . ", "input": " String ENCRYPTION_KEY_NO_ZNODE_NAME \n String KEY_VERSION_ZNODE_NAME \n String PRINCIPAL_NAME_ZNODE_NAME \n String baseZNode \n String CREATED_TIME_ZNODE_NAME \n String KDC_FLAGS_ZNODE_NAME \n String DISABLED_ZNODE_NAME \n String KEYS_ZNODE_NAME \n String IDENTITIES_ZNODE_NAME \n String KEY_ZNODE_NAME \n String EXPIRE_TIME_ZNODE_NAME \n String KEY_TYPE_ZNODE_NAME \n String LOCKED_ZNODE_NAME \n String getEncryptionKeyTypeZNode \n String getBaseZNode \n String getDisabledZNode \n String getKeyTypeZNode \n String getEncryptionKeyNoZNode \n String getEncryptionKeyZNode \n String getLockedZNode \n String getCreatedTimeZNode \n String getExpireTimeZNode \n String getKeyVersionZNode \n String getKeysZNode \n String getIdentitiesZNode \n List<String> getIdentityNames \n String getPrincipalNameZnode \n String getIndentityZNode", "output": "String function ( String arg0 ) { return ZKUtil . joinZNode ( getIndentityZNode ( arg0 ) , KDC_FLAGS_ZNODE_NAME ) ; }"}, {"instruction": "Generate java code\nreturns the condition checking failed severity used by this operation . ", "input": " Change fChange \n int fConditionCheckingFailedSeverity \n CheckConditionsOperation fCheckConditionOperation \n Refactoring fRefactoring \n RefactoringStatus getConditionCheckingStatus \n Change getChange \n void run \n int getConditionCheckingStyle", "output": "int function ( ) { return fConditionCheckingFailedSeverity ; }"}, {"instruction": "Generate java code\nrandom matrix . ", "input": " int blocksize \n GenMatrix<C> ZERO \n int DEFAULT_BSIZE \n GenMatrix<C> ONE \n Logger logger \n RingFactory<C> coFac \n float density \n int rows \n int cols \n Random random \n float DEFAULT_DENSITY \n GenMatrix<C> randomUpper \n GenMatrix<C> randomUpper \n GenMatrix<C> randomLower \n GenMatrix<C> randomLower \n GenMatrixRing<C> product \n GenMatrix<C> fromList \n boolean isField \n boolean isCommutative \n GenMatrix<C> parse \n GenMatrix<C> parse \n java.math.BigInteger characteristic \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n int hashCode \n boolean equals \n GenMatrix<C> getONE \n GenMatrix<C> getZERO \n GenMatrix<C> fromInteger \n GenMatrix<C> fromInteger \n String toString \n boolean isAssociative \n GenMatrixRing<C> transpose \n GenMatrix<C> copy", "output": "GenMatrix < C > function ( int arg0 , Random arg1 ) { return arg1 ( arg0 , density , arg1 ) ; }"}, {"instruction": "Generate java code\nrandom number generator used by the orignal bh benchmark . ", "input": " int nbody \n boolean printMsgs \n int nsteps \n double TSTOP \n boolean printResults \n double DTIME \n void usage \n void main \n void parseCmdLine \n double xRand", "output": "double function ( double arg0 ) { double loc0 = 16807.0 * arg0 + 1 ; arg0 = loc0 - ( 2147483647.0 * Math . floor ( loc0 / 2147483647.0 ) ) ; return arg0 ; }"}, {"instruction": "Generate java code\nparses a jerry page and returns the events found in the json of this page ", "input": " String url \n List<Event> getEvents \n List<Event> getEvents \n List<Event> getEvents \n List<Event> getEvents \n String getURL \n EventSource[] getSources", "output": "List < Event > function ( String arg0 ) { List < Event > loc0 = new ArrayList < Event > ( ) ; JSONEvent [ ] loc1 = new Gson ( ) . fromJson ( arg0 , JSONEvent [ ] . class ) ; for ( JSONEvent loc2 : loc1 ) { loc0 . add ( new Event ( loc2 . getId ( ) , loc2 . getTitle ( ) , loc2 . getDescription ( ) , loc2 . getStart ( ) , loc2 . getEnd ( ) ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ngets the topmost y-position of the bounding box . ", "input": " JLabel label \n double xGrow \n double yGrow \n double x \n double y \n Color color \n int getX \n int getHeight \n void grow \n void setColor \n String toString \n int getWidth \n void draw \n void translate \n void paintShape", "output": "int function ( ) { return ( int ) Math . round ( y - yGrow ) ; }"}, {"instruction": "Generate java code\ncreates builder to build path . ", "input": " String path \n Path EMPTY \n String relativeTo \n Builder withPath \n Path build \n String getPath \n String asString \n String getRelativeTo \n Builder withRelativeTo", "output": "Builder function ( ) { return new Builder ( ) ; }"}, {"instruction": "Generate java code\nfind the constructor for the class specified . ", "input": " Object[] iArgs \n Constructor iConstructor \n Class iClassToInstantiate \n long serialVersionUID \n Class[] iParamTypes \n Object create \n Factory getInstance", "output": "void function ( ) { try { iConstructor = iClassToInstantiate . getConstructor ( iParamTypes ) ; } catch ( NoSuchMethodException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nreturns the polygon 's vertices . first and last vertex are equal . ", "input": " List<VectorXZ> vertexLoop \n List<VectorXZ> getVertexCollection \n VectorXZ getCenter \n boolean intersects \n boolean intersects \n boolean intersects \n double getOutlineLength \n SimplePolygonXZ asSimplePolygon \n PolygonXZ reverse \n VectorXZ getVertex \n List<VectorXZ> intersectionPositions \n boolean isEquivalentTo \n LineSegmentXZ getClosestSegment \n int size \n Collection<LineSegmentXZ> intersectionSegments \n TriangleXZ asTriangleXZ \n boolean isSelfIntersecting \n boolean isSelfIntersecting \n PolygonXYZ xyz \n void assertLoopProperty \n List<VectorXZ> getVertices \n VectorXZ getVertexAfter \n boolean isSimple \n String toString \n VectorXZ getVertexBefore \n List<LineSegmentXZ> getSegments", "output": "List < VectorXZ > function ( ) { return vertexLoop ; }"}, {"instruction": "Generate java code\ncreates a new tabulardata ", "input": " long executionMaxTime \n String[] ITEM_DESCRIPTIONS \n long cacheHitCount \n String query \n String TABULAR_TYPE_NAME \n long cachePutCount \n CompositeType COMPOSITE_TYPE \n long cacheMissCount \n String[] INDEX_NAMES \n long executionAvgTime \n long executionMinTime \n String COMPOSITE_TYPE_NAME \n OpenType[] ITEM_TYPES \n long executionCount \n String[] ITEM_NAMES \n String COMPOSITE_TYPE_DESCRIPTION \n long executionRowCount \n TabularType TABULAR_TYPE \n String TABULAR_TYPE_DESCRIPTION \n void add \n long getCachePutCount \n long getExecutionCount \n long getExecutionAvgTime \n long getCacheMissCount \n long getExecutionRowCount \n long getCacheHitCount \n long getExecutionMinTime \n QueryStats[] fromTabularData \n String toString \n CompositeData toCompositeData \n String getQuery \n long getExecutionMaxTime", "output": "TabularData function ( ) { return new TabularDataSupport ( TABULAR_TYPE ) ; }"}, {"instruction": "Generate java code\nsets the comment for the select statement . ", "input": " LockOptions lockOptions \n int guesstimatedBufferSize \n StringBuilder whereClause \n Dialect dialect \n StringBuilder selectClause \n String outerJoinsAfterWhere \n String outerJoinsAfterFrom \n StringBuilder fromClause \n String comment \n StringBuilder orderByClause \n void appendFromClauseFragment \n void appendFromClauseFragment \n void setOuterJoins \n void setLockOptions \n void appendOrderByFragment \n String toStatementString \n boolean isNotEmpty \n boolean isNotEmpty \n String cleanRestrictions \n void appendSelectClauseFragment \n void setLockMode \n void appendRestrictions", "output": "void function ( String arg0 ) { this . comment = arg0 ; this . guesstimatedBufferSize += arg0 . length ( ) ; }"}, {"instruction": "Generate java code\nsets the parent link of the given entry to the given id ", "input": " boolean forward \n Logger LOGGER \n Comparator<BaseContentEntry<?>> getUpdatedComparator \n void setContent \n Comparator<BaseContentEntry<?>> getTitleComparator \n int compare \n int compare \n String getXhtmlContent \n Comparator<BaseContentEntry<?>> getReverseUpdatedComparator \n void setParent \n String getParentId", "output": "void function ( BaseContentEntry < ? > arg0 , String arg1 ) { arg0 . addLink ( SitesLink . Rel . PARENT , ILink . Type . ATOM , arg1 ) ; }"}, {"instruction": "Generate java code\nadds a new row to the table . ", "input": " Map<String,String> styles \n List<List<PdfPCell>> rows \n float[] colWidths \n PdfPTable createTable \n boolean process \n void setColWidths \n boolean isContent \n boolean isNestable \n List<Chunk> getChunks \n int type", "output": "void function ( List < PdfPCell > arg0 ) { if ( arg0 != null ) { Collections . reverse ( arg0 ) ; rows . add ( arg0 ) ; arg0 = null ; } }"}, {"instruction": "Generate java code\ngets the temporary properties file . ", "input": " File customPropertiesFile \n Properties properties \n File tempPropertiesFile \n void ImportProperties \n File getCustomPropertiesFile \n File WritePropertiesFile \n String get \n void put", "output": "File function ( ) { return tempPropertiesFile ; }"}, {"instruction": "Generate java code\nreturns the cached . ", "input": " FooComponent[] components \n List fees \n List bazez \n List subs \n FooProxy foo \n Collection bag \n Date[] timeArray \n FooProxy[] fooArray \n Collection byteBag \n Collection idFooBag \n List topComponents \n Map fooComponentToFoo \n Map glarchToFoo \n Set cached \n List customs \n String[] stringArray \n String text \n Map topGlarchez \n NestingComponent collectionComponent \n Map fooToGlarch \n Map cachedMap \n SortedSet sortablez \n Set cascadingBars \n Set fooSet \n List manyToAny \n Baz superBaz \n SortedSet stringSet \n int count \n Map anyToAny \n Map stringGlarchMap \n Set topFoos \n int[] intArray \n Map stringDateMap \n String code \n List moreParts \n List stringList \n String name \n List parts \n Collection fooBag \n Map getStringGlarchMap \n List getManyToAny \n void setTimeArray \n String getName \n void setFoo \n SortedSet getSortablez \n void setStringArray \n int compareTo \n void setFooSet \n FooProxy getFoo \n void setCustoms \n FooComponent[] getComponents \n NestingComponent getCollectionComponent \n String getCode \n int getCount \n void setParts \n void setCount \n Map getTopGlarchez \n void setComponents \n Date[] getTimeArray \n String getText \n void setCode \n void setCascadingBars \n void setCollectionComponent \n void setDefaults \n Collection getFooBag \n FooProxy[] getFooArray \n Map getFooToGlarch \n void setMoreParts \n Collection getIdFooBag \n Map getStringDateMap \n void setStringSet \n String[] getStringArray \n void setIntArray \n List getStringList \n Map getAnyToAny \n void setName \n void setFooComponentToFoo \n void setBag \n Map getGlarchToFoo \n Set getFooSet \n void setGlarchToFoo \n void setFooBag \n void setStringList \n void setCachedMap \n Map getCachedMap \n Collection getByteBag \n Set getCascadingBars \n void setTopGlarchez \n void setTopComponents \n Collection getBag \n List getFees \n void setSortablez \n List getParts \n void setManyToAny \n void setFooArray \n List getCustoms \n Map getFooComponentToFoo \n void setFees \n void setCached \n void setTopFoos \n void setFooToGlarch \n List getBazez \n List getTopComponents \n void setBazez \n void setStringDateMap \n void setByteBag \n void setAnyToAny \n Set getTopFoos \n List getMoreParts \n SortedSet getStringSet \n int[] getIntArray \n void setStringGlarchMap \n void setIdFooBag \n void setText", "output": "Set function ( ) { return cached ; }"}, {"instruction": "Generate java code\nis fatal logging currently enabled ? ", "input": " String name \n Logger logger \n void debug \n void debug \n void log \n Logger getLogger \n boolean isWarnEnabled \n void error \n void error \n void fatal \n void fatal \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isDebugEnabled \n void info \n void info", "output": "boolean function ( ) { return ( getLogger ( ) . isLoggable ( Level . SEVERE ) ) ; }"}, {"instruction": "Generate java code\ngets a comparator that compares using two comparator s . the second comparator is used if the first comparator returns equal . ", "input": " Comparator NATURAL_COMPARATOR \n Comparator transformedComparator \n Object min \n Comparator reversedComparator \n Object max \n Comparator naturalComparator \n Comparator booleanComparator \n Comparator nullHighComparator \n Comparator nullLowComparator", "output": "Comparator function ( Comparator arg0 , Comparator arg1 ) { return chainedComparator ( new Comparator [ ] { arg0 , arg1 } ) ; }"}, {"instruction": "Generate java code\nlog an error with debug log level . ", "input": " Date date \n int LOG_LEVEL_DEBUG \n int level \n Throwable throwable \n List logEntries \n int LOG_LEVEL_OFF \n Object message \n int LOG_LEVEL_WARN \n int LOG_LEVEL_TRACE \n int LOG_LEVEL_ERROR \n int LOG_LEVEL_INFO \n String logName \n String name \n int LOG_LEVEL_FATAL \n int LOG_LEVEL_ALL \n int currentLogLevel \n void log \n Object getMessage \n boolean isLevelEnabled \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void setLevel \n void fatal \n void fatal \n String getLogName \n int getLevel \n int getLevel \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n void reset \n boolean isTraceEnabled \n Date getDate \n boolean isDebugEnabled \n Throwable getThrowable \n List getLogEntries \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_DEBUG ) ) { log ( MemoryLog . LOG_LEVEL_DEBUG , arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\ncreate an instance of locktype ", "input": " QName _SyncToken_QNAME \n QName _Dst_QNAME \n QName _SyncLevel_QNAME \n QName _Status_QNAME \n QName _Depth_QNAME \n QName _Responsedescription_QNAME \n QName _Nresults_QNAME \n QName _Timeout_QNAME \n QName _Href_QNAME \n QName _Src_QNAME \n JAXBElement<String> createDst \n Propstat createPropstat \n Supportedlock createSupportedlock \n Propertybehavior createPropertybehavior \n Lockentry createLockentry \n Resourcetype createResourcetype \n Unauthenticated createUnauthenticated \n JAXBElement<String> createSyncToken \n JAXBElement<String> createStatus \n Link createLink \n SyncCollection createSyncCollection \n Limit createLimit \n Location createLocation \n JAXBElement<String> createSyncLevel \n SupportedReportSet createSupportedReportSet \n Lockinfo createLockinfo \n Getcontentlanguage createGetcontentlanguage \n Lockscope createLockscope \n Getcontenttype createGetcontenttype \n Owner createOwner \n Read createRead \n All createAll \n Lockdiscovery createLockdiscovery \n Exclusive createExclusive \n ReadAcl createReadAcl \n JAXBElement<String> createDepth \n WriteContent createWriteContent \n Getetag createGetetag \n Omit createOmit \n Collection createCollection \n Propname createPropname \n Error createError \n ReadCurrentUserPrivilegeSet createReadCurrentUserPrivilegeSet \n Authenticated createAuthenticated \n Bind createBind \n JAXBElement<BigInteger> createNresults \n JAXBElement<String> createHref \n Report createReport \n JAXBElement<String> createTimeout \n Keepalive createKeepalive \n Shared createShared \n Remove createRemove \n Write createWrite \n JAXBElement<String> createResponsedescription \n Creationdate createCreationdate \n JAXBElement<String> createSrc \n Activelock createActivelock \n Getcontentlength createGetcontentlength \n Prop createProp \n Displayname createDisplayname \n Response createResponse \n UnBind createUnbind \n SearchRequest createSearch \n Set createSet \n Propertyupdate createPropertyupdate \n Locktoken createLocktoken \n Source createSource \n Propfind createPropfind \n Self createSelf \n Getlastmodified createGetlastmodified \n SupportedReport createSupportedReport \n Unlock createUnlock \n Multistatus createMultistatus \n Allprop createAllprop \n WriteProperties createWriteProperties", "output": "Locktype function ( ) { return new Locktype ( ) ; }"}, {"instruction": "Generate java code\nreturns the interleave of frames in this movie track . this is 2 for double buffered animations , and 1 one for animations without double buffering . ", "input": " int xPosition \n boolean isPlayWrapupFrames \n int CMP_VERTICAL \n int yPosition \n int MODE_INDEXED_COLORS \n int MSK_HAS_MASK \n int MSK_HAS_TRANSPARENT_COLOR \n int pageHeight \n int pageWidth \n Vector frames_ \n int transparentColor \n Hashtable properties \n int height \n long totalDuration \n int MODE_HAM8 \n int masking \n int MODE_HAM6 \n int MSK_NONE \n int MSK_LASSO \n int MODE_EHB \n boolean isSwapSpeakers \n int nbPlanes \n int nbPalettes \n int MODE_DIRECT_COLORS \n int xAspect \n Vector audioClips_ \n PropertyChangeSupport listeners \n int screenMode \n int jiffies \n int CMP_BYTE_RUN_1 \n int yAspect \n int CMP_NONE \n int width \n ArrayList<ColorCycle> colorCycles \n int compression \n int getNbPlanes \n int getCompression \n void setYPosition \n List<ColorCycle> getColorCycles \n int getColorCyclesCount \n int getFrameCount \n AudioClip getAudioClip \n void setTransparentColor \n int getNbPalettes \n int getXAspect \n void setPageHeight \n int getTransparentColor \n int getJiffies \n int getMasking \n void firePropertyChange \n void removePropertyChangeListener \n void setHeight \n void setXAspect \n void setScreenMode \n void setCompression \n void setSwapSpeakers \n void setProperty \n void addFrame \n int getAudioClipCount \n void setXPosition \n int getYPosition \n boolean isPlayWrapupFrames \n ANIMFrame getFrame \n int getWidth \n boolean isSwapSpeakers \n void addColorCycle \n void setPageWidth \n int getPageHeight \n long getFrameDuration \n int getHeight \n void addAudioClip \n int getDeltaOperation \n void addPropertyChangeListener \n Object getProperty \n int getXPosition \n void setMasking \n int getPageWidth \n int getYAspect \n void setYAspect \n void setWidth \n void setNbPlanes \n void setPlayWrapupFrames \n long getTotalDuration \n int getScreenMode \n void setJiffies", "output": "int function ( ) { return frames_ . size ( ) > 0 && ( ( ANIMFrame ) frames_ . get ( frames_ . size ( ) - 1 ) ) . getInterleave ( ) == 1 ? 1 : 2 ; }"}, {"instruction": "Generate java code\nreturns the string of xml corresponding to this xmlelement . ", "input": " List<Pair<Object,ChildType>> children \n Map<String,String> attributes \n String elementType \n XmlElement addXml \n XmlElement setAttribute \n XmlElement addText \n boolean equals \n void appendTo \n XmlElement addElement", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; try { appendTo ( loc0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( loc1 ) ; } return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ncompute the base64 encoded size for a stream whose size is specified in the incoming parameter ", "input": " byte[] decodingTable \n byte[] encodingTable \n void encode \n byte[] encode \n byte[] discardNonBase64Bytes \n byte[] decode \n byte[] decode \n String decode \n String decode \n boolean isValidBase64Byte \n String discardNonBase64Chars", "output": "int function ( int arg0 ) { int loc0 ; int loc1 = arg0 % 3 ; if ( loc1 == 0 ) { loc0 = 4 * arg0 / 3 ; } else { loc0 = 4 * ( ( arg0 / 3 ) + 1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns an iterator that returns aggregated values based on the delta finds the max value within each delta . ", "input": " Entry<Double,Integer> next \n Integer HIGHLIGHT_CRITICAL \n Iterator<Entry<Double,Integer>> subMapIterator \n Integer HIGHLIGHT_VALIDATION \n Integer HIGHLIGHT_INFO \n Double xValue \n Integer HIGHLIGHT_NONE \n double delta \n Integer yValue \n TreeMap<Double,Integer> values \n Integer HIGHLIGHT_WARNING \n HighlightEntry next \n Double getKey \n Integer getValue \n int severityToHighlight \n int size \n Integer setValue \n void clear \n double getMaxX \n void addData \n HighlightModel create \n boolean hasNext \n void remove", "output": "Iterator < HighlightEntry > function ( final double arg0 , final double arg1 , final double arg2 ) { return new HighlightIterator ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\napply an `` ilike '' constraint ", "input": " PropertyNameGetter propertyNameGetter \n AuditCriterion hasNotChanged \n AuditCriterion lt \n AuditProjection distinct \n AuditCriterion leProperty \n AggregatedAuditExpression maximize \n AuditProjection min \n AuditCriterion hasChanged \n AuditCriterion gtProperty \n AuditProjection function \n AuditCriterion neProperty \n AuditCriterion ltProperty \n AuditCriterion ge \n AuditCriterion between \n Triple<String,String,Boolean> getData \n AuditCriterion isNotNull \n AggregatedAuditExpression minimize \n AuditCriterion like \n AuditCriterion like \n AuditCriterion in \n AuditCriterion in \n AuditProjection max \n AuditCriterion geProperty \n AuditProjection count \n AuditCriterion eq \n AuditCriterion gt \n AuditOrder asc \n AuditProjection countDistinct \n AuditCriterion ne \n AuditCriterion isNull \n AuditCriterion eqProperty \n AuditCriterion le \n AuditOrder desc", "output": "AuditCriterion function ( String arg0 , MatchMode arg1 ) { return new IlikeAuditExpression ( propertyNameGetter , arg1 . toMatchString ( arg0 ) ) ; }"}, {"instruction": "Generate java code\ntries to execute the script with the given script path . ", "input": " Logger log \n List<File> getScriptFiles \n void runSystemCall \n void getAndExecuteScriptFromGeneratedConfig \n String makeScriptExecutableAndGetAbsolutePath \n List<File> findScripts", "output": "void function ( String arg0 ) { if ( arg0 != null ) { runSystemCall ( arg0 ) ; log . info ( arg0 + \"srini_string\" ) ; } else { throw new ScriptExecutionException ( \"srini_string\" , REASON . NOTAVAILABLE ) ; } }"}, {"instruction": "Generate java code\nlogs the given exception using the platform 's logging mechanism . the exception is logged as an error with the error code javastatusconstants.internal _ error . ", "input": " ExceptionHandler fgInstance \n void displayMessageDialog \n void perform \n void perform \n void perform \n void handle \n void handle \n void handle \n void handle \n void handle", "output": "void function ( Throwable arg0 , String arg1 ) { JavaPlugin . log ( new Status ( IStatus . ERROR , JavaPlugin . getPluginId ( ) , IJavaStatusConstants . INTERNAL_ERROR , arg1 , arg0 ) ) ; }"}, {"instruction": "Generate java code\nformat a message to the given user with the given subject and message body , including a cc list . ", "input": " String[] HTTP \n String encodeForMail \n void open \n void open", "output": "void function ( String arg0 , String arg1 , String arg2 , String arg3 ) { mail ( arg0 , arg1 , arg2 , arg3 , null ) ; }"}, {"instruction": "Generate java code\nfinds the first node of the specified type in the chain of children . ", "input": " FilterPredicate predicate \n List collectedNodes \n AST getLastSibling \n AST findPreviousSibling \n String getPathText \n void getPathText \n String getTokenTypeName \n boolean isSubtreeChild \n String getDebugString \n List getCollectedNodes \n Integer extractIntegerValue \n AST create \n AST createParent \n String getConstantName \n boolean exclude \n boolean exclude \n AST createBinarySubtree \n boolean include \n Map generateTokenNameCache \n void appendSibling \n ASTArray createAstArray \n AST createTree \n void insertChild \n List collectChildren \n AST getLastChild \n void makeSiblingOfParent \n void visit \n boolean hasExactlyOneChild \n AST insertSibling \n List collect \n AST createSibling", "output": "AST function ( AST arg0 , int arg1 ) { AST loc0 = arg0 . getFirstChild ( ) ; while ( loc0 != null && loc0 . getType ( ) != arg1 ) { loc0 = loc0 . getNextSibling ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ntest a requestdispatcher forward with tx commit . ", "input": " String STATUS_ACTIVE \n Logger log \n void testIncludeNoCommit \n void testForwardNoCommit \n WebArchive statusDeployment \n void testIncludeCommit \n void testURL \n WebArchive controlDeployment", "output": "void function ( @ ArquillianResource ( TxControlServlet . class ) URL arg0 ) { testURL ( arg0 , false , true ) ; }"}, {"instruction": "Generate java code\nprecomputes and saves the next element of the iterable . null is considered as end of data . ", "input": " E next \n Iterator<E> fromIterator \n E next \n E computeNext", "output": "boolean function ( ) { next = computeNext ( ) ; return next != null ; }"}, {"instruction": "Generate java code\nget full polynomial . ", "input": " GenPolynomial<GenPolynomial<C>> red \n GenPolynomial<GenPolynomial<C>> green \n GenPolynomial<GenPolynomial<C>> white \n List<GenPolynomial<C>> getRedCoefficients \n boolean isONE \n ExpVector leadingExpVector \n Map.Entry<ExpVector,GenPolynomial<C>> leadingMonomial \n boolean checkInvariant \n ColorPolynomial<C> subtract \n ColorPolynomial<C> subtract \n int length \n boolean isDetermined \n ColorPolynomial<C> sum \n ColorPolynomial<C> sum \n ColorPolynomial<C> abs \n int hashCode \n boolean equals \n boolean isZERO \n List<GenPolynomial<C>> getGreenCoefficients \n String toString \n ColorPolynomial<C> divide \n GenPolynomial<GenPolynomial<C>> getEssentialPolynomial \n ColorPolynomial<C> multiply \n ColorPolynomial<C> multiply", "output": "GenPolynomial < GenPolynomial < C >> function ( ) { GenPolynomial < GenPolynomial < C >> loc0 = green . sum ( red ) . sum ( white ) ; int loc1 = green . length ( ) + red . length ( ) + white . length ( ) ; int loc2 = loc0 . length ( ) ; if ( loc2 != loc1 ) { throw new RuntimeException ( \"srini_string\" + loc1 + \"srini_string\" + loc2 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nhelper method that prints out a byte string as a series of integer or ascii characters . ", "input": " PlaceHolder placeHolder \n void print \n void print \n void printMap \n void printList \n void printInteger", "output": "void function ( byte [ ] arg0 , boolean arg1 , int arg2 ) { for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) System . out . print ( \"srini_string\" ) ; System . out . print ( \"srini_string\" ) ; for ( int loc0 = 0 ; loc0 < arg0 . length ; loc0 ++ ) { System . out . print ( arg1 ? ( char ) arg0 [ loc0 ] : ( int ) arg0 [ loc0 ] + \"srini_string\" ) ; } System . out . println ( ) ; }"}, {"instruction": "Generate java code\nget the content of the given element . ", "input": " PlaceHolder placeHolder \n Element getUniqueChild \n boolean getOptionalChildBooleanContent \n Iterator getChildrenByTagName \n Element getOptionalChild \n Element getOptionalChild \n String getUniqueChildContent \n String getOptionalChildContent", "output": "String function ( final Element arg0 ) { return getElementContent ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nreturn root schema with schema owner as the given user . ", "input": " UserSession session \n OptionManager queryOptions \n ContextInformation contextInformation \n PlannerSettings plannerSettings \n SchemaTreeProvider schemaTreeProvider \n QueryContextInformation queryContextInfo \n BufferManager bufferManager \n ViewExpansionContext viewExpansionContext \n BufferAllocator allocator \n org.slf4j.Logger logger \n DrillbitContext drillbitContext \n ExecutionControls executionControls \n DrillOperatorTable table \n boolean closed \n ContextInformation getContextInformation \n DrillbitEndpoint getCurrentEndpoint \n DrillBuf getManagedBuffer \n String getQueryUserName \n OptionValue getOption \n LogicalPlanPersistence getLpPersistence \n DrillOperatorTable getDrillOperatorTable \n DrillConfig getConfig \n FunctionImplementationRegistry getFunctionRegistry \n BufferAllocator getAllocator \n boolean isUserAuthenticationEnabled \n ExecutionControls getExecutionControls \n boolean isImpersonationEnabled \n StoragePluginRegistry getStorage \n PartitionExplorer getPartitionExplorer \n Collection<DrillbitEndpoint> getActiveEndpoints \n ViewExpansionContext getViewExpansionContext \n OptionManager getOptions \n UserSession getSession \n SchemaPlus getNewDefaultSchema \n QueryContextInformation getQueryContextInfo \n void close \n PlannerSettings getPlannerSettings", "output": "SchemaPlus function ( final String arg0 ) { return schemaTreeProvider . createRootSchema ( arg0 , this ) ; }"}, {"instruction": "Generate java code\nsets the global config object that contains kademlia-wide constants . this method has an effect only if a config object has never been set before . ", "input": " KademliaSetup singleton \n WorkloadGenerator workloadGen \n Logger log \n AbstractNodeFactory nodeFactory \n KademliaMonitor monitor \n Config config \n WorkloadGenerator getWorkloadGenerator \n void setMonitor \n void setNodeFactory \n void setWorkload \n KademliaMonitor getMonitor \n AbstractNodeFactory getNodeFactory \n KademliaSetup getInstance \n Config getConfig \n void setConfig", "output": "void function ( final String arg0 ) { if ( config == null ) { config = new FileConfig ( arg0 ) ; log . info ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nremove them measured rtt from host to monitor ", "input": " int MONITOR \n AverageAccumulator avgPingAttemptsPerNode \n long serialVersionUID \n double latitude \n String city \n String isp \n boolean locatable \n boolean useCountryNames \n int type \n String countryCode \n GnpPosition coordinateRef \n HostMap mapRef \n int HOST \n String area \n int ipAddress \n HashMap<Host,List<Double>> rttToMonitors \n CumulateRTTStrategy currentStrategy \n HashMap<Host,Double> cumulatedRTTs \n int isNotLocatable \n int regionNotFound \n double longitude \n int ccNotFound \n String region \n int cityNotFound \n String countryName \n boolean issetUseCountryNames \n void setUseCountryNames \n void setPositionReference \n int getIpAddress \n int getHostType \n void setLocation \n int hashCode \n String getISP \n String getCountryName \n Set<Host> getMeasuredMonitors \n boolean isLocatable \n String getCity \n String getCountryCode \n void printLocatorStats \n void addRtt \n double getLongitude \n double getLatitude \n void setHostType \n double getAvgPingAttemptsPerNode \n Double cumulate \n void setRtt \n double getRtt \n String getRegion \n boolean equals \n void setRTTCumulationStrategy \n void cumulateRTTsCond \n String toString \n String getArea \n GnpPosition getGnpPositionReference", "output": "void function ( Host arg0 ) { rttToMonitors . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the value associated with all existing keys to newvalue . ", "input": " SortedMap<K,V> kSmallest \n int k \n boolean containsKey \n Collection<V> values \n void clear \n boolean isInRange \n boolean put \n boolean put \n boolean put \n V remove \n boolean containsValue \n K getMinKey \n K getMaxKey \n int size \n K firstKey \n void putAll \n void putAll \n void putAll \n void putAll \n void putAll \n V get \n K lastKey \n String toString \n Set<K> keySet", "output": "void function ( final V arg0 ) { for ( final K loc0 : kSmallest . keySet ( ) ) { kSmallest . put ( loc0 , arg0 ) ; } }"}, {"instruction": "Generate java code\ndeclare an image in the registry table . ", "input": " String IMG_OBJ_JSP \n String OBJECT \n ImageRegistry imageRegistry \n String IMG_OBJ_TOMCAT \n URL ICON_BASE_URL \n HashMap imageDescriptors \n URL makeIconFileURL \n void declareImages \n ImageRegistry getImageRegistry \n ImageRegistry initializeImageRegistry \n ImageDescriptor getImageDescriptor \n Image getImage", "output": "void function ( String arg0 , String arg1 ) { ImageDescriptor loc0 = ImageDescriptor . getMissingImageDescriptor ( ) ; try { loc0 = ImageDescriptor . createFromURL ( makeIconFileURL ( arg1 ) ) ; } catch ( MalformedURLException loc1 ) { DebugPlugin . log ( loc1 ) ; } imageRegistry . put ( arg0 , loc0 ) ; imageDescriptors . put ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\nprints the ast in ` ascii art ' tree form to the specified print writer . ", "input": " boolean showClassNames \n Map tokenTypeNameCache \n String showAsString \n String nodeToString \n void showNode \n String escapeMultibyteChars \n String getTokenTypeName \n boolean isShowClassNames \n void appendEscapedMultibyteChars", "output": "void function ( AST arg0 , PrintWriter arg1 ) { ArrayList < AST > loc0 = new ArrayList < AST > ( ) ; showAst ( loc0 , arg1 , arg0 ) ; arg1 . flush ( ) ; }"}, {"instruction": "Generate java code\nturn type into class . ", "input": " String[] NO_PARAMS_TYPES \n Object convertValue \n Method findMethod \n boolean equals \n boolean simpleCheck \n String[] getTypes \n Method locateMethod", "output": "Class < ? > function ( Type arg0 ) { if ( arg0 instanceof Class ) { return ( Class ) arg0 ; } else if ( arg0 instanceof ParameterizedType ) { ParameterizedType loc0 = ( ParameterizedType ) arg0 ; return toClass ( loc0 . getRawType ( ) ) ; } else { throw PojoLogger . ROOT_LOGGER . unknownType ( arg0 ) ; } }"}, {"instruction": "Generate java code\ntransfer vectors from this to containerout ", "input": " BatchSchema schema \n boolean schemaChanged \n OperatorContext oContext \n List<VectorWrapper<?>> wrappers \n int recordCount \n boolean allocateNewSafe \n void addHyperList \n void addHyperList \n void replace \n void setRecordCount \n boolean hasSchema \n void buildSchema \n void remove \n void cloneAndTransfer \n Iterator<VectorWrapper<?>> iterator \n int getRecordCount \n OperatorContext getOperatorContext \n VectorContainer canonicalize \n boolean isSchemaChanged \n TypedFieldId add \n void add \n void add \n T addOrGet \n T addOrGet \n T addOrGet \n void zeroVectors \n void allocateNew \n VectorWrapper<?> getValueAccessorById \n VectorWrapper<?> getValueAccessorById \n void clear \n int getNumberOfColumns \n BatchSchema getSchema \n SelectionVector4 getSelectionVector4 \n SelectionVector2 getSelectionVector2 \n void addCollection \n TypedFieldId getValueVectorId \n String toString \n void transferIn \n VectorContainer getTransferClone \n VectorContainer getTransferClone", "output": "void function ( VectorContainer arg0 ) { Preconditions . checkArgument ( this . wrappers . size ( ) == arg0 . wrappers . size ( ) ) ; for ( int loc0 = 0 ; loc0 < this . wrappers . size ( ) ; ++ loc0 ) { this . wrappers . get ( loc0 ) . transfer ( arg0 . wrappers . get ( loc0 ) ) ; } }"}, {"instruction": "Generate java code\ncreates a new com.datastax.driver.core.batchstatement.type #unlogged batch statement for the specified cql statement builders . ", "input": " PlaceHolder placeHolder \n CqlMapper.DefaultCqlMapper all \n CQLStatementTupleMapper async \n ContextQuery named \n ContextQuery namedByField \n BatchCQLStatementTupleMapper newBatchStatementBuilder \n BatchCQLStatementTupleMapper counterBatch \n FieldSelector field \n BatchCQLStatementTupleMapper loggedBatch \n BoundCQLStatementMapperBuilder boundQuery \n BoundCQLStatementMapperBuilder boundQuery \n FieldSelector[] fields \n SimpleCQLStatementMapperBuilder simpleQuery \n SimpleCQLStatementMapperBuilder simpleQuery", "output": "BatchCQLStatementTupleMapper function ( CQLStatementBuilder ... arg0 ) { return newBatchStatementBuilder ( BatchStatement . Type . UNLOGGED , arg0 ) ; }"}, {"instruction": "Generate java code\nget the index into the constant pool of the type descriptor of the variable . ", "input": " int typeIndex \n int nameIndex \n int length \n int index \n int startPC \n int nameIndex \n int length \n Object clone \n int index \n String toString \n int startPC", "output": "int function ( ) { return typeIndex ; }"}, {"instruction": "Generate java code\nreturns the location . ", "input": " String city \n List orders \n String name \n String location \n Order createOrder \n void setName \n String getName \n void removeOrder \n void setCity \n void setLocation \n void addOrder \n String toString \n List getOrders \n String getCity", "output": "String function ( ) { return location ; }"}, {"instruction": "Generate java code\nget the contents of a section given the section name . ", "input": " File krb5conf \n Map<String,Object> items \n String insertEntries \n void printEntry \n void load \n void insertSections \n void dump \n List<String> getSections \n void printSection", "output": "Map < String , Object > function ( String arg0 ) { Map < String , Object > loc0 = ( HashMap ) items . get ( arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ntest method for com.itextpdf.text.html.webcolors #getrgbcolor java.lang.string . ", "input": " String RGB_PERCENT \n String RGB_OUT_OF_RANGE \n String RGB_MISSING_COLOR_VALUES \n String dumpColor \n void testGetRGBColorInPercentBlue \n void testGetRGBColorValueOutOfRange \n void testGetRGBColorChannelsMissingBlue \n void moreColorTest \n void testGetRGBColorInPercentRed \n void testGetRGBColorInPercentAlpha \n void testGetRGBColorInPercentGreen \n void goodColorTests \n void testGetRGBColorChannelsMissingGreen \n void badColorTests \n void testGetRGBColorNegativeValue", "output": "void function ( ) { assertEquals ( 127 , WebColors . getRGBColor ( RGB_MISSING_COLOR_VALUES ) . getRed ( ) ) ; }"}, {"instruction": "Generate java code\nthe enumeration members in assorted order : / / not_discarded , obvious , bad_sample , bad_confidence , unused , not_enough_samples , non_canonical_var , implied_post_condition , only_constant_vars , derived_param , unmodified_var , control_check , exact , var filter ", "input": " DiscardCode not_enough_samples \n DiscardCode filtered \n DiscardCode obvious \n DiscardCode implied_post_condition \n DiscardCode derived_param \n long serialVersionUID \n DiscardCode only_constant_vars \n int enumValue \n DiscardCode non_canonical_var \n DiscardCode unmodified_var \n DiscardCode bad_sample \n DiscardCode bad_confidence \n DiscardCode control_check \n DiscardCode exact \n DiscardCode var_filtered \n Object readResolve \n DiscardCode findCode \n String toString", "output": "int function ( DiscardCode arg0 ) { Integer loc0 = new Integer ( this . enumValue ) ; Integer loc1 = new Integer ( arg0 . enumValue ) ; return loc0 . compareTo ( loc1 ) ; }"}, {"instruction": "Generate java code\ncreate a timestamp from the number of microseconds elapsed from the epoch . ", "input": " BigInteger NANOS_PER_SECOND_BIG_INTEGER \n long DURATION_SECONDS_MAX \n long DURATION_SECONDS_MIN \n long TIMESTAMP_SECONDS_MAX \n long NANOS_PER_SECOND \n long TIMESTAMP_SECONDS_MIN \n Timestamp add \n Duration add \n Duration distance \n Duration createDurationFromMicros \n Timestamp subtract \n Duration subtract \n Timestamp createTimestampFromMillis \n BigInteger toBigInteger \n BigInteger toBigInteger \n Duration createDurationFromNanos \n Duration createDurationFromMillis \n Duration createDurationFromBigInteger \n Duration parseDuration \n long toNanos \n long toNanos \n Timestamp getEpoch \n Timestamp parseTimestamp \n String toString \n String toString \n long toMillis \n long toMillis \n Duration divide \n Duration divide \n long divide \n Timestamp createTimestampFromNanos \n Timestamp getCurrentTime \n Duration multiply \n Duration multiply \n long toMicros \n long toMicros \n Duration remainder \n Duration normalizedDuration", "output": "Timestamp function ( long arg0 ) { return Timestamps . fromMicros ( arg0 ) ; }"}, {"instruction": "Generate java code\nthe inverse of #registerloadingcollectionxref . here , we are done processing the said collection entry , so we remove it from the load context . the idea here is that other loading collections can now reference said collection directly from the persistencecontext because ithas completed its load cycle . implementation note : package protected , as this is meant solely for use by collectionloadcontext to be able to locate collectionsbeing loaded by other collectionloadcontext s / resultset s. ", "input": " Map<CollectionKey,LoadingCollectionEntry> xrefLoadingCollectionEntries \n CoreMessageLogger LOG \n Map<ResultSet,EntityLoadContext> entityLoadContexts \n PersistenceContext persistenceContext \n Map<ResultSet,CollectionLoadContext> collectionLoadContexts \n EntityLoadContext getEntityLoadContext \n Map getLoadingCollectionXRefs \n boolean hasRegisteredLoadingCollectionEntries \n CollectionLoadContext getCollectionLoadContext \n PersistenceContext getPersistenceContext \n void cleanup \n void cleanup \n void registerLoadingCollectionXRef \n void cleanupCollectionXRefs \n boolean hasLoadingCollectionEntries \n SessionImplementor getSession \n PersistentCollection locateLoadingCollection \n LoadingCollectionEntry locateLoadingCollectionEntry", "output": "void function ( CollectionKey arg0 ) { if ( ! hasRegisteredLoadingCollectionEntries ( ) ) { return ; } xrefLoadingCollectionEntries . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\ncommit ; ", "input": " android.database.mysql.natives.Connector __connector \n String DEFAULT_PORT \n String encoding \n HashMap<String,String> config \n void rollback \n void disconnect \n void startTransaction \n String getLastError \n ArrayList<String> fetchCol \n void query \n void disableAutocommit \n String fetchOne \n boolean hasMoreRows \n ArrayList<ArrayList<String>> fetchAllArray \n void enableAutocommit \n ArrayList<String> fetchRowArray \n int lastInsertId \n ArrayList<HashMap<String,String>> fetchAllHash \n ArrayList<String> fields \n HashMap<String,String> fetchRowHash \n String escape \n void connect \n void forceFreeResult", "output": "void function ( ) { query ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns true of the result given is the result of an exit command ", "input": " TextArea outputConsole \n Logic logic \n TextField commandInput \n Stoppable mainApp \n void setMainApp \n void clearOutputConsole \n void displayResult \n void clearCommandInput \n void onCommand \n void display \n void display \n void exitApp \n void displayWelcomeMessage \n void setLogic", "output": "boolean function ( CommandResult arg0 ) { return arg0 . feedbackToUser . equals ( ExitCommand . MESSAGE_EXIT_ACKNOWEDGEMENT ) ; }"}, {"instruction": "Generate java code\nfinds the display-space rectangle that bounds the given widget 's client area . ", "input": " String copyright \n Point getLocation \n Point getLocation \n Rectangle toDisplay", "output": "Rectangle function ( Widget arg0 ) { return getBounds ( arg0 , true ) ; }"}, {"instruction": "Generate java code\nreturns the protocol , domain and port of the url . the origin does not typically include a trailing slash . ", "input": " String SCHEME_HTTPS \n String SCHEME_FILE \n String SCHEME_HTTP \n String originUrl \n String applicationUrl \n String lastPathComponent \n String url \n String getApplicationUrlImpl \n String getLastPathComponent \n String getUrl \n String getScheme \n String convertToRelativeUrl \n String getResourceBase \n String getPath \n String getApplicationUrl \n String extractOriginImpl \n String getUrlWithoutHash \n String getUrlWithoutHash", "output": "String function ( ) { if ( originUrl == null ) { originUrl = extractOriginImpl ( url ) ; } return originUrl ; }"}, {"instruction": "Generate java code\ngets the id for this request . ", "input": " String LOGTAG \n AtomicInteger currentId \n String data \n int id \n String name \n void onResponse \n String getName \n void onError \n String getData", "output": "int function ( ) { return id ; }"}, {"instruction": "Generate java code\nmodinteger negative . ", "input": " java.math.BigInteger val \n ModIntegerRing ring \n ModInteger MIREM \n java.math.BigInteger getSymmetricVal \n int MISIGN \n ModInteger gcd \n ModInteger sum \n int compareTo \n ModInteger MINEG \n ModInteger MISUM \n int hashCode \n ModInteger MIDIF \n ModInteger divide \n ModInteger multiply \n int signum \n boolean isONE \n ModInteger inverse \n int MICOMP \n java.math.BigInteger getVal \n boolean isUnit \n ModInteger subtract \n ModInteger MIABS \n ModInteger MIINV \n ModInteger[] egcd \n java.math.BigInteger getModul \n ModInteger abs \n ModInteger MIQ \n boolean equals \n ModInteger clone \n boolean isZERO \n String toString \n ModInteger MIPROD \n ModInteger remainder", "output": "ModInteger function ( ) { return new ModInteger ( ring , val . negate ( ) ) ; }"}, {"instruction": "Generate java code\nreturns buffer as byte array ", "input": " int BUFFER_DEFAULT_LENGTH \n int actualSize \n byte[] buffer \n int position \n void writeInt \n void writeLong \n int getPosition \n int getActualSize \n void ensureLength \n void write \n void write \n void write \n int writeString \n void setPosition \n void writeIntAt \n void writeDouble", "output": "byte [ ] function ( ) { byte [ ] loc0 = new byte [ getActualSize ( ) ] ; System . arraycopy ( buffer , 0 , loc0 , 0 , getActualSize ( ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns an empty operationcallback , type-safe . ", "input": " OperationCallback EMPTY_CALLBACK \n void calledOperationSucceeded \n int scheduleEmptyOperation \n void calledOperationFailed \n Operation<TResult> createEmptyOperation \n Operation<TResult> createEmptyOperationResult", "output": "OperationCallback < TResult > function ( ) { return Operations . EMPTY_CALLBACK ; }"}, {"instruction": "Generate java code\nlog the specified message and object ", "input": " ILog sysOutLog \n PrintWriter sysOut \n ILog log \n void setLog \n void printLogObject \n void removeLogListener \n void logNoHeader \n void logStackTrace \n void printLogStatus \n IStatus createLogStatus \n void printLogMessage \n void printLog \n void close \n void addLogListener \n org.osgi.framework.Bundle getBundle", "output": "void function ( String arg0 , Object arg1 ) { if ( Tracer . isDebugging ( ) ) printLog ( sysOut , arg0 , arg1 ) ; IStatus loc0 = createLogStatus ( arg0 , arg1 , \"srini_string\" ) ; try { log . log ( loc0 ) ; } catch ( Throwable loc1 ) { } }"}, {"instruction": "Generate java code\nexecute the discrete work encapsulated by a returningwork instanceusing the supplied connection , returning the result of returningwork #execute java.sql.connection ", "input": " PlaceHolder placeHolder \n T executeWork", "output": "T function ( ReturningWork < T > arg0 , Connection arg1 ) { return arg0 . execute ( arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the change element 's parent . ", "input": " int PARTLY_ACTIVE \n int[][] ACTIVATION_TABLE \n int INACTIVE \n PreviewNode[] EMPTY_CHILDREN \n int ACTIVE \n PreviewNode fParent \n void feedInput \n void setEnabled \n PreviewNode[] getChildren \n boolean hasOneGroupCategory \n String getText \n boolean hasDerived \n ChangePreviewViewerDescriptor getChangePreviewViewerDescriptor \n void setEnabledShallow \n int getActive \n void initialize \n ImageDescriptor getImageDescriptor", "output": "PreviewNode function ( ) { return fParent ; }"}, {"instruction": "Generate java code\nis this endpoint required to be in fragment endpoint assignment list ? ", "input": " DrillbitEndpoint endpoint \n double affinity \n org.slf4j.Logger logger \n boolean mandatory \n int maxWidth \n int hashCode \n boolean equals \n DrillbitEndpoint getEndpoint \n String toString \n void setAssignmentRequired \n void setMaxWidth \n void addAffinity \n double getAffinity \n int getMaxWidth", "output": "boolean function ( ) { return mandatory || Double . POSITIVE_INFINITY == affinity ; }"}, {"instruction": "Generate java code\nfind a db4odatabase with the same signature as this one ", "input": " int STATIC_ID \n int i_id \n Db4oDatabase STATIC_IDENTITY \n String CREATIONTIME_FIELD \n ObjectContainerBase i_stream \n byte[] i_signature \n long i_uuid \n int bind \n boolean isOlderThan \n int storeAndGetId \n int hashCode \n boolean equals \n long getCreationTime \n byte[] getSignature \n int getID \n String toString \n Db4oDatabase generate", "output": "Db4oDatabase function ( Transaction arg0 ) { if ( i_uuid > 0 ) { Db4oDatabase loc0 = query ( arg0 , true ) ; if ( loc0 != null ) { return loc0 ; } } return query ( arg0 , false ) ; }"}, {"instruction": "Generate java code\ngenerates a random 8 x 8 simpleboard . ", "input": " PlaceHolder placeHolder \n void main \n void initTable", "output": "SimpleBoard function ( ) { SimpleBoard loc0 = new SimpleBoard ( ) ; for ( int loc1 = 0 ; loc1 < 8 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < 8 ; loc2 ++ ) { double loc3 = Math . random ( ) * 12 ; int loc4 = ( int ) loc3 ; loc0 . setElementAt ( loc2 , loc1 , loc4 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nsets the fully configured discoverclasses instance to be used to lookup services ", "input": " ClassLoader classLoader \n DiscoverClasses discovery \n boolean useContextClassLoader \n Log log \n boolean getUseContextClassLoader \n DiscoverClasses getDiscoverClasses \n TagLibrary loadClass \n ClassLoader getClassLoader \n TagLibrary newInstance \n TagLibrary resolveTagLibrary \n void setClassLoader \n void setUseContextClassLoader", "output": "void function ( DiscoverClasses arg0 ) { this . discovery = arg0 ; }"}, {"instruction": "Generate java code\ncache the current display if it has not already been cached by the #launchapp method or a prior call to this method . ", "input": " IUIContext _ui \n Display _display \n Shell _rootShell \n IUIContext getUI \n IUIContext createUI \n void setDisplay \n void update \n Shell getRootShell \n void cacheRootShell \n void setRootShell \n Display getDisplay", "output": "void function ( ) { if ( _display == null ) setDisplay ( Display . getDefault ( ) ) ; }"}, {"instruction": "Generate java code\ntime to live for a contact before it is considered offline ", "input": " int numberOfReplicates \n long timeToLiveForContacts \n int numberOfPingTries \n long timeBetweenRootPings \n long timeBetweenReplicationChecks \n int numberOfReplicationTries \n int minimumNumberOfReplicates \n int getNumberOfPingTries \n int getNumberOfReplicationTries \n void setNumberOfPingTries \n int getNumberOfReplicates \n long getTimeBetweenReplicationChecks \n void setTimeBetweenRootPings \n void setMinimumNumberOfReplicates \n long getTimeToLiveForContacts \n void setNumberOfReplicates \n int getMinimumNumberOfReplicates \n void setTimeBetweenReplicationChecks \n long getTimeBetweenRootPings \n void setNumberOfReplicationTries", "output": "void function ( long arg0 ) { this . timeToLiveForContacts = arg0 ; }"}, {"instruction": "Generate java code\nasserts that a schema namespace is set . ", "input": " PlaceHolder placeHolder \n void assertPrefix \n void assertSpecificLang \n void assertPropName \n void assertNotNull \n void assertArrayName \n void assertStructName \n void assertImplementation", "output": "void function ( String arg0 ) { if ( arg0 == null || arg0 . length ( ) == 0 ) { throw new XMPException ( \"srini_string\" , XMPError . BADPARAM ) ; } }"}, {"instruction": "Generate java code\nreturn number of elements ", "input": " int mCount \n Object[] mNodes \n Comparator mCmp \n int parent \n int compare \n boolean erase \n Object extract \n int left \n List getSorted \n void clear \n void insert \n int right \n List getUnsorted \n Object extractElementAt \n Object peek", "output": "int function ( ) { return mCount ; }"}, {"instruction": "Generate java code\nreturn true if past the next synchronization point after a position . ", "input": " byte[] MAGIC \n String CODEC \n Schema schema \n long blockCount \n int SYNC_SIZE \n String SYNC \n DataFileReader.SeekableInputStream in \n DatumReader<D> reader \n long count \n byte[] sync \n String SCHEMA \n Map<String,byte[]> meta \n D peek \n long blockStart \n byte VERSION \n byte[] syncBuffer \n String COUNT \n long FOOTER_BLOCK \n BinaryDecoder vin \n String NULL_CODEC \n int SYNC_INTERVAL \n D next \n D next \n long tell \n String getMetaString \n long getMetaLong \n boolean hasNext \n void seek \n void sync \n void remove \n Schema getSchema \n Iterator<D> iterator \n byte[] getMeta \n void skipSync \n void close", "output": "boolean function ( long arg0 ) { return ( ( blockStart >= arg0 + SYNC_SIZE ) || ( blockStart >= in . length ( ) ) ) ; }"}, {"instruction": "Generate java code\nreturns the end index . ", "input": " int start \n int end \n char[] buffer \n int getStart \n char[] getBuffer \n void setStart \n void adjust \n boolean hasMore \n int getLength \n void setEnd", "output": "int function ( ) { return end ; }"}, {"instruction": "Generate java code\nupdate the cached set of add-ons . throws on invalid input . ", "input": " String appLocale \n boolean telemetryEnabled \n long profileCreationTime \n boolean blocklistEnabled \n int FORMAT_VERSION \n String distribution \n boolean needsWrite \n String LOG_TAG \n File file \n String osLocale \n String CACHE_FILE \n boolean isAcceptLangUserSet \n boolean initialized \n JSONObject addons \n void setProfileCreationTime \n String getDistributionString \n void updateJSONForAddon \n void updateJSONForAddon \n void removeAddon \n void completeInitialization \n boolean restoreUnlessInitialized \n void writeToFile \n boolean updateLocales \n void beginInitialization \n JSONObject toJSON \n long getProfileCreationTime \n JSONObject getAddonsJSON \n void setOSLocale \n boolean fromJSON \n boolean isAcceptLangUserSet \n void setTelemetryEnabled \n void setBlocklistEnabled \n String getOSLocale \n boolean isBlocklistEnabled \n void ensureInitialized \n String getAppLocale \n JSONObject readFromFile \n void setAcceptLangUserSet \n void setDistributionString \n boolean isTelemetryEnabled \n void setAppLocale", "output": "void function ( String arg0 ) { addons = new JSONObject ( arg0 ) ; needsWrite = true ; }"}, {"instruction": "Generate java code\nretrieves the value of a transaction local variables . if this is the first time the variable is accessed transactionlocal #initialvaluefor transaction will provide the initial value . ", "input": " ObjectContainerBase _container \n Transaction _systemTransaction \n Map<TransactionLocal<?>,Object> _locals \n Tree _delete \n List4 _transactionListeners \n ObjectContainer _objectContainer \n ReferenceSystem _referenceSystem \n void slotFreePointerOnCommit \n void slotFreePointerOnCommit \n ObjectContainerBase container \n void commitTransactionListeners \n void commit \n void checkSynchronization \n void writeUpdateAdjustIndexes \n void addNewReference \n boolean delete \n void clearAll \n ObjectContainer objectContainer \n void deactivate \n void slotFreeOnRollback \n void removeReference \n void produceUpdateSlotChange \n boolean isDeleted \n void slotDelete \n void commitReferenceSystem \n void rollbackReferenceSystem \n boolean supportsVirtualFields \n Context context \n void close \n Transaction systemTransaction \n void rollback \n void processDeletes \n void addTransactionListener \n void setPointer \n void setPointer \n void dontDelete \n ObjectReference referenceForId \n void clear \n void slotFreeOnRollbackCommitSetPointer \n void slotFreePointerOnRollback \n void traverseDelete \n void discardReferenceSystem \n void slotFreeOnCommit \n void rollBackTransactionListeners \n Reflector reflector \n Transaction parentTransaction \n void removeObjectFromReferenceSystem \n void setOutSideRepresentation \n ObjectReference referenceForObject \n boolean isSystemTransaction \n String toString \n Object wrap \n ReferenceSystem referenceSystem \n Object objectForIdFromCache", "output": "ByRef < T > function ( TransactionLocal < T > arg0 ) { final ByRef < T > loc0 = ( ByRef < T > ) _locals . get ( arg0 ) ; if ( null != loc0 ) return loc0 ; final ByRef < T > loc1 = ByRef . newInstance ( arg0 . initialValueFor ( this ) ) ; _locals . put ( arg0 , loc1 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nchecks if the images are loaded in the cache . the variable imageswereloaded is used to ensure that they wo n't be loaded more then once . ", "input": " String T_LCL \n String T_TOOL \n URL iconBaseURL \n ImageRegistry imageRegistry \n String T_OBJ \n String T_VIEW \n String T_OVR \n boolean imagesWereLoaded \n String T_WIZBAN \n ImageDescriptor add \n ImageDescriptor add \n boolean add \n URL makeIconFileURL \n void setImageDescriptors \n ImageDescriptor createImageDescriptor \n void initialize \n void addImages \n ImageDescriptor getImageDescriptor \n ImageDescriptor getImageDescriptor \n Image getImage \n Image getImage", "output": "void function ( ) { if ( imagesWereLoaded ) return ; addImages ( ) ; imagesWereLoaded = true ; }"}, {"instruction": "Generate java code\nget the value of one of the fields of a datetime . this could be used to get a field using a different chronology . for example : instant dt = new instant ; int gjyear = dt.get chronology.getcoptic . year ; ", "input": " PlaceHolder placeHolder \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n Date toDate \n boolean isEqual \n boolean isEqual \n DateTimeZone getZone \n boolean isSupported \n int compareTo \n boolean isBeforeNow \n Instant toInstant \n boolean isBefore \n boolean isBefore \n boolean isEqualNow \n MutableDateTime toMutableDateTimeISO \n DateTime toDateTimeISO \n int hashCode \n boolean equals \n String toString \n String toString \n boolean isAfter \n boolean isAfter \n DateTime toDateTime \n DateTime toDateTime \n DateTime toDateTime \n boolean isAfterNow", "output": "int function ( DateTimeField arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 . get ( getMillis ( ) ) ; }"}, {"instruction": "Generate java code\nreturns the failure stack trace . ", "input": " String fExpected \n Result FAILURE \n String fActual \n Result UNDEFINED \n Result ERROR \n Result IGNORED \n String fName \n ProgressState NOT_STARTED \n ProgressState STOPPED \n Result OK \n String fTrace \n ProgressState COMPLETED \n ProgressState RUNNING \n Result getTestResult \n String getActual \n String getExpected \n ProgressState getProgressState \n ITestElementContainer getParentContainer \n String toString \n String toString \n ITestRunSession getTestRunSession \n FailureTrace getFailureTrace \n double getElapsedTimeInSeconds", "output": "String function ( ) { return fTrace ; }"}, {"instruction": "Generate java code\nclean up queryplancache when sessionfactory is closed ", "input": " SessionFactoryImplementor factory \n Set<DynamicFilterKey> filterKeys \n String query \n String filterName \n Map<String,Integer> parameterMetadata \n int DEFAULT_PARAMETER_METADATA_MAX_COUNT \n int DEFAULT_QUERY_PLAN_MAX_COUNT \n BoundedConcurrentHashMap queryPlanCache \n NativeQueryInterpreter nativeQueryInterpreterService \n Set<String> filterNames \n BoundedConcurrentHashMap<String,ParameterMetadata> parameterMetadataCache \n int hashCode \n CoreMessageLogger LOG \n boolean shallow \n String collectionRole \n HQLQueryPlan getHQLQueryPlan \n int hashCode \n int hashCode \n int hashCode \n boolean equals \n boolean equals \n boolean equals \n FilterQueryPlan getFilterQueryPlan \n ParameterMetadata getSQLParameterMetadata \n NativeSQLQueryPlan getNativeSQLQueryPlan", "output": "void function ( ) { LOG . trace ( \"srini_string\" ) ; queryPlanCache . clear ( ) ; parameterMetadataCache . clear ( ) ; }"}, {"instruction": "Generate java code\nprocesses an error that occurs when the validation of an object fails . ", "input": " String ERROR_CODE_TODO_ENTRY_NOT_FOUND \n Logger LOGGER \n MessageSource messageSource \n ErrorDTO handleTodoEntryNotFound \n DefaultMessageSourceResolvable createSingleErrorMessageRequest \n String getValidationErrorMessage \n ValidationErrorDTO constructValidationErrors", "output": "ValidationErrorDTO function ( MethodArgumentNotValidException arg0 , Locale arg1 ) { BindingResult loc0 = arg0 . getBindingResult ( ) ; List < FieldError > loc1 = loc0 . getFieldErrors ( ) ; LOGGER . error ( \"srini_string\" , loc1 . size ( ) ) ; return constructValidationErrors ( loc1 , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the implementation for language name display . java language names are defined by default . ", "input": " String footerText \n Resources resources \n ElementIndex index \n Locale locale \n ILanguageNames languageNames \n String outputEncoding \n SessionsPage sessionsPage \n Table table \n void setOutputEncoding \n Table createTable \n IReportVisitor createVisitor \n ILanguageNames getLanguageNames \n IIndexUpdate getIndexUpdate \n String getFooterText \n Resources getResources \n Table getTable \n ILinkable getSessionsPage \n String getOutputEncoding \n void setFooterText \n Locale getLocale \n void setLocale \n void addMissedTotalColumns", "output": "void function ( final ILanguageNames arg0 ) { this . languageNames = arg0 ; }"}, {"instruction": "Generate java code\nchildren should override this . the default implementation returns null . ", "input": " IPropertyDescriptor[] EMPTY_ARRAY \n PropertyChangeSupport pcsDelegate \n long serialVersionUID \n void firePropertyChange \n void setPropertyValue \n Object getEditableValue \n IPropertyDescriptor[] getPropertyDescriptors \n void resetPropertyValue \n void addPropertyChangeListener \n boolean isPropertySet \n void removePropertyChangeListener \n void readObject", "output": "Object function ( Object arg0 ) { return null ; }"}, {"instruction": "Generate java code\ncheck kdc udp setting and see if any bad . ", "input": " KdcConfig kdcConfig \n BackendConfig backendConfig \n KOptions startupOptions \n int getKdcTcpPort \n int getKdcPort \n String getKdcRealm \n int checkGetKdcTcpPort \n int getKdcUdpPort \n boolean allowTcp \n boolean allowUdp \n KdcConfig getKdcConfig \n String getKdcHost \n BackendConfig getBackendConfig", "output": "int function ( ) { if ( allowUdp ( ) ) { int loc0 = getKdcUdpPort ( ) ; if ( loc0 < 1 ) { throw new KrbException ( \"srini_string\" ) ; } return loc0 ; } return - 1 ; }"}, {"instruction": "Generate java code\nadds a tag and its corresponding properties to the chain . ", "input": " List<TagAttributes> chain \n String tag \n Map<String,String> attrs \n String getProperty \n boolean hasProperty \n void removeChain \n void adjustFontSize", "output": "void function ( String arg0 , Map < String , String > arg1 ) { this . adjustFontSize ( arg1 ) ; chain . add ( new TagAttributes ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\ncreate querycontextinformation with given defaultschemaname . rest of the members of the querycontextinformation is derived from the current state of the process . ", "input": " PlaceHolder placeHolder \n String getFileNameForQueryFragment \n String getDrillVersion", "output": "QueryContextInformation function ( final String arg0 ) { final long loc0 = System . currentTimeMillis ( ) ; final int loc1 = DateUtility . getIndex ( System . getProperty ( \"srini_string\" ) ) ; return QueryContextInformation . newBuilder ( ) . setDefaultSchemaName ( arg0 ) . setQueryStartTime ( loc0 ) . setTimeZone ( loc1 ) . build ( ) ; }"}, {"instruction": "Generate java code\nparse algebraicnumber from string . ", "input": " GenPolynomialRing<C> ring \n int isField \n GenPolynomial<C> modul \n boolean isField \n boolean isCommutative \n AlgebraicNumber<C> interpolate \n java.math.BigInteger characteristic \n AlgebraicNumber<C> random \n AlgebraicNumber<C> random \n int hashCode \n boolean equals \n AlgebraicNumber<C> getONE \n AlgebraicNumber<C> getZERO \n AlgebraicNumber<C> fromInteger \n AlgebraicNumber<C> fromInteger \n boolean isAssociative \n String toString \n AlgebraicNumber<C> copy \n AlgebraicNumber<C> chineseRemainder", "output": "AlgebraicNumber < C > function ( String arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncreates a compilation unit change based on the events recorded by this compilation unit rewrite . do not remove , used in a product . ", "input": " ImportRewrite fImportRewrite \n ImportRemover fImportRemover \n WorkingCopyOwner fOwner \n ASTRewrite fRewrite \n boolean fStatementsRecovery \n List<TextEditGroup> fTextEditGroups \n ICompilationUnit fCu \n IDocument fRememberContent \n CompilationUnit fRoot \n boolean fResolveBindings \n boolean fBindingsRecovery \n void clearASTRewrite \n ASTRewrite getASTRewrite \n void rememberContent \n AST getAST \n void setBindingRecovery \n void setStatementsRecovery \n ImportRemover getImportRemover \n void clearASTAndImportRewrites \n CompilationUnitChange attachChange \n CategorizedTextEditGroup createCategorizedGroupDescription \n TextEditGroup createGroupDescription \n void setResolveBindings \n ImportRewrite getImportRewrite \n ICompilationUnit getCu \n void clearImportRewrites \n void clearGroupDescriptionEdits \n CompilationUnit getRoot \n boolean isEmptyEdit", "output": "org . eclipse . jdt . internal . corext . refactoring . changes . CompilationUnitChange function ( ) { CompilationUnitChange loc0 = createChange ( true ) ; if ( loc0 == null ) return null ; return new org . eclipse . jdt . internal . corext . refactoring . changes . CompilationUnitChange ( loc0 ) ; }"}, {"instruction": "Generate java code\nupdate this token with the given ast node . note : allowed to be used by semantichighlightingreconciler only . ", "input": " boolean fIsRootResolved \n IBinding fBinding \n Expression fLiteral \n SimpleName fNode \n CompilationUnit fRoot \n boolean fIsBindingResolved \n Expression getLiteral \n IBinding getBinding \n void clear \n SimpleName getNode \n CompilationUnit getRoot", "output": "void function ( SimpleName arg0 ) { clear ( ) ; fNode = arg0 ; }"}, {"instruction": "Generate java code\ntestet , ob der puffer leer ist . ", "input": " char zero \n char minus \n String regexp \n Charset charset \n int pointer \n Receiver receiver \n Sender sender \n int length \n BitAmount bits \n boolean[] buffer \n char plus \n char minus \n String getRegExp \n String receive \n char getLastPulseOfReceiver \n String charform \n String read \n void clear \n char plus \n int getDC \n char zero \n StringBuilder stringform \n boolean[] bitform \n char getLastPulseOfSender \n char bufferToDecimal \n boolean get \n int getLength \n String getCharsetRegExp \n BitBuffer copy \n void buffer \n boolean isFull \n String send", "output": "boolean function ( ) { return pointer == - 1 ; }"}, {"instruction": "Generate java code\nnote : this is an inlined version of javaui #geteditorinputjavaelement ieditorinput , which is not available in 3.1 . ", "input": " PlaceHolder placeHolder \n IOpenable getJavaInput \n void selectInEditor \n IEditorPart getActiveEditor", "output": "IJavaElement function ( IEditorInput arg0 ) { Assert . isNotNull ( arg0 ) ; IJavaElement loc0 = JavaUI . getWorkingCopyManager ( ) . getWorkingCopy ( arg0 ) ; if ( loc0 != null ) return loc0 ; return arg0 . getAdapter ( IJavaElement . class ) ; }"}, {"instruction": "Generate java code\nthis widget 's class name . ", "input": " WidgetReference windowReference \n String refClassName \n String title \n String invokerID \n String windowID \n String id \n WidgetReference invokerReference \n WidgetFinder finder \n String name \n String text \n WidgetReference parentReference \n int index \n String parentID \n Point point \n String tag \n String getName \n String getInvokerID \n int getIndex \n WidgetReference getWindowReference \n String getText \n String getID \n String getTag \n boolean isAssignableFrom \n String getTitle \n Point getInvocationLocation \n WidgetReference getParentReference \n String toString \n WidgetReference getInvokerReference \n String getParentID \n String getWindowID", "output": "String function ( ) { return refClassName ; }"}, {"instruction": "Generate java code\nvalidate the input document collection . note that this method call is not thread safe . redpen instances need to be crated for each thread . ", "input": " String VERSION \n SentenceExtractor sentenceExtractor \n Configuration configuration \n List<Validator> validators \n Logger LOG \n void runSectionValidators \n Configuration getConfiguration \n void initializeValidators \n void runDocumentValidators \n int hashCode \n void runSentenceValidators \n boolean equals \n void applyPreprocessorRules \n void applyPreprocessorRules \n String toString \n Document parse \n Document parse \n List<Document> parse \n List<Validator> getValidators", "output": "List < ValidationError > function ( Document arg0 ) { List < Document > loc0 = new ArrayList < > ( ) ; loc0 . add ( arg0 ) ; Map < Document , List < ValidationError >> loc1 = validate ( loc0 ) ; return loc1 . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the value of the specified service , if the service exists and is started . ", "input": " Map<State,Map<Mode,Mode>> modeToggle \n T getValue \n ServiceController<T> findService \n void stop \n void start \n ServiceController<T> getService \n void remove \n void transition", "output": "T function ( ServiceRegistry arg0 , ServiceName arg1 ) { ServiceController < T > loc0 = findService ( arg0 , arg1 ) ; return ( ( loc0 != null ) && ( loc0 . getState ( ) == State . UP ) ) ? loc0 . getValue ( ) : null ; }"}, {"instruction": "Generate java code\nfrom an iterable of objects , this returns the one with the highest associated value of a function f ", "input": " PlaceHolder placeHolder \n T min", "output": "T function ( Iterable < T > arg0 , Function < T , Double > arg1 ) { T loc0 = null ; Double loc1 = null ; for ( T loc2 : arg0 ) { if ( loc0 == null || arg1 . apply ( loc2 ) > loc1 ) { loc0 = loc2 ; loc1 = arg1 . apply ( loc2 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nconvert the abstract location into a concrete one . returns a point relative to the given component . ", "input": " Point where \n String CENTER \n boolean isValue \n String badFormat \n boolean equals \n String toString \n boolean isIndex \n String parseValue \n ComponentLocation parse \n int parseIndex \n Rectangle getBounds \n String encodeIndex \n String encodeValue", "output": "Point function ( Component arg0 ) { return where != null ? new Point ( where ) : new Point ( arg0 . getWidth ( ) / 2 , arg0 . getHeight ( ) / 2 ) ; }"}, {"instruction": "Generate java code\nsame as toparseablestring . ", "input": " Sequence sequence \n CoverageAtom frontierBranch \n Set<VariableInfo> values \n Set<String> branch_compares \n Variable value \n long serialVersionUID \n long serialVersionUID \n void add_branch_compare \n String print \n String toParseableString \n DFResultsOneSeq parse", "output": "String function ( ) { return toParseableString ( ) ; }"}, {"instruction": "Generate java code\ncloses the bindecorator and the underlying bin . ", "input": " Bin _bin \n int read \n long length \n int syncRead \n void sync \n void write", "output": "void function ( ) { _bin . close ( ) ; }"}, {"instruction": "Generate java code\nreturn the `` use context class loader '' flag . if set to true , digester will attempt to instantiate new command and chain instances from the context class loader . ", "input": " boolean useContextClassLoader \n RuleSet ruleSet \n Digester digester \n Digester getDigester \n void setRuleSet \n RuleSet getRuleSet \n void parse \n void parse \n void setUseContextClassLoader", "output": "boolean function ( ) { return ( this . useContextClassLoader ) ; }"}, {"instruction": "Generate java code\nstops timing , if currently running ; resets accumulated time to 0 . ", "input": " boolean running \n long tAccum \n long tFinish \n long tStart \n long elapsed \n long stop \n void start", "output": "void function ( ) { running = false ; tStart = 0 ; tFinish = 0 ; tAccum = 0 ; }"}, {"instruction": "Generate java code\nactivate basic implementation . ", "input": " int _size \n V[] _values \n Activator _activator \n long serialVersionUID \n K[] _keys \n V defaultValue \n Collection<V> values \n V replace \n void insert \n V valueAt \n V delete \n boolean containsValue \n V put \n V remove \n void bind \n int hashCode \n V get \n V putInternal \n void putAll \n K defaultKeyValue \n Set<K> keySet \n int indexOf \n V[] allocateValueStorage \n K keyAt \n K[] allocateKeyStorage \n Set<Map.Entry<K,V>> entrySet \n boolean containsKey \n void clear \n boolean isEmpty \n int size \n int indexOfKey \n boolean equals \n ArrayMap4<K,V> clone \n void ensureCapacity \n boolean containsKeyImpl \n void initializeBackingArray", "output": "void function ( ActivationPurpose arg0 ) { if ( _activator != null ) { _activator . activate ( arg0 ) ; } }"}, {"instruction": "Generate java code\nfactory method to create a typed list . if there are any elements already in the buffer being decorated , they are validated . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "Buffer function ( Buffer arg0 , Class arg1 ) { return new PredicatedBuffer ( arg0 , InstanceofPredicate . getInstance ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nreturns the programmer defined property of the receiver with the specified name , or null if it has not been set . data mappings allow programmers to associate arbitrary key-value pairs with locator instances . ", "input": " long serialVersionUID \n int UNASSIGNED \n String nameOrLabel \n int index \n WidgetLocator ancestorInfo \n WidgetLocator parentInfo \n HashMap<String,String> map \n ClassReference classRef \n void setAncestorInfo \n Object getAdapter \n int getIndex \n void copyDataTo \n WidgetLocator getParentInfo \n String getWidgetLocatorStringName \n String getNameOrLabel \n WidgetLocator getAncestorInfo \n com.windowtester.runtime.locator.IWidgetLocator[] findAll \n boolean matches \n Map<String,String> getDataMap \n void accept \n void setParentInfo \n Class<?> getTargetClass \n void setIndex \n int hashCode \n boolean equals \n ClassReference getTargetClassRef \n String getTargetClassName \n String toString \n String getData", "output": "void function ( String arg0 , String arg1 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; getDataMap ( ) . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nget the maximum number of locals used in the method . ", "input": " ClassInfo classInfo \n Code code \n int name \n boolean DEBUG \n int modifiers \n int type \n Exceptions exceptions \n Attribute[] attrs \n Catch[] exceptionHandlers \n LineNumberDebugInfo[] lineNumbers \n byte[] code \n int codeLength \n int typeIndex \n void setLineNumbers \n void setCode \n void setLocals \n void setTypeIndex \n void setModifiers \n int modifiers \n int maxStack \n ClassInfo declaringClass \n int[] exceptionTypes \n void setExceptionHandlers \n int nameIndex \n void setNameIndex \n void setMaxLocals \n Object clone \n void setMaxStack \n String toString \n void write \n LocalDebugInfo[] locals", "output": "int function ( ) { if ( code != null ) { return code . maxLocals ( ) ; } return 0 ; }"}, {"instruction": "Generate java code\nreturns value of specified field if exists , or null otherwise ", "input": " Map<String,Object> data \n String ID_KEY \n List<String> fields \n boolean isFieldsOrderImportant \n boolean containsField \n void clear \n ObjectId getId \n Object put \n void remove \n boolean equalObjects \n int size \n Object registerField \n int hashCode \n void putAll \n void putAll \n boolean equals \n String toString \n List<String> fields \n BSONObject append", "output": "Object function ( String arg0 ) { return data . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nwrite all rows added to the named output stream . ", "input": " Schema schema \n int[] arrayWidths \n String SCHEMA_KEY \n GenericData model \n ColumnFileWriter writer \n void writeValue \n long sizeEstimate \n void write \n int write", "output": "void function ( OutputStream arg0 ) { writer . writeTo ( arg0 ) ; }"}, {"instruction": "Generate java code\napply a `` like '' constraint ", "input": " PropertyNameGetter propertyNameGetter \n AuditCriterion hasNotChanged \n AuditCriterion lt \n AuditProjection distinct \n AuditCriterion leProperty \n AggregatedAuditExpression maximize \n AuditProjection min \n AuditCriterion hasChanged \n AuditCriterion gtProperty \n AuditProjection function \n AuditCriterion neProperty \n AuditCriterion ltProperty \n AuditCriterion ge \n AuditCriterion between \n Triple<String,String,Boolean> getData \n AuditCriterion isNotNull \n AggregatedAuditExpression minimize \n AuditCriterion in \n AuditCriterion in \n AuditProjection max \n AuditCriterion geProperty \n AuditProjection count \n AuditCriterion eq \n AuditCriterion gt \n AuditOrder asc \n AuditProjection countDistinct \n AuditCriterion ne \n AuditCriterion isNull \n AuditCriterion eqProperty \n AuditCriterion le \n AuditCriterion ilike \n AuditCriterion ilike \n AuditOrder desc", "output": "AuditCriterion function ( T arg0 ) { return new SimpleAuditExpression ( propertyNameGetter , arg0 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nadd a stackkeeper to the top of the stack list . ", "input": " Charset charset \n TagProcessorFactory tagFactory \n Map<String,Object> memory \n List<Element> ctn \n LinkProvider linkprovider \n boolean autoBookmark \n boolean acceptUnknown \n List<String> roottags \n String BOOKMARK_TREE \n String LAST_MARGIN_BOTTOM \n Rectangle pageSize \n String resourcesRootPath \n LinkedList<StackKeeper> queue \n CssAppliers cssAppliers \n ImageProvider imageProvider \n ImageProvider getImageProvider \n HtmlPipelineContext setTagFactory \n StackKeeper poll \n HtmlPipelineContext setAcceptUnknown \n boolean acceptUnknown \n LinkProvider getLinkProvider \n String getResourcesRootPath \n CssAppliers getCssAppliers \n HtmlPipelineContext charSet \n Charset charSet \n void setLastMarginBottom \n HtmlPipelineContext setImageProvider \n boolean isEmpty \n void setResourcesRootPath \n HtmlPipelineContext setCssApplier \n Map<String,Object> getMemory \n StackKeeper peek \n boolean autoBookmark \n HtmlPipelineContext autoBookmark \n HtmlPipelineContext setLinkProvider \n Float getLastMarginBottom \n Rectangle getPageSize \n List<Element> currentContent \n TagProcessor resolveProcessor \n HtmlPipelineContext clone \n List<String> getRootTags \n void setCssAppliers \n HtmlPipelineContext setRootTags \n HtmlPipelineContext setPageSize", "output": "void function ( final StackKeeper arg0 ) { this . queue . addFirst ( arg0 ) ; }"}, {"instruction": "Generate java code\nremoves from the underlying collection the last element returned . this method calls remove on the underlying iterator and it may throw an unsupportedoperationexception if the underlying iterator does not support this method . ", "input": " Iterator lastUsedIterator \n Object root \n Transformer transformer \n boolean hasNext \n Iterator currentIterator \n ArrayStack stack \n Object currentValue \n Object next \n void findNextByIterator \n boolean hasNext \n void findNext \n void updateCurrentIterator", "output": "void function ( ) { if ( lastUsedIterator == null ) { throw new IllegalStateException ( \"srini_string\" ) ; } lastUsedIterator . remove ( ) ; lastUsedIterator = null ; }"}, {"instruction": "Generate java code\na test run session has been launched . the test tree is not available yet . important : the implementor of this method must not keep a reference to the session element after #sessionfinished itestrunsession has finished . ", "input": " PlaceHolder placeHolder \n void testCaseStarted \n void sessionFinished \n void testCaseFinished \n void sessionStarted", "output": "void function ( ITestRunSession arg0 ) { }"}, {"instruction": "Generate java code\nreturns this triangle if it is counterclockwise , or the reversed triangle if it is clockwise . ", "input": " VectorXZ v1 \n VectorXZ v2 \n VectorXZ v3 \n VectorXZ getCenter \n boolean contains \n TriangleXZ makeCounterclockwise \n int hashCode \n boolean equals \n TriangleXYZ xyz \n List<VectorXZ> getVertices \n boolean isClockwise \n String toString \n TriangleXZ makeRotationSense \n TriangleXZ reverse \n double getArea", "output": "TriangleXZ function ( ) { return makeRotationSense ( true ) ; }"}, {"instruction": "Generate java code\npersist the phenotype given and return it - does not create it . ", "input": " GithubAPIFactory factory \n GithubAPI github \n boolean up \n DatabaseService db \n void init \n List<Phenotype> search \n PhenotypeCreation createRequest \n void syncPhenotype \n Phenotype checkInDb \n void syncPhenotypes \n Phenotype checkInGithub \n void shutdown \n Phenotype getPhenotypeById", "output": "Phenotype function ( Phenotype arg0 ) { String loc0 = \"srini_string\" ; checkArgument ( arg0 . getId ( ) . isPresent ( ) , loc0 ) ; checkArgument ( arg0 . getIssueNumber ( ) . isPresent ( ) , loc0 ) ; db . savePhenotype ( arg0 ) ; github . patchIssue ( arg0 ) ; return arg0 ; }"}, {"instruction": "Generate java code\ngets the iterator as a string . ", "input": " Iterator iterator \n Map.Entry last \n Map map \n boolean canRemove \n Object next \n Object getKey \n Object getValue \n Object setValue \n void reset \n boolean hasNext \n void remove", "output": "String function ( ) { if ( last != null ) { return \"srini_string\" + getKey ( ) + \"srini_string\" + getValue ( ) + \"srini_string\" ; } else { return \"srini_string\" ; } }"}, {"instruction": "Generate java code\nreturns the id given by the given entry 's parent link , or null if it has no parent link . ", "input": " boolean forward \n Logger LOGGER \n Comparator<BaseContentEntry<?>> getUpdatedComparator \n void setContent \n Comparator<BaseContentEntry<?>> getTitleComparator \n int compare \n int compare \n String getXhtmlContent \n Comparator<BaseContentEntry<?>> getReverseUpdatedComparator \n void setParentId \n void setParent", "output": "String function ( BaseContentEntry < ? > arg0 ) { Link loc0 = arg0 . getLink ( SitesLink . Rel . PARENT , ILink . Type . ATOM ) ; if ( loc0 == null ) { return null ; } return loc0 . getHref ( ) ; }"}, {"instruction": "Generate java code\nremove a formula from the cache . take care , remove the object o , invalidate it ! ", "input": " Image image \n ConcurrentMap<CachedTeXFormula,SoftReference<CachedImage>> cache \n String f \n int inset \n Color fgcolor \n AffineTransform identity \n int width \n int type \n ReferenceQueue queue \n int depth \n int size \n int style \n CachedTeXFormula cachedTf \n int max \n int height \n int[] getCachedTeXFormulaDimensions \n int[] getCachedTeXFormulaDimensions \n int[] getCachedTeXFormulaDimensions \n Object paintCachedTeXFormula \n Object paintCachedTeXFormula \n Object paintCachedTeXFormula \n Image getCachedTeXFormulaImage \n Image getCachedTeXFormulaImage \n Image getCachedTeXFormulaImage \n int hashCode \n boolean equals \n void setDimensions \n void clearCache \n SoftReference<CachedImage> makeImage \n void setMaxCachedObjects \n Object getCachedTeXFormula \n Object getCachedTeXFormula", "output": "void function ( Object arg0 ) { if ( arg0 != null && arg0 instanceof CachedTeXFormula ) { cache . remove ( ( CachedTeXFormula ) arg0 ) ; } }"}, {"instruction": "Generate java code\nchecks if the given password matches the hash and salt . the original password should be kept in the database along with its salt . ", "input": " PlaceHolder placeHolder \n byte[] generateSalt \n Map<String,String> hashPassword \n Map<String,String> hashPassword \n byte[] charToBytesASCII \n String byteArrayToHexString \n byte[] hexStringToByteArray", "output": "boolean function ( String arg0 , String arg1 , char [ ] arg2 ) { byte [ ] loc0 = hexStringToByteArray ( arg0 ) ; return arg1 . equals ( hashPassword ( arg2 , loc0 ) . get ( \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nthis method is called right before a worker shuts down ", "input": " long serialVersionUID \n void start", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nverifies if the class of the elements returned by paragraph #end is a paragraph . ", "input": " List<Element> currentContent \n ParaGraph p \n WorkerContextImpl workerContextImpl \n void init \n void verifyContent \n void verifyIfStackOwner", "output": "void function ( ) { final List < Element > loc0 = p . end ( workerContextImpl , new Tag ( \"srini_string\" ) , currentContent ) ; Assert . assertTrue ( loc0 . get ( 0 ) instanceof Paragraph ) ; }"}, {"instruction": "Generate java code\nthis method is invoked at the rpc server when the request is received , but before the call itself is executed ", "input": " PlaceHolder placeHolder \n void serverSendResponse \n void clientStartConnect \n void clientFinishConnect \n void clientSendRequest \n void serverConnecting \n void clientReceiveResponse", "output": "void function ( RPCContext arg0 ) { }"}, {"instruction": "Generate java code\ninsert a contact to the set ", "input": " PastryNode node \n int NUM_OF_COLUMNS \n int NUM_OF_ROWS \n long lastChanged \n RouteSet[][] routingTable \n PastryID nodeId \n void cleanSet \n RouteSet makeBestEntry \n PastryContact getContactWithLongerCommonPrefix \n PastryContact getContactWithLongerCommonPrefix \n RouteSet[] getBestRouteSetRow \n long getLastChanged \n RouteSet getBestRouteSet \n RouteSet getEntrySet \n RouteSet[] getRow \n boolean remove \n Iterator<PastryContact> iterator \n PastryContact getNumericallyClosest \n PastryContact getNumericallyClosest \n void reset \n String toString \n int getNumOfUniqueEntries \n void insertAll", "output": "void function ( PastryContact arg0 ) { if ( arg0 . getOverlayID ( ) . equals ( nodeId ) ) return ; RouteSet loc0 = makeBestEntry ( arg0 . getOverlayID ( ) ) ; if ( ! loc0 . contains ( arg0 ) ) { loc0 . insertEntry ( arg0 ) ; cleanSet ( loc0 ) ; if ( loc0 . contains ( arg0 ) ) lastChanged = Simulator . getCurrentTime ( ) ; } }"}, {"instruction": "Generate java code\ngets the iterator being decorated . ", "input": " Iterator iterator \n Object next \n boolean hasNext \n void remove", "output": "Iterator function ( ) { return iterator ; }"}, {"instruction": "Generate java code\nreturns a synchronized buffer backed by the given buffer . much like the synchronized collections returned by java.util.collections , you must manually synchronize on the returned buffer 's iterator to avoid non-deterministic behavior : buffer b = bufferutils.synchronizedbuffer mybuffer ; synchronized b iterator i = b.iterator ; while i.hasnext process i.next ; ", "input": " Buffer EMPTY_BUFFER \n Buffer predicatedBuffer \n Buffer transformedBuffer \n Buffer unmodifiableBuffer \n Buffer typedBuffer \n Buffer blockingBuffer", "output": "Buffer function ( Buffer arg0 ) { return SynchronizedBuffer . decorate ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the text edits managed by the underlying text edit group . ", "input": " TextEditBasedChange fChange \n TextEditGroup fTextEditGroup \n boolean fIsEnabled \n void setEnabled \n String getName \n IRegion getRegion \n TextEditGroup getTextEditGroup \n boolean isEnabled \n TextEditBasedChange getTextEditChange \n GroupCategorySet getGroupCategorySet", "output": "TextEdit [ ] function ( ) { return fTextEditGroup . getTextEdits ( ) ; }"}, {"instruction": "Generate java code\nhelper method that prints out an integer . ", "input": " PlaceHolder placeHolder \n void print \n void print \n void printMap \n void printList \n void printString \n void printString", "output": "void function ( Integer arg0 , int arg1 ) { for ( int loc0 = 0 ; loc0 < arg1 ; loc0 ++ ) System . out . print ( \"srini_string\" ) ; System . out . println ( \"srini_string\" + arg0 ) ; }"}, {"instruction": "Generate java code\nget preauth handler . ", "input": " KrbSetting krbSetting \n PreauthHandler preauthHandler \n void init \n int generateNonce \n KrbSetting getKrbSetting \n KrbConfig getConfig \n long getTicketValidTime", "output": "PreauthHandler function ( ) { return preauthHandler ; }"}, {"instruction": "Generate java code\nget a set of tokenized words in the sentence . ", "input": " long serialVersionUID \n List<String> links \n List<TokenElement> tokens \n List<LineOffset> offsetMap \n int lineNumber \n String content \n int startPositionOffset \n boolean isFirstSentence \n int getOffsetMapSize \n void setContent \n List<String> getLinks \n void setOffsetMap \n String getContent \n Optional<LineOffset> getOffset \n boolean isFirstSentence \n void setTokens \n int getLineNumber \n int getOffsetPosition \n int hashCode \n boolean equals \n int getStartPositionOffset \n void setIsFirstSentence \n void setLineNumber \n String toString \n List<LineOffset> getOffsetMap \n void addLink", "output": "List < TokenElement > function ( ) { return tokens ; }"}, {"instruction": "Generate java code\ncheck if there are any free cells . ", "input": " boolean[][] newCell \n int[][] grid \n boolean[][] hasCombined \n boolean canMoveLeft \n int getCell \n boolean canMoveDown \n void generateNextCell \n void moveDown \n void resetGrid \n void resetMoved \n int getSize \n boolean canMoveUp \n boolean canMoveRight \n void moveRight \n void moveLeft \n boolean IsCellNew \n void initializeGame \n void moveUp", "output": "boolean function ( ) { for ( int loc0 = 0 ; loc0 < grid . length ; loc0 ++ ) { for ( int loc1 = 0 ; loc1 < grid . length ; loc1 ++ ) { if ( grid [ loc0 ] [ loc1 ] == 0 ) return false ; } } return true ; }"}, {"instruction": "Generate java code\nreturns what kind of occurrences the query should look for . ", "input": " IJavaSearchScope fScope \n String fScopeDescription \n int fLimitTo \n String getScopeDescription \n IJavaSearchScope getScope", "output": "int function ( ) { return fLimitTo ; }"}, {"instruction": "Generate java code\nreturn root schema with schema owner as the given user . ", "input": " List<SchemaPlus> schemaTreesToClose \n boolean isImpersonationEnabled \n org.slf4j.Logger logger \n DrillbitContext dContext \n void addSchemasToCloseList \n void close", "output": "SchemaPlus function ( final String arg0 , final SchemaConfigInfoProvider arg1 ) { final String loc0 = isImpersonationEnabled ? arg0 : ImpersonationUtil . getProcessUserName ( ) ; final SchemaConfig loc1 = SchemaConfig . newBuilder ( loc0 , arg1 ) . build ( ) ; return createRootSchema ( loc1 ) ; }"}, {"instruction": "Generate java code\ncreate and return a builder from system properties . ", "input": " String PROP_WEBTESTS_BROWSER \n String PROP_WEBTESTS_LOCALES \n String PROP_WEBTESTS_HUB_URL \n ChromeBuildr chrome \n SafariBuildr safari \n WebDriver build \n FirefoxBuildr firefox \n RemoteBuildr remote", "output": "SysPropsBuildr function ( ) { return new SysPropsBuildr ( ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable version of the given non-null intlistiterator . ", "input": " IntListIterator EMPTY_INT_LIST_ITERATOR \n IntList EMPTY_INT_LIST \n IntIterator EMPTY_INT_ITERATOR \n IntListIterator singletonIntListIterator \n IntListIterator getEmptyIntListIterator \n IntIterator unmodifiableIntIterator \n IntIterator singletonIntIterator \n IntList getEmptyIntList \n IntIterator getEmptyIntIterator \n IntList unmodifiableIntList \n IntList singletonIntList", "output": "IntListIterator function ( IntListIterator arg0 ) { if ( null == arg0 ) { throw new NullPointerException ( ) ; } return UnmodifiableIntListIterator . wrap ( arg0 ) ; }"}, {"instruction": "Generate java code\nmaybe return directly context ", "input": " EntityManager entityManager \n SecurityScreenDomainService securityService \n Logger log \n ContextDomainService contextDomainService \n CommonDomainService commonService \n ResourceTypeProvider resourceTypeProvider \n ContextEntity getContextByName \n void saveEnvironment \n String deleteContext \n ContextEntity getContextWithType \n ContextEntity createContextByName", "output": "Query function ( Integer arg0 ) { return entityManager . createQuery ( \"srini_string\" ) . setParameter ( \"srini_string\" , arg0 ) ; }"}, {"instruction": "Generate java code\nalso starts the stopwatch . ", "input": " DecimalFormat[] timeFormat \n long elapsedMillis \n long startTime \n void stop \n String stop_start \n void clear \n void start \n String format \n String format \n long elapsedMillis \n double elapsedSeconds \n long snapshot", "output": "void function ( ) { startTime = 0 ; elapsedMillis = 0 ; start ( ) ; }"}, {"instruction": "Generate java code\nclears the stack , reseting its capacity to the default . ", "input": " TShortArrayList _list \n int DEFAULT_CAPACITY \n short pop \n short[] toNativeArray \n void toNativeArray \n int size \n void reset \n void push \n short peek", "output": "void function ( ) { _list . clear ( DEFAULT_CAPACITY ) ; }"}, {"instruction": "Generate java code\nappend newstring to the end of oldstring . ", "input": " int nextBits \n int dstIndex \n byte stringTable[][] \n int bytePointer \n int h \n int andTable[] \n byte uncompData[] \n byte data[] \n int samplesPerPixel \n int bitsToGet \n int nextData \n int w \n int predictor \n int tableIndex \n int bitPointer \n void addStringToTable \n void addStringToTable \n void initializeStringTable \n byte[] decode \n void writeString \n int getNextCode", "output": "byte [ ] function ( byte arg0 [ ] , byte arg1 ) { int loc0 = arg0 . loc0 ; byte loc1 [ ] = new byte [ loc0 + 1 ] ; System . arraycopy ( arg0 , 0 , loc1 , 0 , loc0 ) ; loc1 [ loc0 ] = arg1 ; return loc1 ; }"}, {"instruction": "Generate java code\ninvokes the underlying map #put object , object method . ", "input": " Map map \n Set entrySet \n boolean containsKey \n Collection values \n void clear \n boolean isEmpty \n boolean containsValue \n Object remove \n int size \n int hashCode \n boolean equals \n Object get \n void putAll \n Set keySet", "output": "Object function ( Object arg0 , Object arg1 ) { return map . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nget the loader for the given class . ", "input": " Log log \n Class loadClass \n Class loadClass", "output": "ClassLoader function ( Class arg0 ) { ClassLoader loc0 = arg0 . getClassLoader ( ) ; if ( loc0 == null ) { loc0 = ClassLoader . getSystemClassLoader ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\na helper to get the string fields from the r class ", "input": " PlaceHolder placeHolder \n Class resolveRClass", "output": "String [ ] function ( Context arg0 ) { Class loc0 = resolveRClass ( arg0 . getPackageName ( ) ) ; if ( loc0 != null ) { return Libs . toStringArray ( loc0 . getFields ( ) ) ; } return new String [ 0 ] ; }"}, {"instruction": "Generate java code\nattach a non-null propertychangelistener to this object . ", "input": " IPropertyDescriptor[] EMPTY_ARRAY \n PropertyChangeSupport pcsDelegate \n long serialVersionUID \n void firePropertyChange \n Object getPropertyValue \n void setPropertyValue \n Object getEditableValue \n IPropertyDescriptor[] getPropertyDescriptors \n void resetPropertyValue \n boolean isPropertySet \n void removePropertyChangeListener \n void readObject", "output": "void function ( PropertyChangeListener arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( ) ; } pcsDelegate . addPropertyChangeListener ( arg0 ) ; }"}, {"instruction": "Generate java code\nessentially the same as #resolverooturl class , but here we convert the root url to a file directory reference . in fact we delegate to #resolverooturl class and simply convert itsreturn into a file reference . ", "input": " PlaceHolder placeHolder \n URL resolveRootUrl \n File resolveClassFile", "output": "File function ( Class arg0 ) { try { return new File ( resolveRootUrl ( arg0 ) . toURI ( ) ) ; } catch ( URISyntaxException loc0 ) { throw new RuntimeException ( \"srini_string\" , loc0 ) ; } }"}, {"instruction": "Generate java code\nmakes a note of the resource adapter identifier with which a resource adapter named raname is registered in the org.jboss.jca.core.spi.rar.resourceadapterrepository . subsequent calls to #getregisteredresourceadapteridentifier string with the passed raname returnthe raidentifier ", "input": " ServiceName RESOURCE_ADAPTER_SERVICE_PREFIX \n ServiceName BOOTSTRAP_CONTEXT_SERVICE \n ServiceName RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX \n ServiceName CONNECTION_VALIDATOR_SERVICE \n ServiceName TRANSACTION_INTEGRATION_SERVICE \n ServiceName ARCHIVE_VALIDATION_CONFIG_SERVICE \n ServiceName RESOURCEADAPTERS_SERVICE \n ServiceName DATASOURCES_SERVICE \n ServiceName TRACER_CONFIG_SERVICE \n ServiceName CCM_SERVICE \n String STATISTICS_SUFFIX \n ServiceName NON_JTA_DS_RA_REPOSITORY_SERVICE \n ServiceName DISTRIBUTED_WORKMANAGER_STATS_SERVICE \n ServiceName IRONJACAMAR_RESOURCE \n ServiceName BEAN_VALIDATION_CONFIG_SERVICE \n ServiceName NON_TX_CCM_SERVICE \n ServiceName IDLE_REMOVER_SERVICE \n ServiceName RESOURCE_ADAPTER_REGISTRY_SERVICE \n Map<String,String> resourceAdapterRepositoryIdentifiers \n ServiceName RA_REPOSITORY_SERVICE \n ServiceName JDBC_DRIVER_REGISTRY_SERVICE \n ServiceName RESOURCE_ADAPTER_ACTIVATOR_SERVICE \n ServiceName RA_SERVICE \n ServiceName INACTIVE_RESOURCE_ADAPTER_SERVICE \n ServiceName WORKMANAGER_STATS_SERVICE \n ServiceName RESOURCE_ADAPTER_DEPLOYMENT_SERVICE_PREFIX \n ServiceName RESOURCEADAPTERS_SUBSYSTEM_SERVICE \n ServiceName CONNECTOR_CONFIG_SERVICE \n ServiceName WORKMANAGER_SERVICE \n ServiceName IRONJACAMAR_MDR \n ServiceName MANAGEMENT_REPOSITORY_SERVICE \n void unregisterResourceAdapterIdentifier \n T notNull \n ServiceName getDeploymentServiceName \n ServiceName getDeploymentServiceName \n ServiceName getDeploymentServiceName \n String getRegisteredResourceAdapterIdentifier \n ServiceName getResourceAdapterServiceName \n String stripDotRarSuffix", "output": "void function ( final String arg0 , final String arg1 ) { synchronized ( resourceAdapterRepositoryIdentifiers ) { resourceAdapterRepositoryIdentifiers . put ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nenables periodic lookups for measurement purposes . these look up random keys and are scheduled in a constant interval . ", "input": " Node<T> myNode \n PeerStatus peerStatus \n Logger log \n ComponentsConfig config \n boolean lookupEnabled \n void connectivityChanged \n void beginPeriodicLookups \n void doConnect \n void routingTableBuilt \n void doSingleLookup \n void doDisconnect \n PeerStatus getPeerStatus \n double getSimSec", "output": "void function ( ) { lookupEnabled = true ; beginPeriodicLookups ( ) ; }"}, {"instruction": "Generate java code\nparses the splitter info . ", "input": " int dkconfig_compile_timeout \n Logger debug \n FileCompiler fileCompiler \n boolean dkconfig_delete_splitters_on_exit \n String tempdir \n int guid \n String dkconfig_compiler \n boolean matchPptRegex \n void compileFiles \n void loadSplitters \n String createTempDir \n void load_splitters \n String clean \n boolean matchPpt \n String getFileName \n String getTempDir \n void printAll \n void debugPrintln", "output": "SpinfoFileParser function ( File arg0 ) { if ( tempdir == null ) { tempdir = createTempDir ( ) ; } if ( ! dkconfig_delete_splitters_on_exit ) { System . out . println ( \"srini_string\" + tempdir ) ; } return new SpinfoFileParser ( arg0 , tempdir ) ; }"}, {"instruction": "Generate java code\nsole entry point to application , as always . ", "input": " PlaceHolder placeHolder \n void printCapitalized", "output": "void function ( String [ ] arg0 ) { String loc0 ; TextIO . putln ( \"srini_string\" ) ; loc0 = TextIO . getln ( ) ; TextIO . putln ( ) ; TextIO . putln ( \"srini_string\" ) ; printCapitalized ( loc0 ) ; }"}, {"instruction": "Generate java code\nencode a float to the byte array at the given position . will throw indexoutofbounds if it overflows . users should ensure that there are at least 4 bytes left in the buffer before calling this method . ", "input": " ThreadLocal<Decoders> DECODERS \n BinaryDecoder decoder \n BinaryDecoder d1 \n ThreadLocal<HashData> HASH_DATA \n BinaryDecoder d2 \n int compare \n int compare \n int compare \n int encodeDouble \n void set \n void set \n int hashBytes \n int encodeLong \n int skipLong \n int hashCode \n int hashCode \n int encodeBoolean \n void clear \n int compareBytes \n Decoders initialValue \n HashData initialValue \n int encodeInt", "output": "int function ( float arg0 , byte [ ] arg1 , int arg2 ) { int loc0 = 1 ; int loc1 = Float . floatToRawIntBits ( arg0 ) ; arg1 [ arg2 ] = ( byte ) ( ( loc1 ) & 0xFF ) ; arg1 [ arg2 + loc0 ++ ] = ( byte ) ( ( loc1 >>> 8 ) & 0xFF ) ; arg1 [ arg2 + loc0 ++ ] = ( byte ) ( ( loc1 >>> 16 ) & 0xFF ) ; arg1 [ arg2 + loc0 ++ ] = ( byte ) ( ( loc1 >>> 24 ) & 0xFF ) ; return 4 ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable , empty shortlist . ", "input": " ShortList EMPTY_SHORT_LIST \n ShortListIterator EMPTY_SHORT_LIST_ITERATOR \n ShortIterator EMPTY_SHORT_ITERATOR \n ShortListIterator getEmptyShortListIterator \n ShortIterator singletonShortIterator \n ShortList unmodifiableShortList \n ShortListIterator singletonShortListIterator \n ShortIterator unmodifiableShortIterator \n ShortListIterator unmodifiableShortListIterator \n ShortList singletonShortList \n ShortIterator getEmptyShortIterator", "output": "ShortList function ( ) { return EMPTY_SHORT_LIST ; }"}, {"instruction": "Generate java code\nfor testing purposes only . clears the cached buffer to force a new allocation on the next invocation . ", "input": " long CHANNEL_FIELD_OFFSET \n float BUFFER_REALLOCATION_THRESHOLD \n int MAX_CACHED_BUFFER_SIZE \n int MIN_CACHED_BUFFER_SIZE \n ThreadLocal<SoftReference<byte[]>> BUFFER \n Class<?> FILE_OUTPUT_STREAM_CLASS \n boolean needToReallocate \n byte[] getOrCreateBuffer \n byte[] getBuffer \n void setBuffer \n long getChannelFieldOffset \n Class<?> safeGetClass \n void write \n boolean writeToChannel", "output": "void function ( ) { BUFFER . set ( null ) ; }"}, {"instruction": "Generate java code\npaints an overlay edge ", "input": " Set<Class<? extends Object>> overlayImpls \n VisAnalyzer analyzer \n void handleOverlayMsg \n void handleOperation \n void addOverlayUniverseMetric \n void handleNewHost \n void handleLeavingHost \n boolean isDedicatedOverlayImplFor \n void addOverlayNodeMetric \n void addOverlayImpl \n Translator getTranslator \n Object getBootstrapManagerFor \n String getOverlayName \n void removeEdge \n void addOverlayEdgeMetric \n SchematicPositioner getNewPositioner \n void handleNewHostAfter \n void flashEdge \n void flashEdge \n void flashEdge \n void flashEdge \n void setParentAnalyzer", "output": "EdgeHandle function ( NetID arg0 , NetID arg1 ) { return addEdge ( arg0 , arg1 , null , Color . GREEN , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the current undoable pointed to by the internal cursor if it is an undoableedit object . ", "input": " int MAX_QUEUE_SIZE \n Document doc \n UndoableList queue \n int cursor \n void add \n boolean isRedoable \n void prefsTrim \n String getUndoRangeString \n String getRedoName \n void clear \n boolean isEmpty \n String getRedoRangeString \n void destroy \n void redo \n int getSize \n void undo \n String getUndoName \n void trim \n boolean isUndoable \n Undoable get \n void redoAll \n void undoAll", "output": "UndoableEdit function ( ) { Undoable loc0 = get ( ) ; if ( loc0 instanceof UndoableEdit ) { return ( UndoableEdit ) loc0 ; } else { return null ; } }"}, {"instruction": "Generate java code\nadd a scoreboard for a player ", "input": " int gameID \n Team deadTeam \n Objective sidebarObjective \n Team waitingTeam \n Scoreboard scoreboard \n ArrayList<String> activePlayers \n Team livingTeam \n HashMap<String,Scoreboard> originalScoreboard \n void playerDead \n void addPlayer \n void playerLiving \n void reset \n void removeScoreboard \n void incScore \n void removePlayer \n void updateSidebarTitle", "output": "void function ( final Player arg0 ) { Scoreboard loc0 = arg0 . getScoreboard ( ) ; if ( loc0 != null ) { this . originalScoreboard . put ( arg0 . getName ( ) , loc0 ) ; } arg0 . setScoreboard ( this . scoreboard ) ; }"}, {"instruction": "Generate java code\nchecks if a given string is a valid person email . ", "input": " boolean isPrivate \n String EMAIL_VALIDATION_REGEX \n String MESSAGE_EMAIL_CONSTRAINTS \n String value \n String EXAMPLE \n int hashCode \n boolean equals \n String toString \n boolean isPrivate", "output": "boolean function ( String arg0 ) { return arg0 . matches ( EMAIL_VALIDATION_REGEX ) ; }"}, {"instruction": "Generate java code\nregister a process ' handle ", "input": " ConcurrentHashMap<String,Shutdownable> processMap \n Logger LOG \n Object lock \n void killProcess \n Collection<Shutdownable> getAllProcessHandles \n void killAllProcesses", "output": "void function ( String arg0 , Shutdownable arg1 ) { processMap . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns an array of all the eventsources ", "input": " String url \n List<Event> getEvents \n List<Event> getEvents \n List<Event> getEvents \n List<Event> getEvents \n String getURL \n List<Event> parseEvents", "output": "EventSource [ ] function ( ) { return new EventSource [ ] { EventSource . CENTAURO , EventSource . COURSE , EventSource . PLATFORM , EventSource . PERSONAL } ; }"}, {"instruction": "Generate java code\nends up being a bit faster than math.round . this merely rounds its argument to the nearest int , where x. 5 rounds up . ", "input": " BitMatrix image \n int CORR \n int width \n int rightInit \n int downInit \n int INIT_SIZE \n int height \n int leftInit \n int upInit \n ResultPoint[] centerEdges \n int distanceL2 \n ResultPoint[] detect \n ResultPoint getBlackPointOnSegment \n boolean containsBlackPoint", "output": "int function ( float arg0 ) { return ( int ) ( arg0 + 0.5f ) ; }"}, {"instruction": "Generate java code\nquery if this ring is a field . ", "input": " java.math.BigDecimal val \n int DEFAULT_PRECISION \n BigDecimal ZERO \n MathContext DEFAULT_CONTEXT \n MathContext context \n BigDecimal ONE \n Random random \n boolean isCommutative \n BigDecimal gcd \n BigDecimal sum \n int compareTo \n java.math.BigInteger characteristic \n BigDecimal random \n BigDecimal random \n BigDecimal random \n BigDecimal random \n int hashCode \n BigDecimal divide \n BigDecimal copy \n BigDecimal multiply \n int signum \n boolean isONE \n BigDecimal inverse \n BigDecimal valueOf \n BigDecimal valueOf \n boolean isUnit \n BigDecimal subtract \n BigDecimal parse \n BigDecimal parse \n BigDecimal[] egcd \n BigDecimal abs \n BigDecimal[] divideAndRemainder \n BigDecimal negate \n boolean equals \n BigDecimal clone \n BigDecimal getONE \n BigDecimal getZERO \n BigDecimal fromInteger \n BigDecimal fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n BigDecimal remainder", "output": "boolean function ( ) { return true ; }"}, {"instruction": "Generate java code\ngets the job output key schema . ", "input": " String CONF_INPUT_KEY_SCHEMA \n String CONF_OUTPUT_KEY_SCHEMA \n String CONF_INPUT_VALUE_SCHEMA \n String CONF_OUTPUT_VALUE_SCHEMA \n String CONF_OUTPUT_CODEC \n void setMapOutputKeySchema \n Schema getInputKeySchema \n void setDataModelClass \n void setOutputValueSchema \n Schema getMapOutputKeySchema \n void setOutputKeySchema \n Schema getInputValueSchema \n Schema getMapOutputValueSchema \n void setMapOutputValueSchema \n void setInputKeySchema \n Schema getOutputValueSchema \n void setInputValueSchema", "output": "Schema function ( Configuration arg0 ) { String loc0 = arg0 . get ( CONF_OUTPUT_KEY_SCHEMA ) ; return loc0 != null ? Schema . parse ( loc0 ) : null ; }"}, {"instruction": "Generate java code\nadds a new item , which compares as equal to the given existing item . ", "input": " int UNKNOWN_AFTER \n int counter \n int unknownObjectBehavior \n boolean isLocked \n int UNKNOWN_BEFORE \n int UNKNOWN_THROW_EXCEPTION \n Map map \n boolean add \n void setUnknownObjectBehavior \n int compare \n void checkLocked \n int getUnknownObjectBehavior \n boolean isLocked", "output": "boolean function ( Object arg0 , Object arg1 ) { checkLocked ( ) ; Integer loc0 = ( Integer ) map . get ( arg0 ) ; if ( loc0 == null ) { throw new IllegalArgumentException ( arg0 + \"srini_string\" + this ) ; } Object loc1 = map . put ( arg1 , loc0 ) ; return ( loc1 == null ) ; }"}, {"instruction": "Generate java code\nthis method verifies and ensures display initialization . verification is based on synchronous execution of empty runnable . ", "input": " ArrayList<IDisplayIntrospectionListener> listeners \n ThreadGroup root \n long retryTime \n Display findDisplay \n Display doRun \n Display syncIntrospect \n void removeIntrospectionListener \n void run \n void asyncIntrospect \n Display visit \n void addIntrospectionListener", "output": "void function ( Display arg0 ) { while ( ! arg0 . isDisposed ( ) ) { try { new DisplayReference ( arg0 ) . execute ( new Callable < Boolean > ( ) { public Boolean call ( ) throws Exception { return true ; } } , 30000 ) ; break ; } catch ( Throwable loc0 ) { continue ; } } }"}, {"instruction": "Generate java code\nisempty returns true if this queue is empty , false otherwise . ", "input": " SListNode head \n int size \n SListNode tail \n void enqueue \n Object nth \n int size \n Object dequeue \n String toString \n Object front \n void append", "output": "boolean function ( ) { return size == 0 ; }"}, {"instruction": "Generate java code\nreturn the set of engines that we support given as an argument but the user has n't explicitly declined on another device . can return the input if the user has n't declined any engines . ", "input": " Long storageVersion \n JSONArray declined \n Map<String,Integer> versions \n ExtendedJSONObject engines \n AuthHeaderProvider authHeaderProvider \n MetaGlobalDelegate callback \n String LOG_TAG \n String metaURL \n Map<String,String> syncIDs \n Map<String,MetaGlobalException> exceptions \n String syncID \n boolean isUploading \n Long getStorageVersion \n void upload \n String credentials \n void recordEngineState \n String ifUnmodifiedSince \n void setEngines \n void declineEngine \n ExtendedJSONObject getEngines \n void verifyEngineSettings \n void handleRequestFailure \n void handleRequestError \n void setStorageVersion \n void setDeclinedEngineNames \n Set<String> getDeclinedEngineNames \n void handleUploadSuccess \n String getSyncID \n void setSyncID \n void handleDownloadSuccess \n void setFromRecord \n CryptoRecord asCryptoRecord \n void handleRequestSuccess \n Set<String> getEnabledEngineNames \n AuthHeaderProvider getAuthHeaderProvider \n void fetch \n ExtendedJSONObject asRecordContents \n void declineEngineNames", "output": "Set < String > function ( Set < String > arg0 ) { if ( this . declined == null || this . declined . isEmpty ( ) ) { return arg0 ; } final Set < String > loc0 = new HashSet < String > ( arg0 ) ; loc0 . removeAll ( this . declined ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the `` return block '' for a given `` caller block '' . ", "input": " Block entry \n Block exit \n ArrayList paths \n FlowGraph graph \n LocalVariable returnAddress \n void setReturnAddress \n int numPaths \n void setExit \n FlowGraph graph \n void addPath \n LocalVariable returnAddress \n void removePathsContaining \n void removePath \n Block entry \n Block exit \n void print \n Block pathSource \n Collection paths \n String toString \n void removeAllPaths \n void setEntry", "output": "Block function ( final Block arg0 ) { for ( int loc0 = 0 ; loc0 < paths . size ( ) ; loc0 ++ ) { final Block [ ] loc1 = ( Block [ ] ) paths . get ( loc0 ) ; if ( loc1 [ 0 ] == arg0 ) { return loc1 [ 1 ] ; } } return null ; }"}, {"instruction": "Generate java code\nintended for info.monitorenter.gui.chart.axis.aaxis only . ", "input": " AUnit UNIT_UNCHANGED \n PropertyChangeSupport m_propertyChangeSupport \n long serialVersionUID \n IAxis<?> m_axis \n int hashCode \n boolean equals \n void initPaintIteration \n int getMaxAmountChars \n void setAxis \n void addPropertyChangeListener \n AUnit getUnit \n void removePropertyChangeListener", "output": "IAxis < ? > function ( ) { return this . m_axis ; }"}, {"instruction": "Generate java code\ninternal use only ", "input": " List<RunListener> fListeners \n boolean fPleaseStop \n List<RunListener> fCurrentListeners \n void fireTestIgnored \n void fireTestRunFinished \n void notifyListener \n void run \n void fireTestFailures \n void removeListener \n void pleaseStop \n void fireTestFailure \n void fireTestFinished \n void fireTestAssumptionFailed \n void fireTestRunStarted \n void fireTestStarted \n void addFirstListener", "output": "void function ( RunListener arg0 ) { fListeners . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nperform the click . this is intended to be overridden in subclasses ", "input": " BasicWidgetSelector _selector \n MenuReference showContextMenu \n boolean unspecifiedXY \n Point getXYOffset \n IWidgetLocator click \n IWidgetLocator contextClick", "output": "Widget function ( int arg0 , Widget arg1 , Point arg2 , int arg3 ) { return _selector . click ( arg1 , arg2 . x , arg2 . y , arg3 , arg0 ) ; }"}, {"instruction": "Generate java code\nreturn the directory into which we put our self-extracted native libraries and make sure it exists . ", "input": " byte[] cachedBuffer \n void reliablyCopyExecutable \n void deleteOrThrow \n FileLocker lockLibsDirectory \n void freeCopyBuffer \n File getLibsDirectory \n int findAbiScore \n void dumbDeleteRecrusive \n String[] getSupportedAbis \n String[] getSupportedAbis \n void fallocateIfSupported \n void fallocate", "output": "File function ( Context arg0 ) { File loc0 = getLibsDirectory ( arg0 ) ; if ( ! loc0 . isDirectory ( ) && ! loc0 . mkdirs ( ) ) { throw new RuntimeException ( \"srini_string\" ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns if the status ' severity is info . ", "input": " IStatus OK_STATUS \n String fStatusMessage \n int fSeverity \n boolean isWarning \n int getSeverity \n Throwable getException \n String getMessage \n boolean isMultiStatus \n boolean matches \n IStatus[] getChildren \n boolean isError \n void setError \n boolean isOK \n String getPlugin \n void setOK \n void setInfo \n int getCode \n void setWarning", "output": "boolean function ( ) { return fSeverity == IStatus . INFO ; }"}, {"instruction": "Generate java code\ncreate a new closure that calls one of the closures depending on the predicates . the map consists of predicate keys and closure values . a closure is called if its matching predicate returns true . each predicate is evaluated until one returns true . if no predicates evaluate to true , the default closure is called . the default closure is set in the map with a null key . the ordering is that of the iterator method on the entryset collection of the map . ", "input": " PlaceHolder placeHolder \n Closure nopClosure \n Closure chainedClosure \n Closure chainedClosure \n Closure chainedClosure \n Closure forClosure \n Closure invokerClosure \n Closure invokerClosure \n Closure ifClosure \n Closure whileClosure \n Closure doWhileClosure \n Closure switchMapClosure \n Closure asClosure \n Closure exceptionClosure", "output": "Closure function ( Map arg0 ) { return SwitchClosure . getInstance ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the iterator this iterator is using . ", "input": " Iterator iterator \n Transformer transformer \n Object next \n Object transform \n Transformer getTransformer \n boolean hasNext \n void setTransformer \n void remove \n void setIterator", "output": "Iterator function ( ) { return iterator ; }"}, {"instruction": "Generate java code\ncreate an iterator iterator wrappingthe specified longiterator longiterator . when the given iterator is null , returns null . ", "input": " LongIterator _iterator \n Object next \n boolean hasNext \n void remove", "output": "Iterator function ( LongIterator arg0 ) { return null == arg0 ? null : new LongIteratorIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\nverifies that the data was signed with the given signature , and returns the verified purchase . the data is in json format and signed with a private key . the data also contains the purchasestate and product id of the purchase . ", "input": " String TAG \n String KEY_FACTORY_ALGORITHM \n String SIGNATURE_ALGORITHM \n PublicKey generatePublicKey \n boolean verify", "output": "boolean function ( String arg0 , String arg1 , String arg2 ) { if ( TextUtils . isEmpty ( arg1 ) || TextUtils . isEmpty ( arg0 ) || TextUtils . isEmpty ( arg2 ) ) { } PublicKey loc0 = Security . generatePublicKey ( arg0 ) ; return Security . verify ( loc0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nimplement a hash code for this comparator that is consistent with #equals object equals . ", "input": " BooleanComparator TRUE_FIRST \n long serialVersionUID \n BooleanComparator FALSE_FIRST \n boolean trueFirst \n BooleanComparator getTrueFirstComparator \n int compare \n int compare \n BooleanComparator getBooleanComparator \n boolean equals \n boolean sortsTrueFirst \n BooleanComparator getFalseFirstComparator", "output": "int function ( ) { int loc0 = \"srini_string\" . hashCode ( ) ; return trueFirst ? - 1 * loc0 : loc0 ; }"}, {"instruction": "Generate java code\nthis method attempts to grow an array by allocating a new array and copying all elements . ", "input": " PlaceHolder placeHolder \n Object goodCopyOf \n void main", "output": "Object [ ] function ( Object [ ] arg0 , int arg1 ) { Object [ ] loc0 = new Object [ arg1 ] ; System . arraycopy ( arg0 , 0 , loc0 , 0 , Math . min ( arg0 . length , arg1 ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\nperform actions ", "input": " Logger LOGGER \n void goToSleep \n void goToMine \n void wakeUp \n void goHome \n void work \n String name", "output": "void function ( Action ... arg0 ) { for ( Action loc0 : arg0 ) { loc0 ( loc0 ) ; } }"}, {"instruction": "Generate java code\nhas an association with the specified key been visited already ? ", "input": " Set<AssociationKey> visitedAssociationKeys \n SessionFactoryImplementor factory \n PropertyPath currentPropertyPath \n Logger log \n AssociationVisitationStrategy strategy \n void visitEntityDefinition \n void visitCollectionElements \n void visitCompositeDefinition \n void visitAnyDefinition \n void visitCollectionDefinition \n void visitAttributes \n void visitCollection \n void visitIdentifierDefinition \n void visitEntity \n void addAssociationKey \n void visitAssociation \n void visitCollectionIndex \n void visitAttributeDefinition", "output": "boolean function ( AssociationKey arg0 ) { return visitedAssociationKeys . contains ( arg0 ) || strategy . isDuplicateAssociationKey ( arg0 ) ; }"}, {"instruction": "Generate java code\nparses a style given an externalized string representation ", "input": " String name \n Association association \n Style style \n Style getStyle \n Association getAssociation \n String toString \n String toString", "output": "Style function ( String arg0 ) { if ( SELECT . arg0 . equals ( arg0 ) ) { return SELECT ; } else { return JOIN ; } }"}, {"instruction": "Generate java code\nwhen syncing entities under some sync root , the user can restrict what types of entities will be synced . i.e. you can issue a sync of a feed but restrict the sync only to resource types . this will in effect make sure that the feed only defines the resource types you instruct it to but all the metric types , resource , metrics , etc. that exist under the feed but were not mentioned in the provided inventory structure will be left intact . ", "input": " EnumSet<SegmentType> syncedTypes \n boolean deepSearch \n SyncConfiguration DEFAULT \n boolean deepSearch \n EnumSet<SegmentType> syncedTypes \n Builder withoutType \n boolean isDeepSearch \n Builder withDeepSearch \n SyncConfiguration build \n Builder builder \n Builder withAllTypes \n Builder withoutTypes \n Builder withoutTypes \n Builder withType \n Builder withTypes \n Builder withTypes", "output": "Set < SegmentType > function ( ) { return syncedTypes ; }"}, {"instruction": "Generate java code\ncreate junitall.java that calls all testclasses suites to be generated . ", "input": " FileWriter fw \n void addTestSuite \n void addTest \n void addTest \n void finish", "output": "void function ( String arg0 ) { if ( fw != null ) { return ; } assert arg0 != null ; File loc0 = CreateFileUtil . createOutFile ( arg0 , \"srini_string\" ) ; try { fw = new FileWriter ( loc0 ) ; fw . write ( junitAllHeader ) ; } catch ( IOException loc1 ) { loc1 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\ntest method for org.jboss.security.config.securityconfiguration #getcipheralgorithm . ", "input": " PlaceHolder placeHolder \n void testSetIterationCount \n void testGetKeyStoreURL \n void testGetSalt \n void testGetTrustStoreType \n void testGetKeyStoreType \n void testSetTrustStoreURL \n void testSetKeyStoreURL \n void testSetSalt \n void testLoadPassword \n void testSetCipherSpec \n void testGetExternalPasswordCacheInstance \n void testSetKeyStoreType \n void testIsDeepCopySubjectMode \n void testGetKeyStorePass \n WebArchive deployment \n void testSetTrustStorePass \n void testGetTrustStorePass \n void testSetCipherAlgorithm \n void testSetTrustStoreType \n void testGetTrustStoreURL \n void testSetDeepCopySubjectMode \n void testGetCipherSpec \n void testAddApplicationPolicy \n void testGetApplicationPolicy \n void testSetKeyStorePass \n void testRemoveApplicationPolicy \n void testSetCipherKey \n void testGetIterationCount \n void testGetCipherKey", "output": "void function ( ) { SecurityConfiguration . getCipherAlgorithm ( ) ; }"}, {"instruction": "Generate java code\nsets the color to the graphics context if it is different and returns the previous one of the graphics context or null if there was no change . ", "input": " int m_red \n int m_blue \n int m_green \n int m_alpha \n Color m_color \n Color applyColorUnconditionally \n Color getColor \n int setAlpha \n int getBlue \n int setGreen \n int setRed \n int getAlpha \n int getGreen \n int getRed \n Color setColor \n int setBlue \n int hashCode \n boolean equals \n void assertColorValue", "output": "Color function ( final Graphics arg0 ) { Color loc0 = null ; if ( this . m_color != null ) { final Color loc1 = arg0 . getColor ( ) ; if ( ! loc1 . equals ( this . m_color ) ) { loc0 = loc1 ; arg0 . setColor ( this . m_color ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\ncalled to write an enum value . may be overridden for alternate enum representations . ", "input": " GenericData data \n Schema root \n NullPointerException npe \n void writeWithoutConversion \n Iterator<? extends Object> getArrayElements \n void writeFixed \n Object convert \n void writeField \n int getMapSize \n void error \n void writeMap \n void setSchema \n void writeRecord \n void writeBytes \n void writeArray \n Iterable<Map.Entry<Object,Object>> getMapEntries \n int resolveUnion \n long getArraySize \n void write \n void write \n void writeString \n void writeString \n GenericData getData", "output": "void function ( Schema arg0 , Object arg1 , Encoder arg2 ) { if ( ! data . isEnum ( arg1 ) ) throw new AvroTypeException ( \"srini_string\" + arg1 ) ; arg2 . writeEnum ( arg0 . getEnumOrdinal ( arg1 . toString ( ) ) ) ; }"}, {"instruction": "Generate java code\ntest method for com.flatironschool.javacs.mylinearmap #values . ", "input": " Map<String,Integer> map \n void testContainsValue \n void testClear \n void testKeySet \n void testGet \n void testIsEmpty \n void testRemove \n void testSize \n void setUp \n void testContainsKey \n void testPut \n void testPutAll", "output": "void function ( ) { Collection < Integer > loc0 = map . values ( ) ; assertThat ( loc0 . size ( ) , is ( 4 ) ) ; assertThat ( loc0 . contains ( 3 ) , is ( true ) ) ; assertThat ( loc0 . contains ( 0 ) , is ( true ) ) ; assertThat ( loc0 . contains ( 4 ) , is ( false ) ) ; }"}, {"instruction": "Generate java code\nfinds a single todo entry . ", "input": " TodoCrudService crudService \n Logger LOGGER \n TodoDTO create \n TodoDTO update \n TodoDTO delete \n List<TodoDTO> findAll", "output": "TodoDTO function ( @ PathVariable ( \"srini_string\" ) Long arg0 ) { LOGGER . info ( \"srini_string\" , arg0 ) ; TodoDTO loc0 = crudService . findById ( arg0 ) ; LOGGER . info ( \"srini_string\" , loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn true if debugging is enabled . ", "input": " PrintWriter sysOut \n ILog log \n boolean isDebugging \n void setLog \n void trace \n void trace \n void setDebugging \n boolean isTracing \n void traceSleep \n void close", "output": "boolean function ( ) { return isDebugging ; }"}, {"instruction": "Generate java code\nin output , m = modified , u = unmodified , x = missing . capital letters indicate the specified modbit does occur , lowercase letters indicate it does not occur . ", "input": " int MODIFIED_BITVAL \n int[] mods \n int MISSING_FLOW_BITVAL \n Object[] vals \n int STATIC_CONSTANT \n int[] tuplemod_not_missing \n int[] tuplemod_modified_not_missing \n int MISSING_NONSENSICAL \n int UNMODIFIED_BITVAL \n int MODBIT_VALUES \n int MISSING_NONSENSICAL_BITVAL \n int MODIFIED \n int MISSING_FLOW \n int UNMODIFIED \n Logger debug \n int TUPLEMOD_VALUES \n boolean tuplemodHasUnmodified \n ValueTuple makeUninterned \n boolean modIsMissingFlow \n boolean tuplemodHasMissingNonsensical \n boolean modIsModified \n String valsToString \n boolean tuplemodHasMissingFlow \n ValueTuple shallowcopy \n boolean modIsUnmodified \n boolean isModified \n boolean isModified \n boolean tuplemodHasModified \n ValueTuple trim \n int getModified \n int getModified \n ValueTuple slice \n int hashCode \n int tupleMod \n int tupleMod \n boolean modIsMissingNonsensical \n boolean isUnmodified \n boolean isUnmodified \n boolean isMissingNonsensical \n boolean isMissingNonsensical \n String valToString \n boolean isMissingFlow \n boolean isMissingFlow \n ValueTuple makeFromInterned \n Object getValue \n Object getValue \n boolean isMissing \n boolean isMissing \n int size \n boolean equals \n ValueTuple clone \n String toString \n String toString \n int make_tuplemod \n int parseModified", "output": "String function ( int arg0 ) { return ( ( tuplemodHasModified ( arg0 ) ? \"srini_string\" : \"srini_string\" ) + ( tuplemodHasUnmodified ( arg0 ) ? \"srini_string\" : \"srini_string\" ) + ( tuplemodHasMissingNonsensical ( arg0 ) ? \"srini_string\" : \"srini_string\" ) + ( tuplemodHasMissingFlow ( arg0 ) ? \"srini_string\" : \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nperform a code resolve in a separate thread . ", "input": " IJavaElement[] EMPTY_RESULT \n IJavaElement selectJavaElement \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] performForkedCodeResolve \n boolean canOperateOn \n IStructuredSelection getStructuredSelection \n IClassFile getInputAsClassFile \n ITypeRoot getInput \n ITypeRoot getInput \n IType getTypeAtOffset \n IJavaElement getElementAtOffset \n IJavaElement getElementAtOffset \n IJavaElement getElementAtOffset \n IJavaElement[] codeResolveOrInputForked \n ICompilationUnit getInputAsCompilationUnit \n IJavaElement[] getElements \n IJavaElement resolveEnclosingElement \n IJavaElement resolveEnclosingElement", "output": "IJavaElement [ ] function ( JavaEditor arg0 , boolean arg1 ) { ITypeRoot loc0 = getInput ( arg0 , arg1 ) ; if ( loc0 != null ) return performForkedCodeResolve ( loc0 , ( ITextSelection ) arg0 . getSelectionProvider ( ) . getSelection ( ) ) ; return EMPTY_RESULT ; }"}, {"instruction": "Generate java code\nretrieves the path to the log file . ", "input": " int LOG_MAGIC \n String path \n long utime \n long eventNumber \n BufferedRandomAccessFile raf \n long numMessagesWritten \n String channel \n byte data[] \n void flush \n void seekPositionFraction \n void write \n void write \n void close \n Event readNext \n double getPositionFraction", "output": "String function ( ) { return path ; }"}, {"instruction": "Generate java code\nthe maximum number of reconnect attempts before an error is reported back to the client on the first attempt by the client to connect to a server . set to -1 to use unlimited attempts . defaults to -1 . ", "input": " String userName \n int qos \n long reconnectDelayMax \n String password \n long reconnectDelay \n boolean cleanConnection \n long reconnectAttemptsMax \n double reconnectBackOffMultiplier \n long connectAttemptsMax \n String url \n String willTopic \n MqttOptions options \n int willQos \n List<String> topics \n boolean willRetain \n String willPayload \n Builder cleanConnection \n void setPassword \n List<String> getTopics \n void setWillPayload \n void setReconnectBackOffMultiplier \n Builder reconnectAttemptsMax \n long getReconnectDelayMax \n int getWillQos \n String getWillPayload \n void setQos \n Builder password \n void setReconnectDelayMax \n Builder qos \n void setUserName \n void setWillRetain \n Builder connectAttemptsMax \n Builder willTopic \n void setWillTopic \n long getConnectAttemptsMax \n int getQos \n String getUserName \n double getReconnectBackOffMultiplier \n String getWillTopic \n void setReconnectAttemptsMax \n Builder reconnectDelayMax \n boolean getWillRetain \n Builder topics \n void setTopics \n long getReconnectAttemptsMax \n Builder reconnectDelay \n Builder userName \n Builder url \n void setUrl \n Builder willRetain \n String getUrl \n boolean isCleanConnection \n String getPassword \n void setWillQos \n Builder willQos \n MqttOptions build \n Builder reconnectBackOffMultiplier \n void setCleanConnection \n void setReconnectDelay \n Builder willPayload \n long getReconnectDelay", "output": "void function ( long arg0 ) { this . connectAttemptsMax = arg0 ; }"}, {"instruction": "Generate java code\nclears the tile in a specific direction ", "input": " Box boundary \n BufferedImage eastDig \n BufferedImage southDig \n int westDigInt \n BufferedImage baseImage \n int eastDigInt \n BufferedImage northDig \n int layer \n Direction[] corner \n int northDigInt \n String biome \n int southDigInt \n int boardX \n int boardY \n BufferedImage westDig \n int NUM_DIG_STATES \n int getNorthDigInt \n int getEastDigInt \n void setLayer \n int getSouthDigInt \n void setBaseImage \n void digHole \n int getWestDigInt \n Direction[] getCorner \n void setCorner \n void setBiome \n String getBiome \n void setBoardY \n BufferedImage getSouthDig \n void setBoardX \n Box getBoundary \n int getLayer \n void setEastDig \n boolean isEmpty \n BufferedImage getWestDig \n void setSouthDig \n int getBoardX \n int getBoardY \n void setWestDig \n BufferedImage getNorthDig \n BufferedImage getBaseImage \n boolean isFull \n void setNorthDig \n BufferedImage getEastDig", "output": "void function ( Direction arg0 ) { digHole ( arg0 , NUM_DIG_STATES ) ; }"}, {"instruction": "Generate java code\nlock cache access . ", "input": " ReentrantLock lock \n LongSparseArray<Reference<T>> map \n void unlock \n T get \n void clear \n void putNoLock \n T getNoLock \n void put \n void remove \n void remove", "output": "void function ( ) { lock . lock ( ) ; }"}, {"instruction": "Generate java code\ngets the package name for the java class . ", "input": " String qualifiedName \n String className \n String packageName \n String getQualifiedClassName \n ClassName forClass \n String toString \n ClassName forQualifiedName \n String getClassName", "output": "String function ( ) { return packageName ; }"}, {"instruction": "Generate java code\ndump a cursor to the debug log , ignoring any log level settings . the position in the cursor is maintained . caller is responsible for opening and closing cursor . ", "input": " PlaceHolder placeHolder \n String dashes \n String fixedWidth \n String spaces", "output": "void function ( Cursor arg0 ) { dumpCursor ( arg0 , 18 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nquotient multiplication . ", "input": " Logger logger \n QuotientRing<C> ring \n boolean debug \n C num \n C den \n int signum \n boolean isONE \n Quotient<C> inverse \n boolean isUnit \n Quotient<C> subtract \n Quotient<C> gcd \n Quotient<C> sum \n int compareTo \n Quotient<C>[] egcd \n Quotient<C> monic \n Quotient<C> abs \n int hashCode \n Quotient<C> negate \n boolean equals \n Quotient<C> clone \n boolean isZERO \n String toString \n Quotient<C> divide \n Quotient<C> remainder", "output": "Quotient < C > function ( Quotient < C > arg0 ) { if ( arg0 == null || arg0 . isZERO ( ) ) { return arg0 ; } if ( num . isZERO ( ) ) { return this ; } if ( arg0 . isONE ( ) ) { return this ; } if ( this . isONE ( ) ) { return arg0 ; } C loc0 = num . multiply ( arg0 . num ) ; C loc1 = den . multiply ( arg0 . den ) ; return new Quotient < C > ( ring , loc0 , loc1 , false ) ; }"}, {"instruction": "Generate java code\ncomment f ", "input": " int I1z \n int I2z \n int I1 \n int I3 \n int I2 \n int I4 \n void fz \n void f11 \n void f1 \n void f2 \n void f1z", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ncreates a jsonasserter ", "input": " PlaceHolder placeHolder \n String convertReaderToString \n Matcher<Map<String,?>> mapContainingKey \n Matcher<? super Map<?,V>> mapContainingValue \n Matcher<Collection<Object>> emptyCollection \n CollectionMatcher collectionWithSize", "output": "JsonAsserter function ( Reader arg0 ) { return new JsonAsserterImpl ( JsonPath . parse ( convertReaderToString ( arg0 ) ) . json ( ) ) ; }"}, {"instruction": "Generate java code\ngets the number of connection requests being blocked awaiting a free connection . this can happen only if there are more worker threads contending for fewer connections . ", "input": " int leased \n int max \n int pending \n int available \n int getMax \n String toString \n int getAvailable \n int getLeased", "output": "int function ( ) { return this . pending ; }"}, {"instruction": "Generate java code\ncreate a varcomparability based on comparabilities of indices . ", "input": " Logger debug \n int IMPLICIT \n int NONE \n VarComparability makeAlias \n VarComparability makeAlias \n VarComparability indexType \n VarComparability string_length_type \n boolean equality_set_ok \n boolean alwaysComparable \n VarComparability parse \n VarComparability elementType \n boolean comparable \n boolean comparable", "output": "VarComparability function ( String arg0 , VarComparability arg1 ) { if ( arg1 instanceof VarComparabilityNone ) { return VarComparabilityNone . it ; } else { throw new Error ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nreturns the response 's identifier , which matches the pushed notification 's . ", "input": " int identifier \n int command \n int status \n int getCommand \n void setIdentifier \n String getMessage \n boolean isValidErrorMessage \n int getStatus \n void setCommand \n void linkToPushedNotification \n boolean isErrorResponsePacket \n void setStatus", "output": "int function ( ) { return identifier ; }"}, {"instruction": "Generate java code\nremove a propertychangelistener from this component . ", "input": " IPropertyDescriptor[] EMPTY_ARRAY \n PropertyChangeSupport pcsDelegate \n long serialVersionUID \n void firePropertyChange \n Object getPropertyValue \n void setPropertyValue \n Object getEditableValue \n IPropertyDescriptor[] getPropertyDescriptors \n void resetPropertyValue \n void addPropertyChangeListener \n boolean isPropertySet \n void readObject", "output": "void function ( PropertyChangeListener arg0 ) { if ( arg0 != null ) { pcsDelegate . removePropertyChangeListener ( arg0 ) ; } }"}, {"instruction": "Generate java code\nextract discrete keys from this possibly compound key . ", "input": " Point pointT \n abbot.swt.Robot _robot \n void robotKeyClick \n void doKeyDown \n void doKeyUp \n void mouseMove \n void mouseMove \n void keyUp \n void keyUp \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n void mouseUp \n void keyClick \n void keyClick \n void keyDown \n void keyDown \n Event createClickEvent \n void enterText", "output": "int [ ] function ( int arg0 ) { return KeyStrokeDecoder . extractModifiers ( arg0 ) ; }"}, {"instruction": "Generate java code\nconvert integer to character ", "input": " Cell[][] cells \n int width \n long serialVersionUID \n int height \n Iterator<Cell> iterator \n int ctoi \n boolean equals \n Cell getCellAtLocation", "output": "char function ( int arg0 ) { return ( char ) ( arg0 + 'A' ) ; }"}, {"instruction": "Generate java code\nget the subject widget 's class name ", "input": " long serialVersionUID \n int UNASSIGNED \n String nameOrLabel \n int index \n WidgetLocator ancestorInfo \n WidgetLocator parentInfo \n HashMap<String,String> map \n ClassReference classRef \n void setAncestorInfo \n Object getAdapter \n int getIndex \n void setData \n void copyDataTo \n WidgetLocator getParentInfo \n String getWidgetLocatorStringName \n String getNameOrLabel \n WidgetLocator getAncestorInfo \n com.windowtester.runtime.locator.IWidgetLocator[] findAll \n boolean matches \n Map<String,String> getDataMap \n void accept \n void setParentInfo \n Class<?> getTargetClass \n void setIndex \n int hashCode \n boolean equals \n ClassReference getTargetClassRef \n String toString \n String getData", "output": "String function ( ) { if ( classRef != null ) return classRef . getName ( ) ; else return null ; }"}, {"instruction": "Generate java code\nadds the service into the cache map ", "input": " Logger LOGGER \n Map<String,Service> serviceCache \n Service getService", "output": "void function ( Service arg0 ) { serviceCache . put ( arg0 . getName ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\nchecks whether the field specified is supported by this period . ", "input": " PlaceHolder placeHolder \n int size \n int[] getValues \n int hashCode \n int get \n boolean equals \n Period toPeriod \n MutablePeriod toMutablePeriod \n DurationFieldType getFieldType \n String toString \n String toString \n int indexOf \n DurationFieldType[] getFieldTypes", "output": "boolean function ( DurationFieldType arg0 ) { return getPeriodType ( ) . isSupported ( arg0 ) ; }"}, {"instruction": "Generate java code\ninit with krbsetting . ", "input": " KrbSetting krbSetting \n PreauthHandler preauthHandler \n int generateNonce \n KrbSetting getKrbSetting \n PreauthHandler getPreauthHandler \n KrbConfig getConfig \n long getTicketValidTime", "output": "void function ( KrbSetting arg0 ) { this . krbSetting = arg0 ; preauthHandler = new PreauthHandler ( ) ; preauthHandler . init ( this ) ; }"}, {"instruction": "Generate java code\nget the directory into which commited class files should be written . ", "input": " File outputDir \n LinkedList cache \n ClassSource _classSource \n String classpath \n Map openZipFiles \n boolean DEBUG \n boolean USE_SYSTEM_CLASSES \n int CACHE_LIMIT \n boolean verbose \n void setOutputDir \n ClassInfo loadClassFromStream \n void appendClassPath \n ClassInfo loadClassFromFile \n void setVerbose \n ClassInfo[] loadClassesFromZipFile \n void done \n void prependClassPath \n OutputStream outputStreamFor \n OutputStream outputStreamFor \n void setClassPath \n String getClassPath \n void addToCache \n ClassInfo newClass \n ClassInfo loadClassFromRessource \n ClassInfo loadClass \n void writeEntry", "output": "File function ( ) { return outputDir ; }"}, {"instruction": "Generate java code\nlook for @onetomany , @manytomany and @elementcollection annotations ", "input": " PlaceHolder placeHolder \n boolean isEntityClass \n boolean isPersistentField \n boolean doDirtyCheckingInline \n boolean hasLazyLoadableAttributes \n boolean isCompositeClass \n boolean isLazyLoadable \n ClassLoader getLoadingClassLoader \n CtField[] order", "output": "boolean function ( CtField arg0 ) { return arg0 . hasAnnotation ( OneToMany . class ) || arg0 . hasAnnotation ( ManyToMany . class ) || arg0 . hasAnnotation ( ElementCollection . class ) ; }"}, {"instruction": "Generate java code\nreturn the character at the given position . erase characters will return 0 rather than the actual character ", "input": " String inlineMarkupDelimiters \n int sectionLevel \n boolean erased \n boolean inBlock \n boolean listStart \n List<Boolean> valid \n char ESCAPED_CHARACTER_VALUE \n List<Integer> offsets \n List<Character> characters \n String text \n List<Boolean> escaped \n int listLevel \n int lineNo \n boolean allSameCharacter \n void setListStart \n void erase \n void erase \n void erase \n boolean isListStart \n String getText \n boolean isValid \n int getOffset \n int length \n boolean isEmpty \n void eraseWithStyle \n boolean isAllSameCharacter \n void setSectionLevel \n void setInBlock \n boolean isErased \n int getSectionLevel \n int eraseEnclosure \n int getListLevel \n int getLineNo \n boolean isInBlock \n String toString \n char rawCharAt \n void setListLevel \n boolean startsWith", "output": "char function ( int arg0 ) { return charAt ( arg0 , false ) ; }"}, {"instruction": "Generate java code\nequals does not take into account the range of this contact , as this information might change over time and should be updated rather than force a new contact ", "input": " String attributeName \n Comparable[] range \n TransInfo transInfo \n int getTransmissionSize \n String getAttribute \n void setRange \n Comparable[] getRange \n String toString \n TransInfo getTransInfo", "output": "boolean function ( Object arg0 ) { if ( arg0 instanceof MercuryContact ) { MercuryContact loc0 = ( MercuryContact ) arg0 ; return loc0 . getAttribute ( ) . equals ( this . getAttribute ( ) ) && loc0 . getTransInfo ( ) . equals ( this . getTransInfo ( ) ) ; } return false ; }"}, {"instruction": "Generate java code\nycc 8-bit per channel to rgb 8-bit per channel . ", "input": " PlaceHolder placeHolder \n void RGBtoYCC \n void RGB8toYCC16 \n void RGB8toYCC16 \n void YCC8toRGB8 \n void YCC16toRGB8 \n void YCCtoRGB \n IndexColorModel createMacColors", "output": "void function ( int [ ] arg0 , int [ ] arg1 ) { int loc0 = arg0 [ 0 ] ; int loc1 = arg0 [ 1 ] ; int loc2 = arg0 [ 2 ] ; int loc3 = ( 299 * loc0 + 587 * loc1 + 114 * loc2 ) / 1000 ; int loc4 = ( - 1687 * loc0 - 3313 * loc1 + 5000 * loc2 ) / 10000 + 128 ; int loc5 = ( 5000 * loc0 - 4187 * loc1 - 813 * loc2 ) / 10000 + 128 ; arg1 [ 0 ] = min ( 255 , max ( 0 , loc3 ) ) ; arg1 [ 1 ] = min ( 255 , max ( 0 , loc4 ) ) ; arg1 [ 2 ] = min ( 255 , max ( 0 , loc5 ) ) ; }"}, {"instruction": "Generate java code\ncopy algebraicnumber element c. ", "input": " GenPolynomialRing<C> ring \n int isField \n GenPolynomial<C> modul \n boolean isField \n boolean isCommutative \n AlgebraicNumber<C> interpolate \n AlgebraicNumber<C> parse \n AlgebraicNumber<C> parse \n java.math.BigInteger characteristic \n AlgebraicNumber<C> random \n AlgebraicNumber<C> random \n int hashCode \n boolean equals \n AlgebraicNumber<C> getONE \n AlgebraicNumber<C> getZERO \n AlgebraicNumber<C> fromInteger \n AlgebraicNumber<C> fromInteger \n boolean isAssociative \n String toString \n AlgebraicNumber<C> chineseRemainder", "output": "AlgebraicNumber < C > function ( AlgebraicNumber < C > arg0 ) { return new AlgebraicNumber < C > ( this , arg0 . val ) ; }"}, {"instruction": "Generate java code\nreturns a test which will fail and log a warning message . ", "input": " String fName \n Vector fTests \n void setName \n int testCount \n void addTestSuite \n String getName \n void addTestMethod \n void run \n boolean isTestMethod \n Test createTest \n Test testAt \n Enumeration tests \n String exceptionToString \n Constructor getTestConstructor \n void addTest \n String toString \n int countTestCases \n boolean isPublicTestMethod \n void runTest", "output": "Test function ( final String arg0 ) { return new TestCase ( \"srini_string\" ) { protected void runTest ( ) { fail ( arg0 ) ; } } ; }"}, {"instruction": "Generate java code\nconvert a varcharholder to a string . varcharholders are designed specifically for object reuse and mutability , only use this method when absolutely necessary for interacting with interfaces that must take a string . ", "input": " org.slf4j.Logger logger \n int RADIX \n int MAX_INT \n long MAX_LONG \n ISOChronology CHRONOLOGY \n String toStringFromUTF16 \n long varTypesToLong \n void initCap \n int[] memGetDate \n int varTypesToInt \n String toStringFromUTF8 \n long getDate \n boolean isReadableAsDate \n int nfeL \n int nfeI", "output": "String function ( VarCharHolder arg0 ) { return toStringFromUTF8 ( arg0 . start , arg0 . end , arg0 . buffer ) ; }"}, {"instruction": "Generate java code\nchecks is buffer contains needed bytes ", "input": " byte[] data \n int offset \n int limit \n int position \n boolean isAvailable \n byte read \n long readLong \n String readString \n String readString \n byte[] readBytes \n InputBuffer subBuffer \n int readInt \n InputBuffer createFromByteArray", "output": "void function ( int arg0 ) { if ( arg0 > limit - position ) { throw new BSONException ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nmain run method . should never be run on the event dispatch thread , although no check is explicitly done here . ", "input": " String description \n Resolver resolver \n Throwable invalidScriptError \n long serialVersionUID \n String toXMLString \n Map getAttributes \n String getXMLTag \n void writeObject \n void usage \n void usage \n Element addAttributes \n Element toXML \n void setDescription \n String simpleClassName \n Element addContent \n String getDescription \n void parseStepAttributes \n String getUsage \n void readObject \n String getDefaultDescription \n String toEditableString \n Step createStep \n Step createStep \n void runStep \n ComponentTester resolveTester \n Class resolveClass \n void setScriptError \n String toString \n Resolver getResolver \n Map createAttributeMap", "output": "void function ( ) { if ( invalidScriptError != null ) throw invalidScriptError ; Log . debug ( \"srini_string\" + toString ( ) ) ; runStep ( ) ; }"}, {"instruction": "Generate java code\nreturn a view based on layout id ", "input": " String TAG_INTERNET_OFF \n ArrayList<View> mCustomViews \n ViewSwitcher mSwitcher \n LayoutInflater mInflater \n RelativeLayout mContainer \n String[] mSupportedAbsListViews \n Context mContext \n View mTargetView \n String TAG_OTHER_EXCEPTION \n ArrayList<View> mDefaultViews \n View mView \n String TAG_LOADING_CONTENT \n String[] mSupportedViews \n View.OnClickListener mClickListener \n void setClickListener \n void initializeAbsListView \n void initializeViewContainer \n void setmView \n void show \n void showExceptionLayout \n void showInternetOffLayout \n void showLoadingLayout \n void showCustomView \n void setInternetOffMessage \n void setLoadingMessage \n View getmView \n void setInternetOffTitle \n void setDefaultViews \n void hideAll \n void setOtherExceptionTitle \n void addCustomView \n void setOtherExceptionMessage", "output": "View function ( int arg0 , String arg1 ) { View loc0 = mInflater . inflate ( arg0 , null , false ) ; loc0 . setTag ( arg1 ) ; loc0 . setVisibility ( View . GONE ) ; View loc1 = loc0 . findViewById ( R . id . exception_button ) ; if ( loc1 != null ) loc1 . setOnClickListener ( this . mClickListener ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncalculate the greatest common divisor . ", "input": " String PROMPT \n void main", "output": "int function ( int arg0 , int arg1 ) { if ( arg0 < 0 ) { arg0 = - arg0 ; } if ( arg1 < 0 ) { arg1 = - arg1 ; } while ( arg1 != 0 ) { int loc0 = arg0 % arg1 ; arg0 = arg1 ; arg1 = loc0 ; } return arg0 ; }"}, {"instruction": "Generate java code\nconvert a string into a byte for use with the actual registry functions . ", "input": " boolean _debug \n int KEY_QUERY_VALUE \n int NATIVE_HANDLE \n int ERROR_SUCCESS \n int ERROR_CODE \n String getIndirect \n String replace \n byte[] stripHKEY \n byte[] toWindowsName \n Process Launch \n String getValue \n int getHKEY \n String getKeyDefault \n byte[] windowsAbsolutePath \n String[] splitCommandLine \n String[] splitCommandLine \n int WindowsRegCloseKey \n int[] openKey1 \n String getBrowser", "output": "byte [ ] function ( String arg0 ) { byte [ ] loc0 = new byte [ arg0 . length ( ) + 1 ] ; for ( int loc1 = 0 ; loc1 < arg0 . length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0 . charAt ( loc1 ) ; } loc0 [ arg0 . length ( ) ] = 0 ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn the starting location of this move . ", "input": " int startingLocation \n Player thePlayer \n int endingLocation \n Player getPlayer \n int endLocation", "output": "int function ( ) { return startingLocation ; }"}, {"instruction": "Generate java code\nthis method starts a supportpeerrequestoperation , which begs a chosen node for the execution of the role as support peer . ", "input": " AttributeInputStrategy attributeInput \n SkyNetNodeInterface skyNetNode \n AttributeStorage attributeStorage \n Logger log \n SupportPeerInfo activeSupportPeer \n void supportPeerRequestFailed \n void supportPeerRequestSucceeded \n void supportPeerUpdateOperationSucceeded \n void updateCurrentSettingsOfSupportPeer \n void reset \n void supportPeerUpdateOperationFailed \n SupportPeerInfo getActiveSupportPeer \n void setSupportPeer \n void determineNewSupportPeer \n void removeSupportPeer \n int updateSupportPeer", "output": "int function ( SkyNetNodeInfo arg0 , SkyNetNodeInfo arg1 , SkyNetNodeInfo arg2 , long arg3 , OperationCallback < SupportPeerRequestACKMsg > arg4 ) { SupportPeerRequestOperation loc0 = new SupportPeerRequestOperation ( skyNetNode , arg0 , arg1 , arg2 , arg3 , arg4 ) ; loc0 . scheduleImmediately ( ) ; return loc0 . getOperationID ( ) ; }"}, {"instruction": "Generate java code\nsets the string name of this document set ", "input": " int size \n RandomGenerator rand \n String name \n int startRank \n int getSize \n boolean containsResourcesOf \n void setSize \n String getName \n int getKeyForPublish \n int getKeyForLookup \n void setBeginRank", "output": "void function ( String arg0 ) { this . name = arg0 ; System . out . println ( \"srini_string\" = \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nhandles the given invocationtargetexception . ", "input": " ExceptionHandler fgInstance \n void displayMessageDialog \n void log \n void perform \n void perform", "output": "void function ( InvocationTargetException arg0 , Shell arg1 , String arg2 , String arg3 ) { fgInstance . perform ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nget this object as a mutableperiod . this will always return a new mutableperiod with the same fields . the period will use periodtype.standard . ", "input": " long START_1972 \n int iPeriod \n long serialVersionUID \n DurationFieldType getFieldType \n DurationFieldType getFieldType \n boolean isSupported \n int compareTo \n int getValue \n int getValue \n int size \n int hashCode \n void setValue \n int get \n boolean equals \n PeriodType getPeriodType \n Period toPeriod \n int between \n int between \n int standardPeriodIn", "output": "MutablePeriod function ( ) { MutablePeriod loc0 = new MutablePeriod ( ) ; loc0 . add ( this ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the itext version as shown in the producer line . itext is a product developed by itext group nv . itext group requests that you retain the itext producer line in every pdf that is created or manipulated using itext . ", "input": " String release \n String iText \n String iTextVersion \n String key \n String AGPL \n Version version \n String getKey \n String getProduct \n boolean isAGPLVersion \n Version getInstance \n String getRelease", "output": "String function ( ) { return iTextVersion ; }"}, {"instruction": "Generate java code\ncomputes the min ts across all streams . ", "input": " Map<GlobalStreamId,Long> streamToTs \n long lastWaterMarkTs \n ScheduledExecutorService executorService \n Set<GlobalStreamId> inputStreams \n int eventTsLag \n Logger LOG \n int interval \n WindowManager<T> windowManager \n ScheduledFuture<?> executorFuture \n void checkFailures \n void start \n void run \n boolean track", "output": "long function ( ) { long loc0 = 0 ; if ( streamToTs . size ( ) >= inputStreams . size ( ) ) { loc0 = Long . MAX_VALUE ; for ( Map . Entry < GlobalStreamId , Long > loc1 : streamToTs . entrySet ( ) ) { loc0 = Math . min ( loc0 , loc1 . getValue ( ) ) ; } } return loc0 - eventTsLag ; }"}, {"instruction": "Generate java code\ncreates a criterion using the < operator ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria nin \n Criteria nin \n Criteria and \n Criteria gte \n Criteria create \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria eq \n Criteria gt \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n Criteria exists \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( Object arg0 ) { this . criteriaType = RelationalOperator . LT ; this . right = ValueNode . toValueNode ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nsets the css class for the element we will eventually create . blows away any previously set or added class names . ", "input": " List<LazyEventListenerAttacher<?>> listenerAttachers \n String cssClassName \n ManagesEventListeners listenerManager \n Element element \n boolean isCreated \n void addClassName \n void addClickListener \n Element getElement \n void hookListeners \n void addMouseOverListener \n Element createElement \n String getClassName \n void manageEventListener", "output": "void function ( String arg0 ) { this . cssClassName = arg0 ; }"}, {"instruction": "Generate java code\nset the log implementation/log implementation factory by the name of the class . the given class must implement log , and provide a constructor that takes a single string argument containing the nameof the log . ", "input": " Constructor logImplctor \n boolean jdk14IsAvailable \n boolean log4jIsAvailable \n Hashtable logs \n String[] getLogNames \n Log makeNewLogInstance \n Log getInstance \n Log getInstance", "output": "void function ( String arg0 ) { try { Class loc0 = Class . forName ( arg0 ) ; Class [ ] loc1 = new Class [ 1 ] ; loc1 [ 0 ] = \"srini_string\" . getClass ( ) ; logImplctor = loc0 . getConstructor ( loc1 ) ; } catch ( Throwable loc0 ) { logImplctor = null ; } }"}, {"instruction": "Generate java code\nindicates whether or not this operation expects to include default values . ", "input": " String INDEX \n String KEY \n String getName \n ModelNode getAttributeValue \n ModelNode createWriteAttributeOperation \n ModelNode createReadAttributeOperation \n Set<String> getAllWriteAttributeOperationNames \n void setPathAddress \n ModelNode createMapEntryOperation \n ModelNode createListRemoveOperation \n ModelNode createListRemoveOperation \n ModelNode createUndefineAttributeOperation \n String getAttributeName \n ModelNode createCompositeOperation \n ModelNode createCompositeOperation \n ModelNode createReadResourceOperation \n ModelNode createMapRemoveOperation \n ModelNode createMapClearOperation \n ModelNode createMapPutOperation \n ModelNode createDescribeOperation \n ModelNode createListElementOperation \n ModelNode createListElementOperation \n ModelNode createListAddOperation \n ModelNode createListGetOperation \n ModelNode createAttributeOperation \n ModelNode createMapGetOperation \n PathAddress getPathAddress \n ModelNode createAddOperation \n ModelNode createAddOperation \n ModelNode createAddOperation", "output": "boolean function ( ModelNode arg0 ) { return arg0 . hasDefined ( ModelDescriptionConstants . INCLUDE_DEFAULTS ) ? arg0 . get ( ModelDescriptionConstants . INCLUDE_DEFAULTS ) . asBoolean ( ) : true ; }"}, {"instruction": "Generate java code\nget type type to mark this response , default is 0 it will be used in httpcache #httpcache android.content.context , int ", "input": " boolean isInCache \n int responseCode \n String responseBody \n Map<String,Object> responseHeaders \n boolean isInitExpiredTime \n int type \n String url \n long expiredTime \n boolean isInCache \n long getExpiresInMillis \n HttpResponse setInCache \n void setResponseHeader \n void setExpiredTime \n String getResponseBody \n void setResponseCode \n void setResponseHeaders \n void setType \n long getExpiredTime \n void setUrl \n String getUrl \n String getExpiresHeader \n long getCacheControlMaxAge \n int getResponseCode \n Map<String,Object> getResponseHeaders \n void setResponseBody \n Object getResponseHeader \n boolean isExpired", "output": "int function ( ) { return type ; }"}, {"instruction": "Generate java code\nempties the contents of the stack . ", "input": " ArrayByteList list \n byte pop \n int search \n int size \n byte get \n byte push \n boolean empty \n byte peek \n byte peek", "output": "void function ( ) { list . clear ( ) ; }"}, {"instruction": "Generate java code\nreturns the sum of the squares of the available values . ", "input": " int INFINITE_WINDOW \n long serialVersionUID \n double getKurtosis \n double getStandardDeviation \n double getSkewness \n int getWindowSize \n double[] getValues \n double[] getSortedValues \n double apply \n double getMax \n long getN \n void clear \n DescriptiveStatistics newInstance \n DescriptiveStatistics newInstance \n double getMin \n double getElement \n double getVariance \n double getMean \n String toString \n void setWindowSize \n double getSum \n double getPercentile \n void addValue \n double getGeometricMean", "output": "double function ( ) { return apply ( new SumOfSquares ( ) ) ; }"}, {"instruction": "Generate java code\nconverts an iso 8601 string to an xmpdatetime . parse a date according to iso 8601 and http://www.w3.org/tr/note-datetime : yyyy yyyy-mm yyyy-mm-dd yyyy-mm-ddthh : mmtzd yyyy-mm-ddthh : mm : sstzd yyyy-mm-ddthh : mm : ss.stzd data fields : yyyy = four-digit year mm = two-digit month 01 = january , etc. dd = two-digit day of month 01 through 31 hh = two digits of hour 00 through 23 mm = two digits of minute 00 through 59 ss = two digits of second 00 through 59 s = one or more digits representing a decimal fraction of a second tzd = time zone designator z or + hh : mm or - hh : mm note that iso 8601 does not seem to allow years less than 1000 or greater than 9999 . we allow any year , even negative ones . the year is formatted as '' % .4 d '' . note : tolerate missing tzd , assume is utc . photoshop 8 writes dates like this for exif : gpstimestamp . note : does not apply anymore . tolerate missing date portion , in case someone foolishly writes a time-only value that way . ", "input": " String str \n int pos \n char ch \n char ch \n int pos \n int length \n boolean hasNext \n void skip \n String render \n int gatherInt", "output": "XMPDateTime function ( String arg0 ) { return parse ( arg0 , new XMPDateTimeImpl ( ) ) ; }"}, {"instruction": "Generate java code\nspecial handler for deserialization . ", "input": " Map<VarInfoAux,VarInfoAux> interningMap \n String IS_PARAM \n Logger debug \n String HAS_DUPLICATES \n String NULL_TERMINATING \n VarInfoAux theDefault \n String FALSE \n String PACKAGE_NAME \n boolean isInterned \n String IS_STRUCT \n String HAS_NULL \n String TRUE \n long serialVersionUID \n String HAS_ORDER \n String HAS_SIZE \n String NO_PACKAGE_NAME \n Map<String,String> map \n String getValue \n VarInfoAux intern \n boolean isParam \n int hashCode \n boolean equals \n boolean equals \n VarInfoAux setValue \n VarInfoAux clone \n VarInfoAux getDefault \n String toString \n VarInfoAux parse \n boolean getFlag", "output": "Object function ( ) { return this . intern ( ) ; }"}, {"instruction": "Generate java code\nhandles an incoming selection event . ", "input": " TextListener fTextListener \n ChangeType fType \n SelectionListener fSelectionListener \n Set<ITypingRunListener> fListeners \n int fNextOffset \n boolean DEBUG \n TypingRun fRun \n ITextViewer fViewer \n Change fLastChange \n void disconnect \n void fireRunBegun \n void mouseDown \n void handleTextChanged \n void startOrContinue \n void fireRunEnded \n void focusLost \n Change computeChange \n void uninstall \n void handleChange \n boolean hasRun \n void ensureSelectionListenerAdded \n boolean canFollow \n void keyReleased \n void connect \n void addTypingRunListener \n void focusGained \n void keyPressed \n void endIfStarted \n void ensureSelectionListenerRemoved \n void mouseDoubleClick \n ChangeType getType \n void install \n boolean isModification \n void mouseUp \n String toString \n void removeTypingRunListener \n void textChanged", "output": "void function ( ) { handleChange ( new Change ( TypingRun . SELECTION , - 1 ) ) ; }"}, {"instruction": "Generate java code\nget ring factory at index i. ", "input": " int nCopies \n RingFactory<C> ring \n List<RingFactory<C>> ringList \n Logger logger \n Random random \n void addFactory \n boolean containsFactory \n boolean isField \n int length \n boolean isCommutative \n Product<C> parse \n Product<C> parse \n java.math.BigInteger characteristic \n Product<C> random \n Product<C> random \n Product<C> random \n Product<C> random \n Product<C> getAtomic \n int hashCode \n boolean equals \n Product<C> getONE \n Product<C> getZERO \n Product<C> fromInteger \n Product<C> fromInteger \n boolean isAssociative \n String toString \n Product<C> copy", "output": "RingFactory < C > function ( int arg0 ) { if ( nCopies != 0 ) { if ( 0 <= arg0 && arg0 < nCopies ) { return ring ; } throw new RuntimeException ( \"srini_string\" + this . getClass ( ) . getName ( ) ) ; } else { return ringList . get ( arg0 ) ; } }"}, {"instruction": "Generate java code\nchecks if the x value of the hash should be in this area ", "input": " BigInteger id \n int getTransmissionSize \n int[] getIntValue \n BigInteger getXValue \n BigInteger getId \n boolean sameXValue \n int compareTo \n byte[] getBytes \n BigInteger[] getValue \n boolean sameYValue \n BigInteger getYValue \n BigInteger getUniqueValue \n void setId \n String toString", "output": "boolean function ( CanArea arg0 ) { if ( sameXValue ( arg0 ) && sameYValue ( arg0 ) ) return true ; return false ; }"}, {"instruction": "Generate java code\nsets a new value instance overwriting the old value which is returned . you may use null . but you will get it back next call ! ", "input": " V m_key \n K m_value \n V getKey \n K getValue \n int hashCode \n boolean equals", "output": "K function ( final K arg0 ) { final K loc0 = this . m_value ; this . m_value = arg0 ; return loc0 ; }"}, {"instruction": "Generate java code\nintended only for use from testing . ", "input": " DialectResolver dialectResolver \n StrategySelector strategySelector \n Dialect buildDialect \n Dialect constructDialect \n Dialect determineDialect \n void injectServices", "output": "void function ( DialectResolver arg0 ) { this . dialectResolver = arg0 ; }"}, {"instruction": "Generate java code\nwe 've finished writing the concatenated document . ", "input": " Document document \n PdfCopy copy \n PdfCopy getWriter \n int addPages \n void open", "output": "void function ( ) { document . close ( ) ; }"}, {"instruction": "Generate java code\ntiming for frame relative to previous frame . ", "input": " int xPosition \n boolean isPlayWrapupFrames \n int CMP_VERTICAL \n int yPosition \n int MODE_INDEXED_COLORS \n int MSK_HAS_MASK \n int MSK_HAS_TRANSPARENT_COLOR \n int pageHeight \n int pageWidth \n Vector frames_ \n int transparentColor \n Hashtable properties \n int height \n long totalDuration \n int MODE_HAM8 \n int masking \n int MODE_HAM6 \n int MSK_NONE \n int MSK_LASSO \n int MODE_EHB \n boolean isSwapSpeakers \n int nbPlanes \n int nbPalettes \n int MODE_DIRECT_COLORS \n int xAspect \n Vector audioClips_ \n PropertyChangeSupport listeners \n int screenMode \n int jiffies \n int CMP_BYTE_RUN_1 \n int yAspect \n int CMP_NONE \n int width \n ArrayList<ColorCycle> colorCycles \n int compression \n int getNbPlanes \n int getCompression \n void setYPosition \n List<ColorCycle> getColorCycles \n int getColorCyclesCount \n int getFrameCount \n AudioClip getAudioClip \n void setTransparentColor \n int getNbPalettes \n int getXAspect \n void setPageHeight \n int getTransparentColor \n int getJiffies \n int getInterleave \n int getMasking \n void firePropertyChange \n void removePropertyChangeListener \n void setHeight \n void setXAspect \n void setScreenMode \n void setCompression \n void setSwapSpeakers \n void setProperty \n void addFrame \n int getAudioClipCount \n void setXPosition \n int getYPosition \n boolean isPlayWrapupFrames \n ANIMFrame getFrame \n int getWidth \n boolean isSwapSpeakers \n void addColorCycle \n void setPageWidth \n int getPageHeight \n int getHeight \n void addAudioClip \n int getDeltaOperation \n void addPropertyChangeListener \n Object getProperty \n int getXPosition \n void setMasking \n int getPageWidth \n int getYAspect \n void setYAspect \n void setWidth \n void setNbPlanes \n void setPlayWrapupFrames \n long getTotalDuration \n int getScreenMode \n void setJiffies", "output": "long function ( int arg0 ) { return ( ( ANIMFrame ) frames_ . elementAt ( arg0 ) ) . getRelTime ( ) ; }"}, {"instruction": "Generate java code\nif the #call method throws an exception , then this method is called tohandle that exception . this method may either handle the exception and return a value or rethrow the exception . the default implementation just rethrows the exception . subclasses may extend or override . ", "input": " PlaceHolder placeHolder \n void call", "output": "void function ( Throwable arg0 ) { throw arg0 ; }"}, {"instruction": "Generate java code\nreturns the ith digit of the id in base 2 ^ b . i = 0 returns the least significant digit . ", "input": " BigInteger MAX_ID_VALUE \n BigInteger TWO \n BigInteger NUM_OF_DISTINCT_IDS \n int NUM_OF_DIGITS \n BigInteger id \n int getTransmissionSize \n int indexOfMSDD \n int compareTo \n byte[] getBytes \n int hashCode \n BigInteger getUniqueValue \n boolean equals \n boolean isBetween \n BigInteger getMinAbsDistance \n String toString \n BigInteger getCwDistance \n PastryKey getCorrespondingKey \n BigInteger getCcwDistance", "output": "int function ( int arg0 ) { BigInteger loc0 ; int loc1 = arg0 * PastryConstants . ID_BASE_BIT_LENGTH ; loc0 = id . shiftRight ( loc1 ) ; loc0 = loc0 . mod ( TWO . pow ( PastryConstants . ID_BASE_BIT_LENGTH ) ) ; if ( loc0 . compareTo ( BigInteger . valueOf ( Integer . MAX_VALUE ) ) <= 0 ) return loc0 . intValue ( ) ; else return - 1 ; }"}, {"instruction": "Generate java code\nhash code for this local . ", "input": " Logger logger \n QuotientRing<C> ring \n boolean debug \n C num \n C den \n int signum \n boolean isONE \n Quotient<C> inverse \n boolean isUnit \n Quotient<C> subtract \n Quotient<C> gcd \n Quotient<C> sum \n int compareTo \n Quotient<C>[] egcd \n Quotient<C> monic \n Quotient<C> abs \n Quotient<C> negate \n boolean equals \n Quotient<C> clone \n boolean isZERO \n String toString \n Quotient<C> divide \n Quotient<C> multiply \n Quotient<C> remainder", "output": "int function ( ) { int loc0 ; loc0 = ring . hashCode ( ) ; loc0 = 37 * loc0 + num . hashCode ( ) ; loc0 = 37 * loc0 + den . hashCode ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\nwhat is this for ? ", "input": " boolean useCriterion4 \n GenPolynomial<C> pi \n int i \n GenPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n int getPairNumber \n void setUseCriterion3 \n boolean equals \n boolean getUseCriterion3 \n void setZero \n boolean isZero \n void setUseCriterion4 \n String toString \n int compareTo \n void pairNumber \n boolean getUseCriterion4", "output": "MiniPair function ( ) { return new MiniPair ( i , j ) ; }"}, {"instruction": "Generate java code\ncheck whether the log4j logger used is enabled for warn priority . ", "input": " String name \n boolean is12 \n Logger logger \n String FQCN \n void warn \n void warn \n void trace \n void trace \n void debug \n void debug \n boolean isInfoEnabled \n boolean isErrorEnabled \n Logger getLogger \n boolean isTraceEnabled \n boolean isDebugEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void info \n void info", "output": "boolean function ( ) { if ( is12 ) { return getLogger ( ) . isEnabledFor ( ( Priority ) Level . WARN ) ; } else { return getLogger ( ) . isEnabledFor ( Level . WARN ) ; } }"}, {"instruction": "Generate java code\nfor test use ", "input": " Map<String,Entry> sessions \n long lastAccessTime \n String ticket \n TicketContainer instance \n String getTicket", "output": "boolean function ( String arg0 , String arg1 ) { if ( \"srini_string\" . equals ( arg0 ) && \"srini_string\" . equals ( arg1 ) ) return true ; Entry loc0 = sessions . get ( arg0 ) ; return loc0 != null && loc0 . arg1 . equals ( arg1 ) ; }"}, {"instruction": "Generate java code\ngets the number chosen . ", "input": " String errorMessage \n String numberChosen \n String buyerName \n Boolean isTest \n String getBuyerName \n void setIsTest \n void execute \n String getErrorMessage", "output": "String function ( ) { return numberChosen ; }"}, {"instruction": "Generate java code\ngets the transformers , do not modify the array . ", "input": " Transformer[] iTransformers \n long serialVersionUID \n Object transform \n Transformer getInstance \n Transformer getInstance \n Transformer getInstance", "output": "Transformer [ ] function ( ) { return iTransformers ; }"}, {"instruction": "Generate java code\nflashes the output area a specified color . currently inoperable . ", "input": " Font consoleFont \n int ydim \n SwingConsoleFrame targetFrame \n int ypos \n Position caretPosition \n int xpos \n Properties configuration \n CSIColor[][] colorsBuffer \n StrokeInformer aStrokeInformer \n HashMap<CSIColor,Color> colorMap \n CSIColor[][] backcolorsBuffer \n CSIColor[][] colors \n CSIColor[][] backcolors \n int xdim \n FontMetrics fMetric \n char[][] charsBuffer \n char[][] chars \n CSIColor backColor \n CSIColor frontColor \n void locate \n void safeprint \n void run \n void saveBuffer \n void componentResized \n void waitKeys \n void addKeyListener \n boolean isInsideBounds \n boolean isInsideBounds \n int defineFontSize \n void componentMoved \n int peekColor \n CharKey inkey \n void componentHidden \n void waitKey \n void restore \n char peekChar \n void refresh \n void refresh \n int getColor \n void printTransparent \n void cls \n void componentShown \n void flushColorTable \n void setAutoRefresh \n String loadFont \n String input \n String input \n void print \n void print \n void print \n void print \n void print \n void print \n void print \n CSIColor peekCSIColor \n void locateCaret \n Color colorPreProcess", "output": "void function ( int arg0 ) { }"}, {"instruction": "Generate java code\nget the index into the constant pool of the field 's constant value , if any . returns 0 if the field does not have a constant value . ", "input": " ClassInfo classInfo \n int name \n int modifiers \n int type \n Attribute[] attrs \n ConstantValue constantValue \n void setConstantValue \n int typeIndex \n int nameIndex \n void setNameIndex \n String toString \n void setTypeIndex \n void setModifiers \n int modifiers \n void write \n ClassInfo declaringClass", "output": "int function ( ) { if ( constantValue != null ) { return constantValue . constantValueIndex ( ) ; } return 0 ; }"}, {"instruction": "Generate java code\nsets the sigma parameter unit is msec ", "input": " RandomGenerator rand \n LognormalDist dist \n double sigma \n double mu \n long getJitter \n void writeBackToXML \n void setMu", "output": "void function ( double arg0 ) { this . sigma = arg0 ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable , empty doubleiterator ", "input": " DoubleListIterator EMPTY_DOUBLE_LIST_ITERATOR \n DoubleIterator EMPTY_DOUBLE_ITERATOR \n DoubleList EMPTY_DOUBLE_LIST \n DoubleList unmodifiableDoubleList \n DoubleList getEmptyDoubleList \n DoubleIterator singletonDoubleIterator \n DoubleListIterator unmodifiableDoubleListIterator \n DoubleList singletonDoubleList \n DoubleIterator unmodifiableDoubleIterator \n DoubleListIterator singletonDoubleListIterator \n DoubleListIterator getEmptyDoubleListIterator", "output": "DoubleIterator function ( ) { return EMPTY_DOUBLE_ITERATOR ; }"}, {"instruction": "Generate java code\nif a response packet regarding this notification was received , this method returns it . otherwise it returns null . ", "input": " Exception exception \n int identifier \n Payload payload \n ResponsePacket response \n int transmissionAttempts \n boolean transmissionCompleted \n long expiry \n Device device \n void setExpiry \n void setTransmissionAttempts \n boolean isTransmissionCompleted \n Exception getException \n void setIdentifier \n long getExpiry \n void setResponse \n List<PushedNotification> findSuccessfulNotifications \n Device getDevice \n void setTransmissionCompleted \n void setDevice \n Payload getPayload \n void addTransmissionAttempt \n boolean isSuccessful \n void setPayload \n int getIdentifier \n String getLatestTransmissionAttempt \n List<PushedNotification> findFailedNotifications \n int getTransmissionAttempts \n String toString \n void setException", "output": "ResponsePacket function ( ) { return response ; }"}, {"instruction": "Generate java code\ncreate a new perspective locator that identifies perspectives by name . ", "input": " IPerspectiveDescriptor descriptor \n long serialVersionUID \n IPerspectiveDescriptor getDescriptor \n IConditionHandler isClosed \n PerspectiveLocator forId \n IConditionHandler isActive \n ICondition isActive \n String getPerspectiveId", "output": "PerspectiveLocator function ( String arg0 ) { return new PerspectiveLocator ( PerspectiveFinder . findByNameInRegistry ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable version of the given non-null shortlist . ", "input": " ShortList EMPTY_SHORT_LIST \n ShortListIterator EMPTY_SHORT_LIST_ITERATOR \n ShortIterator EMPTY_SHORT_ITERATOR \n ShortListIterator getEmptyShortListIterator \n ShortIterator singletonShortIterator \n ShortListIterator singletonShortListIterator \n ShortIterator unmodifiableShortIterator \n ShortList getEmptyShortList \n ShortListIterator unmodifiableShortListIterator \n ShortList singletonShortList \n ShortIterator getEmptyShortIterator", "output": "ShortList function ( ShortList arg0 ) { if ( null == arg0 ) { throw new NullPointerException ( ) ; } return UnmodifiableShortList . wrap ( arg0 ) ; }"}, {"instruction": "Generate java code\nlog a message and exception with debug log level . ", "input": " String name \n Logger logger \n void log \n Logger getLogger \n boolean isWarnEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void warn \n void warn \n void trace \n void trace \n boolean isInfoEnabled \n boolean isErrorEnabled \n boolean isTraceEnabled \n boolean isDebugEnabled \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { log ( Level . FINE , String . valueOf ( arg0 ) , arg1 ) ; }"}, {"instruction": "Generate java code\nrun the query given and return one result from it . ", "input": " Joiner OR_QUERY_JOINER \n Path path \n SolrClient server \n CoreContainer cores \n boolean autocommit \n String WILDCARD_QSTRING \n String CORE_NAME \n SolrMapper mapper \n boolean up \n String FIELD_IS \n void init \n Phenotype savePhenotype \n String addStatusFilter \n Phenotype getPhenotypeByIssueNumber \n Phenotype getPhenotype \n void commit \n boolean getAutocommit \n List<Phenotype> searchPhenotypes \n Phenotype getPhenotypeByField \n void setAutocommit \n List<Phenotype> getPhenotypesByStatus \n List<Phenotype> getPhenotypesByField \n String getNextId \n Phenotype getPhenotypeByHpoId \n boolean deletePhenotype \n void checkUp \n void shutdown \n Phenotype getPhenotypeById", "output": "Phenotype function ( SolrQuery arg0 ) { try { QueryResponse loc0 = server . query ( arg0 ) ; List < SolrDocument > loc1 = loc0 . getResults ( ) ; if ( loc1 . size ( ) == 0 ) { return Phenotype . NULL ; } return mapper . fromDoc ( loc1 . get ( 0 ) ) ; } catch ( SolrServerException loc0 ) { throw new IOException ( loc0 ) ; } }"}, {"instruction": "Generate java code\nget the expression that is depth expressions from the top of the stack , but do not modify the stack . ", "input": " ArrayList stack \n int height \n Expr pop \n void set \n Expr pop1 \n int size \n Expr[] pop2 \n Expr get \n boolean isEmpty \n void replace \n String toString \n void push \n int height", "output": "Expr function ( int arg0 ) { for ( int loc0 = stack . size ( ) - 1 ; loc0 >= 0 ; loc0 -- ) { final Expr loc1 = ( Expr ) stack . get ( loc0 ) ; if ( arg0 == 0 ) { return loc1 ; } arg0 -= loc1 . type ( ) . stackHeight ( ) ; } throw new IllegalArgumentException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncreate a condition that tests if the workbench shell is maximized . ", "input": " PlaceHolder placeHolder \n IUIConditionHandler hasFocus", "output": "IUIConditionHandler function ( ) { return new WorkbenchIsMaximizedCondition ( ) ; }"}, {"instruction": "Generate java code\nadds a log event to the cache . if the number of events reach the capacity of the batch , they will be published . ", "input": " String PUBLISH_THREAD_NAME \n String cacheName \n int eventQueueLength \n ExecutorService executorService \n Object EVENTQUEUELOCK \n Queue<LoggingEvent> eventQueue \n ICachePublisher cachePublisher \n int capacity \n ExecutorService createExecutorService \n Future<Boolean> publishCache \n void publish \n PublishContext startPublish \n void flushAndPublishQueue \n void endPublish \n String getCacheName", "output": "void function ( LoggingEvent arg0 ) { boolean loc0 = false ; synchronized ( EVENTQUEUELOCK ) { if ( eventQueueLength < capacity ) { eventQueue . add ( arg0 ) ; eventQueueLength ++ ; } else { loc0 = true ; } } if ( loc0 ) { flushAndPublishQueue ( false ) ; } }"}, {"instruction": "Generate java code\nretrieve the current timeout setting . the timeout is the amount of time , in milliseconds , we should instruct the database to wait for any requested pessimistic lock acquisition . #no_wait , #wait_forever or #skip_locked represent 3 `` magic '' values . ", "input": " Map<String,LockMode> aliasSpecificLockModes \n int NO_WAIT \n LockOptions NONE \n boolean scope \n int SKIP_LOCKED \n LockOptions READ \n LockOptions UPGRADE \n LockMode lockMode \n int timeout \n int WAIT_FOREVER \n LockMode getLockMode \n LockOptions makeCopy \n LockMode getEffectiveLockMode \n int getAliasLockCount \n LockOptions setLockMode \n Iterator getAliasLockIterator \n LockOptions setAliasSpecificLockMode \n LockMode getAliasSpecificLockMode \n LockOptions setTimeOut \n LockMode findGreatestLockMode \n boolean hasAliasSpecificLockModes \n LockOptions copy \n LockOptions setScope \n boolean getScope", "output": "int function ( ) { return timeout ; }"}, {"instruction": "Generate java code\ntest method for com.itextpdf.text.html.webcolors #getrgbcolor java.lang.string . ", "input": " String RGB_PERCENT \n String RGB_OUT_OF_RANGE \n String RGB_MISSING_COLOR_VALUES \n String dumpColor \n void testGetRGBColorInPercentBlue \n void testGetRGBColorValueOutOfRange \n void testGetRGBColorChannelsMissingBlue \n void moreColorTest \n void testGetRGBColorInPercentAlpha \n void testGetRGBColorInPercentGreen \n void goodColorTests \n void testGetRGBColorChannelsMissingRed \n void testGetRGBColorChannelsMissingGreen \n void badColorTests \n void testGetRGBColorNegativeValue", "output": "void function ( ) { assertEquals ( 255 , WebColors . getRGBColor ( RGB_PERCENT ) . getRed ( ) ) ; }"}, {"instruction": "Generate java code\nhash code for this quotient ring . ", "input": " RingFactory<C> ring \n boolean debug \n Logger logger \n Quotient<C> random \n Quotient<C> random \n boolean isField \n boolean equals \n Quotient<C> getONE \n boolean isCommutative \n Quotient<C> getZERO \n Quotient<C> fromInteger \n Quotient<C> fromInteger \n boolean isAssociative \n String toString \n Quotient<C> parse \n Quotient<C> parse \n Quotient<C> copy \n java.math.BigInteger characteristic", "output": "int function ( ) { int loc0 ; loc0 = ring . hashCode ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns a set that maintains the order of elements that are added backed by the given set . if an element is added twice , the order is determined by the first add . the order is observed through the iterator or toarray . ", "input": " Set EMPTY_SET \n SortedSet EMPTY_SORTED_SET \n Set transformedSet \n SortedSet typedSortedSet \n Set synchronizedSet \n SortedSet synchronizedSortedSet \n SortedSet predicatedSortedSet \n Set unmodifiableSet \n boolean isEqualSet \n SortedSet transformedSortedSet \n int hashCodeForSet \n Set predicatedSet \n SortedSet unmodifiableSortedSet \n Set typedSet", "output": "Set function ( Set arg0 ) { return ListOrderedSet . decorate ( arg0 ) ; }"}, {"instruction": "Generate java code\nadd one metric to this record to be displayed on the custom dashboard . ", "input": " Map<String,Double> customMetrics \n long timeStamp \n long serialVersionUID \n String name \n boolean valid \n String revision \n Map<String,Double> getCustomMetrics \n String getFormattedRecord \n String getName \n long getTimestamp \n boolean isValid \n Double getMetric \n String getRevision", "output": "void function ( String arg0 , Double arg1 ) { valid = true ; customMetrics . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nget composite id sub-attribute definitions . ", "input": " PlaceHolder placeHolder \n Iterable<AttributeDefinition> getCompositeCollectionIndexSubAttributes \n Iterable<AttributeDefinition> getCompositeCollectionElementSubAttributes \n Iterable<AttributeDefinition> getSingularSubAttributes", "output": "Iterable < AttributeDefinition > function ( AbstractEntityPersister arg0 ) { return getSingularSubAttributes ( arg0 , arg0 , ( CompositeType ) arg0 . getIdentifierType ( ) , arg0 . getTableName ( ) , arg0 . getRootTableIdentifierColumnNames ( ) ) ; }"}, {"instruction": "Generate java code\nshould archive validation be performed ", "input": " Map<String,CloneableBootstrapContext> bootstrapContexts \n AtomicBoolean archiveValidationFailOnError \n AtomicBoolean beanValidation \n CloneableBootstrapContext defaultBootstrapContext \n AtomicBoolean archiveValidation \n AtomicBoolean archiveValidationFailOnWarn \n boolean getBeanValidation \n Map<String,CloneableBootstrapContext> getBootstrapContexts \n void setArchiveValidationFailOnWarn \n void setBootstrapContexts \n void setDefaultBootstrapContext \n boolean getArchiveValidationFailOnWarn \n void setArchiveValidationFailOnError \n CloneableBootstrapContext getDefaultBootstrapContext \n boolean getArchiveValidationFailOnError \n void setTracer \n void setArchiveValidation \n boolean getTracer \n void setBeanValidation", "output": "boolean function ( ) { return archiveValidation . get ( ) ; }"}, {"instruction": "Generate java code\nthe validation logic can either be defined in the property validation logic or as a regex of the property type . this method distincts between those different possibility and returns the actual validation pattern . ", "input": " PropertyTypeEntity propertyTypeEntity \n String fcExternalKey \n String DEFAULTVALIDATIONEXPRESSION \n String propertyComment \n Integer cardinalityProperty \n boolean nullable \n String validationLogic \n String defaultValue \n String displayName \n boolean testing \n boolean optional \n ForeignableOwner fcOwner \n long serialVersionUID \n String exampleValue \n Comparator<PropertyDescriptorEntity> CARDINALITY_AND_NAME_COMPARATOR \n String propertyName \n String machineInterpretationKey \n boolean encrypt \n long v \n List<PropertyTagEntity> propertyTags \n String fcExternalLink \n Comparator<PropertyDescriptorEntity> NAME_SORTING_COMPARATOR \n Integer id \n Set<PropertyEntity> properties \n void setDefaultValue \n int compare \n int compare \n String getExternalKey \n boolean hasTagWithName \n String getExternalLink \n ForeignableOwner getOwner \n Set<String> getPropertyTagsNameSet \n void setExampleValue \n void setOwner \n void setExternalKey \n String getPropertyTypeValidationRegex \n int foreignableFieldHashCode \n void addPropertyTag \n PropertyDescriptorEntity getCopy \n String getForeignableObjectName \n String removeLineBreaks \n Set<PropertyEntity> getProperties \n String getPropertyDescriptorDisplayName \n void addProperty \n List<PropertyTagEntity> getPropertyTags \n boolean isCustomType \n void setPropertyName \n void removePropertyTag \n String toString \n void setExternalLink \n void removeProperty", "output": "String function ( ) { String loc0 = null ; if ( isCustomType ( ) ) { loc0 = this . validationLogic == null ? DEFAULTVALIDATIONEXPRESSION : this . validationLogic ; } else { loc0 = this . validationLogic == null ? getPropertyTypeValidationRegex ( ) : this . validationLogic ; } return loc0 ; }"}, {"instruction": "Generate java code\nmicroservice entry point ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "void function ( String [ ] arg0 ) { SpringApplication . run ( PriceApplication . class , arg0 ) ; }"}, {"instruction": "Generate java code\nretrieve the overall lock mode in effect for this set of options . in certain contexts hql and criteria , lock-modes can be defined in an even more granular #setaliasspecificlockmode string , lockmode per-alias fashion ", "input": " Map<String,LockMode> aliasSpecificLockModes \n int NO_WAIT \n LockOptions NONE \n boolean scope \n int SKIP_LOCKED \n LockOptions READ \n LockOptions UPGRADE \n LockMode lockMode \n int timeout \n int WAIT_FOREVER \n LockOptions makeCopy \n LockMode getEffectiveLockMode \n int getAliasLockCount \n LockOptions setLockMode \n Iterator getAliasLockIterator \n LockOptions setAliasSpecificLockMode \n LockMode getAliasSpecificLockMode \n LockOptions setTimeOut \n LockMode findGreatestLockMode \n boolean hasAliasSpecificLockModes \n int getTimeOut \n LockOptions copy \n LockOptions setScope \n boolean getScope", "output": "LockMode function ( ) { return lockMode ; }"}, {"instruction": "Generate java code\nhash the member reference . ", "input": " NameAndType nameAndType \n Type declaringClass \n NameAndType nameAndType \n boolean equals \n String name \n String toString \n Type type \n Type declaringClass", "output": "int function ( ) { return declaringClass . hashCode ( ) ^ nameAndType . hashCode ( ) ; }"}, {"instruction": "Generate java code\nreturns the loggerfactory ", "input": " Logger logger \n LoggerFactory myself \n void setLogger \n Logger logger \n Logger getLogger \n Logger getLogger", "output": "LoggerFactory function ( ) { return myself ; }"}, {"instruction": "Generate java code\nappends the given string to the buffer . ", "input": " String text \n Charset charset \n StateController controller \n XMLParserMemory memory \n List<XMLParserListener> listeners \n TagState tagState \n ParserMonitor monitor \n State state \n XMLParserMemory memory \n void startElement \n InputStreamReader detectEncoding \n char currentLastChar \n XMLParser removeListener \n void parse \n void parse \n void parse \n void parse \n Charset getCharset \n TagState currentTagState \n void currentTagState \n String current \n void endElement \n void flush \n void parseWithReader \n void unknownData \n String currentTag \n void setMonitor \n String bufferToString \n void setState \n void comment \n StateController selectState \n void text \n void callText \n XMLParser addListener \n int bufferSize", "output": "XMLParser function ( final String arg0 ) { this . memory . current ( ) . append ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nisvalidnode returns true if this node is valid ; false otherwise . by default , an invalid node is one that does n't belong to a list mylist is null , but subclasses can override this definition . ", "input": " Object item \n List myList \n ListNode next \n Object item \n ListNode prev \n void setItem \n void insertAfter \n void remove \n void insertBefore", "output": "boolean function ( ) { return myList != null ; }"}, {"instruction": "Generate java code\nstatic method to get single instance of class ", "input": " Logger LOGGER \n PrintStream error \n PrintStream output \n ConsoleLoggerModule singleton \n void unprepare \n ConsoleLoggerModule prepare \n void printErrorString \n void printString", "output": "ConsoleLoggerModule function ( ) { if ( ConsoleLoggerModule . singleton == null ) { ConsoleLoggerModule . singleton = new ConsoleLoggerModule ( ) ; } return ConsoleLoggerModule . singleton ; }"}, {"instruction": "Generate java code\nthere is no relation defined in the uppermost hierarchy instance - this is an inconsistency and shall result in a runtime exception ", "input": " AppServerRelationHierarchyEntity entity \n void testRefersToRelationResourceRelationTypeEntity \n void testSetRelationResourceRelationTypeEntity \n void testRefersToRelationConsumedResourceRelationEntity \n void testGetApplicationServer1Step \n void testGetRelationConsumed \n void testGetApplicationServerNullAS \n void testSetRelationResourceRelationTypeEntityOverwritten \n void testGetApplicationServer2Step \n void setUp \n void testSetRelationConsumedResourceRelationEntity \n void testGetRelease \n void testGetRelationType \n void testGetApplicationServerDirect \n void testGetApplicationServerNOKWrongRelationType", "output": "void function ( ) { AppServerRelationHierarchyEntity loc0 = new AppServerRelationHierarchyEntity ( ) ; entity . setParentRelation ( loc0 ) ; entity . getApplicationServer ( ) ; }"}, {"instruction": "Generate java code\ntransfers from right to left ", "input": " PlaceHolder placeHolder \n void swap \n void swap", "output": "T [ ] function ( T [ ] arg0 , T [ ] arg1 ) { return ArrayTool . transferValues ( arg0 , arg1 , 0 , arg1 . length ) ; }"}, {"instruction": "Generate java code\nmark a client as collapsed . ", "input": " String selectedClient \n String PREF_COLLAPSED_CLIENT_GUIDS \n SharedPreferences sharedPrefs \n String PREF_HIDDEN_CLIENT_GUIDS \n Set<String> collapsedClients \n Set<String> hiddenClients \n String PREF_SELECTED_CLIENT_GUID \n boolean updateClientMembership \n boolean isClientCollapsed \n boolean setClientHidden \n void setClientAsSelected \n boolean isClientHidden \n Set<String> getStringSet", "output": "boolean function ( String arg0 , boolean arg1 ) { return updateClientMembership ( PREF_COLLAPSED_CLIENT_GUIDS , collapsedClients , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngets the value of the billto property . ", "input": " USAddress billTo \n String comment \n Items items \n XMLGregorianCalendar orderDate \n USAddress shipTo \n Items getItems \n USAddress getShipTo \n void setBillTo \n void setItems \n void setOrderDate \n void setComment \n XMLGregorianCalendar getOrderDate \n String getComment \n void setShipTo", "output": "USAddress function ( ) { return billTo ; }"}, {"instruction": "Generate java code\nget sentence containing the error . ", "input": " Sentence sentence \n long serialVersionUID \n LineOffset endPosition \n String validatorName \n String message \n LineOffset startPosition \n Optional<LineOffset> getStartPosition \n int getLineNumber \n String getValidatorName \n String getMessage \n Optional<LineOffset> getEndPosition \n String toString \n int getStartColumnNumber", "output": "Sentence function ( ) { return sentence ; }"}, {"instruction": "Generate java code\nget the type name as in the static field names defined on java.sql.types . if a type code is not recognized , it is reported as unknown ? where ' ? ' is replace with the given type code.intended as useful for logging purposes ... ", "input": " CoreMessageLogger LOG \n Map<Integer,String> JDBC_TYPE_MAP \n Map<Integer,String> buildJdbcTypeMap \n boolean isStandardTypeCode \n boolean isStandardTypeCode", "output": "String function ( Integer arg0 ) { String loc0 = JDBC_TYPE_MAP . get ( arg0 ) ; if ( loc0 == null ) { return \"srini_string\" + arg0 + \"srini_string\" ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns whether there may be some scenarios in which the robot does not function properly . ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean hasMultiClickFrameBug \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isWindows ( ) || Platform . isOSX ( ) ; }"}, {"instruction": "Generate java code\nif both parameters are null , returns true . if one parameter is null and the other is n't , returns false . otherwise , returns o1.equals o2 . ", "input": " String newLine \n String convertToHexString \n String hangingParagraph \n boolean iff \n String toNColsStr \n int occurCount \n boolean implies \n String createArgListJVML \n List<String> toNCols \n boolean isJavaIdentifier", "output": "boolean function ( Object arg0 , Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return false ; } return ( arg0 . equals ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nreturns an array of all of this bag 's elements . ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n int calcTotalSize \n boolean equals \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "Object [ ] function ( Object [ ] arg0 ) { return extractList ( ) . toArray ( arg0 ) ; }"}, {"instruction": "Generate java code\nadds a listener for problem marker changes . ", "input": " Set<IResource> fResourcesWithAnnotationChanges \n HashSet<IResource> fChangedElements \n ListenerList<IProblemChangedListener> fListeners \n UIJob fNotifierJob \n Set<IResource> fResourcesWithMarkerChanges \n void checkInvalidate \n void resourceChanged \n void modelChanged \n void modelChanged \n boolean isErrorDelta \n boolean visit \n void removeListener \n void fireChanges \n void postAsyncUpdate \n void runPendingUpdates", "output": "void function ( IProblemChangedListener arg0 ) { if ( fListeners . isEmpty ( ) ) { JavaPlugin . getWorkspace ( ) . addResourceChangeListener ( this ) ; JavaPlugin . getDefault ( ) . getCompilationUnitDocumentProvider ( ) . addGlobalAnnotationModelListener ( this ) ; } fListeners . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nstarts the timeout thread if it is not currently running . nothing happens if a thread is already running . ", "input": " Thread fCurrentThread \n Timeout fCurrentTimeoutState \n int IDLE \n Display fDisplay \n Object fMutex \n boolean fTimeoutState \n long fNextTimeout \n boolean fKeepRunningOnTimeout \n int fState \n int RUNNING \n int STOPPED \n Timeout restart \n void hold \n boolean tryTransition \n void setNextTimeout \n void stop \n boolean isState \n boolean hasTimedOut \n String name \n void checkedTransition \n void startThread \n void assertStates \n void setTimedOut \n void unhold", "output": "Timeout function ( long arg0 ) { Assert . assertTrue ( arg0 > 0 ) ; synchronized ( fMutex ) { switch ( fState ) { case STOPPED : startThread ( ) ; setNextTimeout ( arg0 ) ; break ; case IDLE : unhold ( ) ; setNextTimeout ( arg0 ) ; break ; default : break ; } return fCurrentTimeoutState ; } }"}, {"instruction": "Generate java code\nregisters the given tag library class name against the given namespace uri . the class will be loaded via the given classloader this should be called before the parser is used . ", "input": " InputStream m_inputStream \n Exception m_scriptCompilationException \n Log log \n Jelly m_jellyEngine \n XMLOutput m_output \n Script m_script \n OutputStream m_outputStream \n boolean m_scriptCompiled \n String m_errorMsg \n JellyContext m_context \n void setErrorMsg \n void setOutputStream \n void setContext \n void compileScriptAndKeep \n void setVariable \n URL resolveURL \n JellyContext getContext \n boolean execute \n void setScript \n void setScript \n String getErrorMsg", "output": "void function ( String arg0 , String arg1 ) { if ( m_context != null ) m_context . registerTagLibrary ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nthe result of running junit on type ", "input": " Result result \n String toString \n int failureCount", "output": "PrintableResult function ( Class < ? > arg0 ) { return testResult ( Request . aClass ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nnotification that the payment was canceled . ", "input": " long serialVersionUID \n void fireJavaScriptEvent \n void onPaymentSucceeded \n void onPaymentFailed", "output": "void function ( String arg0 ) { fireJavaScriptEvent ( \"srini_string\" , mpl . getPaymentResults ( \"srini_string\" , \"srini_string\" , \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nreturn true if debugging is enabled . ", "input": " PrintWriter sysOut \n ILog log \n boolean isDebugging \n void setLog \n void trace \n void trace \n void setDebugging \n boolean isTracing \n void traceSleep \n void close", "output": "boolean function ( ) { return isDebugging ; }"}, {"instruction": "Generate java code\nreturns the execution data store with data for all loaded classes . ", "input": " SessionInfoStore sessionInfos \n ExecutionDataStore executionData \n void load \n void load \n SessionInfoStore getSessionInfoStore \n void save \n void save", "output": "ExecutionDataStore function ( ) { return executionData ; }"}, {"instruction": "Generate java code\nindicates whether the origin response indicated the associated resource had variants i.e. that the vary header was set on the origin response . ", "input": " Date date \n Map<String,String> variantMap \n StatusLine statusLine \n HeaderGroup responseHeaders \n Resource resource \n Date requestDate \n long serialVersionUID \n Date responseDate \n Resource getResource \n Header[] getHeaders \n Header getFirstHeader \n Header[] getAllHeaders \n Map<String,String> getVariantMap \n String getReasonPhrase \n ProtocolVersion getProtocolVersion \n Date getResponseDate \n Date parseDate \n int getStatusCode \n StatusLine getStatusLine \n Date getDate \n String toString \n Date getRequestDate", "output": "boolean function ( ) { return getFirstHeader ( HeaderConstants . VARY ) != null ; }"}, {"instruction": "Generate java code\nget an issue title for the phenotype with the name given . ", "input": " String LABEL_SUFFIX \n Joiner JOINER \n String ETAG \n String BODY_FORMAT \n String body \n String title \n Pattern BODY_PATTERN \n List<Label> labels \n String NEW_LINE \n int number \n Pattern ETAG_PATTERN \n Pattern LABEL_PATTERN \n Splitter SPLITTER \n String state \n Map<String,String> getRequestParams \n String getBody \n void readEtag \n Phenotype asPhenotype \n void setTitle \n void setBody \n void setNumber \n Phenotype.Status getPTStatus \n int getNumber \n List<Label> getLabels \n String getState \n String getTitle \n void setState \n String describe \n void setLabels", "output": "String function ( String arg0 ) { return \"srini_string\" + arg0 ; }"}, {"instruction": "Generate java code\nsets the currently used node factory . ", "input": " KademliaSetup singleton \n WorkloadGenerator workloadGen \n Logger log \n AbstractNodeFactory nodeFactory \n KademliaMonitor monitor \n Config config \n WorkloadGenerator getWorkloadGenerator \n void setMonitor \n void setWorkload \n KademliaMonitor getMonitor \n AbstractNodeFactory getNodeFactory \n KademliaSetup getInstance \n void setConfigPath \n Config getConfig \n void setConfig", "output": "void function ( final AbstractNodeFactory arg0 ) { nodeFactory = arg0 ; }"}, {"instruction": "Generate java code\nsets entity content as a parameter list . this method is mutually exclusive with #settext string , #setbinary byte , #setstream java.io.inputstream , #setserializable java.io.serializable , #setfile java.io.file methods . ", "input": " File file \n boolean gzipCompress \n InputStream stream \n byte[] binary \n String contentEncoding \n boolean chunked \n String text \n List<NameValuePair> parameters \n Serializable serializable \n ContentType contentType \n EntityBuilder setBinary \n String getContentEncoding \n boolean isGzipCompress \n EntityBuilder setStream \n String getText \n void clearContent \n EntityBuilder setContentEncoding \n EntityBuilder chunked \n EntityBuilder setSerializable \n File getFile \n Serializable getSerializable \n EntityBuilder setFile \n boolean isChunked \n EntityBuilder gzipCompress \n HttpEntity build \n List<NameValuePair> getParameters \n EntityBuilder create \n ContentType getContentType \n ContentType getContentOrDefault \n byte[] getBinary \n InputStream getStream \n EntityBuilder setContentType \n EntityBuilder setText", "output": "EntityBuilder function ( final NameValuePair ... arg0 ) { return setParameters ( Arrays . asList ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns the memory bin for the given uri for external use . ", "input": " int _pageSize \n int DEFAULT_PAGESIZE \n Map<String,Bin> _binsByUri \n Bin produceBin \n void rename \n boolean exists \n void delete \n Bin open", "output": "Bin function ( String arg0 ) { return _binsByUri . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the reconciling strategies for this composite strategy . ", "input": " IReconcilingStrategy[] fStrategies \n void reconcile \n void reconcile \n void setDocument \n void setProgressMonitor \n IReconcilingStrategy[] getReconcilingStrategies \n void initialReconcile", "output": "void function ( IReconcilingStrategy [ ] arg0 ) { fStrategies = arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the applications property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the applications property . for example , to add a new item , do as follows : getapplications . add newitem ; objects of the following type s are allowed in the list application ", "input": " List<ApplicationPredecessorRelation> applicationPredecessors \n List<ApplicationID> removedApplications \n List<Application> applications \n List<ApplicationID> getRemovedApplications \n List<ApplicationPredecessorRelation> getApplicationPredecessors", "output": "List < Application > function ( ) { if ( applications == null ) { applications = new ArrayList < Application > ( ) ; } return this . applications ; }"}, {"instruction": "Generate java code\nmove to the specified synchronization point , as returned by datafilewriter #sync . ", "input": " byte[] MAGIC \n String CODEC \n Schema schema \n long blockCount \n int SYNC_SIZE \n String SYNC \n DataFileReader.SeekableInputStream in \n DatumReader<D> reader \n long count \n byte[] sync \n String SCHEMA \n Map<String,byte[]> meta \n D peek \n long blockStart \n byte VERSION \n byte[] syncBuffer \n String COUNT \n long FOOTER_BLOCK \n BinaryDecoder vin \n String NULL_CODEC \n int SYNC_INTERVAL \n D next \n D next \n long tell \n String getMetaString \n long getMetaLong \n boolean hasNext \n boolean pastSync \n void sync \n void remove \n Schema getSchema \n Iterator<D> iterator \n byte[] getMeta \n void skipSync \n void close", "output": "void function ( long arg0 ) { in . seek ( arg0 ) ; blockCount = 0 ; blockStart = arg0 ; vin = DecoderFactory . get ( ) . binaryDecoder ( in , vin ) ; }"}, {"instruction": "Generate java code\nreads an unsigned exp-golomb-coded format integer . ", "input": " byte[] data \n int byteOffset \n int bitOffset \n int byteLimit \n int bitsLeft \n boolean readBit \n int getPosition \n int readExpGolombCodeNum \n void assertValidOffset \n void reset \n void reset \n int readSignedExpGolombCodedInt \n int peekExpGolombCodedNumLength \n void skipBits \n void setPosition \n int readBits", "output": "int function ( ) { return readExpGolombCodeNum ( ) ; }"}, {"instruction": "Generate java code\ncompares this object with the specified object for ascending millisecond instant order . this ordering is inconsistent with equals , as it ignores the chronology . all readableinstant instances are accepted . ", "input": " PlaceHolder placeHolder \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n Date toDate \n boolean isEqual \n boolean isEqual \n DateTimeZone getZone \n boolean isSupported \n boolean isBeforeNow \n Instant toInstant \n boolean isBefore \n boolean isBefore \n boolean isEqualNow \n MutableDateTime toMutableDateTimeISO \n DateTime toDateTimeISO \n int hashCode \n int get \n int get \n boolean equals \n String toString \n String toString \n boolean isAfter \n boolean isAfter \n DateTime toDateTime \n DateTime toDateTime \n DateTime toDateTime \n boolean isAfterNow", "output": "int function ( ReadableInstant arg0 ) { if ( this == arg0 ) { return 0 ; } long loc0 = arg0 . getMillis ( ) ; long loc1 = getMillis ( ) ; if ( loc1 == loc0 ) { return 0 ; } if ( loc1 < loc0 ) { return - 1 ; } else { return 1 ; } }"}, {"instruction": "Generate java code\nreturns whether a java.awt.filedialog misreports its screenlocation . ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean hasMultiClickFrameBug \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return ( Platform . isOSX ( ) && Platform . JAVA_VERSION <= 0x1425 ) || ( Platform . isWindows ( ) && Platform . JAVA_VERSION <= Platform . JAVA_1_5 ) ; }"}, {"instruction": "Generate java code\nreturns the last sibling of ` a ' . ", "input": " FilterPredicate predicate \n List collectedNodes \n AST findTypeInChildren \n AST findPreviousSibling \n String getPathText \n void getPathText \n String getTokenTypeName \n boolean isSubtreeChild \n String getDebugString \n List getCollectedNodes \n Integer extractIntegerValue \n AST create \n AST createParent \n String getConstantName \n boolean exclude \n boolean exclude \n AST createBinarySubtree \n boolean include \n Map generateTokenNameCache \n void appendSibling \n ASTArray createAstArray \n AST createTree \n void insertChild \n List collectChildren \n AST getLastChild \n void makeSiblingOfParent \n void visit \n boolean hasExactlyOneChild \n AST insertSibling \n List collect \n AST createSibling", "output": "AST function ( AST arg0 ) { AST loc0 = null ; while ( arg0 != null ) { loc0 = arg0 ; arg0 = arg0 . getNextSibling ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturn the current amount of allocated memory that this accountant is managing accounting for . note this does not include reservation memory that has n't been allocated . ", "input": " Accountant parent \n AtomicLong allocationLimit \n AtomicLong peakAllocation \n long reservation \n boolean ok \n AtomicLong locallyHeldMemory \n void releaseBytes \n void updatePeak \n AllocationOutcome allocateBytes \n boolean forceAllocate \n AllocationOutcome allocate \n long getLimit \n void setLimit \n long getPeakMemoryAllocation \n boolean isOk \n void close \n boolean isOverLimit", "output": "long function ( ) { return locallyHeldMemory . get ( ) ; }"}, {"instruction": "Generate java code\nretrieve a propertymapping describing the given collection role . ", "input": " SessionFactoryImplementor sfi \n Map<String,PropertyMapping> collectionPropertyMappingByRole \n QueryableCollection getCollectionPersister \n Type getElementType \n JoinSequence createJoinSequence \n JoinSequence createJoinSequence \n Type findFunctionReturnType \n Type findFunctionReturnType \n AssociationType getElementAssociationType \n String getImportedClassName \n SQLFunction requireSQLFunction \n SessionFactoryImplementor getFactory \n boolean hasPhysicalDiscriminatorColumn \n EntityPersister requireClassPersister \n QueryableCollection requireQueryableCollection \n String[] getCollectionElementColumns \n String[][] generateColumnNames \n String getIdentifierOrUniqueKeyPropertyName \n int getColumnSpan \n String getAssociatedEntityName \n JoinSequence createCollectionJoinSequence \n Queryable findQueryableUsingImports \n Queryable findQueryableUsingImports \n boolean isStrictJPAQLComplianceEnabled \n EntityPersister findEntityPersisterByName \n SQLFunction findSQLFunction", "output": "PropertyMapping function ( String arg0 ) { return collectionPropertyMappingByRole . get ( arg0 ) ; }"}, {"instruction": "Generate java code\ndelegate method for javainformationprovider #getinformationpresentercontrolcreator ", "input": " IEditorPart fEditor \n IEditorPart getEditor \n IJavaElement[] getJavaElementsAt \n boolean isInheritDoc \n IRegion getHoverRegion \n void setEditor \n IInformationControlCreator getHoverControlCreator \n Object getHoverInfo2 \n ITypeRoot getEditorInputJavaElement \n ICodeAssist getCodeAssist", "output": "IInformationControlCreator function ( ) { return new IInformationControlCreator ( ) { @ Override public IInformationControl createInformationControl ( Shell arg0 ) { return new DefaultInformationControl ( arg0 , true ) ; } } ; }"}, {"instruction": "Generate java code\nrelease a port from the reference count , and update isdone if all is done . ", "input": " Logger LOG \n LocalAssignment _assignment \n Future<Void> _pending \n boolean _isDone \n Set<PortNAssignment> _references \n Future<T> _wrapped \n int _port \n boolean cancel \n boolean isCancelled \n int hashCode \n T get \n T get \n boolean equals \n Future<Void> reserve \n String toString \n String toString \n boolean isDone \n boolean isDone", "output": "boolean function ( int arg0 , LocalAssignment arg1 ) { PortNAssignment loc0 = new PortNAssignment ( arg0 , arg1 ) ; boolean loc1 = _references . remove ( loc0 ) ; if ( loc1 && _references . isEmpty ( ) ) { _isDone = true ; } return loc1 ; }"}, {"instruction": "Generate java code\ngetter for property currenttextcolor . ", "input": " int OPAQUE \n int TA_LEFT \n int TA_BASELINE \n ArrayList<MetaObject> MetaObjects \n int TA_TOP \n int TA_BOTTOM \n int TA_UPDATECP \n int TA_RIGHT \n int extentWy \n int extentWx \n int WINDING \n BaseColor currentTextColor \n int offsetWx \n int textAlign \n int offsetWy \n MetaFont currentFont \n float scalingX \n int lineJoin \n BaseColor currentBackgroundColor \n float scalingY \n int TA_CENTER \n int backgroundMode \n Point currentPoint \n int TA_NOUPDATECP \n int polyFillMode \n MetaBrush currentBrush \n int ALTERNATE \n MetaPen currentPen \n Stack<MetaState> savedStates \n int TRANSPARENT \n void restoreState \n void addMetaObject \n void saveState \n int getTextAlign \n int getBackgroundMode \n MetaPen getCurrentPen \n void setCurrentBackgroundColor \n void setMetaState \n MetaBrush getCurrentBrush \n void setBackgroundMode \n void setOffsetWy \n MetaFont getCurrentFont \n void setOffsetWx \n void setLineJoinRectangle \n void setScalingY \n float transformAngle \n void setScalingX \n BaseColor getCurrentBackgroundColor \n void setPolyFillMode \n float transformY \n float transformX \n int getPolyFillMode \n void setExtentWy \n void deleteMetaObject \n void setExtentWx \n Point getCurrentPoint \n void setTextAlign \n void setCurrentPoint \n void setLineJoinPolygon \n boolean getLineNeutral \n void setCurrentTextColor \n void selectMetaObject \n void cleanup", "output": "BaseColor function ( ) { return currentTextColor ; }"}, {"instruction": "Generate java code\nreturns cpi resources which reference consume a given ppi resource ", "input": " EntityManager entityManager \n Logger log \n long serialVersionUID \n ResourceDependencyResolverService dependencyResolverService \n void setSoftlinkRelation \n SoftlinkRelationEntity getSoftLinkRelationByCpiAndSoftlinkRef \n void removeSoftlinkRelation \n List<SoftlinkRelationEntity> getSoftlinksForCpi \n ResourceEntity getSoftlinkResolvableSlaveResource", "output": "List < ResourceEntity > function ( ResourceEntity arg0 ) { if ( arg0 . getId ( ) != null ) { return entityManager . createQuery ( \"srini_string\" , ResourceEntity . class ) . setParameter ( \"srini_string\" , arg0 . getSoftlinkId ( ) ) . getResultList ( ) ; } return Collections . emptyList ( ) ; }"}, {"instruction": "Generate java code\nreads data lookup quality information from the given file . ", "input": " Map<Integer,OpDelay> opDelay \n Map<Integer,DataLookupQuality> dataQuality \n Map<Integer,NodeLookupQuality> nodeQuality \n Map<Integer,OpTraffic> opTraffic \n void readOpDelay \n void readOpTraffic \n void readNodeQuality", "output": "void function ( final String arg0 ) { dataQuality = new HashMap < Integer , DataLookupQuality > ( ) ; FileReader loc0 = new FileReader ( arg0 ) ; BufferedReader loc1 = new BufferedReader ( loc0 ) ; String loc2 = null ; DataLookupQuality loc3 ; loc1 . readLine ( ) ; while ( ( loc2 = loc1 . readLine ( ) ) != null ) { loc3 = DataLookupQuality . fromString ( loc2 ) ; } }"}, {"instruction": "Generate java code\nreturns the serialized payload of the request in this rpc . will only be generated from a requestor and will not include handshake or meta-data . if the request payload has not been set yet , returns null . ", "input": " Map<String,ByteBuffer> requestCallMeta \n Map<String,ByteBuffer> responseCallMeta \n Object response \n List<ByteBuffer> requestPayload \n List<ByteBuffer> responsePayload \n HandshakeRequest handshakeRequest \n HandshakeResponse handshakeResponse \n Exception error \n Message message \n void setResponseCallMeta \n void setRequestHandshakeMeta \n Map<String,ByteBuffer> requestHandshakeMeta \n void setRequestPayload \n void setResponsePayload \n Message getMessage \n void setResponse \n void setResponseHandshakeMeta \n void setRequestCallMeta \n Exception error \n void setMessage \n void setHandshakeRequest \n Map<String,ByteBuffer> responseHandshakeMeta \n Map<String,ByteBuffer> requestCallMeta \n boolean isError \n Map<String,ByteBuffer> responseCallMeta \n HandshakeRequest getHandshakeRequest \n Object response \n void setError \n void setHandshakeResponse \n HandshakeResponse getHandshakeResponse \n List<ByteBuffer> getResponsePayload", "output": "List < ByteBuffer > function ( ) { return this . requestPayload ; }"}, {"instruction": "Generate java code\ncreate and return a remotebuildr instance . ", "input": " String PROP_WEBTESTS_BROWSER \n String PROP_WEBTESTS_LOCALES \n String PROP_WEBTESTS_HUB_URL \n ChromeBuildr chrome \n SafariBuildr safari \n SysPropsBuildr fromSysProps \n WebDriver build \n FirefoxBuildr firefox", "output": "RemoteBuildr function ( ) { return new RemoteBuildr ( ) ; }"}, {"instruction": "Generate java code\nremoves all the elements from this collection that are returned by iterable . ", "input": " int _size \n List4 _last \n List4 _first \n int _version \n void prepend \n void replace \n boolean remove \n Object singleElement \n Iterator4 iterator \n List4 find \n void assertNotNull \n Object get \n Object get \n void replaceByIdentity \n Object[] toArray \n Object[] toArray \n void adjustOnRemoval \n int indexOf \n void doPrepend \n List4 findByIdentity \n boolean add \n void doAdd \n Object ensure \n boolean containsAll \n void clear \n boolean isEmpty \n int version \n boolean contains \n int size \n void addAll \n void addAll \n void addAll \n Object deepClone \n boolean containsByIdentity \n String toString \n Iterator4 internalIterator \n void changed", "output": "void function ( Iterable4 arg0 ) { removeAll ( arg0 . iterator ( ) ) ; }"}, {"instruction": "Generate java code\ntest that stopping the hibernate-osgi bundle happens cleanly . todo : this will be really simplistic at first , but should be expanded upon . ", "input": " BundleContext context \n void testNative \n void commonTests \n void testLazyLoading \n void testClientBundle \n Bundle findHibernateBundle \n void testExtensionPoints \n void testHibernateBundle \n TestService getTestService \n JavaArchive deployment \n void testJpa", "output": "void function ( ) { commonTests ( ) ; findHibernateBundle ( \"srini_string\" ) . stop ( ) ; testHibernateBundle ( \"srini_string\" , Bundle . RESOLVED ) ; assertNull ( context . getServiceReference ( OsgiSessionFactoryService . class ) ) ; assertNull ( context . getServiceReference ( OsgiPersistenceProviderService . class ) ) ; }"}, {"instruction": "Generate java code\ncalled when a chunk with a generic tag is written . it is useful to pinpoint the chunk location to generate bookmarks , for example . ", "input": " PlaceHolder placeHolder \n void onSection \n void onParagraph \n void onParagraphEnd \n void onOpenDocument \n void onSectionEnd \n void onEndPage \n void onChapter \n void onCloseDocument \n void onChapterEnd \n void onStartPage", "output": "void function ( PdfWriter arg0 , Document arg1 , Rectangle arg2 , String arg3 ) { }"}, {"instruction": "Generate java code\nreturns the artifact type . ", "input": " String CLASSIFIER_SEPARATOR \n String m_fullClassifier \n String FILE_SEPARATOR \n String TYPE_SEPARATOR \n String m_artifact \n String m_group \n String m_classifier \n String m_version \n String SYNTAX \n String GROUP_SEPARATOR \n String VERSION_SEPARATOR \n String METADATA_FILE \n MavenRepositoryURL m_repositoryURL \n String REPOSITORY_SEPARATOR \n String VERSION_SNAPSHOT \n String TYPE_JAR \n String m_type \n String ARTIFACT_SEPARATOR \n String VERSION_LATEST \n String METADATA_FILE_LOCAL \n String getVersion \n MavenURL parsePathWithSchemePrefix \n MavenRepositoryURL getRepositoryURL \n String getArtifactMetdataPath \n void parseArtifactPart \n String getClassifier \n String getSnapshotVersion \n String getVersionMetadataPath \n String getArtifactPath \n String getArtifactPath \n String getArtifact \n String getSnapshotPath \n String getGroup \n String getArtifactLocalMetdataPath \n String getVersionLocalMetadataPath", "output": "String function ( ) { return m_type ; }"}, {"instruction": "Generate java code\nreturns a scanner which is configured to scan java multi-line comments . ", "input": " JavaCommentScanner fMultilineCommentScanner \n JavaCommentScanner fSinglelineCommentScanner \n JavaDocScanner fJavaDocScanner \n PreferenceListener fPreferenceListener \n JavaCodeScanner fCodeScanner \n IPreferenceStore fPreferenceStore \n SingleTokenJavaScanner fStringScanner \n String[] LEGAL_CONTENT_TYPES \n JavaColorManager fColorManager \n Preferences fCorePreferenceStore \n RuleBasedScanner getJavaDocScanner \n RuleBasedScanner getSinglelineCommentScanner \n IDocumentPartitioner createDocumentPartitioner \n RuleBasedScanner getStringScanner \n IPreferenceStore getPreferenceStore \n RuleBasedScanner getCodeScanner \n void setupJavaDocumentPartitioner \n void setupJavaDocumentPartitioner \n void adaptToPreferenceChange \n String[] getPartitionManagingPositionCategories \n IPartitionTokenScanner getPartitionScanner \n void propertyChange \n void propertyChange \n void dispose \n boolean affectsBehavior \n IColorManager getColorManager \n Preferences getCorePreferenceStore", "output": "RuleBasedScanner function ( ) { return fMultilineCommentScanner ; }"}, {"instruction": "Generate java code\nreturns the number of hits that match the given query . ", "input": " TContact c \n int numberOfHits \n int getTotalHits \n long getSize \n int hashCode \n boolean equals \n String toString \n TContact getContact", "output": "int function ( ) { return numberOfHits ; }"}, {"instruction": "Generate java code\ncheck to see if the given item is in an array . ", "input": " PlaceHolder placeHolder \n int findFirstNotContainedIn \n int ctrlSelect \n int last \n int stdSelect \n int indexToSelect \n int indexToSelect \n int shiftSelect \n int first", "output": "boolean function ( int arg0 , int [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1 . length ; ++ loc0 ) { if ( arg1 [ loc0 ] == arg0 ) return true ; } return false ; }"}, {"instruction": "Generate java code\nget a list of nodes that have no outbound edges . ", "input": " Set<Node> allNodes \n ListMultimap<Node,Edge<Node>> adjacencies \n int lowlink \n V nodeValue \n boolean visited \n int index \n AdjacencyList<V> getReversedList \n Collection<Node> getInternalRootNodes \n Node getNewNode \n AdjacencyList<V> newInstance \n List<V> convert \n int compareTo \n V getNodeValue \n void fix \n int hashCode \n List<V> getRootNodes \n void printEdges \n Collection<Edge<Node>> getAllEdges \n List<Edge<Node>> getAdjacent \n String toString \n void clearVisited \n void addEdge \n Collection<Node> getInternalLeafNodes \n Set<Node> getNodeSet", "output": "Collection < V > function ( ) { return convert ( getInternalLeafNodes ( ) ) ; }"}, {"instruction": "Generate java code\nremove a value from the map ", "input": " LinkedHashMap<S,LinkedHashMap<S,T>> values \n boolean contains \n T get \n Set<T> removeComplementarySet \n void put", "output": "T function ( S arg0 , S arg1 ) { Map < S , T > loc0 ; if ( ( loc0 = values . get ( arg0 ) ) != null ) { if ( loc0 . containsKey ( arg1 ) ) return loc0 . remove ( arg1 ) ; } return null ; }"}, {"instruction": "Generate java code\nsets the error messages directly from a reader . ", "input": " String BASE_PATH \n HashMap<String,String> currentLanguage \n HashMap<String,String> defaultLanguage \n String getComposedMessage \n String getComposedMessage \n HashMap<String,String> getLanguageMessages \n String getMessage \n String getMessage \n HashMap<String,String> readLanguageStream \n HashMap<String,String> readLanguageStream \n boolean setLanguage", "output": "void function ( Reader arg0 ) { currentLanguage = readLanguageStream ( arg0 ) ; }"}, {"instruction": "Generate java code\ngetter for property backgroundmode . ", "input": " int OPAQUE \n int TA_LEFT \n int TA_BASELINE \n ArrayList<MetaObject> MetaObjects \n int TA_TOP \n int TA_BOTTOM \n int TA_UPDATECP \n int TA_RIGHT \n int extentWy \n int extentWx \n int WINDING \n BaseColor currentTextColor \n int offsetWx \n int textAlign \n int offsetWy \n MetaFont currentFont \n float scalingX \n int lineJoin \n BaseColor currentBackgroundColor \n float scalingY \n int TA_CENTER \n int backgroundMode \n Point currentPoint \n int TA_NOUPDATECP \n int polyFillMode \n MetaBrush currentBrush \n int ALTERNATE \n MetaPen currentPen \n Stack<MetaState> savedStates \n int TRANSPARENT \n void restoreState \n void addMetaObject \n void saveState \n int getTextAlign \n MetaPen getCurrentPen \n void setCurrentBackgroundColor \n void setMetaState \n MetaBrush getCurrentBrush \n void setBackgroundMode \n void setOffsetWy \n MetaFont getCurrentFont \n void setOffsetWx \n void setLineJoinRectangle \n void setScalingY \n float transformAngle \n void setScalingX \n BaseColor getCurrentBackgroundColor \n void setPolyFillMode \n float transformY \n float transformX \n int getPolyFillMode \n void setExtentWy \n BaseColor getCurrentTextColor \n void deleteMetaObject \n void setExtentWx \n Point getCurrentPoint \n void setTextAlign \n void setCurrentPoint \n void setLineJoinPolygon \n boolean getLineNeutral \n void setCurrentTextColor \n void selectMetaObject \n void cleanup", "output": "int function ( ) { return backgroundMode ; }"}, {"instruction": "Generate java code\nreturn the directory into which we put our self-extracted native libraries and make sure it exists . ", "input": " byte[] cachedBuffer \n void reliablyCopyExecutable \n void deleteOrThrow \n FileLocker lockLibsDirectory \n void freeCopyBuffer \n File getLibsDirectory \n int findAbiScore \n void dumbDeleteRecrusive \n String[] getSupportedAbis \n String[] getSupportedAbis \n void fallocateIfSupported \n void fallocate", "output": "File function ( Context arg0 ) { File loc0 = getLibsDirectory ( arg0 ) ; if ( ! loc0 . isDirectory ( ) && ! loc0 . mkdirs ( ) ) { throw new RuntimeException ( \"srini_string\" ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns the number of values = v. ", "input": " long serialVersionUID \n TreeMap freqTable \n int compare \n double getPct \n double getPct \n double getPct \n double getPct \n long getCumFreq \n long getCumFreq \n long getCumFreq \n long getCumFreq \n Iterator valuesIterator \n double getCumPct \n double getCumPct \n double getCumPct \n double getCumPct \n void clear \n String toString \n void addValue \n void addValue \n void addValue \n void addValue \n void addValue \n long getSumFreq", "output": "long function ( Object arg0 ) { if ( arg0 instanceof Integer ) { return getCount ( ( ( Integer ) arg0 ) . longValue ( ) ) ; } long loc0 = 0 ; try { Long loc1 = ( Long ) freqTable . get ( arg0 ) ; if ( loc1 != null ) { loc0 = loc1 . longValue ( ) ; } } catch ( ClassCastException loc1 ) { } return loc0 ; }"}, {"instruction": "Generate java code\nwrites a buffer to the seeked address ", "input": " int COPY_SIZE \n int _blockSize \n int read \n int read \n long regularAddress \n void delete \n void seek \n void sync \n void blockSize \n int blockSize \n IoAdapter delegatedIoAdapter \n boolean exists \n long getLength \n void blockCopy \n void blockSeek \n void blockSeek \n void copy \n void copy \n void close \n IoAdapter open", "output": "void function ( byte [ ] arg0 ) { write ( arg0 , arg0 . length ) ; }"}, {"instruction": "Generate java code\nscalar product of vector of polynomials with polynomial . ", "input": " Logger logger \n List<GenPolynomial<C>> vectorAdd \n boolean isZero", "output": "List < GenPolynomial < C >> function ( List < GenPolynomial < C >> arg0 , GenPolynomial < C > arg1 ) { List < GenPolynomial < C >> loc0 = new ArrayList < GenPolynomial < C >> ( arg0 . size ( ) ) ; for ( GenPolynomial < C > loc1 : arg0 ) { if ( loc1 != null ) { loc1 = loc1 . multiply ( arg1 ) ; } loc0 . add ( loc1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturn a library that loads the structure-only from code.jquery.com ", "input": " String BASE_RESOURCE_URL \n String url \n JQueryLibrary core \n JQueryLibrary baseTheme \n JQueryLibrary ui \n void renderOn \n JQueryLibrary mobileTheme \n JQueryLibrary mobile \n JQueryLibrary theme", "output": "JQueryLibrary function ( String arg0 ) { return new JQueryLibrary ( BASE_RESOURCE_URL + \"srini_string\" + arg0 + \"srini_string\" + arg0 + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns 0-15 15/16 times . returns 0-255 255/256 times . returns 0-4095 4095/4096 times . returns 0-65535 every time . ", "input": " long seed \n boolean seedSet \n void testRandomLength \n String randomString \n Random createRandom \n void resetRandomSeed \n long getRandomSeed \n ByteBuffer randomBytes", "output": "int function ( Random arg0 ) { int loc0 = arg0 . nextInt ( ) ; if ( loc0 < 0 ) loc0 = - loc0 ; return loc0 & ( ( loc0 & 0xF0000 ) != 0 ? 0xF : ( ( loc0 & 0xFF0000 ) != 0 ? 0xFF : ( ( loc0 & 0xFFF0000 ) != 0 ? 0xFFF : 0xFFFF ) ) ) ; }"}, {"instruction": "Generate java code\ncalled once before initial sorting starts the first time . note : as of 3.8 a completion proposal computer can request that proposals are resorted . if such a computer is active , then this method will not be called . clients may override , the default implementation does nothing . ", "input": " PlaceHolder placeHolder \n int compare \n void endSorting", "output": "void function ( ContentAssistInvocationContext arg0 ) { }"}, {"instruction": "Generate java code\nreturns true if the experiment has aditional values . ", "input": " Context context \n String experimentName \n JSONObject getValues \n boolean isActive \n boolean isActive", "output": "boolean function ( ) { return SwitchBoard . hasExperimentValues ( context , experimentName ) ; }"}, {"instruction": "Generate java code\nopens the given url in the browser as choosen in the preferences . ", "input": " PlaceHolder placeHolder \n void internalOpen \n void openExternal", "output": "void function ( final URL arg0 , Display arg1 ) { arg1 . syncExec ( new Runnable ( ) { @ Override public void run ( ) { internalOpen ( arg0 , false ) ; } } ) ; }"}, {"instruction": "Generate java code\ntransfers from right to left ", "input": " PlaceHolder placeHolder \n void swap \n void swap", "output": "byte [ ] function ( byte [ ] arg0 , byte [ ] arg1 ) { return ArrayTool . transferValues ( arg0 , arg1 , 0 , arg1 . length ) ; }"}, {"instruction": "Generate java code\nsetter for the font provider ", "input": " FontProvider provider \n ListItem createListItem \n void setParagraphLeading \n List createList \n Image createImage \n FontProvider getFontProvider \n Chunk createChunk \n LineSeparator createLineSeparator \n Paragraph createParagraph \n Font getFont \n HyphenationEvent getHyphenation \n void updateElement", "output": "void function ( final FontProvider arg0 ) { this . provider = arg0 ; }"}, {"instruction": "Generate java code\ncreates a criterion using the > operator ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria lt \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria nin \n Criteria nin \n Criteria and \n Criteria gte \n Criteria create \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria eq \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n Criteria exists \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( Object arg0 ) { this . criteriaType = RelationalOperator . GT ; this . right = ValueNode . toValueNode ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nonly exposed so that script may invoke it on load from disk . ", "input": " String description \n Resolver resolver \n Throwable invalidScriptError \n String toXMLString \n Map getAttributes \n String getXMLTag \n void writeObject \n void usage \n void usage \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n Element addContent \n String getDescription \n String getUsage \n void readObject \n String getDefaultDescription \n String toEditableString \n Step createStep \n Step createStep \n void runStep \n ComponentTester resolveTester \n Class resolveClass \n void setScriptError \n String toString \n Resolver getResolver \n Map createAttributeMap", "output": "void function ( Map arg0 ) { Log . debug ( \"srini_string\" + getClass ( ) ) ; description = ( String ) arg0 . get ( TAG_DESC ) ; }"}, {"instruction": "Generate java code\nassertion which requires list of one element as a result of indefinite path search . ", "input": " PlaceHolder placeHolder \n void assertHasResults \n void assertEvaluationThrows \n void assertEvaluationThrows \n void assertHasNoResults", "output": "void function ( final String arg0 , final String arg1 , Configuration arg2 ) { assertHasResults ( arg0 , arg1 , 1 , arg2 ) ; }"}, {"instruction": "Generate java code\nsets the suffix of the output file including the file extension . the file name will be constructed by appending the prefix , some configuration and version information , and the suffix . if that file already exists , it will be overwritten . if not , it will be created . if the path does not exist , it is attempted to create it as well . a new file is created only if none has been opened by this analyzer before . if one file is still open from an earlier analyzer run , it will be used . the output file is constructed with this prefix only if #setoutputfile string has never been called before setting thecomplete output file path disables prefix/suffix settings . the contents of this output file is aimed at supporting in-depth analysis of the measurement results . it is not the same as the contents written onto the writer passed to #stop writer as that contents isintended to be displayed after the simulation run . calls to this method are ignored if this analyzer has already been started . ", "input": " Logger log \n String description \n int clusterIDLength \n String style \n boolean started \n String fileDescr \n String seed \n int BUFFER_CAPACITY \n String filePrefix \n String fileSuffix \n PrintWriter out \n void appendClusterID \n void setOutputFilePrefix \n void stopped \n void start \n void appendNewLine \n void started \n void setDescription \n boolean isStarted \n void setOutputFile \n void appendSeparator \n void setOutputFileDescr \n void stop \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void appendToFile \n void setStyle \n void setSeed \n String getFileName", "output": "void function ( final String arg0 ) { if ( ! started ) { fileSuffix = arg0 ; } }"}, {"instruction": "Generate java code\nreturns a boolean indicating whether the subpath is degenerate or not . a degenerate subpath is the subpath consisting of a single-point closed path or of two or more points at the same coordinates . ", "input": " List<Shape> segments \n Point2D startPoint \n boolean closed \n Point2D getStartPoint \n boolean isSinglePointOpen \n void addSegment \n boolean isClosed \n boolean isEmpty \n boolean isSinglePointClosed \n List<Point2D> getPiecewiseLinearApproximation \n void setStartPoint \n void setStartPoint \n Point2D getLastPoint \n void setClosed \n List<Shape> getSegments", "output": "boolean function ( ) { if ( segments . size ( ) > 0 && closed ) { return false ; } for ( Shape loc0 : segments ) { Set < Point2D > loc1 = new HashSet < Point2D > ( loc0 . getBasePoints ( ) ) ; if ( loc1 . size ( ) != 1 ) { return false ; } } return segments . size ( ) > 0 || closed ; }"}, {"instruction": "Generate java code\ngets the first codec which can decode the specified format . ", "input": " Registry instance \n Codec[] getCodecs \n Codec[] getDecoders \n String[] getCodecClasses \n Codec[] getEncoders \n void unregisterCodec \n void putCodec \n Codec getEncoder \n String[] getDecoderClasses \n void init \n String getExtension \n Codec getCodec \n void putReader \n MovieReader getReader \n MovieReader getReader \n void putFileFormat \n Format[] getWriterFormats \n Format getFileFormat \n Format[] getReaderFormats \n Format[] getFileFormats \n String[] getWriterClasses \n String[] getReaderClasses \n String[] getEncoderClasses \n MovieWriter getWriter \n MovieWriter getWriter \n ArrayList<Format> suggestOutputFormats \n void putWriter \n Registry getInstance", "output": "Codec function ( Format arg0 ) { return getCodec ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nget the index into the local variable array . ", "input": " String name \n int index \n Type type \n int hashCode \n boolean equals \n String name \n String toString \n Type type", "output": "int function ( ) { return index ; }"}, {"instruction": "Generate java code\nreturns the number of expressions on the stack . ", "input": " ArrayList stack \n int height \n Expr pop \n void set \n Expr pop1 \n Expr[] pop2 \n Expr get \n boolean isEmpty \n void replace \n String toString \n void push \n Expr peek \n Expr peek \n int height", "output": "int function ( ) { return stack . size ( ) ; }"}, {"instruction": "Generate java code\nverifies if div is a stack owner . should be true . ", "input": " List<Element> currentContent \n Div d \n WorkerContextImpl workerContextImpl \n void init \n void verifyNumberOfParagraphs \n void verifyIfPdfDiv \n void verifyContent", "output": "void function ( ) { Assert . assertTrue ( d . isStackOwner ( ) ) ; }"}, {"instruction": "Generate java code\nnormally , the propagation of messages through channels and routers of the internet is affected by the propagation delays of the physical media , and the processing - , queuing - , and transmission delays of the routers . the so called internet propagation delay is modeled as the sum of a fixed part that combines the aforementioned router and propagation delays , and a variable part to reproduce the jitter . invoking this method returns the internet propagation delay in ms between two hosts in the internet . note that this delay is derived from measurement data , and it therefore estimates the one-way delay of the measured round-trip-times between the specified hosts . ", "input": " GnpSubnet subnet \n GnpLatencyModel lm \n void setLatencyModel \n int getGeoPriority \n double getGeographicalDistance", "output": "double function ( NetID arg0 , NetID arg1 ) { NetLayer loc0 = subnet . getNetLayer ( arg0 ) ; NetLayer loc1 = subnet . getNetLayer ( arg1 ) ; return lm . getPropagationDelay ( ( GnpNetLayer ) loc0 , ( GnpNetLayer ) loc1 ) / ( double ) Simulator . MILLISECOND_UNIT ; }"}, {"instruction": "Generate java code\ncreate a widget not found match result . ", "input": " int MATCH \n Collection _widgets \n int _dbComparisons \n Widget _widget \n Hierarchy _hierarchy \n int BFS \n int DFS \n int _type \n ArrayList _list \n int WIDGET_NOT_FOUND \n int MULTIPLE_WIDGETS_FOUND \n int _searchType \n Widget getParent \n Collection getRoots \n Widget getWidget \n Collection getWidgets \n Collection getWidgets \n MatchResult match \n void findMatches \n MatchResult multipleFound \n void pause \n boolean contains \n int getType \n MatchResult find \n MatchResult find \n MatchResult find \n MatchResult find \n MatchResult find \n MatchResult find \n void assertNotNull \n void assertNotNull \n MatchResult find0 \n void dispose \n int getFinderRetryInterval \n int getMaxFinderRetries \n void setFound", "output": "MatchResult function ( ) { return new MatchResult ( WIDGET_NOT_FOUND ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable view of the given bag . any modification attempts to the returned bag will raise an unsupportedoperationexception . ", "input": " Bag EMPTY_BAG \n Bag EMPTY_SORTED_BAG \n Bag predicatedBag \n SortedBag synchronizedSortedBag \n SortedBag predicatedSortedBag \n SortedBag transformedSortedBag \n Bag typedBag \n Bag transformedBag \n SortedBag unmodifiableSortedBag \n SortedBag typedSortedBag \n Bag synchronizedBag", "output": "Bag function ( Bag arg0 ) { return UnmodifiableBag . decorate ( arg0 ) ; }"}, {"instruction": "Generate java code\nempty payload object has no syncid or storageversion and should call freshstart . ", "input": " String LOG_TAG \n String TEST_NW_URL \n String TEST_PASSWORD \n String TEST_SYNC_ID \n String TEST_SERVER \n String TEST_CLUSTER_URL \n boolean calledFreshStart \n boolean calledResetAllStages \n String TEST_SYNC_KEY \n GlobalSession session \n long TEST_STORAGE_VERSION \n boolean calledProcessMissingMetaGlobal \n boolean calledUploadKeys \n String TEST_INFO_COLLECTIONS_JSON \n KeyBundle syncKeyBundle \n int TEST_PORT \n HTTPServerTestHelper data \n boolean calledRequiresUpgrade \n InfoCollections infoCollections \n boolean calledWipeServer \n MockGlobalSessionCallback callback \n String TEST_USERNAME \n void doFreshStart \n void doSession \n void testFetchRequiresUpgrade \n JSONArray makeTestDeclinedArray \n void testFetchSuccessWithDifferentSyncIDMergesDeclined \n void testFreshStart \n void assertSameContents \n void setUp \n void testFetchSuccessWithDifferentSyncID \n void testFetchMissing \n void testFetchNoPayload \n void testFetchSuccessWithSameSyncID \n void testFetchMalformedPayload", "output": "void function ( ) { MockServer loc0 = new MockServer ( 200 , TestMetaGlobal . TEST_META_GLOBAL_EMPTY_PAYLOAD_RESPONSE ) ; doSession ( loc0 ) ; assertTrue ( calledFreshStart ) ; }"}, {"instruction": "Generate java code\nverify if the thief uses the provided stealing method ", "input": " PlaceHolder placeHolder \n void testChangeMethod", "output": "void function ( ) { final StealingMethod loc0 = mock ( StealingMethod . class ) ; final HalflingThief loc1 = new HalflingThief ( loc0 ) ; loc1 . steal ( ) ; verify ( loc0 ) . steal ( ) ; verifyNoMoreInteractions ( loc0 ) ; }"}, {"instruction": "Generate java code\nchecks if given port is open on ` localhost ' ", "input": " Logger LOG \n String cmdHistory \n PythonProcess mockPythonProcess \n PythonInterpreter pythonInterpreter \n void testPy4jInstalled \n void checkMultiRowErrorFails \n boolean tryToConnect \n void tryToClose \n void testOpenInterpreter \n String answerFromPythonMock \n void beforeTest \n void testClose \n Properties getPythonTestProperties \n void testInterpret \n void testPy4jIsNotInstalled", "output": "boolean function ( Integer arg0 ) { Socket loc0 = new Socket ( ) ; boolean loc1 = false ; int loc2 = 0 ; boolean loc3 = false ; while ( loc3 = tryToConnect ( loc0 , arg0 ) && loc2 < 10 ) { loc1 = loc3 ; tryToClose ( loc0 ) ; loc2 ++ ; loc0 = new Socket ( ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nlike #assign autocloseable , except that any exception thrown by closing the previously held pointer is wrapped with an unchecked runtimeexception . ", "input": " T pointer \n T adopt \n T get \n void close \n void assign", "output": "void function ( final T arg0 ) { try { assign ( arg0 ) ; } catch ( final Exception loc0 ) { throw new RuntimeException ( loc0 ) ; } }"}, {"instruction": "Generate java code\ngets the position back ", "input": " MSG_TYPE msgType \n SequenceNumber sequenceNr \n byte hopCount \n Point position \n int radius \n MSG_TYPE getMsgType \n int getSizeOfAbstractMessage \n byte getHopCount \n boolean equals \n SequenceNumber getSequenceNr \n int getRadius", "output": "Point function ( ) { return position ; }"}, {"instruction": "Generate java code\nanswers the uicontext . notice this is acting as a context factory . ", "input": " IUIContext _ui \n Display _display \n Shell _rootShell \n IUIContext createUI \n void cacheDisplay \n void setDisplay \n void update \n Shell getRootShell \n void cacheRootShell \n void setRootShell \n Display getDisplay", "output": "IUIContext function ( ) { if ( _ui == null ) _ui = createUI ( ) ; return _ui ; }"}, {"instruction": "Generate java code\nreturns the position of the first digit in the trailing number of the given string or -1 if the string does not end with number example : alice has got a cat 12 - will return 20 the position of ' 1 ' alice has got a black cat - will return -1 no trailing number in the string ", "input": " List<String> partNames \n String PART_NAME \n Map<Character,String> greekLetters \n Map<String,String> wordToDecimal \n String replaceLastWordNumberToDecimal \n String replaceNumbersToDecimal \n String normalizePartQualifiers \n int digitsPercentage \n int romanToDecimal \n String removeStopWords \n String getTrailingInteger \n boolean inLevenshteinDistance \n String replaceLastRomanNumberToDecimal \n String normalize \n boolean isRomanNumber \n boolean isDecimalNumber \n boolean isEngWordNumber \n int processDecimal", "output": "int function ( String arg0 ) { int loc0 ; for ( loc0 = arg0 . length ( ) - 1 ; loc0 >= 0 ; loc0 -- ) { char loc1 = arg0 . charAt ( loc0 ) ; if ( ! Character . isDigit ( loc1 ) ) { break ; } } if ( loc0 == arg0 . length ( ) - 1 ) { return - 1 ; } return loc0 + 1 ; }"}, {"instruction": "Generate java code\ncalculate the srp verifier v value . ", "input": " int HASH_LENGTH_HEX \n int CRYPTO_KEY_LENGTH_BYTES \n int SALT_LENGTH_HEX \n int NUMBER_OF_QUICK_STRETCH_ROUNDS \n String KW_VERSION_STRING \n boolean LOG_PERSONAL_INFORMATION \n int CRYPTO_KEY_LENGTH_HEX \n String LOG_TAG \n int SALT_LENGTH_BYTES \n int HASH_LENGTH_BYTES \n byte[] unwrapkB \n String defaultClientName \n String getAudienceForURL \n String hexModN \n KeyBundle generateSyncKeyBundle \n byte[] generateQuickStretchedPW \n byte[] generateAuthPW \n String computeClientState \n byte[] KW \n void pii \n BigInteger srpVerifierLowercaseX \n String bytes \n byte[] generateUnwrapBKey \n byte[] KWE", "output": "BigInteger function ( byte [ ] arg0 , byte [ ] arg1 , byte [ ] arg2 , BigInteger arg3 , BigInteger arg4 ) { BigInteger loc0 = srpVerifierLowercaseX ( arg0 , arg1 , arg2 ) ; BigInteger loc1 = arg3 . modPow ( loc0 , arg4 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nmethod to get exception details ", "input": " Logger LOGGER \n void init \n void compare \n int validateInput \n void main", "output": "String function ( Throwable arg0 ) { return ( arg0 . getCause ( ) != null ) ? arg0 . getCause ( ) . getMessage ( ) : arg0 . getMessage ( ) ; }"}, {"instruction": "Generate java code\nsets the value of the machineinterpretationkey property . ", "input": " String validationPattern \n boolean isValueOptional \n boolean encrypted \n String machineInterpretationKey \n String displayName \n String defaultValue \n String technicalKey \n boolean isKeyOptional \n List<String> tags \n String exampleValue \n void setDefaultValue \n String getExampleValue \n List<String> getTags \n String getValidationPattern \n boolean isIsKeyOptional \n void setIsKeyOptional \n void setDisplayName \n void setExampleValue \n String getDefaultValue \n String getTechnicalKey \n void setEncrypted \n void setTechnicalKey \n String getDisplayName \n boolean isEncrypted \n String getMachineInterpretationKey \n void setValidationPattern \n boolean isIsValueOptional \n void setIsValueOptional", "output": "void function ( String arg0 ) { this . machineInterpretationKey = arg0 ; }"}, {"instruction": "Generate java code\nchecks if a charsequence is empty '' '' or null . stringutils.isempty null = true stringutils.isempty '' '' = true stringutils.isempty '' '' = false stringutils.isempty `` bob '' = false stringutils.isempty '' bob '' = false note : this method changed in lang version 2.0 . it no longer trims the charsequence . that functionality is available in isblank . ", "input": " PlaceHolder placeHolder \n T notNull \n String unescape \n String concat \n void onlyOneIsTrue \n void isTrue \n boolean onlyOneIsTrueNonThrow \n String hex \n String toString \n String join \n String join \n void closeQuietly \n T notEmpty \n String escape \n int indexOf", "output": "boolean function ( CharSequence arg0 ) { return arg0 == null || arg0 . length ( ) == 0 ; }"}, {"instruction": "Generate java code\ngets date value form cursor for column index . ", "input": " PlaceHolder placeHolder \n Long getLong \n Character getChar \n Integer getInt \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n void bind \n Byte getByte \n Short getShort \n byte[] getByteArray \n Double getDouble \n Boolean getBoolean \n Float getFloat \n String getString", "output": "Date function ( @ NonNull Cursor arg0 , int arg1 ) { if ( arg0 . isNull ( arg1 ) ) { return null ; } return new Date ( arg0 . getLong ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nsets the invoked . ", "input": " Log log \n List customers \n boolean invoked \n void addCustomer \n List getCustomers \n boolean isInvoked \n String toString \n void run \n void removeCustomer", "output": "void function ( boolean arg0 ) { this . invoked = arg0 ; }"}, {"instruction": "Generate java code\nreturns the character used for escaping values where the field delimiter is part of the value . defaults to ' '' ' ", "input": " TextParsingSettings DEFAULT \n String emptyValue \n byte normalizedNewLine \n boolean parseUnescapedQuotes \n boolean headerExtractionEnabled \n int numberOfRecordsToRead \n boolean useRepeatedVarChar \n org.slf4j.Logger logger \n boolean ignoreLeadingWhitespaces \n byte delimiter \n boolean ignoreTrailingWhitespaces \n byte quote \n byte quoteEscape \n byte[] newLineDelimiter \n long maxCharsPerColumn \n String lineSeparatorString \n byte comment \n boolean skipFirstLine \n byte getQuoteEscape \n String getEmptyValue \n boolean isIgnoreLeadingWhitespaces \n byte bSafe \n String getLineSeparatorString \n void setIgnoreLeadingWhitespaces \n void setNormalizedNewLine \n boolean isQuoteEscape \n void setIgnoreTrailingWhitespaces \n void setQuoteEscape \n boolean isUseRepeatedVarChar \n void setUseRepeatedVarChar \n void setDelimiter \n void setHeaderExtractionEnabled \n byte getNormalizedNewLine \n byte getComment \n void setEmptyValue \n void setNumberOfRecordsToRead \n boolean isSkipFirstLine \n byte[] getNewLineDelimiter \n void setSkipFirstLine \n void setQuote \n byte b \n void set \n boolean isQuote \n boolean isIgnoreTrailingWhitespaces \n int getNumberOfRecordsToRead \n byte getDelimiter \n long getMaxCharsPerColumn \n boolean isDelimiter \n void setMaxCharsPerColumn \n boolean isHeaderExtractionEnabled \n void setComment \n boolean isParseUnescapedQuotes \n void setParseUnescapedQuotes", "output": "byte function ( ) { return quote ; }"}, {"instruction": "Generate java code\nfor use by subclasses when an error is encountered during parsing . should only be used by the xml parsing ctors . ", "input": " String description \n Resolver resolver \n String copyright \n Throwable invalidScriptError \n WidgetTester tester \n String toXMLString \n String getXMLTag \n Widget resolve \n void usage \n void usage \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n String getDescription \n String getDefaultDescription \n void runStep \n WidgetTester resolveTester \n HashMap createAttributeMap \n HashMap getAttributes \n void writeObject \n Element addContent \n void parseStepAttributes \n String getUsage \n void readObject \n String toEditableString \n Step createStep \n Step createStep \n Class resolveClass \n WidgetFinder getFinder \n Resolver getResolver", "output": "void function ( Throwable arg0 ) { if ( invalidScriptError != null ) invalidScriptError = arg0 ; else Log . warn ( \"srini_string\" + arg0 ) ; }"}, {"instruction": "Generate java code\nreturns all the headers that were on the origin response . ", "input": " Date date \n Map<String,String> variantMap \n StatusLine statusLine \n HeaderGroup responseHeaders \n Resource resource \n Date requestDate \n long serialVersionUID \n Date responseDate \n Resource getResource \n Header[] getHeaders \n Header getFirstHeader \n Map<String,String> getVariantMap \n String getReasonPhrase \n ProtocolVersion getProtocolVersion \n Date getResponseDate \n boolean hasVariants \n Date parseDate \n int getStatusCode \n StatusLine getStatusLine \n Date getDate \n String toString \n Date getRequestDate", "output": "Header [ ] function ( ) { return responseHeaders . getAllHeaders ( ) ; }"}, {"instruction": "Generate java code\ngets the error that was thrown during rpc execution . does not block . either #get or #get long , timeunit should be called first because these methods block until the rpc has completed . ", "input": " CountDownLatch latch \n Callback<T> chainedCallback \n Throwable error \n T result \n boolean cancel \n boolean isCancelled \n void handleResult \n void handleError \n T getResult \n T get \n T get \n void await \n void await \n boolean isDone", "output": "Throwable function ( ) { return error ; }"}, {"instruction": "Generate java code\ncalled when the document is opened . ", "input": " ArrayList<PdfPageEvent> events \n void addPageEvent \n void onSection \n void onParagraph \n void onParagraphEnd \n void onSectionEnd \n void onEndPage \n void onChapter \n void onGenericTag \n void onCloseDocument \n void onChapterEnd \n void onStartPage", "output": "void function ( PdfWriter arg0 , Document arg1 ) { for ( PdfPageEvent loc0 : events ) { loc0 . onOpenDocument ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nremoves the softlinkrelation of a cpi resource . ", "input": " EntityManager entityManager \n Logger log \n long serialVersionUID \n ResourceDependencyResolverService dependencyResolverService \n void setSoftlinkRelation \n List<ResourceEntity> getConsumingResources \n SoftlinkRelationEntity getSoftLinkRelationByCpiAndSoftlinkRef \n List<SoftlinkRelationEntity> getSoftlinksForCpi \n ResourceEntity getSoftlinkResolvableSlaveResource", "output": "void function ( ResourceEntity arg0 ) { List < SoftlinkRelationEntity > loc0 = getSoftlinksForCpi ( arg0 ) ; arg0 . clearSoftlinkRelations ( ) ; for ( SoftlinkRelationEntity loc1 : loc0 ) { entityManager . remove ( loc1 ) ; } }"}, {"instruction": "Generate java code\nconstructor that takes already-interned arguments . ", "input": " int MODIFIED_BITVAL \n int[] mods \n int MISSING_FLOW_BITVAL \n Object[] vals \n int STATIC_CONSTANT \n int[] tuplemod_not_missing \n int[] tuplemod_modified_not_missing \n int MISSING_NONSENSICAL \n int UNMODIFIED_BITVAL \n int MODBIT_VALUES \n int MISSING_NONSENSICAL_BITVAL \n int MODIFIED \n int MISSING_FLOW \n int UNMODIFIED \n Logger debug \n int TUPLEMOD_VALUES \n boolean tuplemodHasUnmodified \n ValueTuple makeUninterned \n boolean modIsMissingFlow \n boolean tuplemodHasMissingNonsensical \n String tuplemodToStringBrief \n boolean modIsModified \n String valsToString \n boolean tuplemodHasMissingFlow \n ValueTuple shallowcopy \n boolean modIsUnmodified \n boolean isModified \n boolean isModified \n boolean tuplemodHasModified \n ValueTuple trim \n int getModified \n int getModified \n ValueTuple slice \n int hashCode \n int tupleMod \n int tupleMod \n boolean modIsMissingNonsensical \n boolean isUnmodified \n boolean isUnmodified \n boolean isMissingNonsensical \n boolean isMissingNonsensical \n String valToString \n boolean isMissingFlow \n boolean isMissingFlow \n Object getValue \n Object getValue \n boolean isMissing \n boolean isMissing \n int size \n boolean equals \n ValueTuple clone \n String toString \n String toString \n int make_tuplemod \n int parseModified", "output": "ValueTuple function ( Object [ ] arg0 , int [ ] arg1 ) { return new ValueTuple ( arg0 , arg1 , true ) ; }"}, {"instruction": "Generate java code\nreturns a list of all loaded frequency adjusters of the function ", "input": " Logger log \n double frequency \n List<FrequencyAdjuster> frequencyAdjusters \n double maxMagnitude \n void setFrequencyAdjuster \n double getMaxMagnitude \n double getFrequency \n void setFrequencyDouble \n String toString \n double execute \n void setFrequency \n void setMaxMagnitude \n double getDerivativeAt", "output": "List < FrequencyAdjuster > function ( ) { return this . frequencyAdjusters ; }"}, {"instruction": "Generate java code\nreturns true if the arguments form a strictly increasing sequence ", "input": " double functionValueAccuracy \n boolean resultComputed \n double defaultFunctionValueAccuracy \n UnivariateRealFunction f \n double relativeAccuracy \n double absoluteAccuracy \n double result \n int iterationCount \n int defaultMaximalIterationCount \n int maximalIterationCount \n double defaultAbsoluteAccuracy \n double defaultRelativeAccuracy \n long serialVersionUID \n double getFunctionValueAccuracy \n void setAbsoluteAccuracy \n void verifySequence \n void setResult \n void setRelativeAccuracy \n void resetFunctionValueAccuracy \n int getMaximalIterationCount \n void resetRelativeAccuracy \n double getAbsoluteAccuracy \n int getIterationCount \n void resetAbsoluteAccuracy \n void verifyInterval \n double getResult \n void setMaximalIterationCount \n void resetMaximalIterationCount \n boolean isBracketing \n void clearResult \n void verifyBracketing \n double getRelativeAccuracy \n void setFunctionValueAccuracy", "output": "boolean function ( double arg0 , double arg1 , double arg2 ) { return ( arg0 < arg1 ) && ( arg1 < arg2 ) ; }"}, {"instruction": "Generate java code\ncreate an instance of getcontentlanguage ", "input": " QName _SyncToken_QNAME \n QName _Dst_QNAME \n QName _SyncLevel_QNAME \n QName _Status_QNAME \n QName _Depth_QNAME \n QName _Responsedescription_QNAME \n QName _Nresults_QNAME \n QName _Timeout_QNAME \n QName _Href_QNAME \n QName _Src_QNAME \n JAXBElement<String> createDst \n Propstat createPropstat \n Supportedlock createSupportedlock \n Propertybehavior createPropertybehavior \n Lockentry createLockentry \n Resourcetype createResourcetype \n Unauthenticated createUnauthenticated \n JAXBElement<String> createSyncToken \n JAXBElement<String> createStatus \n Link createLink \n SyncCollection createSyncCollection \n Limit createLimit \n Location createLocation \n JAXBElement<String> createSyncLevel \n SupportedReportSet createSupportedReportSet \n Lockinfo createLockinfo \n Lockscope createLockscope \n Getcontenttype createGetcontenttype \n Owner createOwner \n Read createRead \n All createAll \n Lockdiscovery createLockdiscovery \n Exclusive createExclusive \n ReadAcl createReadAcl \n JAXBElement<String> createDepth \n WriteContent createWriteContent \n Getetag createGetetag \n Omit createOmit \n Collection createCollection \n Propname createPropname \n Error createError \n ReadCurrentUserPrivilegeSet createReadCurrentUserPrivilegeSet \n Authenticated createAuthenticated \n Bind createBind \n JAXBElement<BigInteger> createNresults \n JAXBElement<String> createHref \n Report createReport \n JAXBElement<String> createTimeout \n Keepalive createKeepalive \n Shared createShared \n Locktype createLocktype \n Remove createRemove \n Write createWrite \n JAXBElement<String> createResponsedescription \n Creationdate createCreationdate \n JAXBElement<String> createSrc \n Activelock createActivelock \n Getcontentlength createGetcontentlength \n Prop createProp \n Displayname createDisplayname \n Response createResponse \n UnBind createUnbind \n SearchRequest createSearch \n Set createSet \n Propertyupdate createPropertyupdate \n Locktoken createLocktoken \n Source createSource \n Propfind createPropfind \n Self createSelf \n Getlastmodified createGetlastmodified \n SupportedReport createSupportedReport \n Unlock createUnlock \n Multistatus createMultistatus \n Allprop createAllprop \n WriteProperties createWriteProperties", "output": "Getcontentlanguage function ( ) { return new Getcontentlanguage ( ) ; }"}, {"instruction": "Generate java code\ngets the view at given path in the ui hierarchy , ignoring modals . ", "input": " NativeModuleRegistry.Builder mNativeModuleRegistryBuilder \n Context mContext \n JavaScriptModuleRegistry.Builder mJSModuleRegistryBuilder \n View findChild \n ReactInstanceEasyBuilder addNativeModule \n CatalystInstance build \n ReactInstanceEasyBuilder getCatalystInstanceBuilder \n ReactInstanceEasyBuilder addJSModule \n Predicate<View> hasTagValue \n ReactInstanceEasyBuilder setContext \n View getViewWithReactTestId \n ReactTestFactory.ReactInstanceEasyBuilder catalystInstanceBuilder \n String getTestId \n ReactTestFactory getReactTestFactory \n ReactInstanceManager.Builder getReactInstanceManagerBuilder", "output": "T function ( ViewGroup arg0 , int ... arg1 ) { ViewGroup loc0 = arg0 ; View loc1 = loc0 . getChildAt ( 0 ) ; for ( int loc2 = 0 ; loc2 < arg1 . length ; loc2 ++ ) { loc1 = ( ( ViewGroup ) loc1 ) . getChildAt ( arg1 [ loc2 ] ) ; } return ( T ) loc1 ; }"}, {"instruction": "Generate java code\nisvalidnode returns true if this node is valid ; false otherwise . by default , an invalid node is one that does n't belong to a list mylist is null , but subclasses can override this definition . ", "input": " Object item \n List myList \n ListNode next \n Object item \n ListNode prev \n void setItem \n void insertAfter \n void remove \n void insertBefore", "output": "boolean function ( ) { return myList != null ; }"}, {"instruction": "Generate java code\nuses heuristics to deduce the proper type given a string naming the type or java class . the search goes as follows : search for a basic type with ` typename ' as a registration key look for ` typename ' as a class name and if it names a type implementor , return an instanceif it names a compositeusertype or a usertype , return an instance of class wrapped intot the appropriate type adapterif it implements lifecycle , return the corresponding entity type if it implements serializable , return the corresponding serializable type ", "input": " TypeFactory typeFactory \n BasicTypeRegistry basicTypeRegistry \n void registerTypeOverride \n void registerTypeOverride \n void registerTypeOverride \n TypeFactory getTypeFactory \n TypeResolver scope \n BasicType basic", "output": "Type function ( String arg0 , Properties arg1 ) { Type loc0 = basic ( arg0 ) ; if ( loc0 != null ) { return loc0 ; } try { Class loc1 = ReflectHelper . classForName ( arg0 ) ; if ( loc1 != null ) { return typeFactory . byClass ( loc1 , arg1 ) ; } } catch ( ClassNotFoundException loc1 ) { } return null ; }"}, {"instruction": "Generate java code\ninvokes the close method ", "input": " long size \n long pos \n FileChannel channel \n int BUFSIZE \n MappedByteBuffer[] mappedBuffers \n void init \n int read \n int read \n FileChannel getChannel \n long length \n long getFilePointer \n boolean clean \n void seek \n void close", "output": "void function ( ) { close ( ) ; super . finalize ( ) ; }"}, {"instruction": "Generate java code\nreturn solutiongrid ", "input": " int difficulty \n Grid playerGrid \n Grid initialGrid \n Grid solutionGrid \n Grid getInitialGrid \n Set<Cell> getIncorrect \n void setInitialGrid \n int getSize \n boolean hasWon \n Object deepClone \n void reset \n Grid getPlayerGrid \n int getDifficulty \n void setDifficulty", "output": "Grid function ( ) { return solutionGrid ; }"}, {"instruction": "Generate java code\nemits the beginning of the open tag . this method has to be called before other other methods are called on this element . ", "input": " char EQ \n char LT \n char AMP \n char QUOT \n char GT \n XMLElement lastchild \n char SPACE \n String name \n boolean closed \n Writer writer \n boolean openTagDone \n char SLASH \n void quote \n void finishOpenTag \n void addChildElement \n XMLElement text \n XMLElement attr \n XMLElement attr \n XMLElement attr \n void close \n XMLElement element", "output": "void function ( ) { writer . write ( LT ) ; writer . write ( name ) ; }"}, {"instruction": "Generate java code\nreturns whether the group is enabled or not . ", "input": " TextEditBasedChange fChange \n TextEditGroup fTextEditGroup \n boolean fIsEnabled \n void setEnabled \n String getName \n IRegion getRegion \n TextEditGroup getTextEditGroup \n TextEdit[] getTextEdits \n TextEditBasedChange getTextEditChange \n GroupCategorySet getGroupCategorySet", "output": "boolean function ( ) { return fIsEnabled ; }"}, {"instruction": "Generate java code\ncreates a new selection from the given start and length . ", "input": " int fLength \n int fExclusiveEnd \n int INTERSECTS \n int AFTER \n int fStart \n int BEFORE \n int SELECTED \n int getExclusiveEnd \n int getVisitSelectionMode \n Selection createFromStartEnd \n boolean coveredBy \n boolean coveredBy \n int getOffset \n boolean liesOutside \n int getEndVisitSelectionMode \n int getLength \n String toString \n boolean endsIn \n int getInclusiveEnd \n boolean covers \n boolean covers", "output": "Selection function ( int arg0 , int arg1 ) { Assert . isTrue ( arg0 >= 0 && arg1 >= 0 ) ; Selection loc0 = new Selection ( ) ; loc0 . fStart = arg0 ; loc0 . fLength = arg1 ; loc0 . fExclusiveEnd = arg0 + arg1 ; return loc0 ; }"}, {"instruction": "Generate java code\nget padata type . ", "input": " PreauthPluginMeta pluginMeta \n KrbContext context \n int getVersion \n void init \n void tryFirst \n boolean process \n String getName \n List<EncryptionType> getEncTypes \n void prepareQuestions \n boolean tryAgain \n void destroy \n void setPreauthOptions \n PaFlags getFlags \n PluginRequestContext initRequestContext", "output": "PaDataType [ ] function ( ) { return pluginMeta . getPaTypes ( ) ; }"}, {"instruction": "Generate java code\ngets the index of the specified field , or -1 if the field is unsupported . ", "input": " PlaceHolder placeHolder \n int[] getValues \n boolean isEqual \n DateTimeField getField \n DateTimeField getField \n DateTimeFieldType getFieldType \n int indexOfSupported \n int indexOfSupported \n boolean isSupported \n int compareTo \n boolean isBefore \n DateTimeField[] getFields \n int hashCode \n int get \n boolean equals \n String toString \n boolean isAfter \n DateTime toDateTime \n DateTimeFieldType[] getFieldTypes", "output": "int function ( DateTimeFieldType arg0 ) { for ( int loc0 = 0 , loc1 = size ( ) ; loc0 < loc1 ; loc0 ++ ) { if ( getFieldType ( loc0 ) == arg0 ) { return loc0 ; } } return - 1 ; }"}, {"instruction": "Generate java code\nreturns a copy of the interpolating polynomials array . returns a fresh copy of the array . changes made to the copy will not affect the polynomials property . ", "input": " int n \n long serialVersionUID \n PolynomialFunction polynomials[] \n double knots[] \n double[] getKnots \n boolean isStrictlyIncreasing \n PolynomialSplineFunction polynomialSplineDerivative \n int getN \n UnivariateRealFunction derivative \n double value", "output": "PolynomialFunction [ ] function ( ) { PolynomialFunction loc0 [ ] = new PolynomialFunction [ n ] ; System . arraycopy ( polynomials , 0 , loc0 , 0 , n ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn the color of this player ", "input": " int playerNumber \n Rules theRules \n String playerName \n Driver theDriver \n Color playerColor \n Move theMove \n GameplayMediator mediator \n int type \n int getNumber \n void setName \n String getName \n void setColor \n int getType \n boolean makeMove \n void endOfGame \n String toString", "output": "Color function ( ) { return playerColor ; }"}, {"instruction": "Generate java code\nremoves any components sequences added so far , except for seed sequences , which are preserved . ", "input": " PackageLiterals packageLiterals \n ClassLiterals classLiterals \n SequenceCollection gralComponents \n Collection<Sequence> gralSeeds \n int numGeneratedSequences \n void addClassLevelLiteral \n void addGeneratedSequence \n Set<Sequence> getAllGeneratedSequences \n SimpleList<Sequence> getSequencesForType \n SimpleList<Sequence> getSequencesForType \n Set<Sequence> getAllPrimitiveSequences \n void addPackageLevelLiteral", "output": "void function ( ) { gralComponents . clear ( ) ; gralComponents . addAll ( this . gralSeeds ) ; }"}, {"instruction": "Generate java code\nsets the flow control mode for this port . note : this method only supports modes different from xon xoff , because for this mode additional parameters are needed . in order to set xon xoff mode use #setflowcontrol flowcontrol , char , char instead . ", "input": " Device device \n void setBaudRate \n void setBaudRate \n void setDTR \n void setDTR \n void setDivisor \n void setDivisor \n void setDataCharacteristics \n void setDataCharacteristics \n void reset \n void reset \n void setBreakOn \n void setBreakOn \n void setRTS \n void setRTS", "output": "void function ( FlowControl arg0 ) { if ( arg0 == FlowControl . XON_XOFF ) throw new IllegalArgumentException ( Localizer . getLocalizedMessage ( Port . class , \"srini_string\" ) ) ; setFlowControl ( device . getHandle ( ) , arg0 . value , ( char ) 0 , ( char ) 0 ) ; }"}, {"instruction": "Generate java code\nsort the results by the property in ascending order ", "input": " PropertyNameGetter propertyNameGetter \n AuditCriterion hasNotChanged \n AuditCriterion lt \n AuditProjection distinct \n AuditCriterion leProperty \n AggregatedAuditExpression maximize \n AuditProjection min \n AuditCriterion hasChanged \n AuditCriterion gtProperty \n AuditProjection function \n AuditCriterion neProperty \n AuditCriterion ltProperty \n AuditCriterion ge \n AuditCriterion between \n Triple<String,String,Boolean> getData \n AuditCriterion isNotNull \n AggregatedAuditExpression minimize \n AuditCriterion like \n AuditCriterion like \n AuditCriterion in \n AuditCriterion in \n AuditProjection max \n AuditCriterion geProperty \n AuditProjection count \n AuditCriterion eq \n AuditCriterion gt \n AuditProjection countDistinct \n AuditCriterion ne \n AuditCriterion isNull \n AuditCriterion eqProperty \n AuditCriterion le \n AuditCriterion ilike \n AuditCriterion ilike \n AuditOrder desc", "output": "AuditOrder function ( ) { return new PropertyAuditOrder ( propertyNameGetter , true ) ; }"}, {"instruction": "Generate java code\nit is not possible to remove a watcher ... so we just set the tracker in destroyed mode which will simply ignore all subsequent event . ", "input": " Watcher _treeWacher \n boolean _destroyed \n Object _lock \n ZKDataReader<T> _zkDataReader \n long _lastZkTxId \n int _depth \n Clock clock \n String MODULE \n IZKClient _zk \n String _root \n Set<NodeEventsListener<T>> _eventsListeners \n int _rootDepth \n Set<ErrorListener> _errorListeners \n Logger log \n Map<String,TrackedNode<T>> _tree \n void process \n int getDepth \n void raiseEvents \n Map<String,TrackedNode<T>> handleNodeDeleted \n boolean handleEvent \n String logString \n int computeAbsoluteDepth \n long waitForZkTxId \n void registerListener \n Map<String,TrackedNode<T>> trackNode \n Map<String,TrackedNode<T>> handleNodeChildrenChanged \n Map<String,TrackedNode<T>> getTree \n Map<String,TrackedNode<T>> handleNodeDataChanged \n long getLastZkTxId \n int computeDepth \n void raiseError \n void registerErrorListener \n String getRoot \n IZKClient getZKCient \n void track \n void track", "output": "void function ( ) { synchronized ( _lock ) { _destroyed = true ; } }"}, {"instruction": "Generate java code\nget usecriterion3 . ", "input": " boolean useCriterion4 \n GenPolynomial<C> pi \n int i \n GenPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n MiniPair toMiniPair \n int getPairNumber \n void setUseCriterion3 \n boolean equals \n void setZero \n boolean isZero \n void setUseCriterion4 \n String toString \n int compareTo \n void pairNumber \n boolean getUseCriterion4", "output": "boolean function ( ) { return this . useCriterion3 ; }"}, {"instruction": "Generate java code\ncompare two object about result if v1 > v2 , return 1 if v1 = v2 , return 0 if v1 about rule if v1 is null , v2 is null , then return 0 if v1 is null , v2 is not null , then return -1 if v1 is not null , v2 is null , then return 1 return v1 . comparable #compareto object ", "input": " PlaceHolder placeHolder \n String nullStrToEmpty \n Long[] transformLongArray \n long[] transformLongArray \n Integer[] transformIntArray \n int[] transformIntArray \n boolean isEquals", "output": "int function ( V arg0 , V arg1 ) { return arg0 == null ? ( arg1 == null ? 0 : - 1 ) : ( arg1 == null ? 1 : ( ( Comparable ) arg0 ) . compareTo ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nthrow an invalid script exception describing the proper script usage . this should be used by derived classes whenever parsing indicates invalid input . ", "input": " String description \n Resolver resolver \n String copyright \n Throwable invalidScriptError \n WidgetTester tester \n String toXMLString \n String getXMLTag \n Widget resolve \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n String getDescription \n String getDefaultDescription \n void runStep \n WidgetTester resolveTester \n void setScriptError \n HashMap createAttributeMap \n HashMap getAttributes \n void writeObject \n Element addContent \n void parseStepAttributes \n String getUsage \n void readObject \n String toEditableString \n Step createStep \n Step createStep \n Class resolveClass \n WidgetFinder getFinder \n Resolver getResolver", "output": "void function ( ) { usage ( null ) ; }"}, {"instruction": "Generate java code\noverride the default screen capture strategy with a user-defined one . ", "input": " int MAX_CAPTURE_RETRIES \n int CAPTURE_RETRY_INTERVAL \n IScreenCaptureHandler handler \n String BASE_IMAGE_NAME \n String OUTPUT_DIR \n int _counter \n String WINDOW_TESTER_SCREEN_CAPTURE_PATHS_KEY \n String PATH_DELIM \n Robot _robot \n String IMAGE_EXT \n File createScreenCaptureFile \n void ensureOutputDirExists \n String getOutputLocation \n File createScreenCapture \n File createScreenCapture \n File createScreenCapture \n File createScreenCapture \n IScreenCaptureHandler getDefaultHandler \n IScreenCaptureHandler getHandler \n void setOutputLocation \n BufferedImage captureScreen", "output": "void function ( IScreenCaptureHandler arg0 ) { ScreenCapture . arg0 = arg0 ; }"}, {"instruction": "Generate java code\nobtains default ssl socket factory with an ssl context based on the standard jsse trust material cacerts file in the security properties directory . system properties are not taken into consideration . ", "input": " String SSLV2 \n X509HostnameVerifier STRICT_HOSTNAME_VERIFIER \n String TLS \n X509HostnameVerifier ALLOW_ALL_HOSTNAME_VERIFIER \n X509HostnameVerifier hostnameVerifier \n String[] supportedCipherSuites \n X509HostnameVerifier BROWSER_COMPATIBLE_HOSTNAME_VERIFIER \n String[] supportedProtocols \n javax.net.ssl.SSLSocketFactory socketfactory \n String SSL \n void verifyHostname \n String[] split \n Socket createSocket \n Socket createLayeredSocket \n Socket connectSocket \n X509HostnameVerifier getHostnameVerifier \n SSLConnectionSocketFactory getSystemSocketFactory \n void prepareSocket", "output": "SSLConnectionSocketFactory function ( ) { return new SSLConnectionSocketFactory ( SSLContexts . createDefault ( ) , BROWSER_COMPATIBLE_HOSTNAME_VERIFIER ) ; }"}, {"instruction": "Generate java code\ndetermine suitable proxy for gcd algorithms , case bigrational . ", "input": " Logger logger \n GreatestCommonDivisor<ModInteger> getImplementation \n GreatestCommonDivisor<BigInteger> getImplementation \n GreatestCommonDivisor<BigRational> getImplementation \n GreatestCommonDivisor<C> getImplementation", "output": "GreatestCommonDivisor < BigRational > function ( BigRational arg0 ) { GreatestCommonDivisorAbstract < BigRational > loc0 , loc1 ; return getImplementation ( arg0 ) ; }"}, {"instruction": "Generate java code\nnote : it is callers responsibility to validate post exec . ", "input": " PlaceHolder placeHolder \n void syncExec", "output": "void function ( ) { run ( WorkbenchFinder . getActiveWindow ( ) ) ; }"}, {"instruction": "Generate java code\nevaluates the predicate returning false if any stored predicate returns false . ", "input": " long serialVersionUID \n Predicate[] iPredicates \n Predicate getInstance \n Predicate getInstance \n Predicate[] getPredicates", "output": "boolean function ( Object arg0 ) { for ( int loc0 = 0 ; loc0 < iPredicates . length ; loc0 ++ ) { if ( iPredicates [ loc0 ] . evaluate ( arg0 ) ) { return false ; } } return true ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable buffer backed by the given buffer . ", "input": " Buffer EMPTY_BUFFER \n Buffer predicatedBuffer \n Buffer transformedBuffer \n Buffer typedBuffer \n Buffer blockingBuffer \n Buffer synchronizedBuffer", "output": "Buffer function ( Buffer arg0 ) { return UnmodifiableBuffer . decorate ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturn the name of the command that we will look up anddelegate execution to . ", "input": " String name \n String catalogName \n boolean optional \n String nameKey \n void setName \n String getNameKey \n void setCatalogName \n void setNameKey \n String getCatalogName \n boolean postprocess \n Command getCommand \n boolean isOptional \n boolean execute \n void setOptional", "output": "String function ( ) { return ( this . name ) ; }"}, {"instruction": "Generate java code\nreturns a realmatrix whose entries are the the values in thethe input array . the input array is copied , not referenced . ", "input": " PlaceHolder placeHolder \n BigMatrix createColumnBigMatrix \n BigMatrix createColumnBigMatrix \n BigMatrix createColumnBigMatrix \n RealMatrix createColumnRealMatrix \n RealMatrix createRowRealMatrix \n BigMatrix createBigMatrix \n BigMatrix createBigMatrix \n BigMatrix createBigMatrix \n BigMatrix createRowBigMatrix \n BigMatrix createRowBigMatrix \n BigMatrix createRowBigMatrix", "output": "RealMatrix function ( double [ ] [ ] arg0 ) { return new RealMatrixImpl ( arg0 ) ; }"}, {"instruction": "Generate java code\ncalled when the javadoc ant script is generated . ", "input": " IJavadocExportWizardPageContainer fContainer \n IStatus fPageStatus \n void setVisible \n IJavadocExportWizardPageContainer getContainer \n void updateArguments \n IStatus getStatus \n void setStatus \n String[] getConfiguredJavadocOptions \n void performHelp \n String[] getConfiguredVMOptions \n IJavaElement[] getSelectedJavaElements \n Control createContents \n void dispose \n IRunnableContext getRunnableContext \n void setContainer \n void statusUpdated", "output": "void function ( Element arg0 ) { }"}, {"instruction": "Generate java code\nreturn the count of records in the buffer . used for task input only . ", "input": " int count \n ByteBuffer buffer \n ByteBuffer buffer \n void buffer", "output": "int function ( ) { return count ; }"}, {"instruction": "Generate java code\ninserts a symbol map into the set of available symbol maps , keyed by resource url . ", "input": " int ERROR_SYMBOL_FETCH_FAIL \n IterableFastStringMap<JsSymbolMap> resourceSymbols \n String resourceUrl \n List<PendingRequest> pendingRequests \n Callback callback \n int ERROR_MANIFEST_NOT_LOADED \n boolean manifestLoaded \n SymbolServerManifest symbolServerManifest \n IterableFastStringMap<List<XhrCallback>> queuedSymbolMapRequests \n Url symbolManifestUrl \n Url mainResourceUrl \n void init \n void attemptResymbolization \n void onSymbolsReady \n void onSymbolsFetchFailed \n JsSymbolMap get \n void serviceRequest \n void cancelPendingRequests \n void reSymbolize \n void requestSymbolsFor \n ResourceSymbolInfo lookupEntryInManifest", "output": "void function ( String arg0 , JsSymbolMap arg1 ) { resourceSymbols . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ntrack the passed persistence units for the application ", "input": " AttachmentKey<PersistenceUnitsInApplication> PERSISTENCE_UNITS_IN_APPLICATION \n List<PersistenceUnitMetadataHolder> persistenceUnitMetadataHolderList \n int count \n void increment \n List<PersistenceUnitMetadataHolder> getPersistenceUnitHolders \n int getCount", "output": "void function ( PersistenceUnitMetadataHolder arg0 ) { persistenceUnitMetadataHolderList . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nprints the ast in ` ascii art ' form to the specified print stream . ", "input": " boolean showClassNames \n Map tokenTypeNameCache \n String showAsString \n String nodeToString \n void showNode \n String escapeMultibyteChars \n String getTokenTypeName \n boolean isShowClassNames \n void appendEscapedMultibyteChars", "output": "void function ( AST arg0 , PrintStream arg1 ) { showAst ( arg0 , new PrintWriter ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nthis method returns the value of the database column sys_ip_area . company ", "input": " String areaCode \n String IPCODE_UNKNOWN \n String city \n String province \n String edu \n String district \n String company \n Date createTime \n Long endIp \n String owner \n Long startIp \n String country \n boolean isIp \n void setCountry \n Date getCreateTime \n String getCountry \n void setProvince \n long valueOfIpv4 \n String getEdu \n Long getStartIp \n Long getEndIp \n String getOwner \n void setStartIp \n void setEndIp \n void setOwner \n String getStartIpv4 \n String getEndIpv4 \n String getAreaCode \n String ipv4 \n String getDistrict \n String getProvince \n void setDistrict \n void setCompany \n String getCity \n void setCity \n void setAreaCode \n void setCreateTime \n void setEdu \n String toString", "output": "String function ( ) { return company ; }"}, {"instruction": "Generate java code\nis the iselectionempty or null ? ", "input": " String DOT \n String SLASH_STRING \n char DOT_CHAR \n char SLASH_CHAR \n void safeJoin \n void assertNotEmpty \n String slashAppend \n String slashAppend \n String dotAppend \n String dotAppend", "output": "boolean function ( ISelection arg0 ) { if ( ( arg0 == null ) || ( arg0 . isEmpty ( ) ) ) { return true ; } else { return false ; } }"}, {"instruction": "Generate java code\nadd a resolver at the end of the underlying resolver list . the resolver added by this method is at lower priority than any other existing resolvers . ", "input": " CoreMessageLogger LOG \n List<DialectResolver> resolvers \n void addResolverAtFirst \n Dialect resolveDialect", "output": "void function ( DialectResolver arg0 ) { resolvers . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nclear the update-timestamps data . ", "input": " SessionFactoryImplementor factory \n boolean DEBUG_ENABLED \n String REGION_NAME \n CoreMessageLogger LOG \n TimestampsRegion region \n boolean isUpToDate \n Long getLastUpdateTimestampForSpace \n void preInvalidate \n TimestampsRegion getRegion \n void destroy \n String toString \n void invalidate", "output": "void function ( ) { region . evictAll ( ) ; }"}, {"instruction": "Generate java code\nthis method returns the value of the database column sys_ip_area . start_ip ", "input": " String areaCode \n String IPCODE_UNKNOWN \n String city \n String province \n String edu \n String district \n String company \n Date createTime \n Long endIp \n String owner \n Long startIp \n String country \n boolean isIp \n void setCountry \n Date getCreateTime \n String getCountry \n void setProvince \n long valueOfIpv4 \n String getEdu \n Long getEndIp \n String getOwner \n void setStartIp \n void setEndIp \n void setOwner \n String getStartIpv4 \n String getEndIpv4 \n String getAreaCode \n String ipv4 \n String getDistrict \n String getProvince \n void setDistrict \n void setCompany \n String getCity \n void setCity \n void setAreaCode \n void setCreateTime \n String getCompany \n void setEdu \n String toString", "output": "Long function ( ) { return startIp ; }"}, {"instruction": "Generate java code\nadd a single element to the list of elements . ", "input": " ArrayList<Element> list \n void addAll \n List<Element> elements", "output": "void function ( final Element arg0 ) { list . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the number of values for each vertex in the vertex buffer layout . ", "input": " AbstractPrimitiveShader shader \n VectorXYZW lightPos \n GL3 gl \n int valueTypeSize \n int glValueType \n int[] id \n int vertexCount \n void addVerticesToValueBuffer \n int valueTypeSize \n void setShader \n int glValueType \n List<VectorXYZW> getPrimitivesShadowVolumes \n BufferT createBuffer \n void render \n void delete \n void put \n void setPointerLayout", "output": "int function ( ) { return 4 ; }"}, {"instruction": "Generate java code\ngets the statementreplacer for the replace statements in the file parsed . ", "input": " String lineSep \n StatementReplacer statementReplacer \n String spinfoFileName \n String tempDir \n SplitterObject[][] splitterObjects \n void readPptStatements \n boolean isComment \n SplitterObject[][] createSplitterObjects \n void setFormatting \n void readReplaceStatements \n void parseFile \n boolean isFormatting \n boolean isBlank \n SplitterObject[][] getSplitterObjects", "output": "StatementReplacer function ( ) { return statementReplacer ; }"}, {"instruction": "Generate java code\nbuild a properly sized map , especially handling load size and load factor to prevent immediate resizing . especially helpful for copy map contents . ", "input": " int MINIMUM_INITIAL_CAPACITY \n List EMPTY_LIST \n Collection EMPTY_COLLECTION \n Map EMPTY_MAP \n float LOAD_FACTOR \n Set<T> makeCopy \n Map<X,Y> makeCopy \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n ArrayList<T> arrayList \n boolean isNotEmpty \n boolean isNotEmpty \n ConcurrentHashMap<K,V> concurrentMap \n ConcurrentHashMap<K,V> concurrentMap \n int determineProperSizing \n int determineProperSizing \n int determineProperSizing", "output": "Map < K , V > function ( int arg0 ) { return new HashMap < K , V > ( determineProperSizing ( arg0 ) , LOAD_FACTOR ) ; }"}, {"instruction": "Generate java code\nliefert das signal , mit dem die letzte ' 1 ' codiert wurde . ", "input": " ZeroBuffer zeroBuffer \n int pointer \n char last \n State state \n boolean[] buffer \n AMI.Medium medium \n State next \n boolean[] receive \n HDB3Receiver.Lookahead lookahead \n void puffern \n boolean[] flush \n int size \n boolean get \n void clear \n void reset \n void buffer \n boolean[] convertToBoolArray", "output": "char function ( ) { return this . last ; }"}, {"instruction": "Generate java code\nreturns delegate reflector ", "input": " GenericArrayReflector _array \n Collection4 _collectionPredicates \n Hashtable4 _classByClass \n ObjectContainerBase _stream \n KnownClassesRepository _repository \n Transaction _trans \n Reflector _delegate \n void setTransaction \n void registerCollection \n void registerCollection \n ReflectClass forName \n ReflectClass[] knownClasses \n void configuration \n GenericClass ensureDelegate \n GenericClass genericClass \n boolean isCollection \n ReflectClassPredicate classPredicate \n void registerPrimitiveClass \n boolean hasTransaction \n ReflectArray array \n Object deepClone \n ReflectClass forClass \n ReflectClass forGenericObject \n ObjectContainerBase getStream \n ReflectClass forObject \n void setParent \n T withLock \n void register", "output": "Reflector function ( ) { return _delegate ; }"}, {"instruction": "Generate java code\ncreates this element in domain model and also creates other resources if needed e.g. external files ", "input": " PlaceHolder placeHolder \n String getName \n void remove \n void remove", "output": "void function ( CLIWrapper arg0 ) { throw new IllegalStateException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the task ids allocated for the given component id . the task ids are always returned in ascending order . ", "input": " StormTopology _topology \n String _stormId \n Map<Integer,String> _taskToComponent \n Map<String,List<Integer>> _componentToTasks \n Map _stormConf \n Map<String,Map<String,Fields>> _componentToStreamToFields \n int maxTopologyMessageTimeout \n String getComponentId \n Map<String,Map<String,Grouping>> getTargets \n Map<Integer,String> getTaskToComponent \n Set<String> getComponentIds \n String getStormId \n Set<String> getComponentStreams \n String toJSONString \n StormTopology getRawTopology \n Fields getComponentOutputFields \n Fields getComponentOutputFields \n ComponentCommon getComponentCommon \n Map<GlobalStreamId,Grouping> getSources", "output": "List < Integer > function ( String arg0 ) { List < Integer > loc0 = _componentToTasks . get ( arg0 ) ; if ( loc0 == null ) return new ArrayList < > ( ) ; else return new ArrayList < > ( loc0 ) ; }"}, {"instruction": "Generate java code\nupdates the given bean in the database sql update ", "input": " int[] insertJdbcTypes \n DataSource dataSource \n String autoIncrColumnName \n Long doInsertAutoIncrOLD \n String getSqlSelect \n Object[] getValuesForPrimaryKey \n int doDelete \n int doDelete \n String getSqlCountAll \n void log \n String getSqlCount \n boolean doSelect \n T doSelect \n JdbcTemplate getJdbcTemplate \n PreparedStatementCreator getPreparedStatementCreator \n boolean doExists \n boolean doExists \n long doCountAll \n String getSqlInsert \n String getSqlUpdate \n Object[] getValuesForInsert \n Object[] getValuesForUpdate \n long doInsertAutoIncr \n RowMapper<T> getRowMapper \n RowMapper<T> getRowMapper \n void doInsert \n String toString \n String getSqlDelete", "output": "int function ( T arg0 ) { JdbcTemplate loc0 = getJdbcTemplate ( ) ; int loc1 = loc0 . update ( getSqlUpdate ( ) , getValuesForUpdate ( arg0 ) ) ; if ( loc1 != 0 && loc1 != 1 ) { throw new RuntimeException ( \"srini_string\" + loc1 + \"srini_string\" ) ; } return loc1 ; }"}, {"instruction": "Generate java code\ntest 0-argument commands ", "input": " Parser parser \n void findCommand_invalidArgs \n void addCommand_invalidArgs \n void addCommand_duplicateTags_merged \n void deleteCommand_numericArg_indexParsedCorrectly \n void viewCommand_argsIsNotSingleNumber \n void viewCommand_noArgs \n void viewAllCommand_argsIsNotSingleNumber \n void emptyInput_returnsIncorrect \n void clearCommand_parsedCorrectly \n void unknownCommandWord_returnsHelp \n void viewAllCommand_noArgs \n void addCommand_invalidPersonDataInArgs \n void addCommand_validPersonData_parsedCorrectly \n void listCommand_parsedCorrectly \n void viewCommand_numericArg_indexParsedCorrectly \n T parseAndAssertCommandType \n void findCommand_validArgs_parsedCorrectly \n String convertPersonToAddCommandString \n void deleteCommand_noArgs \n void deleteCommand_argsIsNotSingleNumber \n Person generateTestPerson \n void findCommand_duplicateKeys_parsedCorrectly \n void parseAndAssertIncorrectWithMessage \n void setup \n void viewAllCommand_numericArg_indexParsedCorrectly \n void exitCommand_parsedCorrectly", "output": "void function ( ) { final String loc0 = \"srini_string\" ; parseAndAssertCommandType ( loc0 , HelpCommand . class ) ; }"}, {"instruction": "Generate java code\nrotates the camera around the yaw axis ", "input": " VectorXYZ pos \n VectorXYZ lookAt \n VectorXYZ up \n void moveMapRight \n void setCamera \n void setCamera \n void moveForward \n void move \n void move \n void roll \n VectorXYZ getUp \n void moveMapUp \n void setPos \n void setPos \n void mapPitch \n VectorXYZ getRight \n void setLookAt \n void setLookAt \n VectorXYZ getViewDirection \n VectorXYZ getPos \n void moveRight \n VectorXYZ getLookAt \n void moveMapForward \n String toString \n void pitch \n void rotateY \n void moveUp", "output": "void function ( double arg0 ) { VectorXYZ loc0 = lookAt . subtract ( pos ) ; VectorXYZ loc1 = loc0 . rotateVec ( arg0 , up ) ; lookAt = pos . add ( loc1 ) ; }"}, {"instruction": "Generate java code\nattempt to retrieve an object from the cache . ", "input": " AdvancedCache<Object,Object> writeCache \n AdvancedCache cache \n PutFromLoadValidator putValidator \n boolean TRACE_ENABLED \n Log log \n BaseRegion region \n void removeAll \n void evictAll \n boolean putFromLoad \n boolean putFromLoad \n boolean insert \n boolean update \n void remove \n void evict", "output": "Object function ( Object arg0 , long arg1 ) { if ( ! region . checkValid ( ) ) { return null ; } final Object loc0 = cache . get ( arg0 ) ; if ( loc0 == null ) { putValidator . registerPendingPut ( arg0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsets the location of the guide ", "input": " String PROPERTY_CHILDREN \n boolean horizontal \n String PROPERTY_POSITION \n int position \n Map map \n long serialVersionUID \n PropertyChangeSupport listeners \n int getAlignment \n void attachPart \n int getPosition \n void detachPart \n void addPropertyChangeListener \n void removePropertyChangeListener \n void setHorizontal \n Map getMap \n boolean isHorizontal \n Set getParts", "output": "void function ( int arg0 ) { if ( position != arg0 ) { int loc0 = position ; position = arg0 ; listeners . firePropertyChange ( PROPERTY_POSITION , new Integer ( loc0 ) , new Integer ( position ) ) ; } }"}, {"instruction": "Generate java code\nintended for aerrorbarpolicyconfigurable only . ", "input": " int m_negativeYErrorPixel \n int m_negativeXErrorPixel \n int m_positiveYErrorPixel \n int m_positiveXErrorPixel \n ITrace2D m_trace \n long serialVersionUID \n void setTrace \n void setPositiveXErrorPixel \n int getNegativeXErrorPixel \n int hashCode \n boolean equals \n int getPositiveYErrorPixel \n void setNegativeYErrorPixel \n void clear \n ITrace2D getTrace \n void setNegativeXErrorPixel \n int getPositiveXErrorPixel \n int getNegativeYErrorPixel", "output": "void function ( final int arg0 ) { this . m_positiveYErrorPixel = arg0 ; }"}, {"instruction": "Generate java code\nconverts the collected terms and values to a string . does not write to the parent writer . ", "input": " List<Pair<String,Object>> values \n PrintWriter pw \n Map<Prel,OpId> ids \n Spacer spacer \n SqlExplainLevel detailLevel \n void explain \n RelWriter input \n RelWriter item \n void explain_ \n boolean nest \n void explainInputs \n RelWriter done \n SqlExplainLevel getDetailLevel \n RelWriter itemIf", "output": "String function ( ) { final StringBuilder loc0 = new StringBuilder ( \"srini_string\" ) ; for ( Ord < Pair < String , Object >> loc1 : Ord . zip ( values ) ) { if ( loc1 . i > 0 ) { loc0 . append ( \"srini_string\" ) ; } loc0 . append ( loc1 . e . left ) . append ( \"srini_string\" ) . append ( loc1 . e . right ) . append ( \"srini_string\" ) ; } loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nget the widget finder that is doing the heavy lifting . ", "input": " IUIContext _ui \n WidgetFinderService _finderService \n Widget[] findAllInScope \n IWidgetLocator[] findAll", "output": "WidgetFinderService function ( Display arg0 ) { if ( _finderService == null ) _finderService = new WidgetFinderService ( arg0 ) ; return _finderService ; }"}, {"instruction": "Generate java code\nload default values for the shader . should be called after every #useshader and before any draw calls . ", "input": " int shaderProgram \n GL3 gl \n int vertexShader \n int fragmentShader \n void useShader \n int getProgram \n void disableShader \n void freeResources \n void finalize \n void validateShader", "output": "void function ( ) { }"}, {"instruction": "Generate java code\nalways call super if you override ", "input": " PlaceHolder placeHolder \n void lockFile \n Object createWeakReference \n Reflector createReflector \n Class constructorClass \n void killYapRef \n boolean isConnected \n Thread addShutdownHook \n Object weakReferenceTarget \n Constructor serializableConstructor \n void forEachCollectionElement \n void registerCollections \n long nanoTime \n Reflector reflectorForType \n boolean methodIsAvailable \n Object deserialize \n void extendConfiguration \n Config4Class extendConfiguration \n void unlockFile \n Object createActivateObjectReference \n int ver \n NetTypeHandler[] types \n void setAccessible \n String format \n boolean isEnum \n void throwIllegalArgumentException \n Object createReferenceQueue \n byte[] serialize \n void pollReferenceQueue \n Object getContextClassLoader \n Object getYapRefObject \n Class loadClass \n void removeShutdownHook \n boolean isCollectionTranslator \n boolean useNativeSerialization \n NetTypeHandler[] netTypes", "output": "void function ( Config4Impl arg0 ) { }"}, {"instruction": "Generate java code\nreturn true if the rule is triggered by the given line and name given the structure of the supplied document ", "input": " List<String> parameters \n int lineNumber \n RuleType ruleType \n int lineNumberLimit \n String extractJSValidatorName \n int getLineNumber \n RuleType getRuleType \n List<String> getParameters \n int getLineNumberLimit \n void setLineNumberLimit \n boolean isInsideSentences \n void addParameter", "output": "boolean function ( Document arg0 , ValidationError arg1 ) { int loc0 = arg1 . getLineNumber ( ) ; String loc1 = arg1 . getValidatorName ( ) ; if ( loc1 . equals ( \"srini_string\" ) ) { loc1 = extractJSValidatorName ( arg1 . getMessage ( ) ) ; } return isTriggeredBy ( arg0 , loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\ncalled when the document is opened . ", "input": " PlaceHolder placeHolder \n void onSection \n void onParagraph \n void onParagraphEnd \n void onSectionEnd \n void onEndPage \n void onChapter \n void onGenericTag \n void onCloseDocument \n void onChapterEnd \n void onStartPage", "output": "void function ( PdfWriter arg0 , Document arg1 ) { }"}, {"instruction": "Generate java code\nwrite all rows added to the named output stream . ", "input": " byte[] MAGIC_1 \n ColumnFileMetaData metaData \n long size \n byte[] MAGIC_0 \n ColumnOutputBuffer[] columns \n long rowCount \n int columnCount \n byte[] MAGIC \n void writeLength \n void writeHeader \n long[] computeStarts \n void startRow \n void endRow \n void checkColumns \n int getColumnCount \n void writeRow \n void incrementSize \n ColumnFileMetaData getMetaData \n void writeValue \n long sizeEstimate", "output": "void function ( OutputStream arg0 ) { writeHeader ( arg0 ) ; for ( int loc0 = 0 ; loc0 < columnCount ; loc0 ++ ) columns [ loc0 ] . writeTo ( arg0 ) ; }"}, {"instruction": "Generate java code\nexecute the specified command returning a value if any ", "input": " IJavascriptRuntime runtime \n IWebEngine engine \n String getArrayFunction \n String getFunction \n String getFunction \n void setDefaultWebEngine \n String getArrayConstructor \n IJavascriptRuntime getInstance \n String getArgString \n String getConstructor", "output": "JSObject function ( String arg0 ) { Object loc0 = engine . executeScript ( arg0 ) ; if ( loc0 instanceof JSObject ) { return ( JSObject ) loc0 ; } return null ; }"}, {"instruction": "Generate java code\nverify if the time per execution of a task matches the actual time required to execute the task a given number of times ", "input": " Function<Integer,T> factory \n int THREAD_COUNT \n int TASK_COUNT \n int expectedExecutionTime \n void testToString \n void testIdGeneration \n O get", "output": "void function ( ) { for ( int loc0 = 0 ; loc0 < 10 ; loc0 ++ ) { assertEquals ( this . expectedExecutionTime * loc0 , this . factory . apply ( loc0 ) . getTimeMs ( ) ) ; } }"}, {"instruction": "Generate java code\nset parser state to unknownstate . ", "input": " State closeStarComment \n State selfClosing \n State tagAttributes \n State unquoted \n State unknown \n State inTag \n State cdata \n State previousState \n State doctype \n State tagEncountered \n State singleQuoted \n XMLParser parser \n State xml \n State specialChar \n State doubleQuoted \n State closingTag \n State comment \n State attrValue \n State starComment \n State currentState \n State closeComment \n State processingInstruction \n XMLParser closeStarComment \n XMLParser selfClosing \n XMLParser tagAttributes \n XMLParser unquotedAttr \n XMLParser attributeValue \n XMLParser doubleQuotedAttr \n XMLParser singleQuotedAttr \n XMLParser previousState \n XMLParser inTag \n XMLParser cdata \n XMLParser doctype \n XMLParser tagEncountered \n XMLParser specialChar \n XMLParser setState \n XMLParser closingTag \n XMLParser comment \n XMLParser starComment \n XMLParser processingInstructions \n XMLParser closeComment", "output": "XMLParser function ( ) { return setState ( unknown ) ; }"}, {"instruction": "Generate java code\ncreates the edge origin , destination . if the edge did not already exists , increments the edge count . ", "input": " boolean[][] adjMatrix \n int vertices \n int edges \n void removeEdge \n boolean hasEdge \n int getNumEdges \n UDGraph paths \n UDGraph length2Paths \n String toString \n void main \n int getNumVertices \n boolean validVertex", "output": "void function ( int arg0 , int arg1 ) { if ( validVertex ( arg0 ) && validVertex ( arg1 ) ) { if ( ! adjMatrix [ arg0 ] [ arg1 ] ) { adjMatrix [ arg0 ] [ arg1 ] = true ; edges ++ ; } } }"}, {"instruction": "Generate java code\nget the subject widget 's class . ", "input": " long serialVersionUID \n HashMap _map \n int UNASSIGNED \n int _index \n WidgetLocator _parentInfo \n Class _cls \n String _nameOrLabel \n IWidgetMatcher _matcher \n int getIndex \n void setData \n WidgetLocator getParentInfo \n String getNameOrLabel \n IWidgetLocator[] findAll \n boolean matches \n Map getDataMap \n void setParentInfo \n void setIndex \n int hashCode \n boolean equals \n String toString \n String getTargetClassName \n String getData", "output": "Class function ( ) { return _cls ; }"}, {"instruction": "Generate java code\nretrieve a list of all the location information trees for a sub message field . ", "input": " Map<FieldDescriptor,List<TextFormatParseInfoTree>> subtreesFromField \n Map<FieldDescriptor,List<TextFormatParseLocation>> locationsFromField \n Map<FieldDescriptor,List<Builder>> subtreeBuildersFromField \n TextFormatParseInfoTree getNestedTree \n TextFormatParseLocation getLocation \n Builder getBuilderForSubMessageField \n Builder setLocation \n TextFormatParseInfoTree build \n Builder builder \n T getFromList \n List<TextFormatParseLocation> getLocations", "output": "List < TextFormatParseInfoTree > function ( final FieldDescriptor arg0 ) { List < TextFormatParseInfoTree > loc0 = subtreesFromField . get ( arg0 ) ; return loc0 == null ? Collections . < TextFormatParseInfoTree > emptyList ( ) : loc0 ; }"}, {"instruction": "Generate java code\nreceive a message from an imported script . ", "input": " PlaceHolder placeHolder \n void onAlert \n void onConfirm \n void onPrompt \n void onDebugRequest \n void onReady", "output": "void function ( GeckoView arg0 , Bundle arg1 , GeckoView . MessageResult arg2 ) { if ( arg2 != null ) { arg2 . failure ( null ) ; } }"}, {"instruction": "Generate java code\ntake a screenshot . ", "input": " int CLOSE_ALL_WAIT_THRESHOLD \n int _disposedCount \n boolean _first \n IUIContext ui \n boolean _screenCaptureOnFirst \n int _closeCalls \n int CLOSE_ALL_WAIT_INTERVAL \n Display _display \n ShellTester _shellTester \n Shell _lastDisposed \n int CALL_TO_NUCLEAR_CLOSE_INTERVAL \n boolean _captureScreens \n void handleConditions \n Shell[] getShells \n Shell[] getShells \n boolean isLast \n String getText \n void closeShell \n void closeOpenShells \n void closeModalShellsNuclearOption \n boolean captureScreens \n void doClose \n int getStyle \n String getShellStateDump \n String getState \n void closeShells \n void closeShells \n ShellTester getShellTester \n Display getDisplay \n boolean isModal", "output": "void function ( String arg0 ) { String loc0 = TestMonitor . getInstance ( ) . getCurrentTestCaseID ( ) ; TraceHandler . trace ( IRuntimePluginTraceOptions . WIDGET_SELECTION , \"srini_string\" + arg0 + \"srini_string\" + loc0 ) ; ScreenCapture . createScreenCapture ( loc0 ) ; }"}, {"instruction": "Generate java code\nget the sax inputsource to be used for the source . ", "input": " String FEATURE \n XMLReader reader \n InputSource inputSource \n String getSystemId \n InputSource sourceToInputSource \n void setSystemId \n void setInputSource \n void setXMLReader \n XMLReader getXMLReader", "output": "InputSource function ( ) { return inputSource ; }"}, {"instruction": "Generate java code\ncreate an instance of callcontext ", "input": " QName _HistoryHeader_QNAME \n QName _ISDVInfo_QNAME \n QName _KeyValuePairList_QNAME \n QName _LocalizedMessage_QNAME \n QName _BusinessException_QNAME \n QName _Message_QNAME \n QName _CallContext_QNAME \n QName _ValidationException_QNAME \n QName _NotFoundException_QNAME \n QName _ValidationContext_QNAME \n QName _TimePeriod_QNAME \n QName _OpenTimePeriod_QNAME \n QName _LocalizedString_QNAME \n QName _KeyValuePair_QNAME \n QName _TechnicalException_QNAME \n ISDVInfo createISDVInfo \n JAXBElement<ISDVInfo> createISDVInfo \n ValidationException createValidationException \n JAXBElement<ValidationException> createValidationException \n OpenTimePeriod createOpenTimePeriod \n JAXBElement<OpenTimePeriod> createOpenTimePeriod \n LocalizedMessage createLocalizedMessage \n JAXBElement<LocalizedMessage> createLocalizedMessage \n TechnicalException createTechnicalException \n JAXBElement<TechnicalException> createTechnicalException \n KeyValuePairList createKeyValuePairList \n JAXBElement<KeyValuePairList> createKeyValuePairList \n TimePeriod createTimePeriod \n JAXBElement<TimePeriod> createTimePeriod \n LocalizedString createLocalizedString \n JAXBElement<LocalizedString> createLocalizedString \n HistoryHeader createHistoryHeader \n JAXBElement<HistoryHeader> createHistoryHeader \n KeyValuePair createKeyValuePair \n JAXBElement<KeyValuePair> createKeyValuePair \n BusinessException createBusinessException \n JAXBElement<BusinessException> createBusinessException \n NotFoundException createNotFoundException \n JAXBElement<NotFoundException> createNotFoundException \n ValidationContext createValidationContext \n JAXBElement<ValidationContext> createValidationContext \n Message createMessage \n JAXBElement<Message> createMessage", "output": "CallContext function ( ) { return new CallContext ( ) ; }"}, {"instruction": "Generate java code\ncompare the resource groups by name null ", "input": " String ALLRESOURCESBYTYPE_QUERY \n Set<FavoriteResourceEntity> favorites \n String fcExternalKey \n Set<ResourceActivationEntity> resourceActivationEntities \n long serialVersionUID \n ReleaseEntity outOfServiceRelease \n Set<ResourceEntity> resources \n Set<TemplateDescriptorEntity> runtimeTemplateDescriptors \n long v \n String fcExternalLink \n String name \n Integer id \n ResourceTypeEntity resourceType \n void setName \n ReleaseEntity getNewestRelease \n void setFcExternalLink \n ReleaseEntity getFirstRelease \n String getFcExternalLink \n String getFcExternalKey \n void setResourceType \n void setFcExternalKey \n String toString \n SortedSet<ReleaseEntity> getReleases \n boolean isAppServerContainer", "output": "int function ( ResourceGroupEntity arg0 ) { if ( arg0 == null ) { return 1 ; } else { if ( getName ( ) == null ) { return arg0 . getName ( ) == null ? 0 : - 1 ; } else { return arg0 . getName ( ) == null ? 1 : getName ( ) . compareTo ( arg0 . getName ( ) ) ; } } }"}, {"instruction": "Generate java code\nresidue absolute value . ", "input": " GenPolynomial<C> val \n ResidueRing<C> ring \n int isunit \n int signum \n boolean isONE \n Residue<C> inverse \n boolean isUnit \n Residue<C> subtract \n Residue<C> gcd \n Residue<C> sum \n int compareTo \n Residue<C>[] egcd \n boolean isConstant \n Residue<C> monic \n int hashCode \n Residue<C> negate \n boolean equals \n Residue<C> clone \n boolean isZERO \n String toString \n Residue<C> divide \n Residue<C> multiply \n Residue<C> remainder", "output": "Residue < C > function ( ) { return new Residue < C > ( ring , val . abs ( ) , isunit ) ; }"}, {"instruction": "Generate java code\nobtain a default hierarchy . this method is provided only to support the deprecated componenttester.assertframeshowing method . ", "input": " Collection EMPTY \n WindowTracker tracker \n Hierarchy defaultHierarchy \n boolean contains \n Container getParent \n Collection getRoots \n Collection getComponents \n Collection findInternalFramesFromIcons \n void dispose \n void setDefault", "output": "Hierarchy function ( ) { return defaultHierarchy != null ? defaultHierarchy : new AWTHierarchy ( ) ; }"}, {"instruction": "Generate java code\nobserves if currently editing resource type ", "input": " Boolean testing \n ch.puzzle.itc.mobiliar.business.utils.Identifiable resourceOrResourceType \n Integer relationId \n void onChangedTestingMode \n boolean isEditable \n boolean isCurrentFocusOnResource \n Integer getResourceId \n Integer getResourceTypeId \n void onChangedResource \n boolean isCurrentFocusOnResourceType \n boolean isPropertyDisplayable \n void onChangedRelation \n boolean isTesting", "output": "void function ( @ Observes ResourceTypeEntity arg0 ) { if ( arg0 != null ) { resourceOrResourceType = arg0 ; } }"}, {"instruction": "Generate java code\ninitializes resources . this must be called before #getresources . this allows us to avoid an evil static initializer that would pollute all the getresources call sites . ", "input": " Resources resources \n Css optionsPageCss \n Resources getResources \n String outer", "output": "void function ( ) { resources = GWT . create ( Resources . class ) ; StyleInjector . inject ( resources . whitelistTableCss ( ) . getText ( ) + resources . optionsPageCss ( ) . getText ( ) + resources . tableControlsCss ( ) . getText ( ) ) ; }"}, {"instruction": "Generate java code\ntriangulation of a polygon with holes , based on a conforming delaunay triangulation ", "input": " Geometry[] EMPTY_GEOM_ARRAY \n placeholderType placeHolder", "output": "List < TriangleXZ > function ( SimplePolygonXZ arg0 , Collection < SimplePolygonXZ > arg1 ) { List < VectorXZ > loc0 = emptyList ( ) ; List < LineSegmentXZ > loc1 = emptyList ( ) ; return triangulate ( arg0 , arg1 , loc1 , loc0 ) ; }"}, {"instruction": "Generate java code\ncopy residue element c. ", "input": " Logger logger \n RingFactory<C> ring \n int isField \n C modul \n Residue<C> random \n Residue<C> random \n int hashCode \n boolean isField \n boolean equals \n Residue<C> getONE \n boolean isCommutative \n Residue<C> getZERO \n Residue<C> fromInteger \n Residue<C> fromInteger \n boolean isAssociative \n String toString \n Residue<C> parse \n Residue<C> parse \n java.math.BigInteger characteristic", "output": "Residue < C > function ( Residue < C > arg0 ) { return new Residue < C > ( arg0 . ring , arg0 . val ) ; }"}, {"instruction": "Generate java code\nanswers the stored key that is equal to the specified key . ", "input": " HashMapEntry next \n HashMapEntry[] elementData \n int start \n int threshold \n IElementComparer comparer \n HashMapEntry entry \n float loadFactor \n int elementCount \n int lastSlot \n EmptyEnumerator emptyEnumerator \n int firstSlot \n Object value \n boolean key \n int DEFAULT_CAPACITY \n boolean containsKey \n Enumeration keys \n void rehash \n boolean keyEquals \n Object put \n Object remove \n int size \n boolean hasMoreElements \n boolean hasMoreElements \n void computeMaxSize \n int hashCode \n Enumeration elements \n Object get \n String toString \n String toString \n void appendToStringWithCommaNL \n HashMapEntry getEntry \n Object nextElement \n Object nextElement", "output": "Object function ( Object arg0 ) { int loc0 = ( hashCode ( arg0 ) & 0x7FFFFFFF ) % elementData . length ; HashMapEntry loc1 = elementData [ loc0 ] ; while ( loc1 != null ) { if ( keyEquals ( arg0 , loc1 . arg0 ) ) return loc1 . arg0 ; loc1 = loc1 . next ; } return null ; }"}, {"instruction": "Generate java code\nencodes a string into its quoted-printable form using the default string charset . unsafe characters are escaped . this function implements a subset of quoted-printable encoding specification rule # 1 and rule # 2 as defined in rfc 1521 and is suitable for encoding binary data . ", "input": " String charset \n BitSet PRINTABLE_CHARS \n byte SPACE \n byte ESCAPE_CHAR \n byte TAB \n byte[] decodeQuotedPrintable \n void encodeQuotedPrintable \n byte[] encodeQuotedPrintable \n String getDefaultCharset \n byte[] decode \n String decode \n String decode \n Object decode", "output": "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } try { return encode ( arg0 , getDefaultCharset ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new EncoderException ( loc0 . getMessage ( ) , loc0 ) ; } }"}, {"instruction": "Generate java code\nget base znode . ", "input": " String ENCRYPTION_KEY_NO_ZNODE_NAME \n String KEY_VERSION_ZNODE_NAME \n String PRINCIPAL_NAME_ZNODE_NAME \n String baseZNode \n String CREATED_TIME_ZNODE_NAME \n String KDC_FLAGS_ZNODE_NAME \n String DISABLED_ZNODE_NAME \n String KEYS_ZNODE_NAME \n String IDENTITIES_ZNODE_NAME \n String KEY_ZNODE_NAME \n String EXPIRE_TIME_ZNODE_NAME \n String KEY_TYPE_ZNODE_NAME \n String LOCKED_ZNODE_NAME \n String getEncryptionKeyTypeZNode \n String getDisabledZNode \n String getKeyTypeZNode \n String getEncryptionKeyNoZNode \n String getEncryptionKeyZNode \n String getLockedZNode \n String getCreatedTimeZNode \n String getExpireTimeZNode \n String getKeyVersionZNode \n String getKeysZNode \n String getIdentitiesZNode \n List<String> getIdentityNames \n String getPrincipalNameZnode \n String getIndentityZNode \n String getKdcFlagsZNode", "output": "String function ( ) { return baseZNode ; }"}, {"instruction": "Generate java code\nadds the subpath to this path . ", "input": " List<Subpath> subpaths \n String START_PATH_ERR_MSG \n Point2D currentPoint \n Point2D getCurrentPoint \n void curveTo \n void curveTo \n boolean isEmpty \n Subpath getLastSubpath \n List<Subpath> getSubpaths \n void lineTo \n void closeSubpath \n void addSubpaths \n List<Integer> replaceCloseWithLine \n void closeAllSubpaths \n void rectangle \n void curveFromTo \n void moveTo", "output": "void function ( Subpath arg0 ) { subpaths . add ( arg0 ) ; currentPoint = arg0 . getLastPoint ( ) ; }"}, {"instruction": "Generate java code\ndecrements active tranbsaction count and completes suspension if we are suspending and there are no more active transactions left . ", "input": " int activeInvocationCount \n InjectedValue<DeploymentRepository> deploymentRepositoryInjectedValue \n AtomicIntegerFieldUpdater<EJBSuspendHandlerService> activeTransactionCountUpdater \n boolean gracefulTxnShutdown \n ServerActivityCallback listener \n AtomicReferenceFieldUpdater<EJBSuspendHandlerService,ServerActivityCallback> listenerUpdater \n InjectedValue<SuspendController> suspendControllerInjectedValue \n InjectedValue<LocalTransactionContext> localTransactionContextInjectedValue \n int activeTransactionCount \n AtomicIntegerFieldUpdater<EJBSuspendHandlerService> activeInvocationCountUpdater \n boolean suspended \n ServiceName SERVICE_NAME \n void resume \n void beforeCompletion \n void enableGracefulTxnShutdown \n void invocationComplete \n void doneSuspended \n boolean isSuspended \n void afterCompletion \n void start \n InjectedValue<SuspendController> getSuspendControllerInjectedValue \n void suspended \n void transactionCreated \n EJBSuspendHandlerService getValue \n void stop \n InjectedValue<LocalTransactionContext> getLocalTransactionContextInjectedValue \n InjectedValue<DeploymentRepository> getDeploymentRepositoryInjectedValue \n boolean acceptInvocation \n void preSuspend", "output": "void function ( ) { int loc0 = activeTransactionCountUpdater . decrementAndGet ( this ) ; if ( suspended && loc0 == 0 && activeInvocationCountUpdater . get ( this ) == 0 ) { doneSuspended ( ) ; } }"}, {"instruction": "Generate java code\nclient address ", "input": " InetAddress _remoteAddr \n Principal realPrincipal \n Subject _subject \n AtomicInteger uniqueId \n Integer _reqID \n ThreadLocal<ReqContext> ctxt \n Principal principal \n void setSubject \n boolean isImpersonating \n Principal realPrincipal \n Subject subject \n Integer requestID \n void setRealPrincipal \n ReqContext context \n void reset \n String toString \n ReqContext initialValue \n InetAddress remoteAddress", "output": "void function ( InetAddress arg0 ) { _remoteAddr = arg0 ; }"}, {"instruction": "Generate java code\ncreates a zip fie from the given source directory and output zip file name ", "input": " PlaceHolder placeHolder \n void zipDirectory \n void unzip \n boolean matches", "output": "void function ( Logger arg0 , File arg1 , File arg2 ) { FileFilter loc0 = null ; createZipFile ( arg0 , arg1 , arg2 , loc0 ) ; }"}, {"instruction": "Generate java code\nsum of getcheckinitialconditionsticks and getcheckfinalconditionsticks ", "input": " RefactoringTickProvider DEFAULT \n int CHECK_INITIAL_CONDITIONS \n int INITIALIZE_CHANGE \n int CHECK_FINAL_CONDITIONS \n int CREATE_CHANGE \n int[] fValues \n int getAllTicks \n int getCreateChangeTicks \n int getCheckInitialConditionsTicks \n int getCheckFinalConditionsTicks \n int getInitializeChangeTicks", "output": "int function ( ) { return fValues [ CHECK_INITIAL_CONDITIONS ] + fValues [ CHECK_FINAL_CONDITIONS ] ; }"}, {"instruction": "Generate java code\nreturns a label for a version name . example is ' 1.4.1 ' ", "input": " String CONCAT_STRING \n String getURLPart \n String getFilePattern \n String markLTR \n String getResourceName \n String getResourceName \n String getPathLabel", "output": "String function ( String arg0 ) { return markLTR ( arg0 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nlocal absolute value . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n GenPolynomial<C> num \n int isunit \n GenPolynomial<C> den \n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n GenPolynomial<C> gcd \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n Local<C> monic \n int hashCode \n Local<C> negate \n GenPolynomial<C> lcm \n boolean equals \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "Local < C > function ( ) { return new Local < C > ( ring , num . abs ( ) , den , true ) ; }"}, {"instruction": "Generate java code\ngenerate variable list . ", "input": " String var \n int N \n String order \n String sum1 \n String polyList \n String sumUm \n String variable \n void main \n String toString", "output": "String function ( String arg0 , String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0 . append ( arg0 ) ; loc0 . append ( \"srini_string\" ) ; for ( int loc1 = 0 ; loc1 <= N ; loc1 ++ ) { loc0 . append ( variable ( loc1 ) ) ; if ( loc1 < N ) { loc0 . append ( \"srini_string\" ) ; } } loc0 . append ( \"srini_string\" ) ; loc0 . append ( arg1 ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ngets the predicate this iterator is using . ", "input": " Predicate predicate \n Object nextObject \n ListIterator iterator \n boolean nextObjectSet \n boolean previousObjectSet \n int nextIndex \n Object previousObject \n void add \n Object next \n void set \n Object previous \n boolean hasNext \n ListIterator getListIterator \n int nextIndex \n boolean setNextObject \n void remove \n boolean setPreviousObject \n void setPredicate \n void clearNextObject \n boolean hasPrevious \n int previousIndex \n void clearPreviousObject \n void setListIterator", "output": "Predicate function ( ) { return predicate ; }"}, {"instruction": "Generate java code\nget listview height according to every children ", "input": " String CLASS_NAME_GRID_VIEW \n String FIELD_NAME_VERTICAL_SPACING \n List<T> getDescendants \n void setViewHeight \n void setSearchViewOnClickListener \n int getGridViewVerticalSpacing \n int getAbsListViewHeightBasedOnChildren \n void setAbsListViewHeightBasedOnChildren \n void setListViewHeightBasedOnChildren", "output": "int function ( ListView arg0 ) { int loc0 = getAbsListViewHeightBasedOnChildren ( arg0 ) ; ListAdapter loc1 ; int loc2 ; if ( arg0 != null && ( loc1 = arg0 . getAdapter ( ) ) != null && ( loc2 = loc1 . getCount ( ) ) > 0 ) { loc0 += arg0 . getDividerHeight ( ) * ( loc2 - 1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ncreates a new customizable refactoring descriptor initialized with its default values . this method may be reimplemented to return a language-specified refactoring descriptor which can be initialized using language-specific features . refactoring tool providers may reimplement this method to provide a uniform api to expose refactoring functionality in the form of refactoring descriptors . callers of this method are supposed to cast the resulting refactoring descriptor to the corresponding language-specific refactoring descriptor provided by the api of the refactoring tooling provider . note : this method is supposed to be reimplemented by clients wishing to provide customizable refactoring descriptors . ", "input": " PlaceHolder placeHolder \n Map<String,String> retrieveArgumentMap \n String getId", "output": "RefactoringDescriptor function ( ) { return null ; }"}, {"instruction": "Generate java code\ncreate an instance of businessexception ", "input": " QName _HistoryHeader_QNAME \n QName _ISDVInfo_QNAME \n QName _KeyValuePairList_QNAME \n QName _LocalizedMessage_QNAME \n QName _BusinessException_QNAME \n QName _Message_QNAME \n QName _CallContext_QNAME \n QName _ValidationException_QNAME \n QName _NotFoundException_QNAME \n QName _ValidationContext_QNAME \n QName _TimePeriod_QNAME \n QName _OpenTimePeriod_QNAME \n QName _LocalizedString_QNAME \n QName _KeyValuePair_QNAME \n QName _TechnicalException_QNAME \n ISDVInfo createISDVInfo \n JAXBElement<ISDVInfo> createISDVInfo \n ValidationException createValidationException \n JAXBElement<ValidationException> createValidationException \n CallContext createCallContext \n JAXBElement<CallContext> createCallContext \n OpenTimePeriod createOpenTimePeriod \n JAXBElement<OpenTimePeriod> createOpenTimePeriod \n LocalizedMessage createLocalizedMessage \n JAXBElement<LocalizedMessage> createLocalizedMessage \n TechnicalException createTechnicalException \n JAXBElement<TechnicalException> createTechnicalException \n KeyValuePairList createKeyValuePairList \n JAXBElement<KeyValuePairList> createKeyValuePairList \n TimePeriod createTimePeriod \n JAXBElement<TimePeriod> createTimePeriod \n LocalizedString createLocalizedString \n JAXBElement<LocalizedString> createLocalizedString \n HistoryHeader createHistoryHeader \n JAXBElement<HistoryHeader> createHistoryHeader \n KeyValuePair createKeyValuePair \n JAXBElement<KeyValuePair> createKeyValuePair \n NotFoundException createNotFoundException \n JAXBElement<NotFoundException> createNotFoundException \n ValidationContext createValidationContext \n JAXBElement<ValidationContext> createValidationContext \n Message createMessage \n JAXBElement<Message> createMessage", "output": "BusinessException function ( ) { return new BusinessException ( ) ; }"}, {"instruction": "Generate java code\ncreate a fingerprint per the following spec ", "input": " Map<String,ECParameterSpec> CURVES \n String NISTP384 \n Map<Integer,String> CURVE_SIZES \n String ECDSA_SHA2_PREFIX \n ECParameterSpec nistp521 \n String NISTP521 \n ECParameterSpec nistp384 \n String NISTP256 \n ECParameterSpec nistp256 \n byte[] keyBlob \n String getCurveName \n ECPublicKeySpec publicKeySpecFromOpenSSH \n ECPublicKeySpec publicKeySpecFromOpenSSH \n String encodeAsOpenSSH \n byte[] readLengthFirst \n String fingerprintPublicKey \n byte[] encodeECPoint \n String hexColonDelimited \n ECPoint decodeECPoint \n int getCurveSize \n void writeLengthFirst \n byte[] removeLeadingZeroes", "output": "String function ( ECPublicKey arg0 ) { byte [ ] loc0 = loc0 ( arg0 ) ; return hexColonDelimited ( Hashing . md5 ( ) . hashBytes ( loc0 ) ) ; }"}, {"instruction": "Generate java code\nappend a hashcode for a byte . ", "input": " int iConstant \n int iTotal \n HashCodeBuilder appendSuper \n int toHashCode", "output": "HashCodeBuilder function ( byte arg0 ) { iTotal = iTotal * iConstant + arg0 ; return this ; }"}, {"instruction": "Generate java code\nreturns true iff the method could be a virtual method , i.e. if it is not a constructor , is private , or is static . ", "input": " PlaceHolder placeHolder \n IMethod isDeclaredInInterface \n IMethod overridesAnotherMethod \n IMethod getTopmostMethod \n RefactoringStatus checkIfComesFromInterface \n RefactoringStatus checkIfOverridesAnother", "output": "boolean function ( IMethod arg0 ) { if ( arg0 . isConstructor ( ) ) return false ; if ( JdtFlags . isPrivate ( arg0 ) ) return false ; if ( JdtFlags . isStatic ( arg0 ) ) return false ; return true ; }"}, {"instruction": "Generate java code\ninvoke to tell listeners that an atomic test flagged that it assumed something false . ", "input": " List<RunListener> fListeners \n boolean fPleaseStop \n List<RunListener> fCurrentListeners \n void fireTestIgnored \n void fireTestRunFinished \n void notifyListener \n void run \n void fireTestFailures \n void removeListener \n void pleaseStop \n void fireTestFailure \n void fireTestFinished \n void fireTestRunStarted \n void fireTestStarted \n void addListener \n void addFirstListener", "output": "void function ( final Failure arg0 ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener arg1 ) throws Exception { arg1 . testAssumptionFailure ( arg0 ) ; } } . run ( ) ; }"}, {"instruction": "Generate java code\nget a cached formula ", "input": " Image image \n ConcurrentMap<CachedTeXFormula,SoftReference<CachedImage>> cache \n String f \n int inset \n Color fgcolor \n AffineTransform identity \n int width \n int type \n ReferenceQueue queue \n int depth \n int size \n int style \n CachedTeXFormula cachedTf \n int max \n int height \n void removeCachedTeXFormula \n void removeCachedTeXFormula \n void removeCachedTeXFormula \n int[] getCachedTeXFormulaDimensions \n int[] getCachedTeXFormulaDimensions \n int[] getCachedTeXFormulaDimensions \n Object paintCachedTeXFormula \n Object paintCachedTeXFormula \n Object paintCachedTeXFormula \n int hashCode \n boolean equals \n void setDimensions \n void clearCache \n SoftReference<CachedImage> makeImage \n void setMaxCachedObjects \n Object getCachedTeXFormula \n Object getCachedTeXFormula", "output": "Image function ( String arg0 , int arg1 , int arg2 , int arg3 , int arg4 , Color arg5 ) { return getCachedTeXFormulaImage ( new CachedTeXFormula ( arg0 , arg1 , arg2 , arg3 , arg4 , arg5 ) ) ; }"}, {"instruction": "Generate java code\na shorthand for readfixed bytes , 0 , bytes.length . ", "input": " PlaceHolder placeHolder \n void skipFixed \n long readArrayStart \n long arrayNext \n long skipMap \n Utf8 readString \n String readString \n long skipArray \n void skipBytes \n long mapNext \n long readLong \n int readEnum \n int readIndex \n double readDouble \n void skipString \n float readFloat \n ByteBuffer readBytes \n void readNull \n boolean readBoolean \n int readInt \n long readMapStart", "output": "void function ( byte [ ] arg0 ) { readFixed ( arg0 , 0 , arg0 . length ) ; }"}, {"instruction": "Generate java code\nset the sql comment to use . ", "input": " CriteriaImpl impl \n Criteria criteria \n DetachedCriteria add \n Criteria getExecutableCriteria \n DetachedCriteria setFetchMode \n DetachedCriteria setProjection \n DetachedCriteria forEntityName \n DetachedCriteria forEntityName \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria createCriteria \n DetachedCriteria setLockMode \n DetachedCriteria setLockMode \n DetachedCriteria setResultTransformer \n CriteriaImpl getCriteriaImpl \n DetachedCriteria forClass \n DetachedCriteria forClass \n DetachedCriteria addOrder \n String toString \n String getAlias \n DetachedCriteria createAlias \n DetachedCriteria createAlias \n DetachedCriteria createAlias \n DetachedCriteria createAlias \n DetachedCriteria createAlias", "output": "DetachedCriteria function ( String arg0 ) { criteria . setComment ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nwaits until the statemodel reaches the indicated state . note : waitforstate methods may not be called from multiple threads simoultaneously . ", "input": " int[] targetStates_ \n StateModel model_ \n void stateChanged \n void setStateModel", "output": "void function ( int arg0 ) { int [ ] loc0 = { arg0 } ; waitForState ( loc0 ) ; }"}, {"instruction": "Generate java code\nappends the `` order by '' fragment , prefixed by a comma if the `` order by '' fragment already exists . ", "input": " LockOptions lockOptions \n int guesstimatedBufferSize \n StringBuilder whereClause \n Dialect dialect \n StringBuilder selectClause \n String outerJoinsAfterWhere \n String outerJoinsAfterFrom \n StringBuilder fromClause \n String comment \n StringBuilder orderByClause \n void appendFromClauseFragment \n void appendFromClauseFragment \n void setOuterJoins \n void setLockOptions \n void setComment \n String toStatementString \n boolean isNotEmpty \n boolean isNotEmpty \n String cleanRestrictions \n void appendSelectClauseFragment \n void setLockMode \n void appendRestrictions", "output": "void function ( String arg0 ) { if ( this . orderByClause == null ) { this . orderByClause = new StringBuilder ( ) ; } else { this . orderByClause . append ( \"srini_string\" ) ; this . guesstimatedBufferSize += 2 ; } this . orderByClause . append ( arg0 ) ; }"}, {"instruction": "Generate java code\nget event listener of this object ", "input": " String name \n AngularObjectListener listener \n String noteId \n String paragraphId \n List<AngularObjectWatcher> watchers \n T object \n void addWatcher \n String getName \n void set \n void set \n void removeWatcher \n String getParagraphId \n void clearAllWatchers \n int hashCode \n boolean equals \n Object get \n boolean isGlobal \n void setParagraphId \n void setListener \n String toString \n void setNoteId \n void emit \n String getNoteId", "output": "AngularObjectListener function ( ) { return listener ; }"}, {"instruction": "Generate java code\nfactory method that performs validation and copies the parameter array . ", "input": " Closure[] iClosures \n long serialVersionUID \n Closure[] getClosures \n void execute", "output": "Closure function ( Closure [ ] arg0 ) { FunctorUtils . validate ( arg0 ) ; if ( arg0 . length == 0 ) { return NOPClosure . INSTANCE ; } arg0 = FunctorUtils . copy ( arg0 ) ; return new ChainedClosure ( arg0 ) ; }"}, {"instruction": "Generate java code\nindicates whether some other object is `` equal to '' this comparator . ", "input": " EditorContext context \n boolean DEBUG \n int compare \n void db", "output": "boolean function ( final Object arg0 ) { return ( arg0 instanceof TypeComparator ) ; }"}, {"instruction": "Generate java code\nis this menu contained by this control ? ", "input": " SWTHierarchy _hierarchy \n boolean isOrphanedBy \n boolean isSubMenu", "output": "boolean function ( Menu arg0 , Control arg1 ) { Collection loc0 = _hierarchy . getWidgets ( arg1 ) ; return loc0 == null ? false : loc0 . contains ( arg0 ) ; }"}, {"instruction": "Generate java code\ndispatch a mouserelease event . ", "input": " Point pointT \n abbot.swt.Robot _robot \n void robotKeyClick \n void doKeyDown \n void doKeyUp \n void mouseMove \n void mouseMove \n void keyUp \n void keyUp \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n int[] extractKeys \n void keyClick \n void keyClick \n void keyDown \n void keyDown \n Event createClickEvent \n void enterText", "output": "void function ( int arg0 ) { Event loc0 = createClickEvent ( arg0 ) ; loc0 . type = SWT . MouseUp ; new SWTPushEventOperation ( loc0 ) . execute ( ) ; }"}, {"instruction": "Generate java code\nadds a notification . ", "input": " Notification mForegroundNotification \n ConcurrentHashMap<Integer,Notification> mNotifications \n NotificationManagerCompat mNotificationManager \n Context mContext \n int mForegroundNotificationId \n void updateForegroundNotification \n void setForegroundNotification \n boolean isOngoing \n boolean isOngoing \n void update \n boolean isDone \n void remove", "output": "void function ( int arg0 , Notification arg1 ) { mNotificationManager . notify ( arg0 , arg1 ) ; mNotifications . put ( arg0 , arg1 ) ; if ( mForegroundNotification == null && isOngoing ( arg1 ) ) { setForegroundNotification ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nlooks at the top of this stack without removing it . ", "input": " ArrayShortList list \n short pop \n int search \n int size \n short get \n void clear \n short push \n boolean empty", "output": "short function ( ) { if ( list . isEmpty ( ) ) { throw new EmptyStackException ( ) ; } return list . get ( list . size ( ) - 1 ) ; }"}, {"instruction": "Generate java code\nreturn the ending location of this move . ", "input": " int startingLocation \n Player thePlayer \n int endingLocation \n Player getPlayer \n int startLocation", "output": "int function ( ) { return endingLocation ; }"}, {"instruction": "Generate java code\nsets the new vendorid . ", "input": " long signature1 \n int productID \n String manufacturer \n int vendorID \n long version \n long signature2 \n String productDescription \n String serialNumber \n int MAX_HEADER_LENGTH \n String manufacturerID \n boolean remoteWakeupCapable \n boolean pnpEnabled \n int maxPower \n boolean selfPowered \n boolean isPnpEnabled \n long getSignature2 \n void setProductID \n void setPnpEnabled \n void setManufacturer \n void setMaxPower \n void setProductDescription \n String getManufacturer \n void setSelfPowered \n long getSignature1 \n void setManufacturerID \n boolean isRemoteWakeupCapable \n String getManufacturerID \n void validate \n int getMaxPower \n long getVersion \n void setSignature1 \n String getSerialNumber \n void setSerialNumber \n void setVersion \n void setSignature2 \n String getProductDescription \n int getProductID \n boolean isSelfPowered \n void setRemoteWakeupCapable \n int getVendorID", "output": "void function ( int arg0 ) { this . vendorID = arg0 ; }"}, {"instruction": "Generate java code\nfinds the cross product of two 3d vectors represented to float arrays ", "input": " float x \n float z \n float y \n void setLength \n void logVector \n void normalize \n double dot \n float length \n void copy \n void copy \n void reverse \n double rotToRad \n void rotateX \n void rotateY \n void rotateZ", "output": "void function ( float [ ] arg0 , float [ ] arg1 , Point3D arg2 ) { arg2 . x = arg0 [ 1 ] * arg1 [ 2 ] - arg0 [ 2 ] * arg1 [ 1 ] ; arg2 . y = arg0 [ 2 ] * arg1 [ 0 ] - arg0 [ 0 ] * arg1 [ 2 ] ; arg2 . z = arg0 [ 0 ] * arg1 [ 1 ] - arg0 [ 1 ] * arg1 [ 0 ] ; }"}, {"instruction": "Generate java code\ngets the size of the list of keys . ", "input": " long serialVersionUID \n Object[] keys \n int hashCode \n Object getKey \n int hashCode \n boolean equals \n String toString \n Object[] getKeys", "output": "int function ( ) { return keys . length ; }"}, {"instruction": "Generate java code\nfind a widget , using the given matcher to determine whether a given widget in the hierarchy in the given display is the desired one . ", "input": " int MATCH \n Collection _widgets \n int _dbComparisons \n Widget _widget \n Hierarchy _hierarchy \n int BFS \n int DFS \n int _type \n ArrayList _list \n int WIDGET_NOT_FOUND \n int MULTIPLE_WIDGETS_FOUND \n int _searchType \n Widget getParent \n Collection getRoots \n Widget getWidget \n Collection getWidgets \n Collection getWidgets \n MatchResult match \n void findMatches \n MatchResult multipleFound \n void pause \n boolean contains \n int getType \n void assertNotNull \n void assertNotNull \n MatchResult find0 \n void dispose \n MatchResult notFound \n int getFinderRetryInterval \n int getMaxFinderRetries \n void setFound", "output": "MatchResult function ( Display arg0 , Matcher arg1 ) { return find ( arg0 , arg1 , getMaxFinderRetries ( ) ) ; }"}, {"instruction": "Generate java code\nassume for test failures when running with elytron profile enabled . it skips test in case the ' - delytron ' mavenargument is used for elytron profile activation and system property wildfly.tmp.enable.elytron.profile.tests has n't value ` true ' . ", "input": " Supplier<Boolean> CONDITION_SKIP_ELYTRON_PROFILE \n void assumeInvocationTestsEnabled \n void assumeCondition", "output": "void function ( ) { assumeCondition ( \"srini_string\" , CONDITION_SKIP_ELYTRON_PROFILE ) ; }"}, {"instruction": "Generate java code\nreads a group of ppt statements statements following the line `` ppt_name ... '' . all the lines between firstline and the first empty line are placed into a list and then this list is placed in to pptsections . ", "input": " String lineSep \n StatementReplacer statementReplacer \n String spinfoFileName \n String tempDir \n SplitterObject[][] splitterObjects \n boolean isComment \n StatementReplacer getReplacer \n SplitterObject[][] createSplitterObjects \n void setFormatting \n void readReplaceStatements \n void parseFile \n boolean isFormatting \n boolean isBlank \n SplitterObject[][] getSplitterObjects", "output": "void function ( LineNumberReader arg0 , List < List < String >> arg1 , String arg2 ) { List < String > loc0 = new ArrayList < String > ( ) ; loc0 . add ( arg2 ) ; String loc1 = arg0 . readLine ( ) ; while ( ( loc1 != null ) && ( ! loc1 . trim ( ) . equals ( \"srini_string\" ) ) ) { loc0 . add ( loc1 ) ; loc1 = arg0 . readLine ( ) ; } arg1 . add ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturn a library that loads the core from code.jquery.com ", "input": " String BASE_RESOURCE_URL \n String url \n JQueryLibrary mobileStructure \n JQueryLibrary baseTheme \n JQueryLibrary ui \n void renderOn \n JQueryLibrary mobileTheme \n JQueryLibrary mobile \n JQueryLibrary theme", "output": "JQueryLibrary function ( String arg0 ) { return new JQueryLibrary ( BASE_RESOURCE_URL + \"srini_string\" + arg0 + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nbuild a condition that tests whether the active wizard page has an expected message text . ", "input": " long serialVersionUID \n IUICondition hasErrorMessage \n IUICondition hasDescription \n String toString \n IUICondition hasTitle", "output": "IUICondition function ( String arg0 ) { return new HasTextCondition ( new WizardPageElement ( ) { public String getText ( IUIContext arg1 ) throws WidgetSearchException { return getPage ( ) . getMessage ( ) ; } } , arg0 ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable set of enabled filter names . ", "input": " String internalFetchProfile \n EntityGraph loadGraph \n SessionFactoryImplementor sessionFactory \n Map<String,Filter> enabledFilters \n Set<String> enabledFetchProfileNames \n EntityGraph fetchGraph \n LoadQueryInfluencers NONE \n void setInternalFetchProfile \n EntityGraph getFetchGraph \n void setLoadGraph \n Map<String,Filter> getEnabledFilters \n boolean isFetchProfileEnabled \n Object getFilterParameterValue \n void enableFetchProfile \n Set<String> getEnabledFetchProfileNames \n SessionFactoryImplementor getSessionFactory \n void disableFilter \n String[] parseFilterParameterName \n void disableFetchProfile \n void checkFetchProfileName \n Type getFilterParameterType \n boolean hasEnabledFilters \n Filter enableFilter \n void setFetchGraph \n String getInternalFetchProfile \n Filter getEnabledFilter \n boolean hasEnabledFetchProfiles \n EntityGraph getLoadGraph", "output": "Set < String > function ( ) { return java . util . Collections . unmodifiableSet ( enabledFilters . keySet ( ) ) ; }"}, {"instruction": "Generate java code\ncreate and cache a new recording debug info structure ", "input": " IPath workspaceLocation \n String PROJECT_CLASSPATH \n String[] recorderClasspath \n String[] bundleClasspath \n String recLogContent \n String RECORDER_CLASSPATH \n DebugRecordingInfo mostRecentInfo \n String devLogContent \n ISemanticEvent[] semanticEvents \n Object[] getClasspath \n DebugRecordingInfo getInfo \n void printInfo \n void printClasspath \n String getDevelopmentLogContent \n String[] getRecorderClasspath \n void setRecorderClasspath \n boolean shouldShow \n IPath getWorkspaceLocation \n String[] getBundleClasspath \n ISemanticEvent[] getSemanticEvents \n void setSemanticEvents \n void setSemanticEvents \n String getRecorderLogContent \n Object[] getClasspathNames \n String readLogContent \n void copyToClipboard \n void setBundleClasspath \n void setWorkspaceLocation \n String convertToText", "output": "void function ( ) { mostRecentInfo = new DebugRecordingInfo ( ) ; }"}, {"instruction": "Generate java code\nsolves a linear system for x , y with cramer 's rule . ax + by = e cx + dy = f ", "input": " PlaceHolder placeHolder \n double det \n double det", "output": "double [ ] function ( double arg0 , double arg1 , double arg2 , double arg3 , double arg4 , double arg5 ) { System . out . println ( \"srini_string\" + arg0 + \"srini_string\" + arg1 + \"srini_string\" + arg2 + \"srini_string\" + arg3 + \"srini_string\" + arg4 + \"srini_string\" + arg5 + \"srini_string\" ) ; double loc0 = ( arg4 * arg3 - arg1 * arg5 ) / ( arg0 * arg3 - arg1 * arg2 ) ; double loc1 = ( arg0 * arg5 - arg4 * arg2 ) / ( arg0 * arg3 - arg1 * arg2 ) ; return new double [ ] { loc0 , loc1 } ; }"}, {"instruction": "Generate java code\nreturns the paint surface associated with this paint session . ", "input": " PaintSurface paintSurface \n placeholderType placeHolder", "output": "PaintSurface function ( ) { return paintSurface ; }"}, {"instruction": "Generate java code\nthis method splits a string by hyphens in it and returns the list of strings . ", "input": " PlaceHolder placeHolder \n String getDocContent \n ArrayList<String> processToken \n Map<Integer,Double> sortByValue \n Map<String,Integer> getStemmedTokens", "output": "List < String > function ( String arg0 ) { return Arrays . asList ( ( arg0 . split ( \"srini_string\" ) ) ) ; }"}, {"instruction": "Generate java code\nstop monitoring the ui for responsiveness . ", "input": " ITestCleanupHandler _cleanupHandler \n boolean _isRunning \n List<ITestExecutionListener> _listeners \n RunningState _runningState \n TestExceptionCache _exceptionCache \n void startUIMonitor \n void testFinished \n void exceptionCaught \n IUIThreadMonitor getUIThreadMonitor \n void testStarted \n TestExceptionCache getExceptions \n void setIsRunning \n boolean isRunning \n void cleanUp \n void testFinishing \n void waitUntilFinished \n void stopTestMonitors \n void setException \n void addListener \n boolean isExceptional \n void testStarting \n void doWaitForFinish \n void uiTimeout \n boolean terminateWaitForFinish \n void removeListener \n void throwException \n RunningState getState \n void setCleanupHandler \n void startTestMonitors \n TestExceptionCache getExceptionCache", "output": "void function ( ) { getUIThreadMonitor ( ) . setListener ( null ) ; }"}, {"instruction": "Generate java code\nlaunch the application ", "input": " Shell shell \n boolean ALPHA \n Text text \n boolean BETA \n void toggleBETA \n Text getText \n void toggleALPHA \n Shell getShell \n void createContents \n void open", "output": "void function ( String [ ] arg0 ) { try { TextTestShell loc0 = new TextTestShell ( ) ; loc0 . open ( ) ; final Display loc1 = Display . getDefault ( ) ; while ( ! loc0 . getShell ( ) . isDisposed ( ) ) { if ( ! loc1 . readAndDispatch ( ) ) loc1 . sleep ( ) ; } } catch ( Exception loc0 ) { loc0 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\ntransform a given cache into a cache that fails silently if cache reads fail . ", "input": " PlaceHolder placeHolder \n AdvancedCache asyncWriteCache \n boolean isClustered \n AdvancedCache localCache \n AdvancedCache failSilentWriteCache \n AdvancedCache failSilentWriteCache \n boolean isSynchronousCache \n T withinTx \n T withinTx \n AdvancedCache ignoreReturnValuesCache \n AdvancedCache ignoreReturnValuesCache \n boolean isInvalidationCache \n void broadcastEvictAll", "output": "AdvancedCache function ( AdvancedCache arg0 ) { return arg0 . withFlags ( Flag . FAIL_SILENTLY , Flag . ZERO_LOCK_ACQUISITION_TIMEOUT ) ; }"}, {"instruction": "Generate java code\nreturn the original line number for this line ", "input": " String inlineMarkupDelimiters \n int sectionLevel \n boolean erased \n boolean inBlock \n boolean listStart \n List<Boolean> valid \n char ESCAPED_CHARACTER_VALUE \n List<Integer> offsets \n List<Character> characters \n String text \n List<Boolean> escaped \n int listLevel \n int lineNo \n boolean allSameCharacter \n void setListStart \n void erase \n void erase \n void erase \n boolean isListStart \n String getText \n boolean isValid \n int getOffset \n int length \n boolean isEmpty \n void eraseWithStyle \n boolean isAllSameCharacter \n void setSectionLevel \n void setInBlock \n boolean isErased \n int getSectionLevel \n int eraseEnclosure \n int getListLevel \n boolean isInBlock \n String toString \n char rawCharAt \n void setListLevel \n char charAt \n char charAt \n boolean startsWith", "output": "int function ( ) { return lineNo ; }"}, {"instruction": "Generate java code\ngets the next key from the map . ", "input": " Iterator iterator \n Map.Entry last \n Map map \n boolean canRemove \n Object getKey \n Object getValue \n Object setValue \n void reset \n boolean hasNext \n String toString \n void remove", "output": "Object function ( ) { last = ( Map . Entry ) iterator . next ( ) ; canRemove = true ; return last . getKey ( ) ; }"}, {"instruction": "Generate java code\ncalled by the default implementation of #writearray to get thesize of an array . the default implementation is for collection . ", "input": " GenericData data \n Schema root \n NullPointerException npe \n void writeWithoutConversion \n Iterator<? extends Object> getArrayElements \n void writeFixed \n void writeEnum \n Object convert \n void writeField \n int getMapSize \n void error \n void writeMap \n void setSchema \n void writeRecord \n void writeBytes \n void writeArray \n Iterable<Map.Entry<Object,Object>> getMapEntries \n int resolveUnion \n void write \n void write \n void writeString \n void writeString \n GenericData getData", "output": "long function ( Object arg0 ) { return ( ( Collection ) arg0 ) . size ( ) ; }"}, {"instruction": "Generate java code\ncalled when a paragraph is written . paragraphposition will hold the height of the end of the paragraph . ", "input": " PlaceHolder placeHolder \n void onSection \n void onParagraph \n void onOpenDocument \n void onSectionEnd \n void onEndPage \n void onChapter \n void onGenericTag \n void onCloseDocument \n void onChapterEnd \n void onStartPage", "output": "void function ( PdfWriter arg0 , Document arg1 , float arg2 ) { }"}, {"instruction": "Generate java code\nadds the given text as a child to this node . the text will be quoted . ", "input": " char EQ \n char LT \n char AMP \n char QUOT \n char GT \n XMLElement lastchild \n char SPACE \n String name \n boolean closed \n Writer writer \n boolean openTagDone \n char SLASH \n void quote \n void finishOpenTag \n void addChildElement \n XMLElement text \n XMLElement attr \n XMLElement attr \n XMLElement attr \n void close \n void beginOpenTag \n XMLElement element", "output": "XMLElement function ( final String arg0 ) { if ( closed ) { throw new IOException ( format ( \"srini_string\" , name ) ) ; } finishOpenTag ( ) ; if ( lastchild != null ) { lastchild . close ( ) ; } quote ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nparse an inputstream that optionally detects encoding from the stream ", "input": " String text \n Charset charset \n StateController controller \n XMLParserMemory memory \n List<XMLParserListener> listeners \n TagState tagState \n ParserMonitor monitor \n State state \n XMLParserMemory memory \n void startElement \n InputStreamReader detectEncoding \n char currentLastChar \n XMLParser removeListener \n Charset getCharset \n TagState currentTagState \n void currentTagState \n String current \n void endElement \n void flush \n void parseWithReader \n void unknownData \n String currentTag \n void setMonitor \n String bufferToString \n void setState \n void comment \n StateController selectState \n void text \n XMLParser append \n XMLParser append \n XMLParser append \n void callText \n XMLParser addListener \n int bufferSize", "output": "void function ( final InputStream arg0 , final boolean arg1 ) { if ( arg1 ) { parse ( arg1 ( new BufferedInputStream ( arg0 ) ) ) ; } else { parse ( arg0 ) ; } }"}, {"instruction": "Generate java code\ngetter for property ` entityname ' . ", "input": " String propertyName \n String entityName \n String getRole \n void configure \n Serializable generate \n String getPropertyName", "output": "String function ( ) { return entityName ; }"}, {"instruction": "Generate java code\ndoes this word contain upper-case letters only ? ", "input": " Set<ISpellDictionary> fDictionaries \n Set<String> fIgnored \n Locale fLocale \n String[] URL_PREFIXES \n IPreferenceStore fPreferences \n void addDictionary \n void addWord \n void ignoreWord \n void removeDictionary \n boolean isMixedCase \n Set<RankedWordProposal> getProposals \n boolean acceptsWords \n void execute \n void checkWord \n boolean isUrl \n boolean isDigits \n Locale getLocale \n boolean isCorrect", "output": "boolean function ( final String arg0 ) { for ( int loc0 = arg0 . length ( ) - 1 ; loc0 >= 0 ; loc0 -- ) { if ( Character . isLowerCase ( arg0 . charAt ( loc0 ) ) ) return false ; } return true ; }"}, {"instruction": "Generate java code\nmaps a codec name into a codecfactory . currently there are five codecs registered by default : null deflate snappy bzip2 xz ", "input": " int DEFAULT_XZ_LEVEL \n Map<String,CodecFactory> REGISTERED \n int DEFAULT_DEFLATE_LEVEL \n Codec createInstance \n CodecFactory snappyCodec \n CodecFactory bzip2Codec \n CodecFactory deflateCodec \n String toString \n CodecFactory xzCodec \n CodecFactory addCodec \n CodecFactory nullCodec", "output": "CodecFactory function ( String arg0 ) { CodecFactory loc0 = REGISTERED . get ( arg0 ) ; if ( loc0 == null ) { throw new AvroRuntimeException ( \"srini_string\" + arg0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ninvoked when a test method is about to start ", "input": " PlaceHolder placeHolder \n Statement apply \n void finished \n void failed \n void succeeded", "output": "void function ( FrameworkMethod arg0 ) { }"}, {"instruction": "Generate java code\ncreate two hazelcastinstance server @bean s clustered together . ", "input": " String CLUSTER_HOST \n Logger LOG \n String MASTER_SERVER \n HazelcastInstance hazelcastInstance \n int CLUSTER_PORT \n HazelcastInstance singleton \n HazelcastInstance makeClient \n void preDestroy \n HazelcastInstance makeServer \n KeyValueOperations keyValueTemplate", "output": "HazelcastInstance function ( ) { HazelcastInstance loc0 = InstanceHelper . makeServer ( Constants . HAZELCAST_INSTANCE_NAME , CLUSTER_PORT ) ; LOG . trace ( \"srini_string\" , loc0 ) ; InstanceHelper . makeServer ( \"srini_string\" + Constants . HAZELCAST_INSTANCE_NAME , ( 1 + CLUSTER_PORT ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\ninvokes the underlying map #isempty method . ", "input": " Map map \n Set entrySet \n boolean containsKey \n Collection values \n void clear \n boolean containsValue \n Object put \n Object remove \n int size \n int hashCode \n boolean equals \n Object get \n void putAll \n Set keySet", "output": "boolean function ( ) { return map . isEmpty ( ) ; }"}, {"instruction": "Generate java code\nreturns the quirks . ", "input": " T headPointer \n int mode \n boolean quirks \n T formPointer \n StackNode<T>[] stack \n boolean framesetOk \n boolean needToDropLF \n T deepTreeSurrogateParent \n int[] templateModeStack \n StackNode<T>[] listOfActiveFormattingElements \n int originalMode \n T getDeepTreeSurrogateParent \n int getListOfActiveFormattingElementsLength \n boolean isFramesetOk \n void destructor \n int[] getTemplateModeStack \n int getStackLength \n T getHeadPointer \n int getOriginalMode \n int getTemplateModeStackLength \n StackNode<T>[] getStack \n boolean isNeedToDropLF \n StackNode<T>[] getListOfActiveFormattingElements \n int getMode \n T getFormPointer", "output": "boolean function ( ) { return quirks ; }"}, {"instruction": "Generate java code\nsets the value of ours ", "input": " long theirs \n long ours \n String description \n int iterations \n int getIterations \n void setIterations \n long getOurAvg \n String toString \n void setDescription \n void setTheirs \n long getTheirs \n String getDescription \n long getOurs \n long getTheirAvg", "output": "void function ( long arg0 ) { this . ours = arg0 ; }"}, {"instruction": "Generate java code\ngetter for the leading ", "input": " boolean knockout \n LineDashPattern lineDashPattern \n BaseColor fillColor \n float wordSpacing \n float leading \n BaseColor strokeColor \n int lineJoinStyle \n float miterLimit \n int lineCapStyle \n float lineWidth \n int renderMode \n PdfName colorSpaceFill \n PdfName colorSpaceStroke \n float fontSize \n float rise \n Matrix ctm \n float horizontalScaling \n float characterSpacing \n CMapAwareDocumentFont font \n float getFontSize \n int getRenderMode \n void setLineDashPattern \n int getLineJoinStyle \n PdfName getColorSpaceStroke \n float getCharacterSpacing \n void setLineWidth \n Matrix getCtm \n void setLineCapStyle \n PdfName getColorSpaceFill \n float getMiterLimit \n float getLineWidth \n float getWordSpacing \n boolean isKnockout \n BaseColor getFillColor \n CMapAwareDocumentFont getFont \n void setMiterLimit \n float getRise \n BaseColor getStrokeColor \n int getLineCapStyle \n LineDashPattern getLineDashPattern \n float getHorizontalScaling \n void setLineJoinStyle", "output": "float function ( ) { return leading ; }"}, {"instruction": "Generate java code\nalways return constant . ", "input": " Factory NULL_INSTANCE \n long serialVersionUID \n Object iConstant \n Object getConstant \n Factory getInstance", "output": "Object function ( ) { return iConstant ; }"}, {"instruction": "Generate java code\nget reference to the scene that has the input focus ", "input": " List<Scene> scenes \n Map<String,Scene> sceneHashMap \n List<Btimer> btimers \n Scene focusScene \n void startScene \n void startScene \n void addTimer \n void stopScene \n void setInputFocus \n void setInputFocus \n List<Scene> getScenes \n void updateTimers \n boolean sceneExist \n void addScene", "output": "Scene function ( ) { return focusScene ; }"}, {"instruction": "Generate java code\nbuilds the commands . ", "input": " PlaceHolder placeHolder \n Command findCommand \n boolean commandEquals", "output": "List < Command > function ( String ... arg0 ) { List < Command > loc0 = new ArrayList < Command > ( ) ; for ( String loc1 : arg0 ) { Command loc2 = findCommand ( loc1 ) ; if ( loc2 != null ) { loc0 . add ( loc2 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nremoves from the underlying collection the last element returned by the iterator . as with next and hasnext , this method calls remove on the underlying iterator . therefore , this method may throw an unsupportedoperationexception if the underlying iterator does not support this method . ", "input": " Iterator lastUsedIterator \n boolean isLocked \n Iterator currentIterator \n List iteratorChain \n int currentIteratorIndex \n Object next \n void checkLocked \n int size \n void addIterator \n boolean isLocked \n void lockChain \n boolean hasNext \n List getIterators \n void setIterator \n void updateCurrentIterator", "output": "void function ( ) { lockChain ( ) ; updateCurrentIterator ( ) ; lastUsedIterator . remove ( ) ; }"}, {"instruction": "Generate java code\ninclusive min / max ", "input": " Random rand \n int nextIntRange \n double getAngle \n byte[] putBytesInArray", "output": "float function ( float arg0 , float arg1 ) { return arg0 + ( rand . nextFloat ( ) * ( ( 1 + arg1 ) - arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturn the slot id 's of all active jsf versions . ", "input": " Map<String,ModuleIdentifier> apiIds \n Set<String> allVersions \n List<String> activeVersions \n JSFModuleIdFactory instance \n Map<String,ModuleIdentifier> implIds \n String API_MODULE \n String INJECTION_MODULE \n String defaultSlot \n Map<String,ModuleIdentifier> injectionIds \n String IMPL_MODULE \n void loadIds \n String getDefaultSlot \n String computeSlot \n boolean isBogusPath \n void loadIdsManually \n void setDefaultSlot \n ModuleIdentifier getImplModId \n boolean isValidJSFSlot \n JSFModuleIdFactory getInstance \n void loadIdsFromModulePath \n void checkVersionIntegrity \n ModuleIdentifier getApiModId \n ModuleIdentifier getInjectionModId", "output": "List < String > function ( ) { return Collections . unmodifiableList ( activeVersions ) ; }"}, {"instruction": "Generate java code\nsets the current active layout manager ", "input": " SchemaDiagramPart diagram \n Map partsToNodeMap \n GraphXYLayout xyLayoutManager \n Map figureToBoundsMap \n LayoutManager activeLayoutManager \n GraphLayoutManager graphLayoutManager \n void layout \n void setConstraint \n Object getConstraint \n Dimension getPreferredSize \n Dimension getMinimumSize \n LayoutManager getActiveLayoutManager \n void invalidate \n void setXYLayoutConstraint \n void remove", "output": "void function ( IFigure arg0 , LayoutManager arg1 ) { arg0 . setLayoutManager ( arg1 ) ; this . activeLayoutManager = arg1 ; if ( arg1 == xyLayoutManager ) { diagram . installEditPolicy ( EditPolicy . LAYOUT_ROLE , new SchemaXYLayoutPolicy ( ) ) ; } else { diagram . installEditPolicy ( EditPolicy . LAYOUT_ROLE , null ) ; } }"}, {"instruction": "Generate java code\ntransfers money from one account to another . ", "input": " double[] accounts \n int size \n double getTotalBalance", "output": "void function ( int arg0 , int arg1 , double arg2 ) { if ( accounts [ arg0 ] < arg2 ) return ; System . out . print ( Thread . currentThread ( ) ) ; accounts [ arg0 ] -= arg2 ; System . out . printf ( \"srini_string\" , arg2 , arg0 , arg1 ) ; accounts [ arg1 ] += arg2 ; System . out . printf ( \"srini_string\" , getTotalBalance ( ) ) ; }"}, {"instruction": "Generate java code\ncalled to evict data from the entire region ", "input": " CoreMessageLogger LOG \n void unlockRegion \n void evictAll \n BaseGeneralDataRegion getInternalRegion \n void unlockItem \n Object get \n boolean putFromLoad \n boolean putFromLoad \n SoftLock lockItem \n SoftLock lockRegion \n boolean isDefaultMinimalPutOverride \n void remove \n void evict", "output": "void function ( ) { evictAll ( ) ; }"}, {"instruction": "Generate java code\nconverts an instance of the object model described in org.apache.avro.jsonproperties to a json string . ", "input": " ResolvingDecoder resolver \n Schema SCHEMA \n Schema written \n JsonFactory FACTORY \n ObjectMapper MAPPER \n JsonNode read \n Object read \n JsonNode read \n Object parseJson \n void writeObject \n void write \n void write \n void write \n void setSchema \n void setSchema \n void setSchema \n void setSchema \n Object readObject", "output": "String function ( Object arg0 ) { return JacksonUtils . toJsonNode ( arg0 ) . toString ( ) ; }"}, {"instruction": "Generate java code\nconfigure a job 's mapper implementation . ", "input": " String COMBINER \n String MAP_OUTPUT_SCHEMA \n String INPUT_SCHEMA \n String MAPPER \n String TEXT_PREFIX \n String CONF_DATA_MODEL \n String BINARY_PREFIX \n String OUTPUT_SCHEMA \n String INPUT_IS_REFLECT \n String MAP_OUTPUT_IS_REFLECT \n String REDUCER \n String OUTPUT_CODEC \n void configureAvroShuffle \n GenericData createDataModel \n Schema getOutputSchema \n void setInputSequenceFile \n void configureAvroInput \n void setDataModelClass \n void setInputSchema \n void setInputReflect \n void setOutputSchema \n void configureAvroOutput \n Class<? extends GenericData> getDataModelClass \n void setMapOutputSchema \n GenericData newDataModelInstance \n Schema getInputSchema \n void setReducerClass \n Schema getMapOutputSchema \n void setReflect \n GenericData createInputDataModel \n void setMapOutputReflect \n void setOutputCodec \n void setCombinerClass \n GenericData createMapOutputDataModel \n void setOutputMeta \n void setOutputMeta \n void setOutputMeta", "output": "void function ( JobConf arg0 , Class < ? extends AvroMapper > arg1 ) { arg0 . set ( MAPPER , arg1 . getName ( ) ) ; }"}, {"instruction": "Generate java code\nresidue summation . ", "input": " GenPolynomial<C> val \n ResidueRing<C> ring \n int isunit \n int signum \n boolean isONE \n Residue<C> inverse \n boolean isUnit \n Residue<C> subtract \n Residue<C> gcd \n int compareTo \n Residue<C>[] egcd \n boolean isConstant \n Residue<C> monic \n Residue<C> abs \n int hashCode \n Residue<C> negate \n boolean equals \n Residue<C> clone \n boolean isZERO \n String toString \n Residue<C> divide \n Residue<C> multiply \n Residue<C> remainder", "output": "Residue < C > function ( Residue < C > arg0 ) { return new Residue < C > ( ring , val . sum ( arg0 . val ) ) ; }"}, {"instruction": "Generate java code\ninvoked when a test fails ", "input": " PlaceHolder placeHolder \n void finishedQuietly \n Statement apply \n void startingQuietly \n void finished \n void succeededQuietly \n void starting \n void failedQuietly \n void skippedQuietly \n void succeeded \n void skipped", "output": "void function ( Throwable arg0 , Description arg1 ) { }"}, {"instruction": "Generate java code\nis the current token a single letter token surrounded by non-whitespace characters ? ", "input": " LinkedList<Integer> fSentenceBreaks \n String fDelimiter \n int WHITE_SPACE_TOKEN \n int fOffset \n int fNext \n int fPredecessor \n int fPrevious \n boolean fStartsSentence \n String fLastToken \n String fContent \n boolean fIsIgnoringSingleLetters \n int fSuccessor \n BreakIterator fWordIterator \n String next \n int getBegin \n boolean hasNext \n boolean isWhitespace \n int nextSentence \n void skipTokens \n int getEnd \n void remove \n boolean isToken \n boolean isToken \n boolean isUrlToken \n void setIgnoreSingleLetters \n String nextToken \n boolean isAlphaNumeric \n void nextBreak \n boolean startsSentence", "output": "boolean function ( final int arg0 ) { if ( ! Character . isLetter ( fContent . charAt ( arg0 ) ) ) return false ; if ( arg0 > 0 && ! Character . isWhitespace ( fContent . charAt ( arg0 - 1 ) ) ) return false ; if ( arg0 < fContent . length ( ) - 1 && ! Character . isWhitespace ( fContent . charAt ( arg0 + 1 ) ) ) return false ; return true ; }"}, {"instruction": "Generate java code\ncreate and return a new predicate that checks if the element is displayed . ", "input": " PlaceHolder placeHolder \n Predicate<WebElement> attrEquals \n Predicate<WebElement> textEndsWith \n Predicate<WebElement> hasClass \n Predicate<WebElement> textMatches \n Function<WebElement,Boolean> clear \n Predicate<WebElement> cssValue \n Function<WebElement,Boolean> sendKeys \n Function<WebElement,Boolean> click \n Predicate<WebElement> attrStartsWith \n Predicate<WebElement> not \n Predicate<WebElement> textStartsWith \n Predicate<WebElement> isEnabled \n Predicate<WebElement> textEquals \n Predicate<WebElement> textContains \n Predicate<WebElement> attrEndsWith", "output": "Predicate < WebElement > function ( ) { return new Predicate < WebElement > ( ) { @ Override public boolean apply ( WebElement arg0 ) { return arg0 . isDisplayed ( ) ; } @ Override public String toString ( ) { return \"srini_string\" ; } } ; }"}, {"instruction": "Generate java code\ncreates junit tests for the faults . output is a set of . java files . the default junit class name is the driver class name + index ", "input": " boolean includeParseableString \n String junitDriverClassName \n String packageName \n Map<String,List<List<ExecutableSequence>>> createdSequencesAndClasses \n int testsPerFile \n String dirName \n File createJunitTestFile \n File writeSubSuite \n File writeDriverFile \n File writeDriverFile \n File writeDriverFile \n File writeDriverFile \n String indent \n void createOutputDir \n List<File> createJunitFiles \n List<File> createJunitFiles \n List<String> getJunitTestSuiteNames \n void outputPackageName \n File getDir \n PrintStream createTextOutputStream", "output": "List < File > function ( List < ExecutableSequence > arg0 ) { return createJunitTestFiles ( arg0 , junitDriverClassName ) ; }"}, {"instruction": "Generate java code\ngets the value of the message property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the message property . for example , to add a new item , do as follows : getmessage . add newitem ; objects of the following type s are allowed in the list message ", "input": " List<LocalizedMessage> localizedMessage \n String name \n List<Message> message \n List<ValidationContext> child \n void setName \n String getName \n List<LocalizedMessage> getLocalizedMessage \n List<ValidationContext> getChild", "output": "List < Message > function ( ) { if ( message == null ) { message = new ArrayList < Message > ( ) ; } return this . message ; }"}, {"instruction": "Generate java code\nperforms actions that follow a disconnect . ", "input": " Node<T> myNode \n PeerStatus peerStatus \n Logger log \n ComponentsConfig config \n boolean lookupEnabled \n void enablePeriodicLookup \n void connectivityChanged \n void beginPeriodicLookups \n void doConnect \n void routingTableBuilt \n void doSingleLookup \n PeerStatus getPeerStatus \n double getSimSec", "output": "void function ( ) { peerStatus = PeerStatus . ABSENT ; myNode . getOperationFactory ( ) . abortAllOperations ( ) ; }"}, {"instruction": "Generate java code\nappend a hashcode for a float array . ", "input": " int iConstant \n int iTotal \n HashCodeBuilder appendSuper \n int toHashCode", "output": "HashCodeBuilder function ( float [ ] arg0 ) { if ( arg0 == null ) { iTotal = iTotal * iConstant ; } else { for ( float loc0 : arg0 ) { append ( loc0 ) ; } } return this ; }"}, {"instruction": "Generate java code\nshould be called only once , for global ", "input": " List<KdcPreauth> preauths \n boolean isToken \n void loadPreauthPlugins \n PreauthContext preparePreauthContext \n void providePaData \n boolean isPkinit \n void initWith \n void verify \n void destroy \n void provideEdata \n PreauthHandle findHandle", "output": "void function ( ) { loadPreauthPlugins ( ) ; }"}, {"instruction": "Generate java code\ngets the rectangular position of a bitmap if it were placed inside a view with scale type set to android.widget.imageview #scaletype #center_inside . ", "input": " PlaceHolder placeHolder \n Rect getBitmapRectCenterInsideHelper", "output": "Rect function ( int arg0 , int arg1 , int arg2 , int arg3 ) { return getBitmapRectCenterInsideHelper ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\ncreates the paletteroot and adds all palette elements . ", "input": " PlaceHolder placeHolder \n PaletteContainer createControlGroup \n List createCategories \n PaletteContainer createComponentsDrawer", "output": "PaletteRoot function ( ) { PaletteRoot loc0 = new PaletteRoot ( ) ; loc0 . addAll ( createCategories ( loc0 ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\nthis loader is used when proxy debugging is enabled . in that case there is no point in fetching the bundle from device as remote executor will have to do it anyway . ", "input": " PlaceHolder placeHolder \n JSBundleLoader createAssetLoader \n void loadScript \n JSBundleLoader createCachedBundleFromNetworkLoader \n String getSourceUrl", "output": "JSBundleLoader function ( final String arg0 ) { return new JSBundleLoader ( ) { @ Override public void loadScript ( ReactBridge arg1 ) { arg1 . loadScriptFromNetworkCached ( arg0 , null ) ; } @ Override public String getSourceUrl ( ) { return arg0 ; } } ; }"}, {"instruction": "Generate java code\nmethod to get the average of the colors of this pixel ", "input": " int x \n int y \n DigitalPicture picture \n int getCol \n int correctValue \n Color getColor \n void setAlpha \n int getRow \n int getBlue \n int getBlue \n void setRed \n void setGreen \n int getAlpha \n void updatePicture \n int getX \n int getY \n int getRed \n int getRed \n int getGreen \n int getGreen \n void setColor \n double colorDistance \n double colorDistance \n void setBlue \n String toString", "output": "double function ( ) { double loc0 = ( getRed ( ) + getGreen ( ) + getBlue ( ) ) / 3.0 ; return loc0 ; }"}, {"instruction": "Generate java code\nmap column names to protocol field names . ", "input": " Cursor cursor \n int[] columns \n String[] fields \n int MAX_SERVER_STRING_CHARS \n void fillHoneycomb \n ClientReadingListRecord getNext \n ClientReadingListRecord fromCursorRow \n void putNull \n void put \n void put \n void fillGingerbread", "output": "String function ( final String arg0 ) { switch ( arg0 ) { case \"srini_string\" : return \"srini_string\" ; case \"srini_string\" : return \"srini_string\" ; case \"srini_string\" : return \"srini_string\" ; } return arg0 ; }"}, {"instruction": "Generate java code\nwhen set to true , the xml parser will attempt to validate the jelly xml before converting it into a script . ", "input": " Log log \n boolean loadedProperties \n String defaultNamespaceURI \n JellyContext context \n boolean validateXML \n URL url \n URL rootContext \n String getJellyVersion \n void setDefaultNamespaceURI \n void setRootContext \n String readBuildTimestampResource \n void main \n URL resolveURL \n void setUrl \n URL getUrl \n JellyContext getJellyContext \n Script compileScript \n void loadJellyProperties \n void loadProperties \n void loadProperties \n URL getRootContext \n String getJellyBuildDate \n void setScript", "output": "void function ( boolean arg0 ) { this . validateXML = arg0 ; }"}, {"instruction": "Generate java code\nthis method tests , if this skynet-id ranges between the two provided bounds . ", "input": " BigDecimal skyNetID \n BigDecimal getUniqueValue \n boolean equals \n BigDecimal getID \n int compareTo \n byte[] getBytes \n String getPlainSkyNetID", "output": "boolean function ( SkyNetID arg0 , SkyNetID arg1 ) { if ( arg0 . compareTo ( arg1 ) < 0 ) { if ( this . compareTo ( arg0 ) > 0 && this . compareTo ( arg1 ) < 0 ) { return true ; } } else { if ( this . compareTo ( arg0 ) > 0 || this . compareTo ( arg1 ) < 0 ) { return true ; } } return false ; }"}, {"instruction": "Generate java code\nsets the preferred difficulty for this user and overwrites any previous preference . ", "input": " String SIZE \n String LIBRARY_LOCATION \n String DIFFICULTY \n void setPreferredSize \n void clearPreferences \n Integer getPreferredSize \n String getPuzzleLibraryLocation \n Difficulty getPreferredDifficulty \n void setPuzzleLibraryLocation", "output": "void function ( Difficulty arg0 ) { Preferences loc0 = Preferences . userNodeForPackage ( this . getClass ( ) ) ; loc0 . putInt ( DIFFICULTY , arg0 . toInt ( ) ) ; }"}, {"instruction": "Generate java code\nit is safe to call this method concurrently from any random thread . ", "input": " Action1<Resource> urlDeletedAction \n PingDestination destination \n Action<?,?> action \n Action1<Resource> urlCreatedAction \n List<UrlChangesCollector.UrlChange> changes \n Object lock \n void apply \n List<UrlChangesCollector.UrlChange> getChanges \n Action1<Resource> getUrlDeletedAction \n Action1<Resource> getUrlCreatedAction", "output": "void function ( Resource arg0 ) { if ( PingDestination . isUrl ( arg0 ) ) { synchronized ( lock ) { PingDestination loc0 = PingDestination . from ( arg0 ) ; changes . add ( new UrlChange ( Action . deleted ( ) , loc0 ) ) ; Log . LOG . debugf ( \"srini_string\" , loc0 . getUrl ( ) ) ; } } }"}, {"instruction": "Generate java code\nthe name of the context where the property is defined ", "input": " boolean isTesting \n String typeName \n Clob propertyValue \n Clob exampleValue \n boolean isEncrypted \n String propContName \n Integer descriptorId \n String typeContName \n Integer typeId \n Clob defaultValue \n String resourceName \n String fcExternalKey \n String technicalKey \n String mik \n Integer propContextId \n String origin \n Integer cardinalityProperty \n Integer propertyValueTypeId \n String displayName \n String fcOwner \n Integer propertyId \n Integer masterTypeId \n boolean isNullable \n String fcExternalLink \n String validationRegex \n String loadedFor \n boolean isOptional \n String validationLogic \n String descriptorOrigin \n Integer typeContextId \n Clob propertyComment \n ResourceEditPropertyBuilder withDisplayAndTechKeyName \n ResourceEditPropertyBuilder withOrigin \n ResourceEditPropertyBuilder withValidationRegex \n ResourceEditPropertyBuilder withIsEncrypted \n ResourceEditPropertyBuilder withDescriptorOrigin \n Clob convert \n ResourceEditPropertyBuilder withTechnicalKey \n ResourceEditPropertyBuilder withMasterResTypeName \n ResourceEditPropertyBuilder withLoadedFor \n ResourceEditPropertyBuilder withDisplayName \n ResourceEditPropertyBuilder withValue \n ResourceEditPropertyBuilder withFcExternalLink \n ResourceEditPropertyBuilder withDefaultValue \n ResourceEditPropertyBuilder withDescriptorId \n ResourceEditPropertyBuilder withTypeId \n ResourceEditPropertyBuilder withDescriptor \n ResourceEditPropertyBuilder withCardinality \n ResourceEditPropertyBuilder withValidationLogic \n ResourceEditPropertyBuilder withPropertyContextTypeId \n ResourceEditPropertyBuilder withPropertyId \n ResourceEditPropertyBuilder withPropContName \n ResourceEditPropertyBuilder withComment \n ResourceEditPropertyBuilder withFcOwner \n ResourceEditPropertyBuilder withMasterResTypeId \n ResourceEditPropertyBuilder withFcExternalKey \n ResourceEditProperty build \n ResourceEditPropertyBuilder withIsTesting \n ResourceEditPropertyBuilder withExampleValue \n ResourceEditPropertyBuilder withResourceName \n ResourceEditPropertyBuilder withPropContextId \n ResourceEditPropertyBuilder withIsNullable", "output": "ResourceEditPropertyBuilder function ( String arg0 ) { this . typeContName = arg0 ; return this ; }"}, {"instruction": "Generate java code\ndefault begin for when you do n't need anything but no authentication and default settings for ssl . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "Sardine function ( ) { return begin ( null , null ) ; }"}, {"instruction": "Generate java code\ndecodes the stream and produces animation frames into the specified movie track . this method can only be called once . ", "input": " int nFrames \n int nColors \n boolean enforce8BitColorModel \n ImageInputStream in \n long[] offsets \n SEQMovieTrack track \n int speed \n int resolution \n void readFrames \n void setEnforce8BitColorModel \n void readFrame \n void readOffsets \n void readHeader", "output": "void function ( SEQMovieTrack arg0 , boolean arg1 ) { this . track = arg0 ; readHeader ( ) ; readOffsets ( ) ; readFrames ( ) ; }"}, {"instruction": "Generate java code\nreturns the value as a byte array . ", "input": " long releaseTimestamp \n Object value \n int getTransmissionSize \n Object getObject \n long getReleaseTimestamp \n String toString", "output": "byte [ ] function ( ) { ByteArrayOutputStream loc0 = new ByteArrayOutputStream ( ) ; ObjectOutputStream loc1 ; try { loc1 = new ObjectOutputStream ( loc0 ) ; loc1 . writeObject ( value ) ; loc1 . close ( ) ; } catch ( IOException loc2 ) { loc2 . printStackTrace ( ) ; } return loc0 . toByteArray ( ) ; }"}, {"instruction": "Generate java code\nlogs all objects in the passed objectcontainer . ", "input": " java.io.PrintStream out \n boolean silent \n String sp \n int maximumDepth \n Class[] IGNORE \n int MAXIMUM_OBJECTS \n int normalizeNArray1 \n Class[] getClassHierarchy \n Class[] getClassHierarchy \n Object normalizeNArray \n void log \n void log \n void log \n void log \n void log \n void log \n void log \n void setMaximumDepth \n void main \n void msgCount \n int[] arrayDimensions \n void setOut \n int arrayElementCount", "output": "void function ( ObjectContainer arg0 ) { ObjectSet loc0 = arg0 . queryByExample ( null ) ; while ( loc0 . hasNext ( ) ) { log ( arg0 , loc0 . next ( ) ) ; } }"}, {"instruction": "Generate java code\nreturn all root components in the current awt hierarchy . ", "input": " Collection EMPTY \n WindowTracker tracker \n Hierarchy defaultHierarchy \n boolean contains \n Container getParent \n Collection getComponents \n Collection findInternalFramesFromIcons \n Hierarchy getDefault \n void dispose \n void setDefault", "output": "Collection function ( ) { return tracker . getRootWindows ( ) ; }"}, {"instruction": "Generate java code\nsetup filters for this finder . filters are checked before search criteria . typical filters are defined in the filter enum . ", "input": " ISearchable scope \n ISWTWidgetMatcher matcher \n ISWTWidgetReference<?>[] doFindAll \n DisplayReference display \n ISWTWidgetMatcher addFilters \n SWTWidgetFinder withScope \n int getFinderRetryInterval \n SWTWidgetFinder forActiveShell \n SWTWidgetFinder forDisplay \n int getMaxFinderRetries \n boolean matches \n ISearchable activeShell \n ISWTWidgetReference<?>[] findAll", "output": "SWTWidgetFinder function ( ISWTWidgetMatcher ... arg0 ) { Invariants . notNull ( arg0 ) ; throw new UnsupportedOperationException ( ) ; }"}, {"instruction": "Generate java code\nfetch records modified since the provided timestamp . the caller is responsible for closing the cursor . ", "input": " Context context \n String[] GUID_COLUMNS \n String LOG_TAG \n RepoUtils.QueryHelper queryHelper \n int purgeGuid \n Cursor fetchAll \n Cursor getGUIDsSince \n void update \n Uri insert \n void updateByGuid \n void delete \n void wipe \n String[] getAllColumns \n String dateModifiedWhere \n Cursor fetch \n int bulkInsert \n ContentValues getContentValues \n void dumpDB \n void purgeDeleted \n Uri getUri", "output": "Cursor function ( long arg0 ) { return queryHelper . safeQuery ( \"srini_string\" , getAllColumns ( ) , dateModifiedWhere ( arg0 ) , null , null ) ; }"}, {"instruction": "Generate java code\na distinct property value count projection ", "input": " PlaceHolder placeHolder \n Projection sqlGroupProjection \n AggregateProjection max \n CountProjection count \n Projection distinct \n AggregateProjection sum \n ProjectionList projectionList \n PropertyProjection groupProperty \n AggregateProjection min \n AggregateProjection avg \n PropertyProjection property \n Projection alias \n Projection sqlProjection \n IdentifierProjection id \n Projection rowCount", "output": "CountProjection function ( String arg0 ) { return new CountProjection ( arg0 ) . setDistinct ( ) ; }"}, {"instruction": "Generate java code\nsets the callback object for the imageloader . once this is set , we may invoke the callback once all images that need to be loaded report in from their onload event handlers . ", "input": " ArrayList<ImageHandle> images \n CallBack callBack \n int totalImages \n int loadedImages \n ArrayList<ImageLoader> imageLoaders \n void addHandle \n void incrementLoadedImages \n void onImagesLoaded \n void loadImages \n void dispatchIfComplete \n boolean isAllLoaded \n ImageHandle loadImage", "output": "void function ( CallBack arg0 ) { this . callBack = arg0 ; }"}, {"instruction": "Generate java code\ncalculates and returns the next element which is either gap or dash . ", "input": " float val \n boolean isGap \n float dashPhase \n int elemOrdinalNumber \n DashArrayElem currentElem \n PdfArray dashArray \n int currentIndex \n boolean isSolid \n boolean isGap \n float getVal \n float getDashPhase \n boolean isEven \n void setGap \n PdfArray getDashArray \n void setDashArray \n void reset \n void setDashPhase \n void setVal \n void initFirst", "output": "DashArrayElem function ( ) { DashArrayElem loc0 = currentElem ; if ( dashArray . size ( ) > 0 ) { currentIndex = ( currentIndex + 1 ) % dashArray . size ( ) ; currentElem = new DashArrayElem ( dashArray . getAsNumber ( currentIndex ) . floatValue ( ) , isEven ( ++ elemOrdinalNumber ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsets the value of the responsedescription property . ", "input": " Prop prop \n Error error \n String status \n String responsedescription \n Error getError \n String getResponsedescription \n void setError \n void setProp \n String getStatus \n Prop getProp \n void setStatus", "output": "void function ( String arg0 ) { this . responsedescription = arg0 ; }"}, {"instruction": "Generate java code\nis algebraicnumber one . ", "input": " GenPolynomial<C> val \n AlgebraicNumberRing<C> ring \n int isunit \n int signum \n AlgebraicNumber<C> inverse \n GenPolynomial<C> getVal \n boolean isUnit \n AlgebraicNumber<C> subtract \n AlgebraicNumber<C> gcd \n AlgebraicNumber<C> sum \n int compareTo \n AlgebraicNumber<C>[] egcd \n AlgebraicNumber<C> monic \n AlgebraicNumber<C> abs \n int hashCode \n AlgebraicNumber<C> negate \n boolean equals \n AlgebraicNumber<C> clone \n boolean isZERO \n String toString \n AlgebraicNumber<C> divide \n AlgebraicNumber<C> multiply \n AlgebraicNumber<C> remainder", "output": "boolean function ( ) { return val . equals ( ring . ring . getONE ( ) ) ; }"}, {"instruction": "Generate java code\nif called with one or more null elements in objects , the test will halt and be ignored . ", "input": " PlaceHolder placeHolder \n void assumeFalse \n void assumeFalse \n void assumeTrue \n void assumeTrue \n void assumeNoException \n void assumeNoException \n void assumeThat \n void assumeThat", "output": "void function ( Object ... arg0 ) { assumeThat ( asList ( arg0 ) , everyItem ( notNullValue ( ) ) ) ; }"}, {"instruction": "Generate java code\nreturns always null . ", "input": " String fStatusMessage \n int fSeverity \n boolean isWarning \n int getSeverity \n IStatus createError \n String getMessage \n IStatus createWarning \n boolean isMultiStatus \n boolean matches \n IStatus[] getChildren \n boolean isError \n void setError \n boolean isOK \n String getPlugin \n void setOK \n void setInfo \n boolean isInfo \n IStatus createInfo \n int getCode \n void setWarning", "output": "Throwable function ( ) { return null ; }"}, {"instruction": "Generate java code\nadds a gnutella event listener to this dispatcher ", "input": " List<IGnutellaEventListener> listeners \n GnutellaEvents inst \n void queryFailed \n void querySucceeded \n void connectionBreak \n void reBootstrapped \n void connectionSucceeded \n GnutellaEvents getGlobal \n void connectionStarted \n void pingTimeouted \n void removeListener \n void connectionFailed \n void queryMadeHop \n void queryStarted", "output": "void function ( IGnutellaEventListener arg0 ) { listeners . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis method returns the derivative for the given function at the current simulation time . ", "input": " HashMap<Class<? extends Function>,Function> functions \n FunctionGenerator instance \n Logger log \n double getValue \n Map<Class<? extends Function>,Double> getValues \n double getValueAt \n Map<Class<? extends Function>,Double> getValuesAt \n void setFunction \n FunctionGenerator getInstance \n Collection<Class<? extends Function>> getLoadedFunctionClasses \n double getDerivativeAt", "output": "double function ( Class < ? extends Function > arg0 ) { return getDerivativeAt ( Simulator . getInstance ( ) . getCurrentTime ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\ntest the singleton in a non-concurrent setting ", "input": " Supplier<S> singletonInstanceMethod \n void testMultipleCallsReturnTheSameObjectInDifferentThreads", "output": "void function ( ) { S loc0 = this . singletonInstanceMethod . get ( ) ; S loc1 = this . singletonInstanceMethod . get ( ) ; S loc2 = this . singletonInstanceMethod . get ( ) ; assertSame ( loc0 , loc1 ) ; assertSame ( loc0 , loc2 ) ; assertSame ( loc1 , loc2 ) ; }"}, {"instruction": "Generate java code\nfactory method to create a typed set . if there are any elements already in the set being decorated , they are validated . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "Set function ( Set arg0 , Class arg1 ) { return new PredicatedSet ( arg0 , InstanceofPredicate . getInstance ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nprints the absolute pathname of the class file containing the specified class name , as prescribed by the class path . ", "input": " String CLASSPATH \n String getClasspath \n void setClasspath \n void printClasspath \n void instanceMain \n void main \n URL findClass \n void printUsage \n String asResourceName \n void validate", "output": "void function ( String arg0 ) { URL loc0 = findClass ( arg0 ) ; if ( loc0 == null ) { System . out . println ( \"srini_string\" + arg0 + \"srini_string\" ) ; } else { System . out . println ( \"srini_string\" + arg0 + \"srini_string\" + loc0 . getFile ( ) + \"srini_string\" ) ; } validate ( ) ; printClasspath ( ) ; }"}, {"instruction": "Generate java code\nchecks if a given string is a valid person phone number . ", "input": " String MESSAGE_PHONE_CONSTRAINTS \n String PHONE_VALIDATION_REGEX \n boolean isPrivate \n String EXAMPLE \n String value \n int hashCode \n boolean equals \n String toString \n boolean isPrivate", "output": "boolean function ( String arg0 ) { return arg0 . matches ( PHONE_VALIDATION_REGEX ) ; }"}, {"instruction": "Generate java code\nreturns an about : neterror uri with the unknownprotocolfound text as a parameter . ", "input": " String MARKET_INTENT_URI_PACKAGE_PREFIX \n String[] NATIVE_EVENTS \n String EXTRA_BROWSER_FALLBACK_URL \n IntentHelper instance \n FragmentActivity activity \n String LOGTAG \n String UNKNOWN_PROTOCOL_URI_PREFIX \n String MALFORMED_URI_PREFIX \n JSONObject message \n String[] EVENTS \n String GENERIC_URI_PREFIX \n IntentHelper init \n void openWebActivity \n void getHandlers \n void handleMessage \n void handleMessage \n void destroy \n void onActivityResult \n void open \n void openNoHandler \n void openForResult", "output": "String function ( final String arg0 ) { return UNKNOWN_PROTOCOL_URI_PREFIX + arg0 ; }"}, {"instruction": "Generate java code\nsets the horizontal indent of a dependent control . assumes that griddata is used . ", "input": " PlaceHolder placeHolder \n void setHorizontalSpan \n void setWidthHint \n int getIndent \n void setHeightHint \n void setHorizontalGrabbing \n void modifyLabelSpans \n void setVerticalGrabbing \n int getNumberOfColumns \n void doDefaultLayout \n void doDefaultLayout", "output": "void function ( Control arg0 ) { Object loc0 = arg0 . getLayoutData ( ) ; if ( loc0 instanceof GridData ) { ( ( GridData ) loc0 ) . horizontalIndent = LayoutUtil . getIndent ( ) ; } }"}, {"instruction": "Generate java code\nthese functions support parsing serialized rdf into an xmp object , and serailizing an xmp object into rdf . the input for parsing may be any valid unicode encoding . iso latin-1 is also recognized , but its use is strongly discouraged . serialization is always as utf-8 . parsefrombuffer parses rdf from an inputstream . the encoding is recognized automatically . ", "input": " XMPSchemaRegistry schema \n XMPVersionInfo versionInfo \n XMPSchemaRegistry getSchemaRegistry \n void serialize \n void serialize \n String serializeToString \n XMPMeta parseFromString \n XMPMeta parseFromString \n XMPVersionInfo getVersionInfo \n byte[] serializeToBuffer \n XMPMeta create \n void reset \n XMPMeta parseFromBuffer \n XMPMeta parseFromBuffer \n void assertImplementation", "output": "XMPMeta function ( InputStream arg0 , ParseOptions arg1 ) { return XMPMetaParser . parse ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nadds a path from the block before a subroutine is called to a block after the subroutine is called . if the callerblock is already associated with a returnblock , the old returnblock is replaced . ", "input": " Block entry \n Block exit \n ArrayList paths \n FlowGraph graph \n LocalVariable returnAddress \n void setReturnAddress \n int numPaths \n void setExit \n FlowGraph graph \n LocalVariable returnAddress \n void removePathsContaining \n void removePath \n Block entry \n Block exit \n void print \n Block pathTarget \n Block pathSource \n Collection paths \n String toString \n void removeAllPaths \n void setEntry", "output": "void function ( final Block arg0 , final Block arg1 ) { for ( int loc0 = 0 ; loc0 < paths . size ( ) ; loc0 ++ ) { final Block [ ] loc1 = ( Block [ ] ) paths . get ( loc0 ) ; if ( loc1 [ 0 ] == arg0 ) { loc1 [ 1 ] = arg1 ; return ; } } paths . add ( new Block [ ] { arg0 , arg1 } ) ; }"}, {"instruction": "Generate java code\nprepares the renderer . this method is non-blocking , and hence it may be necessary to call it more than once in order to transition the renderer into the prepared state . ", "input": " long MATCH_LONGEST_US \n int STATE_UNPREPARED \n long UNKNOWN_TIME_US \n int STATE_PREPARED \n int STATE_ENABLED \n long END_OF_TRACK_US \n int STATE_STARTED \n int state \n int STATE_RELEASED \n boolean doPrepare \n void onReleased \n void release \n boolean isReady \n void handleMessage \n void start \n int getTrackCount \n long getDurationUs \n void seekTo \n MediaClock getMediaClock \n int getState \n void onStarted \n void stop \n void enable \n void disable \n long getBufferedPositionUs \n void onEnabled \n void maybeThrowError \n MediaFormat getFormat \n void doSomeWork \n void onStopped \n void onDisabled \n boolean isEnded", "output": "int function ( long arg0 ) { Assertions . checkState ( state == STATE_UNPREPARED ) ; state = doPrepare ( arg0 ) ? STATE_PREPARED : STATE_UNPREPARED ; return state ; }"}, {"instruction": "Generate java code\ncount the number of columns this projection uses . ", "input": " String[] REUSABLE_ALIASES \n int NUM_REUSABLE_ALIASES \n Projection as \n String[] getAliases \n String getAliasForLocation \n String[] initializeReusableAliases \n String aliasForLocation \n String[] getColumnAliases \n String[] getColumnAliases \n String[] getColumnAliases \n String[] getColumnAliases \n boolean isGrouped \n Type[] getTypes \n String toGroupSqlString", "output": "int function ( Criteria arg0 , CriteriaQuery arg1 ) { final Type [ ] loc0 = getTypes ( arg0 , arg1 ) ; int loc1 = 0 ; for ( Type loc2 : loc0 ) { loc1 += loc2 . getColumnSpan ( arg1 . getFactory ( ) ) ; } return loc1 ; }"}, {"instruction": "Generate java code\ndata from this message . ", "input": " byte[] payload \n boolean truncated \n StdStreamType type \n boolean isTruncated \n StdStreamType getType", "output": "byte [ ] function ( ) { return payload ; }"}, {"instruction": "Generate java code\nsets the value of the quotaavailablebytes property . ", "input": " Owner owner \n PrincipalURL principalURL \n Creationdate creationdate \n Getlastmodified getlastmodified \n Getcontentlanguage getcontentlanguage \n Getetag getetag \n Getcontentlength getcontentlength \n SupportedReportSet supportedReportSet \n Acl acl \n PrincipalCollectionSet principalCollectionSet \n Resourcetype resourcetype \n List<Element> any \n QuotaUsedBytes quotaUsedBytes \n Lockdiscovery lockdiscovery \n QuotaAvailableBytes quotaAvailableBytes \n Getcontenttype getcontenttype \n Displayname displayname \n Supportedlock supportedlock \n Group group \n PrincipalCollectionSet getPrincipalCollectionSet \n Creationdate getCreationdate \n void setCreationdate \n Getcontentlength getGetcontentlength \n Displayname getDisplayname \n void setGetcontenttype \n void setAcl \n Owner getOwner \n Getlastmodified getGetlastmodified \n Supportedlock getSupportedlock \n void setLockdiscovery \n void setOwner \n SupportedReportSet getSupportedReportSet \n void setSupportedReportSet \n void setSupportedlock \n void setPrincipalCollectionSet \n QuotaUsedBytes getQuotaUsedBytes \n Acl getAcl \n void setQuotaUsedBytes \n void setPrincipalURL \n PrincipalURL getPrincipalURL \n void setGetetag \n Resourcetype getResourcetype \n Getcontentlanguage getGetcontentlanguage \n void setResourcetype \n Getetag getGetetag \n void setGroup \n Getcontenttype getGetcontenttype \n Group getGroup \n void setGetcontentlanguage \n Lockdiscovery getLockdiscovery \n void setGetlastmodified \n QuotaAvailableBytes getQuotaAvailableBytes \n void setDisplayname \n void setGetcontentlength \n List<Element> getAny", "output": "void function ( QuotaAvailableBytes arg0 ) { this . quotaAvailableBytes = arg0 ; }"}, {"instruction": "Generate java code\nreturn the context attribute key for the attribute . ", "input": " String fromKey \n void setFromKey \n boolean execute", "output": "String function ( ) { return ( this . fromKey ) ; }"}, {"instruction": "Generate java code\nadds ands schedules a new frequency adjuster for this function ", "input": " Logger log \n double frequency \n List<FrequencyAdjuster> frequencyAdjusters \n double maxMagnitude \n double getMaxMagnitude \n double getFrequency \n void setFrequencyDouble \n String toString \n double execute \n void setFrequency \n void setMaxMagnitude \n List<FrequencyAdjuster> getFrequencyAdjusters \n double getDerivativeAt", "output": "void function ( FrequencyAdjuster arg0 ) { arg0 . setFunction ( this ) ; this . frequencyAdjusters . add ( arg0 ) ; arg0 . schedule ( ) ; log . debug ( \"srini_string\" + arg0 . toString ( ) ) ; }"}, {"instruction": "Generate java code\nreturns the current depth of the stack . ", "input": " TLongArrayList _list \n int DEFAULT_CAPACITY \n long pop \n long[] toNativeArray \n void toNativeArray \n void clear \n void reset \n void push \n long peek", "output": "int function ( ) { return _list . size ( ) ; }"}, {"instruction": "Generate java code\nloads the copy participants for the given element . ", "input": " ParticipantExtensionPoint fgMoveExtensions \n ParticipantExtensionPoint fgDeleteInstance \n String COPY_PARTICIPANT_EXT_POINT \n String RENAME_PARTICIPANT_EXT_POINT \n String DELETE_PARTICIPANT_EXT_POINT \n ParticipantExtensionPoint fgRenameInstance \n String CREATE_PARTICIPANT_EXT_POINT \n String MOVE_PARTICIPANT_EXT_POINT \n ParticipantExtensionPoint fgCreateInstance \n ParticipantExtensionPoint fgCopyInstance \n MoveParticipant[] loadMoveParticipants \n MoveParticipant[] loadMoveParticipants \n DeleteParticipant[] loadDeleteParticipants \n DeleteParticipant[] loadDeleteParticipants \n RenameParticipant[] loadRenameParticipants \n RenameParticipant[] loadRenameParticipants \n CreateParticipant[] loadCreateParticipants \n CreateParticipant[] loadCreateParticipants", "output": "CopyParticipant [ ] function ( RefactoringStatus arg0 , RefactoringProcessor arg1 , Object arg2 , CopyArguments arg3 , String arg4 [ ] , SharableParticipants arg5 ) { return loadCopyParticipants ( arg0 , arg1 , arg2 , arg3 , null , arg4 , arg5 ) ; }"}, {"instruction": "Generate java code\nreturns the global monitor which can be used to delegate information/occured events to a specific analyzer/s . ", "input": " Simulator singleton \n Logger log \n long seed \n Monitor monitor \n DefaultConfigurator defaultConfigurator \n long MINUTE_UNIT \n long SECOND_UNIT \n boolean running \n Scheduler scheduler \n long MICROSECOND_UNIT \n long MILLISECOND_UNIT \n boolean finishedWithoutError \n Scenario scenario \n RandomGenerator randomGen \n long HOUR_UNIT \n void setRealTime \n void shutdownSimulation \n long getSeed \n void setFinishAt \n String getSimulatedRealtime \n void checkRunning \n void start \n void setScenario \n boolean isFinishedWithoutError \n void configure \n void scheduleEvent \n String getFormattedTime \n DefaultConfigurator getConfigurator \n void setStatusInterval \n long getEndTime \n RandomGenerator getRandom \n void setMonitor \n Scenario getScenario \n void reset \n void setTimeSkew \n Simulator getInstance \n long getCurrentTime \n Scheduler getScheduler \n void setSeed", "output": "Monitor function ( ) { if ( monitor == null ) monitor = new DefaultMonitor ( ) ; return monitor ; }"}, {"instruction": "Generate java code\nhandles an incoming text event . ", "input": " TextListener fTextListener \n ChangeType fType \n SelectionListener fSelectionListener \n Set<ITypingRunListener> fListeners \n int fNextOffset \n boolean DEBUG \n TypingRun fRun \n ITextViewer fViewer \n Change fLastChange \n void disconnect \n void fireRunBegun \n void mouseDown \n void startOrContinue \n void fireRunEnded \n void focusLost \n Change computeChange \n void uninstall \n void handleChange \n boolean hasRun \n void ensureSelectionListenerAdded \n boolean canFollow \n void keyReleased \n void connect \n void addTypingRunListener \n void focusGained \n void keyPressed \n void endIfStarted \n void handleSelectionChanged \n void ensureSelectionListenerRemoved \n void mouseDoubleClick \n ChangeType getType \n void install \n boolean isModification \n void mouseUp \n String toString \n void removeTypingRunListener \n void textChanged", "output": "void function ( TextEvent arg0 ) { Change loc0 = computeChange ( arg0 ) ; handleChange ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturn the map entries as instances of map.entry in a collection that is safe from concurrent modification . ie . we may safely add new instances to the underlying map during iteration of the entries . ", "input": " boolean dirty \n Entry<IdentityKey<K>,V>[] entryArray \n Iterator<IdentityKey<K>> identityKeyIterator \n Map<IdentityKey<K>,V> map \n V value \n K key \n int hash \n K next \n K getKey \n IdentityMap<K,V> instantiateSequenced \n Set<Entry<K,V>> entrySet \n boolean containsKey \n Collection<V> values \n boolean isEmpty \n void clear \n boolean hasNext \n boolean containsValue \n V put \n V remove \n void remove \n V getValue \n Iterator<K> keyIterator \n int size \n Map.Entry[] entryArray \n int hashCode \n V get \n void putAll \n V setValue \n boolean equals \n String toString \n String toString \n Set<K> keySet \n K getRealKey", "output": "Map . Entry < K , V > [ ] function ( Map < K , V > arg0 ) { return ( ( IdentityMap < K , V > ) arg0 ) . entryArray ( ) ; }"}, {"instruction": "Generate java code\ncreates a triangle strip between two outlines with identical number of vectors ", "input": " PlaceHolder placeHolder \n List<VectorXYZ> createVerticalTriangleStrip \n List<List<VectorXYZ>> createShapeExtrusionAlong \n List<VectorXYZ> rotateShapeX \n List<VectorXYZ> createLineBetween \n List<VectorXYZ> transformShape \n void filterWorldObjectCollisions", "output": "List < VectorXYZ > function ( List < VectorXYZ > arg0 , List < VectorXYZ > arg1 ) { assert arg0 . size ( ) == arg1 . size ( ) ; VectorXYZ [ ] loc0 = new VectorXYZ [ arg0 . size ( ) * 2 ] ; for ( int loc1 = 0 ; loc1 < arg0 . size ( ) ; loc1 ++ ) { loc0 [ loc1 * 2 ] = arg0 . get ( loc1 ) ; loc0 [ loc1 * 2 + 1 ] = arg1 . get ( loc1 ) ; } return asList ( loc0 ) ; }"}, {"instruction": "Generate java code\nreturns the propertytagentities a comma separated string ", "input": " PropertyTagEditingService propertyTagService \n String getTagsAsList \n List<PropertyTagEntity> getAllGlobalPropertyTags \n void addPropertyTag \n boolean deletePropertyTag \n void addGlobalPropertyTag \n void addLocalPropertyTag", "output": "String function ( List < PropertyTagEntity > arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; if ( arg0 != null ) { for ( PropertyTagEntity loc1 : arg0 ) { if ( loc1 . getName ( ) != null && ! loc1 . getName ( ) . isEmpty ( ) ) { loc0 . append ( loc1 . getName ( ) ) . append ( \"srini_string\" ) ; } } } return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nsets the value of the report property . ", "input": " Report report \n Report getReport", "output": "void function ( Report arg0 ) { this . report = arg0 ; }"}, {"instruction": "Generate java code\nthis has time complexity of o n and space complexity of o n as well because recursion would be used n no . of times , which uses stack internally . ", "input": " Node head \n Node next \n int data \n Node Delete \n void deleteAt \n void setData \n void reverseListPrint \n void reverseListPrint \n void insertAt \n void deleteLast \n boolean isEmpty \n boolean isCycle \n void insert \n void reverseList \n int fetchLast \n Node getNext \n void delete \n int fetchFirst \n Node InsertNth \n Node InsertNth \n void ReversePrint \n void traverse \n void reverseListRecursive \n int fetch \n void deleteFirst \n void setNext \n void insertLast \n int getData", "output": "Node function ( Node arg0 ) { if ( arg0 == null ) { return null ; } Node loc0 = reverseListRescursive ( arg0 . next ) ; if ( loc0 == null ) { head . next = arg0 ; } else { loc0 . next = arg0 ; } return arg0 ; }"}, {"instruction": "Generate java code\nsets the job input value schema . ", "input": " String CONF_INPUT_KEY_SCHEMA \n String CONF_OUTPUT_KEY_SCHEMA \n String CONF_INPUT_VALUE_SCHEMA \n String CONF_OUTPUT_VALUE_SCHEMA \n String CONF_OUTPUT_CODEC \n void setMapOutputKeySchema \n Schema getInputKeySchema \n void setDataModelClass \n void setOutputValueSchema \n Schema getMapOutputKeySchema \n void setOutputKeySchema \n Schema getInputValueSchema \n Schema getMapOutputValueSchema \n void setMapOutputValueSchema \n Schema getOutputKeySchema \n void setInputKeySchema \n Schema getOutputValueSchema", "output": "void function ( Job arg0 , Schema arg1 ) { arg0 . getConfiguration ( ) . set ( CONF_INPUT_VALUE_SCHEMA , arg1 . toString ( ) ) ; }"}, {"instruction": "Generate java code\ntesting ext option password as a exact command to execute . the exact command is a string delimited by ' ' . ", "input": " String KEYSTORE_URL \n VaultSession nonInteractiveSession \n String VAULT_ALIAS \n ModelNode originalVault \n String VAULT_DAT_FILE \n PathAddress VAULT_PATH \n String ATTRIBUTE_NAME \n URL url \n String VAULT_ATTRIBUTE \n String RESOURCE_LOCATION \n String VAULTED_PROPERTY \n Logger LOGGER \n String VAULT_PASSWORD \n int ITER_COUNT \n String SALT \n String VAULT_BLOCK \n ManagementClient managementClient \n VaultHandler vaultHandler \n ExternalPasswordProvider passwordProvider \n void testCustomModuleClassPassword \n String buildCommand \n void testCmdPassword \n void testPicketboxClassPassword \n void testWrongPassword \n String getVaultedPassword \n WebArchive appDeploymentCahce \n void clean \n void tearDown \n void testCustomModuleClassWithArguments \n void removeVault \n void setup \n void createVault", "output": "void function ( ) { createVault ( buildCommand ( \"srini_string\" , \"srini_string\" ) ) ; Assert . assertEquals ( VAULT_ATTRIBUTE , getVaultedPassword ( ) ) ; removeVault ( ) ; }"}, {"instruction": "Generate java code\ngets the person 's name . ", "input": " String college \n String gender \n String name \n ArrayList<Attribute> responses \n ArrayList<Attribute> getResponses \n String getCollege \n boolean equals \n String getGender \n void saveResponse", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nsend the post request to requested url of blocking ", "input": " String resMessage \n String urlstring \n String filename \n String stateHTTP \n String uuid \n Context context \n HttpListener httpListener \n String requestType \n Hashtable<String,String> header \n int resCode \n String requeststring \n int reqID \n void addHeader \n String getResponse \n void run \n void setUuid \n void addHttpLIstener \n int getReqID \n void sendPost \n String getURL \n String getFilename \n int getResCode \n String getUuid \n void setContext \n void send", "output": "void function ( ) { stateHTTP = \"srini_string\" ; send ( ) ; }"}, {"instruction": "Generate java code\nextracts the millis from an object of this converter 's type . this implementation returns the current time . ", "input": " PlaceHolder placeHolder \n boolean isReadableInterval \n PeriodType getPeriodType \n String toString \n Chronology getChronology \n Chronology getChronology \n int[] getPartialValues \n int[] getPartialValues", "output": "long function ( Object arg0 , Chronology arg1 ) { return DateTimeUtils . currentTimeMillis ( ) ; }"}, {"instruction": "Generate java code\nthe amount of memory this machine has mb ", "input": " Map<String,JsonBall> metadata \n Date created \n Type type \n Set<String> ips \n ImmutableSet.Builder<String> ips \n ImmutableMap.Builder<String,JsonBall> metadata \n String name \n String id \n State state \n Function<JsonBall,String> unquoteString \n String dataset \n int memorySizeMb \n Date updated \n int diskSizeGb \n Builder toBuilder \n Builder metadata \n String getName \n String getId \n int compareTo \n Builder type \n Date getUpdated \n Map<String,String> getMetadataAsJsonLiterals \n int hashCode \n Builder builder \n Builder id \n Builder state \n String value \n String value \n Builder memorySizeMb \n Type fromValue \n State fromValue \n Map<String,String> getMetadata \n String apply \n Builder created \n int getDiskSizeGb \n String getDatasetURN \n Date getCreated \n Builder addMetadata \n Builder ips \n Builder addIp \n State getState \n Builder fromMachine \n Machine build \n Type getType \n boolean equals \n Builder name \n String toString \n String toString \n String toString \n Builder dataset \n Builder updated \n Set<String> getIps \n Builder diskSizeGb", "output": "int function ( ) { return memorySizeMb ; }"}, {"instruction": "Generate java code\nreturns suspend controller injected value . ", "input": " int activeInvocationCount \n InjectedValue<DeploymentRepository> deploymentRepositoryInjectedValue \n AtomicIntegerFieldUpdater<EJBSuspendHandlerService> activeTransactionCountUpdater \n boolean gracefulTxnShutdown \n ServerActivityCallback listener \n AtomicReferenceFieldUpdater<EJBSuspendHandlerService,ServerActivityCallback> listenerUpdater \n InjectedValue<SuspendController> suspendControllerInjectedValue \n InjectedValue<LocalTransactionContext> localTransactionContextInjectedValue \n int activeTransactionCount \n AtomicIntegerFieldUpdater<EJBSuspendHandlerService> activeInvocationCountUpdater \n boolean suspended \n ServiceName SERVICE_NAME \n void resume \n void beforeCompletion \n void enableGracefulTxnShutdown \n void invocationComplete \n void doneSuspended \n boolean isSuspended \n void decrementTransactionCount \n void afterCompletion \n void start \n void suspended \n void transactionCreated \n EJBSuspendHandlerService getValue \n void stop \n InjectedValue<LocalTransactionContext> getLocalTransactionContextInjectedValue \n InjectedValue<DeploymentRepository> getDeploymentRepositoryInjectedValue \n boolean acceptInvocation \n void preSuspend", "output": "InjectedValue < SuspendController > function ( ) { return suspendControllerInjectedValue ; }"}, {"instruction": "Generate java code\nverifies that the numbers of paragraphs returned by div #end . ", "input": " List<Element> currentContent \n Div d \n WorkerContextImpl workerContextImpl \n void init \n void verifyIfPdfDiv \n void verifyContent \n void verifyIfStackOwner", "output": "void function ( ) { final List < Element > loc0 = d . end ( workerContextImpl , new Tag ( \"srini_string\" ) , currentContent ) ; Assert . assertEquals ( 1 , loc0 . size ( ) ) ; }"}, {"instruction": "Generate java code\nverify that a given object is non-null . ", "input": " PlaceHolder placeHolder \n void equal \n void equal \n void isTrue \n void isTrue \n void fail \n void fail \n void isNull \n void isNull \n void isFalse \n void isFalse", "output": "void function ( Object arg0 ) { isNotNull ( arg0 , \"srini_string\" + arg0 + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nset wm ", "input": " NamedWorkManager workManager \n Logger log \n NamedWorkManager getWorkManager \n void endpointActivation \n void stop \n int hashCode \n void endpointDeactivation \n boolean equals \n void start \n XAResource[] getXAResources", "output": "void function ( NamedWorkManager arg0 ) { this . workManager = arg0 ; }"}, {"instruction": "Generate java code\ncomparison with any other object . ", "input": " Logger logger \n Ideal<C> ideal \n GenPolynomialRing<C> ring \n int isField \n Local<C> random \n Local<C> random \n Local<C> random \n int hashCode \n boolean isField \n Local<C> getONE \n boolean isCommutative \n Local<C> getZERO \n Local<C> fromInteger \n Local<C> fromInteger \n boolean isAssociative \n String toString \n Local<C> parse \n Local<C> parse \n Local<C> copy \n java.math.BigInteger characteristic", "output": "boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof LocalRing ) ) { return false ; } LocalRing < C > loc0 = null ; try { loc0 = ( LocalRing < C > ) arg0 ; } catch ( ClassCastException loc1 ) { } if ( loc0 == null ) { return false ; } if ( ! ring . equals ( loc0 . ring ) ) { return false ; } return ideal . equals ( loc0 . ideal ) ; }"}, {"instruction": "Generate java code\nnegative of this vector . ", "input": " List<C> val \n Logger logger \n GenVectorModul<C> modul \n int signum \n GenVector<C> leftLinearCombination \n GenVector<C> rightScalarProduct \n GenVector<C> subtract \n GenVector<C> scalarMultiply \n GenVector<C> sum \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n int compareTo \n GenVector<C> leftScalarMultiply \n C scalarProduct \n GenVector<C> scalarProduct \n GenVector<C> abs \n int hashCode \n boolean equals \n GenVector<C> clone \n boolean isZERO \n String toString", "output": "GenVector < C > function ( ) { ArrayList < C > loc0 = new ArrayList < C > ( modul . cols ) ; for ( C loc1 : val ) { C loc2 = loc1 . negate ( ) ; loc0 . add ( loc2 ) ; } return new GenVector < C > ( modul , loc0 ) ; }"}, {"instruction": "Generate java code\nif the child of a structured element is a dictionary , we inspect the child ; we may also draw a tag . ", "input": " PdfReader reader \n PrintWriter out \n String xmlName \n void convertToXml \n void convertToXml \n String fixTagName \n void inspectChildArray \n void inspectChild \n void parseTag", "output": "void function ( PdfDictionary arg0 ) { inspectChildDictionary ( arg0 , false ) ; }"}, {"instruction": "Generate java code\nreturn the wrapped datum . ", "input": " T datum \n int hashCode \n boolean equals \n String toString", "output": "T function ( ) { return datum ; }"}, {"instruction": "Generate java code\nget the matcher identifying the target of this match . ", "input": " Matcher _parentMatcher \n int _index \n int DEFAULT_INDEX \n Matcher _matcher \n Matcher getParentMatcher \n String toString \n boolean matches", "output": "Matcher function ( ) { return _matcher ; }"}, {"instruction": "Generate java code\napply an `` in '' constraint ", "input": " PropertyNameGetter propertyNameGetter \n AuditCriterion hasNotChanged \n AuditCriterion lt \n AuditProjection distinct \n AuditCriterion leProperty \n AggregatedAuditExpression maximize \n AuditProjection min \n AuditCriterion hasChanged \n AuditCriterion gtProperty \n AuditProjection function \n AuditCriterion neProperty \n AuditCriterion ltProperty \n AuditCriterion ge \n AuditCriterion between \n Triple<String,String,Boolean> getData \n AuditCriterion isNotNull \n AggregatedAuditExpression minimize \n AuditCriterion like \n AuditCriterion like \n AuditProjection max \n AuditCriterion geProperty \n AuditProjection count \n AuditCriterion eq \n AuditCriterion gt \n AuditOrder asc \n AuditProjection countDistinct \n AuditCriterion ne \n AuditCriterion isNull \n AuditCriterion eqProperty \n AuditCriterion le \n AuditCriterion ilike \n AuditCriterion ilike \n AuditOrder desc", "output": "AuditCriterion function ( Collection arg0 ) { return new InAuditExpression ( propertyNameGetter , arg0 . toArray ( ) ) ; }"}, {"instruction": "Generate java code\nload all resources for the selected type and exclude resource from excludelist ", "input": " MaiaAmwFederationServicePredecessorHandler maiaAmwFederationServicePredecessorHandler \n ForeignableBoundary foreignableBoundary \n EditResourceView resource \n Map<Integer,ResourceGroup> resourceGroupMap \n Permissions permissions \n ResourceTypeDataProvider resourceTypeDataProvider \n boolean loadList \n long serialVersionUID \n CopyResource copyResource \n List<ResourceGroup> getResourcesForSelectedResourceType \n String copyFromResource \n boolean isCanCopyResource \n void enableLoadList \n void refreshResourceList \n boolean isCanCopyFromPredecessorResource \n boolean copyFromResourceAction \n boolean copyFromPredecessorResourceAction \n String copyFromPredecessorResource", "output": "List < ResourceGroup > function ( Integer arg0 , List < Integer > arg1 ) { return copyResource . loadResourceGroupsForType ( arg0 , resource . getResource ( ) ) ; }"}, {"instruction": "Generate java code\nreturns whether this polygon is self-intersecting ", "input": " List<VectorXZ> vertexLoop \n List<VectorXZ> getVertexCollection \n VectorXZ getCenter \n boolean intersects \n boolean intersects \n boolean intersects \n double getOutlineLength \n SimplePolygonXZ asSimplePolygon \n PolygonXZ reverse \n VectorXZ getVertex \n List<VectorXZ> intersectionPositions \n boolean isEquivalentTo \n List<VectorXZ> getVertexLoop \n LineSegmentXZ getClosestSegment \n int size \n Collection<LineSegmentXZ> intersectionSegments \n TriangleXZ asTriangleXZ \n PolygonXYZ xyz \n void assertLoopProperty \n List<VectorXZ> getVertices \n VectorXZ getVertexAfter \n boolean isSimple \n String toString \n VectorXZ getVertexBefore \n List<LineSegmentXZ> getSegments", "output": "boolean function ( ) { return isSelfIntersecting ( vertexLoop ) ; }"}, {"instruction": "Generate java code\nreturns the name of this method as given by imethod #getelementname ", "input": " String fMethodSignature \n IMethod fMethod \n char MNEMONIC_DELIMITER \n String fMethodName \n int LENGTH \n boolean fIsConstructor \n String getMethodSignature \n IMethod findMethod \n int hashCode \n boolean isConstructor \n boolean equals \n boolean exists \n String getStableSignature \n String toString \n IMethod getMethod", "output": "String function ( ) { return fMethodName ; }"}, {"instruction": "Generate java code\nget all functions which are defined on the given resourcetype ", "input": " Permissions permissionBoundary \n EntityManager entityManager \n ResourceTypeRepository resourceTypeRepository \n FreemarkerSyntaxValidator freemarkerValidator \n ResourceRepository resourceRepository \n FunctionRepository functionRepository \n FunctionService functionService \n void deleteFunction \n AmwFunctionEntity getFunctionByIdAndRevision \n AmwFunctionEntity getFunctionById \n List<AmwFunctionEntity> getAllOverwritableSupertypeFunctions \n List<AmwFunctionEntity> getAllOverwritableSupertypeFunctions \n List<RevisionInformation> getFunctionRevisions \n AmwFunctionEntity overwriteResourceFunction \n AmwFunctionEntity overwriteResourceTypeFunction \n AmwFunctionEntity createNewResourceFunction \n void saveFunction \n AmwFunctionEntity createNewResourceTypeFunction", "output": "List < AmwFunctionEntity > function ( ResourceTypeEntity arg0 ) { Objects . requireNonNull ( arg0 , \"srini_string\" ) ; ResourceTypeEntity loc0 = resourceTypeRepository . loadWithFunctionsAndMiksForId ( arg0 . getId ( ) ) ; return new ArrayList < > ( loc0 . getFunctions ( ) ) ; }"}, {"instruction": "Generate java code\nverify if nullnode #getinstance actually returns the same object instance ", "input": " PlaceHolder placeHolder \n void testFields \n void testWalk", "output": "void function ( ) { final NullNode loc0 = NullNode . getInstance ( ) ; assertNotNull ( loc0 ) ; assertSame ( loc0 , NullNode . getInstance ( ) ) ; }"}, {"instruction": "Generate java code\nstop the player . ", "input": " ArrayList<String> files \n MusicPlayer player \n void listAllFilles \n void listFile \n void removeFile \n int getNumberOfFiles \n void listMatching \n int findFirst \n void startPlaying \n void addFile \n void playSampleOf", "output": "void function ( ) { player . stop ( ) ; }"}, {"instruction": "Generate java code\nattempt to resolve the specified property type through reflection . ", "input": " PropertyAccessor DIRECT_PROPERTY_ACCESSOR \n Method OBJECT_EQUALS \n Class[] SINGLE_OBJECT_PARAM_SIGNATURE \n Object[] NO_PARAMS \n Method OBJECT_HASHCODE \n Class[] NO_PARAM_SIGNATURE \n PropertyAccessor BASIC_PROPERTY_ACCESSOR \n boolean overridesHashCode \n Getter getGetter \n Getter getter \n Object getConstantValue \n boolean isFinalClass \n boolean overridesEquals \n Method getMethod \n Class classForName \n Class classForName \n Constructor getConstructor \n boolean implementsInterface \n Constructor<T> getDefaultConstructor \n Method extractHashCodeMethod \n Method extractEqualsMethod \n boolean isPublic \n boolean isPublic \n boolean isAbstractClass", "output": "Class function ( String arg0 , String arg1 ) { try { Class loc0 = ReflectHelper . classForName ( arg0 ) ; return getter ( loc0 , arg1 ) . getReturnType ( ) ; } catch ( ClassNotFoundException loc0 ) { throw new MappingException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 , loc0 ) ; } }"}, {"instruction": "Generate java code\nreturn links the sentence contains . ", "input": " long serialVersionUID \n List<String> links \n List<TokenElement> tokens \n List<LineOffset> offsetMap \n int lineNumber \n String content \n int startPositionOffset \n boolean isFirstSentence \n int getOffsetMapSize \n void setContent \n void setOffsetMap \n String getContent \n List<TokenElement> getTokens \n Optional<LineOffset> getOffset \n boolean isFirstSentence \n void setTokens \n int getLineNumber \n int getOffsetPosition \n int hashCode \n boolean equals \n int getStartPositionOffset \n void setIsFirstSentence \n void setLineNumber \n String toString \n List<LineOffset> getOffsetMap \n void addLink", "output": "List < String > function ( ) { return links ; }"}, {"instruction": "Generate java code\nsole entry point to application , as always . ", "input": " PlaceHolder placeHolder \n void printCapitalized", "output": "void function ( String [ ] arg0 ) { String loc0 ; TextIO . putln ( \"srini_string\" ) ; loc0 = TextIO . getln ( ) ; TextIO . putln ( ) ; TextIO . putln ( \"srini_string\" ) ; printCapitalized ( loc0 ) ; }"}, {"instruction": "Generate java code\ncollects an event and puts it into the event queue for later processing . ", "input": " Thread eventProcessor \n Vector queue \n boolean isCoalesce \n boolean isAlive \n int priority \n void startProcessor \n void stop \n boolean isCoalesce \n void processEvents \n void start \n void clear \n void processEvent \n void setCoalesce \n void join", "output": "void function ( Object arg0 ) { synchronized ( queue ) { if ( ! isCoalesce || ! queue . contains ( arg0 ) ) { queue . addElement ( arg0 ) ; if ( isAlive ) startProcessor ( ) ; } } }"}, {"instruction": "Generate java code\ngenerates enumerateiterator.tuple items with indexes starting at 0 . ", "input": " Object NO_ELEMENT \n Object SKIP \n Iterator4 EMPTY_ITERATOR \n Iterable4 EMPTY_ITERABLE \n Object next \n Iterable4 crossProduct \n Iterable4 crossProduct \n Iterable4 crossProduct \n Iterable4 iterable \n Iterable4 iterable \n Iterator4<Integer> range \n Iterator4 flatten \n Object current \n Iterator4 iterator \n Iterator4 iterator \n Iterator4 iterator \n Object[] toArray \n Object[] toArray \n String join \n String join \n String join \n Iterator4 copy \n Iterator4 map \n Iterator4 map \n Iterable4 map \n Iterator4 iterate \n Iterator4 singletonIterator \n boolean moveNext \n Iterable4 singletonIterable \n java.util.Iterator<T> platformIterator \n Iterator4 concat \n Iterator4 concat \n Iterable4 concat \n Iterable4 concat \n Iterator4 concat \n Iterable4 concatMap \n boolean any \n Iterator4<T> filter \n Iterable4 filter \n Iterator4 filter \n Iterator4<T> take \n int size \n int size \n Iterable4<T> series \n void reset \n String toString \n String toString \n Iterable4 append", "output": "Iterable4 function ( final Iterable4 arg0 ) { return new Iterable4 ( ) { public Iterator4 iterator ( ) { return new EnumerateIterator ( arg0 . iterator ( ) ) ; } } ; }"}, {"instruction": "Generate java code\nprints a table with x - and y-values for a method ", "input": " PlaceHolder placeHolder \n double square \n void main", "output": "void function ( double arg0 , double arg1 , int arg2 , Method arg3 ) { System . out . println ( arg3 ) ; double loc0 = ( arg1 - arg0 ) / ( arg2 - 1 ) ; for ( double loc1 = arg0 ; loc1 <= arg1 ; loc1 += loc0 ) { try { double loc2 = ( Double ) arg3 . invoke ( null , loc1 ) ; System . out . printf ( \"srini_string\" , loc1 , loc2 ) ; } catch ( Exception loc2 ) { loc2 . printStackTrace ( ) ; } } }"}, {"instruction": "Generate java code\nreturn this file 's metadata . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n ColumnMetaData[] getColumnMetaData \n ColumnMetaData getColumnMetaData \n ColumnMetaData getColumnMetaData \n long getRowCount \n List<ColumnMetaData> getRoots \n void readColumnMetaData \n ColumnValues<T> getValues \n ColumnValues<T> getValues \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n void readHeader \n void readMagic \n void close", "output": "ColumnFileMetaData function ( ) { return metaData ; }"}, {"instruction": "Generate java code\ninterrupts the processlistener thread and terminates the cluster . ", "input": " ProcessListener processListener \n FXMLController guiController \n String user \n File fileBiBiGridJar \n File fileSingularityScript \n ProcessBuilder processBuilder \n File fileInput \n String masterIp \n ObservableList<String> flavorChoices \n PropertiesController propertiesController \n String clusterId \n String getClusterId \n File getInputFile \n void setMasterIp \n void StopCluster \n PropertiesController getPropertiesController \n String getMasterIp \n void StartCluster \n void setClusterId \n void setInputFile \n void UnlockSettings \n void UnlockStopButton \n ObservableList<String> getFlavorChoices", "output": "void function ( ) { processListener . interrupt ( ) ; try { StopCluster ( true ) ; } catch ( IOException loc0 ) { System . out . println ( \"srini_string\" ) ; System . out . println ( loc0 . toString ( ) ) ; } }"}, {"instruction": "Generate java code\ncreate a fingerprint per the following spec ", "input": " PlaceHolder placeHolder \n byte[] keyBlob \n DSAPublicKeySpec publicKeySpecFromOpenSSH \n DSAPublicKeySpec publicKeySpecFromOpenSSH \n String encodeAsOpenSSH \n String fingerprintPublicKey \n byte[] readLengthFirst \n String hexColonDelimited \n void writeLengthFirst", "output": "String function ( BigInteger arg0 , BigInteger arg1 , BigInteger arg2 , BigInteger arg3 ) { byte [ ] loc0 = loc0 ( arg0 , arg1 , arg2 , arg3 ) ; return hexColonDelimited ( Hashing . md5 ( ) . hashBytes ( loc0 ) ) ; }"}, {"instruction": "Generate java code\nget a string that is a comma delimited list of subsystems ", "input": " String MOUNT_STATUS_FILE \n Logger LOG \n String CGROUP_STATUS_FILE \n void writeFileByLine \n void writeFileByLine \n Set<SubSystemType> getSubSystemsFromString \n void deleteDir \n boolean enabled \n List<String> readFileByLine \n String getDir", "output": "String function ( Set < SubSystemType > arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; if ( arg0 . size ( ) == 0 ) { return loc0 . toString ( ) ; } for ( SubSystemType loc1 : arg0 ) { loc0 . append ( loc1 . name ( ) ) . append ( \"srini_string\" ) ; } return loc0 . toString ( ) . substring ( 0 , loc0 . length ( ) - 1 ) ; }"}, {"instruction": "Generate java code\ndetermine if the ui thread is idle ", "input": " SWTIdler idler \n String toString \n void waitForIdle", "output": "boolean function ( ) { return idler . isIdle ( ) ; }"}, {"instruction": "Generate java code\ngetter to find out if adding annotations is allowed after signing . ", "input": " boolean certification \n boolean fillInAllowed \n boolean annotationsAllowed \n PdfName action \n PdfArray fields \n List<FieldLock> fieldLocks \n List<FieldLock> getFieldLocks \n PdfArray getFields \n boolean isCertification \n boolean isFillInAllowed \n PdfName getAction \n String toString", "output": "boolean function ( ) { return annotationsAllowed ; }"}, {"instruction": "Generate java code\ndispatch the event to the gesture detectors and the pan/zoom controller . ", "input": " JavaPanZoomController mPanZoomController \n int EVENT_LISTENER_TIMEOUT \n GestureDetector mGestureDetector \n boolean mAllowDefaultAction \n String LOGTAG \n ListenerTimeoutProcessor mListenerTimeoutProcessor \n int mProcessingBalance \n View mView \n boolean mWaitForTouchListeners \n boolean mHoldInQueue \n SimpleScaleGestureDetector mScaleGestureDetector \n Queue<MotionEvent> mEventQueue \n boolean touchFinished \n boolean handleEvent \n boolean isDownEvent \n void onTabChanged \n void setWaitForTouchListeners \n void processEventBlock \n void destroy \n void run \n void handleEventListenerAction", "output": "void function ( MotionEvent arg0 , boolean arg1 ) { if ( arg1 ) { if ( mGestureDetector . onTouchEvent ( arg0 ) ) { return ; } mScaleGestureDetector . onTouchEvent ( arg0 ) ; if ( mScaleGestureDetector . isInProgress ( ) ) { return ; } } mPanZoomController . handleEvent ( arg0 , ! arg1 ) ; }"}, {"instruction": "Generate java code\ndispatch a keydown event . ", "input": " Point pointT \n abbot.swt.Robot _robot \n void robotKeyClick \n void doKeyDown \n void doKeyUp \n void mouseMove \n void mouseMove \n void keyUp \n void keyUp \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n int[] extractKeys \n void mouseUp \n void keyClick \n void keyClick \n Event createClickEvent \n void enterText", "output": "void function ( final char arg0 ) { Event loc0 = new Event ( ) ; loc0 . type = SWT . KeyDown ; loc0 . character = arg0 ; new SWTPushEventOperation ( loc0 ) . execute ( ) ; }"}, {"instruction": "Generate java code\nreturns the last block in the subroutine . ", "input": " Block entry \n Block exit \n ArrayList paths \n FlowGraph graph \n LocalVariable returnAddress \n void setReturnAddress \n int numPaths \n void setExit \n FlowGraph graph \n void addPath \n LocalVariable returnAddress \n void removePathsContaining \n void removePath \n Block entry \n void print \n Block pathTarget \n Block pathSource \n Collection paths \n String toString \n void removeAllPaths \n void setEntry", "output": "Block function ( ) { return exit ; }"}, {"instruction": "Generate java code\nrun all the tests contained in request . this variant should be used if core has attached listeners that thisrun should notify . ", "input": " String MALFORMED_JUNIT_3_TEST_CLASS_PREFIX \n MaxHistory fHistory \n Runner buildRunner \n MaxCore storedLocally \n List<Description> findLeaves \n void findLeaves \n MaxCore forFolder \n Class<?> getMalformedTestClass \n Request sortRequest \n Request constructLeafRequest \n List<Description> sortedLeavesForTest", "output": "Result function ( Request arg0 , JUnitCore arg1 ) { arg1 . addListener ( fHistory . listener ( ) ) ; return arg1 . run ( sortRequest ( arg0 ) . getRunner ( ) ) ; }"}, {"instruction": "Generate java code\nconvert character to integer ", "input": " Cell[][] cells \n int width \n long serialVersionUID \n int height \n Iterator<Cell> iterator \n boolean equals \n Cell getCellAtLocation \n char itoc", "output": "int function ( char arg0 ) { return arg0 - 'A' ; }"}, {"instruction": "Generate java code\nnotifie les observers ", "input": " ArrayList<MyObserver> _observer \n Figure _message \n void setMessageFigure \n void addObserver \n void notifyObservers", "output": "void function ( Figure arg0 ) { setMessageFigure ( arg0 ) ; notifyObservers ( ) ; }"}, {"instruction": "Generate java code\nverifies if the largest of the margin-bottom 's of the ul and it 's last li is selected and added to the padding-bottom of li , because padding-bottom of ul == null . ", "input": " Tag p \n ListItem single \n Tag last \n ListItem start \n OrderedUnorderedList orderedUnorderedList \n Tag root \n Tag ul \n List<Element> listWithTwo \n ListItem end \n List<Element> listWithOne \n Tag first \n WorkerContextImpl workerContextImpl \n void listWithOneNoListPaddingTop2 \n void listWithTwoNoListPaddingTop2 \n void listWithTwoNoListPaddingTop \n void before \n void listWithOneNoListPaddingBottom2 \n void listWithOneWithListPaddingBottom \n void listWithTwoNoListMarginAndPadding \n void listWithTwoWithListPaddingBottom \n void listWithOneNoListPaddingBottom \n void listWithOneNoListPaddingTop \n void listWithTwoNoListPaddingBottom2 \n void listWithTwoWithListPaddingTop \n void listWithOneNoListMarginAndPadding \n void listWithOneWithListPaddingTop \n void verifyIfStackOwner", "output": "void function ( ) { ul . getCSS ( ) . put ( \"srini_string\" , \"srini_string\" ) ; com . itextpdf . text . List loc0 = ( com . itextpdf . text . List ) orderedUnorderedList . end ( workerContextImpl , ul , listWithTwo ) . get ( 0 ) ; assertEquals ( 100f + 25f , ( ( ListItem ) loc0 . getItems ( ) . get ( 1 ) ) . getSpacingAfter ( ) , 0f ) ; }"}, {"instruction": "Generate java code\nthe user owning this subscription . ", "input": " String password \n String host \n MemoryUser user \n String username \n String type \n boolean autoConnect \n void setPassword \n String getPassword \n void setUsername \n boolean getAutoConnect \n String getType \n String toString \n void setAutoConnect \n void setType \n String getHost \n String getUsername", "output": "User function ( ) { return ( this . user ) ; }"}, {"instruction": "Generate java code\nvisible for testing . ", "input": " ExecutorService executor \n void schedule \n void close", "output": "void function ( final long arg0 , final TimeUnit arg1 ) { executor . awaitTermination ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nget this nodes transinfo ", "input": " String attributeName \n Comparable[] range \n TransInfo transInfo \n int getTransmissionSize \n String getAttribute \n void setRange \n Comparable[] getRange \n boolean equals \n String toString", "output": "TransInfo function ( ) { return transInfo ; }"}, {"instruction": "Generate java code\nmethod to get the green value from a pixel represented as an int ", "input": " int x \n int y \n DigitalPicture picture \n int getCol \n int correctValue \n Color getColor \n void setAlpha \n int getRow \n int getBlue \n int getBlue \n void setRed \n void setGreen \n double getAverage \n int getAlpha \n void updatePicture \n int getX \n int getY \n int getRed \n int getRed \n void setColor \n double colorDistance \n double colorDistance \n void setBlue \n String toString", "output": "int function ( int arg0 ) { int loc0 = ( arg0 >> 8 ) & 0xff ; return loc0 ; }"}, {"instruction": "Generate java code\nwrite accessor for sasl token ", "input": " Logger LOG \n short IDENTIFIER \n byte[] token \n SaslMessageToken read \n byte[] getSaslToken \n int encodeLength \n ChannelBuffer buffer", "output": "void function ( byte [ ] arg0 ) { this . token = arg0 ; }"}, {"instruction": "Generate java code\nget invalid characters . ", "input": " boolean needAfterSpace \n SymbolType name \n long serialVersionUID \n char[] invalidChars \n boolean needBeforeSpace \n char value \n char getValue \n boolean isNeedAfterSpace \n SymbolType getType \n int hashCode \n boolean isNeedBeforeSpace \n boolean equals \n String toString", "output": "char [ ] function ( ) { return invalidChars ; }"}, {"instruction": "Generate java code\nget a fixed-length random string , its a mixture of uppercase and lowercase letters ", "input": " String NUMBERS_AND_LETTERS \n String LETTERS \n String CAPITAL_LETTERS \n String LOWER_CASE_LETTERS \n String NUMBERS \n String getRandom \n String getRandom \n int getRandom \n int getRandom \n String getRandomNumbers \n String getRandomCapitalLetters \n String getRandomLowerCaseLetters \n boolean shuffle \n boolean shuffle \n int[] shuffle \n int[] shuffle \n String getRandomNumbersAndLetters", "output": "String function ( int arg0 ) { return getRandom ( LETTERS , arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the geometric mean of the available values ", "input": " int INFINITE_WINDOW \n long serialVersionUID \n double getKurtosis \n double getStandardDeviation \n double getSkewness \n int getWindowSize \n double[] getValues \n double[] getSortedValues \n double apply \n double getMax \n long getN \n void clear \n DescriptiveStatistics newInstance \n DescriptiveStatistics newInstance \n double getMin \n double getElement \n double getVariance \n double getMean \n double getSumsq \n String toString \n void setWindowSize \n double getSum \n double getPercentile \n void addValue", "output": "double function ( ) { return apply ( new GeometricMean ( ) ) ; }"}, {"instruction": "Generate java code\nreturn the value of a metadata property . ", "input": " Schema schema \n List<String> metaKeyList \n long blockCount \n boolean availableBlock \n byte[] data \n DatumReader<D> reader \n long blockRemaining \n Map<String,byte[]> meta \n int blockSize \n ByteBuffer blockBuffer \n byte[] syncBuffer \n byte[] sync \n Codec codec \n boolean flushOnWrite \n BinaryDecoder datumIn \n int offset \n Header header \n BinaryDecoder vin \n DataBlock block \n long numEntries \n D next \n D next \n boolean isFlushOnWrite \n void remove \n Header getHeader \n Codec resolveCodec \n Iterator<D> iterator \n void compressUsing \n boolean hasNextBlock \n ByteBuffer getAsByteBuffer \n long getBlockSize \n int getBlockSize \n void setFlushOnWrite \n DataBlock nextRawBlock \n long getBlockCount \n void writeBlockTo \n void close \n byte[] getData \n void decompressUsing \n void blockFinished \n String getMetaString \n long getMetaLong \n boolean hasNext \n ByteBuffer nextBlock \n Schema getSchema \n long getNumEntries \n List<String> getMetaKeys \n void initialize \n void initialize", "output": "byte [ ] function ( String arg0 ) { return header . meta . get ( arg0 ) ; }"}, {"instruction": "Generate java code\ncreate a listiterator listiterator wrappingthe specified charlistiterator charlistiterator . when the given iterator is null , returns null . ", "input": " CharListIterator _iterator \n Object next \n void add \n void set \n Object previous \n boolean hasPrevious \n boolean hasNext \n int nextIndex \n int previousIndex \n void remove", "output": "ListIterator function ( CharListIterator arg0 ) { return null == arg0 ? null : new CharListIteratorListIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\ninitialize game . place 2 instances of 2 anywhere on the board . ", "input": " boolean[][] newCell \n int[][] grid \n boolean[][] hasCombined \n boolean canMoveLeft \n int getCell \n boolean canMoveDown \n void generateNextCell \n void moveDown \n void resetGrid \n void resetMoved \n int getSize \n boolean canMoveUp \n boolean canMoveRight \n void moveRight \n boolean isGridFull \n void moveLeft \n boolean IsCellNew \n void moveUp", "output": "void function ( int arg0 ) { resetGrid ( arg0 ) ; resetMoved ( arg0 ) ; generateNextCell ( ) ; generateNextCell ( ) ; }"}, {"instruction": "Generate java code\ndecrypt with the encryption key and key usage . ", "input": " PlaceHolder placeHolder \n EncryptionKey string2Key \n EncryptionKey string2Key \n EncryptionKey random2Key \n EncryptionKey random2Key \n EncryptedData encrypt \n boolean isImplemented \n EncryptionKey makeSubkey \n EncTypeHandler getEncHandler \n EncTypeHandler getEncHandler \n EncTypeHandler getEncHandler \n EncTypeHandler getEncHandler \n EncryptionType getEncryptionType", "output": "byte [ ] function ( EncryptedData arg0 , EncryptionKey arg1 , KeyUsage arg2 ) { EncTypeHandler loc0 = getEncHandler ( arg1 . getKeyType ( ) ) ; byte [ ] loc1 = loc0 . decrypt ( arg0 . getCipher ( ) , arg1 . getKeyData ( ) , arg2 . getValue ( ) ) ; return loc1 ; }"}, {"instruction": "Generate java code\nleer una pagina del libro , se actualiza marcador , no se pueeder leer mas del numero de paginas del libro ", "input": " String dimensiones \n int numeroPaginas \n String titulo \n String colorPortada \n String autor \n int marcador \n void setColorPortada \n void setDimensiones \n String getColorPortada \n String getAutor \n void setTitulo \n int cerrar \n String getTitulo \n void setNumeroPaginas \n int getNumeroPaginas \n String getDimensiones \n void setMarcador \n int escribir \n void setAutor \n Libro clone \n String toString \n int getMarcador \n int abrir", "output": "int function ( ) { int loc0 = this . getMarcador ( ) ; if ( loc0 < this . getNumeroPaginas ( ) ) { loc0 ++ ; this . setMarcador ( loc0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nif the line is a section header , return the section level , or zero if the line is not a section header ", "input": " String inlineMarkupDelimiters \n int sectionLevel \n boolean erased \n boolean inBlock \n boolean listStart \n List<Boolean> valid \n char ESCAPED_CHARACTER_VALUE \n List<Integer> offsets \n List<Character> characters \n String text \n List<Boolean> escaped \n int listLevel \n int lineNo \n boolean allSameCharacter \n void setListStart \n void erase \n void erase \n void erase \n boolean isListStart \n String getText \n boolean isValid \n int getOffset \n int length \n boolean isEmpty \n void eraseWithStyle \n boolean isAllSameCharacter \n void setSectionLevel \n void setInBlock \n boolean isErased \n int eraseEnclosure \n int getListLevel \n int getLineNo \n boolean isInBlock \n String toString \n char rawCharAt \n void setListLevel \n char charAt \n char charAt \n boolean startsWith", "output": "int function ( ) { return sectionLevel ; }"}, {"instruction": "Generate java code\ndoes this lockoptions object define alias-specific lock modes ? ", "input": " Map<String,LockMode> aliasSpecificLockModes \n int NO_WAIT \n LockOptions NONE \n boolean scope \n int SKIP_LOCKED \n LockOptions READ \n LockOptions UPGRADE \n LockMode lockMode \n int timeout \n int WAIT_FOREVER \n LockMode getLockMode \n LockOptions makeCopy \n LockMode getEffectiveLockMode \n int getAliasLockCount \n LockOptions setLockMode \n Iterator getAliasLockIterator \n LockOptions setAliasSpecificLockMode \n LockMode getAliasSpecificLockMode \n LockOptions setTimeOut \n LockMode findGreatestLockMode \n int getTimeOut \n LockOptions copy \n LockOptions setScope \n boolean getScope", "output": "boolean function ( ) { return aliasSpecificLockModes != null && ! aliasSpecificLockModes . isEmpty ( ) ; }"}, {"instruction": "Generate java code\nthere is a global event dispatcher . this method returns it . ", "input": " List<IGnutellaEventListener> listeners \n GnutellaEvents inst \n void queryFailed \n void querySucceeded \n void connectionBreak \n void reBootstrapped \n void connectionSucceeded \n void connectionStarted \n void pingTimeouted \n void removeListener \n void connectionFailed \n void queryMadeHop \n void queryStarted \n void addListener", "output": "GnutellaEvents function ( ) { if ( inst == null ) inst = new GnutellaEvents ( ) ; return inst ; }"}, {"instruction": "Generate java code\nget screen width ", "input": " PlaceHolder placeHolder \n float dip2Dimension \n Bitmap snapShotWithoutStatusBar \n int getStatusHeight \n Bitmap snapShotWithStatusBar \n float toDimension \n int getScreenHeight", "output": "int function ( Context arg0 ) { WindowManager loc0 = ( WindowManager ) arg0 . getSystemService ( Context . WINDOW_SERVICE ) ; DisplayMetrics loc1 = new DisplayMetrics ( ) ; loc0 . getDefaultDisplay ( ) . getMetrics ( loc1 ) ; return loc1 . widthPixels ; }"}, {"instruction": "Generate java code\ngettotal : updated from project 1 @ 5 dec 2010 returns total on top of operands stack . throws exception that indicates that the input formula was not correct . ", "input": " Stack<Double> operands \n Stack<OperationsInterface> operators \n void addOperator \n int size \n void debugPrintStacks \n void clear \n void addGrouping \n void calculate \n void addOperand", "output": "double function ( ) { if ( operands . size ( ) == 1 && operators . isEmpty ( ) ) return operands . pop ( ) ; if ( operators . size ( ) == 1 ) { if ( operands . size ( ) == 2 ) { return ( ( Operator ) operators . pop ( ) ) . compute ( operands . pop ( ) , operands . pop ( ) ) ; } } throw new ExpressionException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncalled once after the initial sorting finished . note : as of 3.8 a completion proposal computer can request that proposals are resorted . if such a computer is active , then this method will not be called . clients may override , the default implementation does nothing . ", "input": " PlaceHolder placeHolder \n int compare \n void beginSorting", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ngets the container location ", "input": " Location mockLocation \n JdbcContainerNameValidator jdbcContainerNameValidator \n JdbcBlobKeyValidator jdbcBlobKeyValidator \n Provider<BlobBuilder> blobBuilders \n JdbcService jdbcService \n BlobEntityToBlob blobEntityToBlob \n void setContainerAccess \n ContainerAccess getContainerAccess \n void clearContainer \n void clearContainer \n Collection<String> getAllContainerNames \n boolean directoryExists \n String putDirectoryBlob \n Blob getBlob \n Iterable<String> getBlobKeysInsideContainer \n String putBlob \n void setBlobAccess \n boolean createContainerInLocation \n void removeBlob \n boolean blobExists \n void deleteContainer \n StorageMetadata getContainerMetadata \n long countBlobs \n BlobAccess getBlobAccess \n String getSeparator \n boolean containerExists \n void createDirectory \n void deleteDirectory", "output": "Location function ( String arg0 ) { return mockLocation ; }"}, {"instruction": "Generate java code\ngets the field type that represents the upper limit of comparison . ", "input": " DateTimeFieldType iUpperLimit \n DateTimeFieldType iLowerLimit \n DateTimeComparator ALL_INSTANCE \n long serialVersionUID \n DateTimeComparator TIME_INSTANCE \n DateTimeComparator DATE_INSTANCE \n DateTimeFieldType getLowerLimit \n int compare \n Object readResolve \n DateTimeComparator getDateOnlyInstance \n int hashCode \n boolean equals \n String toString \n DateTimeComparator getInstance \n DateTimeComparator getInstance \n DateTimeComparator getInstance \n DateTimeComparator getTimeOnlyInstance", "output": "DateTimeFieldType function ( ) { return iUpperLimit ; }"}, {"instruction": "Generate java code\ngroebner base test . ", "input": " Reduction<C> red \n boolean debug \n Logger logger \n List<GenPolynomial<C>> minimalGB \n List<GenPolynomial<C>> GB \n ExtendedGB<C> extGB \n ExtendedGB<C> extGB \n boolean isReductionMatrix \n boolean isReductionMatrix", "output": "boolean function ( List < GenPolynomial < C >> arg0 ) { return isGB ( 0 , arg0 ) ; }"}, {"instruction": "Generate java code\ncopies all bytes in the given source stream to the given destination stream . neither streams are closed . ", "input": " byte[] fgBuffer \n String changeSeparator \n StringBuffer read \n StringBuffer read \n File getFileInPlugin \n void copy \n void unzip \n void write", "output": "void function ( InputStream arg0 , OutputStream arg1 ) { int loc0 = 0 ; while ( loc0 != - 1 ) { loc0 = arg0 . read ( fgBuffer , 0 , fgBuffer . length ) ; if ( loc0 != - 1 ) { arg1 . write ( fgBuffer , 0 , loc0 ) ; } } }"}, {"instruction": "Generate java code\nperforms a search and groups the resulting searchmatch es by searchresultgroup #getcompilationunit . ", "input": " PlaceHolder placeHolder \n ICompilationUnit[] findAffectedCompilationUnits \n ICompilationUnit[] findAffectedCompilationUnits \n boolean containsStatusEntry \n SearchResultGroup[] internalSearch \n void addStatusErrors \n SearchResultGroup[] groupByCu \n SearchResultGroup[] groupByCu \n SearchPattern createOrPattern", "output": "SearchResultGroup [ ] function ( SearchPattern arg0 , IJavaSearchScope arg1 , IProgressMonitor arg2 , RefactoringStatus arg3 ) { return internalSearch ( new SearchEngine ( ) , arg0 , arg1 , new CollectingSearchRequestor ( ) , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nwrites string to buffer as c-style string null-terminated ", "input": " int BUFFER_DEFAULT_LENGTH \n int actualSize \n byte[] buffer \n int position \n void writeInt \n void writeLong \n int getPosition \n byte[] getResult \n int getActualSize \n void ensureLength \n void write \n void write \n void write \n void setPosition \n void writeIntAt \n void writeDouble", "output": "int function ( String arg0 ) { int loc0 = getPosition ( ) ; try { this . write ( arg0 . getBytes ( \"srini_string\" ) ) ; } catch ( UnsupportedEncodingException loc1 ) { throw new BSONException ( \"srini_string\" , loc1 ) ; } this . write ( ( byte ) 0x00 ) ; return getPosition ( ) - loc0 ; }"}, {"instruction": "Generate java code\ngets the value of the caller property . ", "input": " String caller \n String user \n String uuid \n String getUser \n String getUuid \n void setCaller \n void setUser \n void setUuid", "output": "String function ( ) { return caller ; }"}, {"instruction": "Generate java code\ncreate a client transceiver connecting to the provided uri . ", "input": " PlaceHolder placeHolder \n Server createServer", "output": "Transceiver function ( URI arg0 ) { if ( \"srini_string\" . equals ( arg0 . getScheme ( ) ) ) return new HttpTransceiver ( arg0 . toURL ( ) ) ; else if ( \"srini_string\" . equals ( arg0 . getScheme ( ) ) ) return new SaslSocketTransceiver ( new InetSocketAddress ( arg0 . getHost ( ) , arg0 . getPort ( ) ) ) ; else throw new IOException ( \"srini_string\" + arg0 ) ; }"}, {"instruction": "Generate java code\nserializes the given object into a bytebuffer backed by the byte array returned by kryo serialization . ", "input": " Output output \n Input input \n Kryo kryo \n byte[] serialize \n Object deserialize \n Object deserialize", "output": "ByteBuffer function ( Object arg0 ) { output . clear ( ) ; kryo . writeClassAndObject ( output , arg0 ) ; return ByteBuffer . wrap ( output . getBuffer ( ) , 0 , output . position ( ) ) ; }"}, {"instruction": "Generate java code\nretrieve a default instance of lcm using either the environment variable lcm_default_url or the default . if an exception occurs , system.exit -1 is called . ", "input": " LCM singleton \n String regex \n Pattern pat \n LCMDataOutputStream encodeBuffer \n ArrayList<SubscriptionRecord> subscriptions \n LCMSubscriber lcsub \n HashMap<String,ArrayList<SubscriptionRecord>> subscriptionsMap \n boolean closed \n ArrayList<Provider> providers \n void receiveMessage \n void subscribe \n void unsubscribe \n int getNumSubscriptions \n void publish \n void publish \n void publish \n void messageReceived \n void main \n void close \n void subscribeAll", "output": "LCM function ( ) { if ( singleton == null ) { try { singleton = new LCM ( ) ; } catch ( Exception loc0 ) { System . err . println ( \"srini_string\" + loc0 ) ; System . exit ( - 1 ) ; return null ; } } return singleton ; }"}, {"instruction": "Generate java code\ntruncates a string to the maximum length . ", "input": " boolean fgFilterStack \n String SUITE_METHODNAME \n int fgMaxMessageLength \n boolean fLoading \n Properties fPreferences \n void addError \n boolean showStackRaw \n void startTest \n String extractClassName \n void readPreferences \n void testStarted \n Test getTest \n String elapsedTimeAsString \n void addFailure \n boolean useReloadingTestSuiteLoader \n void testFailed \n void setPreferences \n Class<?> loadSuiteClass \n void savePreferences \n void runFailed \n boolean filterLine \n void clearStatus \n String processArguments \n String getPreference \n int getPreference \n String getFilteredTrace \n String getFilteredTrace \n Properties getPreferences \n void setLoading \n File getPreferencesFile \n void setPreference \n void endTest \n void testEnded", "output": "String function ( String arg0 ) { if ( fgMaxMessageLength != - 1 && arg0 . length ( ) > fgMaxMessageLength ) { arg0 = arg0 . substring ( 0 , fgMaxMessageLength ) + \"srini_string\" ; } return arg0 ; }"}, {"instruction": "Generate java code\nclose inputstream ", "input": " PlaceHolder placeHolder \n Drawable bitmapToDrawable \n Bitmap drawableToBitmap \n Bitmap byteToBitmap \n Bitmap getBitmapFromUrl \n Bitmap getBitmapFromUrl \n byte[] drawableToByte \n Bitmap scaleImage \n byte[] bitmapToByte \n Bitmap scaleImageTo \n Drawable byteToDrawable \n Drawable getDrawableFromUrl \n Drawable getDrawableFromUrl \n InputStream getInputStreamFromUrl \n InputStream getInputStreamFromUrl", "output": "void function ( InputStream arg0 ) { if ( arg0 == null ) { return ; } try { arg0 . close ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( \"srini_string\" , loc0 ) ; } }"}, {"instruction": "Generate java code\nalways throws a sqlexception . not supported . ", "input": " String password \n Log log \n String driverClassName \n String jdbcURL \n String userName \n void setPassword \n Connection getConnection \n Connection getConnection \n void setDriverClassName \n void setLoginTimeout \n void setLogWriter \n void setUserName \n void setJdbcURL \n int getLoginTimeout", "output": "PrintWriter function ( ) { throw new SQLException ( Resources . getMessage ( \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nstatic factory method to create a criteria using the provided key ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria lt \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria nin \n Criteria nin \n Criteria gte \n Criteria create \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria eq \n Criteria gt \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n Criteria exists \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( String arg0 ) { checkComplete ( ) ; return new Criteria ( this . criteriaChain , ValueNode . toValueNode ( prefixPath ( arg0 ) ) ) ; }"}, {"instruction": "Generate java code\ngets a reader for an imember 's javadoc comment content from the source attachment . the content does contain only the text from the comment without the javadoc leading star characters . returns null if the member does not contain a javadoc comment or if no source is available . ", "input": " PlaceHolder placeHolder \n Reader findDocInHierarchy \n boolean containsOnlyInheritDoc \n Reader getHTMLContentReader \n Reader getHTMLContentReader \n Reader internalGetContentReader", "output": "Reader function ( IMember arg0 , boolean arg1 ) { Reader loc0 = internalGetContentReader ( arg0 ) ; if ( loc0 != null || ! ( arg1 && ( arg0 . getElementType ( ) == IJavaElement . METHOD ) ) ) return loc0 ; return findDocInHierarchy ( ( IMethod ) arg0 , false , false ) ; }"}, {"instruction": "Generate java code\nsearches up the parent hierarchy from the given tag for a tag of the given type ", "input": " Tag parent \n JellyContext context \n boolean hasTrimmed \n Script body \n boolean escapeText \n Boolean shouldTrim \n Tag getParent \n boolean isTrim \n Script getBody \n void setBody \n void invokeBody \n boolean isEscapeText \n String getBodyText \n String getBodyText \n void setEscapeText \n void setTrim \n void setContext \n void setParent \n JellyContext getContext \n void trimBody", "output": "Tag function ( Tag arg0 , Class arg1 ) { while ( arg0 != null ) { if ( arg1 . isInstance ( arg0 ) ) { return arg0 ; } arg0 = arg0 . getParent ( ) ; } return null ; }"}, {"instruction": "Generate java code\nreplication will be tried numberofreplicationtimes before target contact is given up . ", "input": " int numberOfReplicates \n long timeToLiveForContacts \n int numberOfPingTries \n long timeBetweenRootPings \n long timeBetweenReplicationChecks \n int numberOfReplicationTries \n int minimumNumberOfReplicates \n int getNumberOfPingTries \n void setNumberOfPingTries \n int getNumberOfReplicates \n long getTimeBetweenReplicationChecks \n void setTimeBetweenRootPings \n void setMinimumNumberOfReplicates \n long getTimeToLiveForContacts \n void setNumberOfReplicates \n int getMinimumNumberOfReplicates \n void setTimeToLiveForContacts \n void setTimeBetweenReplicationChecks \n long getTimeBetweenRootPings \n void setNumberOfReplicationTries", "output": "int function ( ) { return numberOfReplicationTries ; }"}, {"instruction": "Generate java code\nreturns the lower bound of a type signature . returns the null type signature if signature is a wildcard or upper bound ? extends t ; returns the signature of the type t of a lower bound ? super t or signature itself if it is not a bound signature . ", "input": " String NULL_TYPE_SIGNATURE \n String OBJECT_SIGNATURE \n char[] NULL_TYPE_SIGNATURE_ARRAY \n char[] OBJECT_SIGNATURE_ARRAY \n String qualifySignature \n int typeEnd \n char[] unboundedSignature \n String stripSignatureToFQN \n String getUpperBound \n char[] getUpperBound \n boolean isJavaLangObject \n int indexOf \n char[] fix83600", "output": "String function ( String arg0 ) { return String . valueOf ( getLowerBound ( arg0 . toCharArray ( ) ) ) ; }"}, {"instruction": "Generate java code\nevaluates the predicate returning true if either predicate returns true . ", "input": " Predicate iPredicate2 \n long serialVersionUID \n Predicate iPredicate1 \n Predicate getInstance \n Predicate[] getPredicates", "output": "boolean function ( Object arg0 ) { return ( iPredicate1 . evaluate ( arg0 ) || iPredicate2 . evaluate ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nget the matrix for a. ", "input": " int blocksize \n GenMatrix<C> ZERO \n int DEFAULT_BSIZE \n GenMatrix<C> ONE \n Logger logger \n RingFactory<C> coFac \n float density \n int rows \n int cols \n Random random \n float DEFAULT_DENSITY \n GenMatrix<C> randomUpper \n GenMatrix<C> randomUpper \n GenMatrix<C> randomLower \n GenMatrix<C> randomLower \n GenMatrixRing<C> product \n GenMatrix<C> fromList \n boolean isField \n boolean isCommutative \n GenMatrix<C> parse \n GenMatrix<C> parse \n java.math.BigInteger characteristic \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n int hashCode \n boolean equals \n GenMatrix<C> getONE \n GenMatrix<C> getZERO \n String toString \n boolean isAssociative \n GenMatrixRing<C> transpose \n GenMatrix<C> copy", "output": "GenMatrix < C > function ( BigInteger arg0 ) { C loc0 = coFac . fromInteger ( arg0 ) ; return ONE . scalarMultiply ( loc0 ) ; }"}, {"instruction": "Generate java code\nsets an listener for execution data . ", "input": " boolean firstBlock \n CompactDataInput in \n ISessionInfoVisitor sessionInfoVisitor \n IExecutionDataVisitor executionDataVisitor \n boolean readBlock \n boolean read \n void readSessionInfo \n void readExecutionData \n void setSessionInfoVisitor \n void readHeader", "output": "void function ( final IExecutionDataVisitor arg0 ) { this . executionDataVisitor = arg0 ; }"}, {"instruction": "Generate java code\nsets the richmediaactivation dictionary specifying the style of presentation , default script behavior , default view information , and animation style when the annotation is activated . part of the richmediasettings . ", "input": " PdfDictionary richMediaSettings \n PdfArray configurations \n PdfArray views \n HashMap<String,PdfIndirectReference> assetsmap \n PdfDictionary richMediaContent \n PdfIndirectReference richMediaContentReference \n PdfWriter writer \n PdfAnnotation annot \n PdfIndirectReference addAsset \n PdfIndirectReference addAsset \n PdfIndirectReference getRichMediaContentReference \n PdfAnnotation createAnnotation \n PdfIndirectReference addConfiguration \n PdfIndirectReference addConfiguration \n PdfIndirectReference addView \n PdfIndirectReference addView \n void setDeactivation", "output": "void function ( RichMediaActivation arg0 ) { richMediaSettings . put ( PdfName . ACTIVATION , arg0 ) ; }"}, {"instruction": "Generate java code\nget a local element from a long value . ", "input": " Logger logger \n Ideal<C> ideal \n GenPolynomialRing<C> ring \n int isField \n Local<C> random \n Local<C> random \n Local<C> random \n int hashCode \n boolean isField \n boolean equals \n Local<C> getONE \n boolean isCommutative \n Local<C> getZERO \n boolean isAssociative \n String toString \n Local<C> parse \n Local<C> parse \n Local<C> copy \n java.math.BigInteger characteristic", "output": "Local < C > function ( long arg0 ) { return new Local < C > ( this , ring . fromInteger ( arg0 ) ) ; }"}, {"instruction": "Generate java code\ncreates a hash using a specific digest algorithm and a provider . ", "input": " String SHA1 \n HashMap<String,String> digestNames \n HashMap<String,String> allowedDigests \n String SHA384 \n HashMap<String,String> fixNames \n String SHA256 \n String RIPEMD160 \n String SHA512 \n MessageDigest getMessageDigestFromOid \n MessageDigest getMessageDigest \n String getAllowedDigests \n String getDigest \n String normalizeDigestName", "output": "byte [ ] function ( InputStream arg0 , String arg1 , String arg2 ) { MessageDigest loc0 = getMessageDigest ( arg1 , arg2 ) ; return digest ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\nremoves the last returned element from the collection that spawned the underlying iterator . ", "input": " Iterator iterator \n Object next \n Iterator getIterator \n boolean hasNext \n void setIterator", "output": "void function ( ) { getIterator ( ) . remove ( ) ; }"}, {"instruction": "Generate java code\ninit the client . ", "input": " Logger LOG \n KrbSetting krbSetting \n KOptions commonOptions \n InternalKrbClient innerClient \n KrbConfig krbConfig \n void setTimeout \n void setKdcHost \n KrbConfig getKrbConfig \n TgtTicket requestTgt \n void setKdcRealm \n void storeTicket \n KrbSetting getSetting \n SgtTicket requestSgt \n SgtTicket requestSgt \n void setKdcUdpPort \n void setKdcTcpPort \n void setAllowUdp \n void setAllowTcp", "output": "void function ( ) { innerClient = new DefaultInternalKrbClient ( krbSetting ) ; innerClient . init ( ) ; }"}, {"instruction": "Generate java code\ncommon ", "input": " MacExtensions MacExt \n Rectangle win32_getBounds \n Rectangle win32_getBounds \n Rectangle carbon_getBounds \n Rectangle carbon_getBounds \n MenuItem[] getItems \n Menu[] getMenus \n Menu[] getMenus \n boolean isMacAccessibilityDisabled \n boolean parentIsControl \n void gtk_getBounds \n Rectangle gtk_getBounds \n Rectangle gtk_getBounds \n boolean isSubMenu \n Rectangle motif_getBounds \n Rectangle motif_getBounds \n int SendMessage \n int SendMessage", "output": "Rectangle function ( Object arg0 ) { Rectangle loc0 = new Rectangle ( 0 , 0 , 0 , 0 ) ; try { Method loc1 = arg0 . getClass ( ) . getDeclaredMethod ( \"srini_string\" , null ) ; loc1 . setAccessible ( true ) ; loc0 = ( Rectangle ) loc1 . invoke ( arg0 , null ) ; } catch ( Throwable loc1 ) { } return loc0 ; }"}, {"instruction": "Generate java code\ncreates two tables . the second table has 1 header row and it should skip the first header . 1 line of table 2 should be on page 1 , the rest on page 2 . ", "input": " String outFolder \n String cmpFolder \n void testKeepRowsTogetherInCombinationWithHeaders \n PdfPTable createTable \n void setUp \n void createDocument \n void testKeepRowsTogetherWithoutHeader \n void compareDocuments", "output": "void function ( ) { final String loc0 = \"srini_string\" ; createDocument ( loc0 , 2 , 10 , \"srini_string\" , true , true ) ; }"}, {"instruction": "Generate java code\nput this widget and its current state into the map ", "input": " Map _map \n IWidgetState get \n WidgetStateMap create", "output": "IWidgetState function ( Widget arg0 ) { return put ( arg0 , WidgetState . create ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns the actual string value . ", "input": " Region fTagPosition \n String TAG_POSTFIX \n AccessorClassReference fAccessorClassReference \n boolean fIsEclipseNLS \n int TAG_PREFIX_LENGTH \n String TAG_PREFIX \n int fIndex \n int TAG_POSTFIX_LENGTH \n String fValue \n Region fPosition \n Region getPosition \n boolean isEclipseNLS \n boolean hasTag \n void setAccessorClassReference \n AccessorClassReference getAccessorClassReference \n void setValue \n void setTagPosition \n String createTagText \n String getTagText \n String toString \n Region getTagPosition", "output": "String function ( ) { return fValue ; }"}, {"instruction": "Generate java code\nhas to be called before any event is being processed to check if the next interval has begun . ", "input": " long end \n String outputFile \n FileAction fileAction \n List<Metric> metrics \n long intervalCounter \n ResultsWriter writer \n Metric time \n long interval \n Logger logger \n long start \n void declareMetrics \n List<String> getMeasurementsFor \n void setAction \n void start \n void addMetric \n boolean isActive \n void setOutputFile \n List<String> getAllMetricsNames \n long timeFromIntervalCount \n void stop \n void setInterval \n void setStart \n void setEnd \n void progressIntervals", "output": "void function ( ) { if ( ! isActive ( ) ) return ; progressIntervals ( Simulator . getCurrentTime ( ) ) ; }"}, {"instruction": "Generate java code\nget a residue element from a biginteger value . ", "input": " Ideal<C> ideal \n Logger logger \n GreatestCommonDivisor<C> engine \n GenPolynomialRing<C> ring \n int isField \n Residue<C> random \n Residue<C> random \n Residue<C> random \n int hashCode \n boolean isField \n boolean equals \n Residue<C> getONE \n boolean isCommutative \n Residue<C> getZERO \n boolean isAssociative \n String toString \n Residue<C> parse \n Residue<C> parse \n Residue<C> copy \n java.math.BigInteger characteristic", "output": "Residue < C > function ( java . math . BigInteger arg0 ) { return new Residue < C > ( this , ring . fromInteger ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nclears the mapping between the raname and the resource adapter identifier , with which the resource adapter is registered with the org.jboss.jca.core.spi.rar.resourceadapterrepository subsequent calls to #getregisteredresourceadapteridentifier string with the passed raname returnnull ", "input": " ServiceName RESOURCE_ADAPTER_SERVICE_PREFIX \n ServiceName BOOTSTRAP_CONTEXT_SERVICE \n ServiceName RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX \n ServiceName CONNECTION_VALIDATOR_SERVICE \n ServiceName TRANSACTION_INTEGRATION_SERVICE \n ServiceName ARCHIVE_VALIDATION_CONFIG_SERVICE \n ServiceName RESOURCEADAPTERS_SERVICE \n ServiceName DATASOURCES_SERVICE \n ServiceName TRACER_CONFIG_SERVICE \n ServiceName CCM_SERVICE \n String STATISTICS_SUFFIX \n ServiceName NON_JTA_DS_RA_REPOSITORY_SERVICE \n ServiceName DISTRIBUTED_WORKMANAGER_STATS_SERVICE \n ServiceName IRONJACAMAR_RESOURCE \n ServiceName BEAN_VALIDATION_CONFIG_SERVICE \n ServiceName NON_TX_CCM_SERVICE \n ServiceName IDLE_REMOVER_SERVICE \n ServiceName RESOURCE_ADAPTER_REGISTRY_SERVICE \n Map<String,String> resourceAdapterRepositoryIdentifiers \n ServiceName RA_REPOSITORY_SERVICE \n ServiceName JDBC_DRIVER_REGISTRY_SERVICE \n ServiceName RESOURCE_ADAPTER_ACTIVATOR_SERVICE \n ServiceName RA_SERVICE \n ServiceName INACTIVE_RESOURCE_ADAPTER_SERVICE \n ServiceName WORKMANAGER_STATS_SERVICE \n ServiceName RESOURCE_ADAPTER_DEPLOYMENT_SERVICE_PREFIX \n ServiceName RESOURCEADAPTERS_SUBSYSTEM_SERVICE \n ServiceName CONNECTOR_CONFIG_SERVICE \n ServiceName WORKMANAGER_SERVICE \n ServiceName IRONJACAMAR_MDR \n ServiceName MANAGEMENT_REPOSITORY_SERVICE \n void registerResourceAdapterIdentifier \n T notNull \n ServiceName getDeploymentServiceName \n ServiceName getDeploymentServiceName \n ServiceName getDeploymentServiceName \n String getRegisteredResourceAdapterIdentifier \n ServiceName getResourceAdapterServiceName \n String stripDotRarSuffix", "output": "void function ( final String arg0 ) { synchronized ( resourceAdapterRepositoryIdentifiers ) { resourceAdapterRepositoryIdentifiers . remove ( arg0 ) ; } }"}, {"instruction": "Generate java code\nmoves this line by a given amount . ", "input": " double y1 \n double x1 \n double y2 \n double x2 \n Color color \n int getX \n int getHeight \n int getY \n void grow \n void setColor \n String toString \n int getWidth \n void draw \n void paintShape", "output": "void function ( double arg0 , double arg1 ) { x1 += arg0 ; y1 += arg1 ; x2 += arg0 ; y2 += arg1 ; Canvas . getInstance ( ) . repaint ( ) ; }"}, {"instruction": "Generate java code\nrolls the camera ", "input": " VectorXYZ pos \n VectorXYZ lookAt \n VectorXYZ up \n void moveMapRight \n void setCamera \n void setCamera \n void moveForward \n void move \n void move \n VectorXYZ getUp \n void yaw \n void moveMapUp \n void setPos \n void setPos \n void mapPitch \n VectorXYZ getRight \n void setLookAt \n void setLookAt \n VectorXYZ getViewDirection \n VectorXYZ getPos \n void moveRight \n VectorXYZ getLookAt \n void moveMapForward \n String toString \n void pitch \n void rotateY \n void moveUp", "output": "void function ( double arg0 ) { VectorXYZ loc0 = getViewDirection ( ) ; up = up . rotateVec ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\nset the children of the tree ", "input": " TreeNode right \n int value \n TreeNode left \n int addTree \n TreeNode createTree", "output": "void function ( TreeNode arg0 , TreeNode arg1 ) { left = arg0 ; right = arg1 ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable version of the given non-null doublelistiterator . ", "input": " DoubleListIterator EMPTY_DOUBLE_LIST_ITERATOR \n DoubleIterator EMPTY_DOUBLE_ITERATOR \n DoubleList EMPTY_DOUBLE_LIST \n DoubleList unmodifiableDoubleList \n DoubleList getEmptyDoubleList \n DoubleIterator singletonDoubleIterator \n DoubleList singletonDoubleList \n DoubleIterator unmodifiableDoubleIterator \n DoubleIterator getEmptyDoubleIterator \n DoubleListIterator singletonDoubleListIterator \n DoubleListIterator getEmptyDoubleListIterator", "output": "DoubleListIterator function ( DoubleListIterator arg0 ) { if ( null == arg0 ) { throw new NullPointerException ( ) ; } return UnmodifiableDoubleListIterator . wrap ( arg0 ) ; }"}, {"instruction": "Generate java code\noutputs the lines to the document . it is equivalent to go false . ", "input": " Float curCharSpace \n float leading \n int NO_MORE_COLUMN \n int alignment \n String splittedChunkText \n int NO_MORE_TEXT \n PdfChunk currentStandbyChunk \n ArrayList<PdfChunk> chunks \n int maxLines \n float startY \n PdfContentByte text \n int currentChunkMarker \n float startX \n float height \n int getAlignment \n void setAlignment \n void setVerticalLayout \n void setOrigin \n void addText \n void addText \n PdfLine createLine \n void setMaxLines \n int getMaxLines \n void setHeight \n float getHeight \n void setLeading \n void writeLine \n float getOriginY \n float getLeading \n float getOriginX \n void shortenChunkArray", "output": "int function ( ) { return go ( false ) ; }"}, {"instruction": "Generate java code\ncalled when the document starts to be parsed . ", "input": " Stack<String> fieldNames \n HashMap<String,List<String>> listFields \n boolean foundRoot \n HashMap<String,String> fields \n Stack<String> fieldValues \n String fileSpec \n HashMap<String,String> getFields \n void endElement \n List<String> getListValues \n void startElement \n String getFieldValue \n String getField \n void text \n void endDocument \n String getFileSpec", "output": "void function ( ) { fileSpec = \"srini_string\" ; }"}, {"instruction": "Generate java code\ncopies a slice of the list into a native array . note that this will not pop them out of the stack . ", "input": " TDoubleArrayList _list \n int DEFAULT_CAPACITY \n double pop \n int size \n void clear \n void reset \n void push \n double peek", "output": "void function ( double [ ] arg0 ) { _list . toNativeArray ( arg0 , 0 , size ( ) ) ; }"}, {"instruction": "Generate java code\nmark a client as hidden . ", "input": " String selectedClient \n String PREF_COLLAPSED_CLIENT_GUIDS \n SharedPreferences sharedPrefs \n String PREF_HIDDEN_CLIENT_GUIDS \n Set<String> collapsedClients \n Set<String> hiddenClients \n String PREF_SELECTED_CLIENT_GUID \n boolean updateClientMembership \n boolean isClientCollapsed \n void setClientAsSelected \n boolean isClientHidden \n boolean setClientCollapsed \n Set<String> getStringSet", "output": "boolean function ( String arg0 , boolean arg1 ) { return updateClientMembership ( PREF_HIDDEN_CLIENT_GUIDS , hiddenClients , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ncompares two canvid and if all value until the n-1 number are common the return value is true . so it is true , if all parents are common ", "input": " List<String> VID \n boolean inBetween \n List<String> listCommon \n boolean lower \n int numberCommon \n void addToVID \n boolean allZero \n void removeFromList \n String einzelnToString \n boolean allOne \n List<String> getVIDList \n String toString \n void setVIDList \n boolean higher", "output": "boolean function ( CanVID arg0 ) { if ( VID . size ( ) != arg0 . getVIDList ( ) . size ( ) ) return false ; for ( int loc0 = 0 ; loc0 < VID . size ( ) - 1 ; loc0 ++ ) { if ( ! VID . get ( loc0 ) . toString ( ) . equals ( arg0 . getVIDList ( ) . get ( loc0 ) . toString ( ) ) ) return false ; } return true ; }"}, {"instruction": "Generate java code\nruns the tests and collects their result in a testresult . ", "input": " String fName \n Vector fTests \n void setName \n int testCount \n void addTestSuite \n String getName \n void addTestMethod \n boolean isTestMethod \n Test createTest \n Test testAt \n Enumeration tests \n String exceptionToString \n Constructor getTestConstructor \n Test warning \n void addTest \n String toString \n int countTestCases \n boolean isPublicTestMethod \n void runTest", "output": "void function ( TestResult arg0 ) { for ( Enumeration loc0 = tests ( ) ; loc0 . hasMoreElements ( ) ; ) { if ( arg0 . shouldStop ( ) ) break ; Test loc1 = ( Test ) loc0 . nextElement ( ) ; runTest ( loc1 , arg0 ) ; } }"}, {"instruction": "Generate java code\nretrieves the pnpenabled value . ", "input": " long signature1 \n int productID \n String manufacturer \n int vendorID \n long version \n long signature2 \n String productDescription \n String serialNumber \n int MAX_HEADER_LENGTH \n String manufacturerID \n boolean remoteWakeupCapable \n boolean pnpEnabled \n int maxPower \n boolean selfPowered \n long getSignature2 \n void setProductID \n void setPnpEnabled \n void setManufacturer \n void setMaxPower \n void setProductDescription \n String getManufacturer \n void setSelfPowered \n long getSignature1 \n void setManufacturerID \n boolean isRemoteWakeupCapable \n String getManufacturerID \n void validate \n int getMaxPower \n long getVersion \n void setSignature1 \n String getSerialNumber \n void setSerialNumber \n void setVersion \n void setSignature2 \n String getProductDescription \n int getProductID \n boolean isSelfPowered \n void setRemoteWakeupCapable \n void setVendorID \n int getVendorID", "output": "boolean function ( ) { return pnpEnabled ; }"}, {"instruction": "Generate java code\nproduct of this vector with scalar . ", "input": " List<C> val \n Logger logger \n GenVectorModul<C> modul \n int signum \n GenVector<C> leftLinearCombination \n GenVector<C> rightScalarProduct \n GenVector<C> subtract \n GenVector<C> sum \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n int compareTo \n GenVector<C> leftScalarMultiply \n C scalarProduct \n GenVector<C> scalarProduct \n GenVector<C> abs \n int hashCode \n GenVector<C> negate \n boolean equals \n GenVector<C> clone \n boolean isZERO \n String toString", "output": "GenVector < C > function ( C arg0 ) { ArrayList < C > loc0 = new ArrayList < C > ( modul . cols ) ; for ( C loc1 : val ) { C loc2 = loc1 . multiply ( arg0 ) ; loc0 . add ( loc2 ) ; } return new GenVector < C > ( modul , loc0 ) ; }"}, {"instruction": "Generate java code\nputs the given collection of keys into this map according to the contract of #put object , object , predicate . the values will be set to null . the keys are added in the order of the collection 's iterator . each key of keys is tested individually with keypredicate and can be added only if the predicate holds . ", "input": " SortedMap<K,V> kSmallest \n int k \n boolean containsKey \n Collection<V> values \n void clear \n boolean isInRange \n boolean put \n boolean put \n boolean put \n V remove \n boolean containsValue \n K getMinKey \n K getMaxKey \n int size \n K firstKey \n V get \n void setAllValues \n K lastKey \n String toString \n Set<K> keySet", "output": "void function ( final Collection < ? extends K > arg0 , final Predicate < ? super K > arg1 ) { for ( final K loc0 : arg0 ) { put ( loc0 , null , arg1 , null ) ; } }"}, {"instruction": "Generate java code\ntopologische position ", "input": " long serialVersionUID \n PositionInfo position \n HashSet<Edge<TNode,TEdge>> edges \n VisualGraph<TNode,TEdge> graph \n void setGraph \n void setPos \n void unsetGraph \n VisualGraph<TNode,TEdge> getGraph \n PositionInfo getPositionInfo \n Color getColor \n Coords getSchematicPosition \n void iterate", "output": "Coords function ( ) { return this . position . getTopoCoords ( ) ; }"}, {"instruction": "Generate java code\nget the index that numbers this base string . ", "input": " Map _seen \n StringBuffer getBase \n String generate", "output": "int function ( String arg0 ) { Integer loc0 = ( Integer ) _seen . get ( arg0 ) ; if ( loc0 == null ) { loc0 = new Integer ( 0 ) ; } else { loc0 = new Integer ( loc0 . intValue ( ) + 1 ) ; } _seen . put ( arg0 , loc0 ) ; return loc0 . intValue ( ) ; }"}, {"instruction": "Generate java code\nno-op method - this renderer is n't interested in image events ", "input": " Vector lastEnd \n StringBuffer result \n Vector lastStart \n void appendTextChunk \n void beginTextBlock \n void endTextBlock \n String getResultantText \n void renderText", "output": "void function ( ImageRenderInfo arg0 ) { }"}, {"instruction": "Generate java code\ngets the exception class . ", "input": " Class clz \n String reposId \n CDRStreamReader[] paramReaders \n java.lang.reflect.Method writeMethod \n CDRStreamWriter retvalWriter \n Method m \n ExceptionWriter[] excepWriters \n boolean isNonVoid \n void arraysort \n Object[] readParams \n void writeRetval \n Method getMethod \n void writeException \n void write", "output": "Class function ( ) { return clz ; }"}, {"instruction": "Generate java code\ncreate a name-already-bound exception . ", "input": " PlaceHolder placeHolder \n Context createSubcontext \n void rebind \n void rebind \n void unbind \n void unbind \n boolean isEmpty \n NameNotFoundException nameNotFoundException \n String getLastComponent \n NotContextException notAContextException \n boolean isLastComponentEmpty \n NamingException namingException \n NamingException namingException \n CannotProceedException cannotProceedException \n InvalidNameException emptyNameException \n NamingEnumeration<T> namingEnumeration", "output": "NameAlreadyBoundException function ( final Name arg0 ) { return new NameAlreadyBoundException ( arg0 . toString ( ) ) ; }"}, {"instruction": "Generate java code\nobtains value of the coreprotocolpnames #http_malformed_input_action parameter . ", "input": " PlaceHolder placeHolder \n ProtocolVersion getVersion \n CodingErrorAction getUnmappableInputAction \n void setUnmappableInputAction \n void setVersion \n void setUserAgent \n String getHttpElementCharset \n boolean useExpectContinue \n void setHttpElementCharset \n void setMalformedInputAction \n String getUserAgent \n String getContentCharset \n void setUseExpectContinue \n void setContentCharset", "output": "CodingErrorAction function ( final HttpParams arg0 ) { Args . notNull ( arg0 , \"srini_string\" ) ; final Object loc0 = arg0 . getParameter ( CoreProtocolPNames . HTTP_MALFORMED_INPUT_ACTION ) ; if ( loc0 == null ) { return CodingErrorAction . REPORT ; } return ( CodingErrorAction ) loc0 ; }"}, {"instruction": "Generate java code\nretrieves a message with no arguments . ", "input": " String RESOURCE_LOCATION \n ResourceBundle rb \n placeholderType placeHolder", "output": "String function ( String arg0 ) { return rb . getString ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the source index of this type variable maplet . ", "input": " String fSourceName \n int fTargetIndex \n int fSourceIndex \n String fTargetName \n String getSourceName \n int getTargetIndex \n int hashCode \n boolean equals \n String getTargetName", "output": "int function ( ) { return fSourceIndex ; }"}, {"instruction": "Generate java code\nreturns the number of vertices in this polygon . the duplicated first/last vertex is not counted twice , so the result is equivalent to #getvertices . size . ", "input": " List<VectorXYZ> vertexLoop \n PolygonXZ getXZPolygon \n List<VectorXYZ> getVertexLoop \n SimplePolygonXZ getSimpleXZPolygon \n TriangleXYZ asTriangleXYZ \n List<VectorXYZ> getVertices \n PolygonXYZ reverse \n List<LineSegmentXYZ> getSegments", "output": "int function ( ) { return vertexLoop . size ( ) - 1 ; }"}, {"instruction": "Generate java code\nsets the value of the synclevel property . ", "input": " String syncToken \n Prop prop \n Limit limit \n String syncLevel \n String getSyncToken \n void setSyncToken \n Limit getLimit \n String getSyncLevel \n void setLimit \n void setProp \n Prop getProp", "output": "void function ( String arg0 ) { this . syncLevel = arg0 ; }"}, {"instruction": "Generate java code\nreturns this triangle if it is clockwise , or the reversed triangle if it is counterclockwise . ", "input": " VectorXZ v1 \n VectorXZ v2 \n VectorXZ v3 \n VectorXZ getCenter \n boolean contains \n TriangleXZ makeClockwise \n int hashCode \n boolean equals \n TriangleXYZ xyz \n List<VectorXZ> getVertices \n boolean isClockwise \n String toString \n TriangleXZ makeRotationSense \n TriangleXZ reverse \n double getArea", "output": "TriangleXZ function ( ) { return makeRotationSense ( false ) ; }"}, {"instruction": "Generate java code\nadds or replaces a page label . there is no text prefix and the first logical page has the default of 1 . ", "input": " int DECIMAL_ARABIC_NUMERALS \n int UPPERCASE_ROMAN_NUMERALS \n int physicalPage \n int LOWERCASE_LETTERS \n int EMPTY \n int LOWERCASE_ROMAN_NUMERALS \n PdfName numberingStyle[] \n String prefix \n int logicalPage \n int numberStyle \n int UPPERCASE_LETTERS \n HashMap<Integer,PdfDictionary> map \n void removePageLabel \n String[] getPageLabels \n PdfDictionary getDictionary \n String toString \n PdfPageLabelFormat[] getPageLabelFormats", "output": "void function ( int arg0 , int arg1 ) { addPageLabel ( arg0 , arg1 , null , 1 ) ; }"}, {"instruction": "Generate java code\ncheck that the user is app_developer or config_admin : app_developer : can edit properties of instances of application config_admin : can edit all properties . ", "input": " EntityManager entityManager \n PermissionService permissionService \n ResourceTypeProvider resourceTypeProvider \n boolean canCreateAppAndAddToAppServer \n boolean hasPermissionToAddRelation \n boolean hasPermissionToDeploy \n boolean canCopyFromResource \n void checkPermissionAndFireCheckedException \n boolean hasPermissionToDeleteRelation \n boolean hasPermissionToDeleteRelationType \n void checkPermissionAndFireException \n boolean hasPermissionToRenameResource \n boolean hasPermissionToRemoveDefaultInstanceOfResType \n boolean hasPermission \n boolean hasPermission \n boolean hasPermissionToTemplateModify \n boolean hasPermissionToEditPropertiesByResource \n boolean canCreateResourceInstance \n boolean canCreateResourceInstance \n boolean hasPermissionToRenameResourceType", "output": "boolean function ( Integer arg0 ) { ResourceTypeEntity loc0 = entityManager . find ( ResourceTypeEntity . class , arg0 ) ; return permissionService . hasPermissionToEditPropertiesOfResource ( loc0 ) ; }"}, {"instruction": "Generate java code\ngives the number of all received messages ", "input": " long receivedBytes \n int sentMsg \n int receivedMsg \n StatisticGenerationEvent event \n long sentBytes \n Logger log \n double[] getSentBytes \n void netMsgReceive \n void addReceivedMsg \n void stop \n double[] getSentMsg \n void start \n void netMsgSend \n void netMsgDrop \n double[] getReceivedBytes \n void addSentMsg", "output": "double [ ] function ( LinkedHashMap < CanOverlayID , CanNode > arg0 ) { double loc0 = receivedMsg * Simulator . MINUTE_UNIT / CanConfig . intervallBetweenStatistics ; double loc1 = loc0 / arg0 . size ( ) ; receivedMsg = 0 ; double [ ] loc2 = { loc0 , loc1 } ; return loc2 ; }"}, {"instruction": "Generate java code\nset the context attribute key for the attribute . ", "input": " String fromKey \n boolean execute \n String getFromKey", "output": "void function ( String arg0 ) { this . fromKey = arg0 ; }"}, {"instruction": "Generate java code\nget iterator of list elements . ", "input": " List<ListElement> listElements \n List<ListElement> getListElements \n void appendElement \n int getNumberOfListElements", "output": "ListElement function ( int arg0 ) { return listElements . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the name of the described extension . ", "input": " String fId \n boolean fIsEnabled \n IConfigurationElement fElement \n boolean fNeedsSortingAfterFiltering \n boolean fIsIncluded \n String ICON \n Expression fEnablementExpression \n int fSortOrder \n String fName \n ImageDescriptor fImage \n String fLastError \n CompletionProposalComputerRegistry fRegistry \n boolean fIsSeparateCommand \n boolean isSeparateCommand \n void sessionEnded \n void setSortOrder \n void sessionStarted \n Expression getEnablementExpression \n void setSeparateCommand \n String getId \n ImageDescriptor getImageDescriptor \n void setIncluded \n boolean matches \n Bundle getBundle \n int getSortOrder \n void setEnabled \n void checkNotNull \n String getDisplayName \n boolean isEnabled \n boolean hasComputers \n boolean hasComputers \n boolean isSortingAfterFilteringNeeded \n boolean isIncluded \n List<ICompletionProposal> computeCompletionProposals \n List<IContextInformation> computeContextInformation \n String getErrorMessage", "output": "String function ( ) { return fName ; }"}, {"instruction": "Generate java code\nlocal multiplication . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n C num \n int isunit \n C den \n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n Local<C> abs \n int hashCode \n Local<C> negate \n boolean equals \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> remainder", "output": "Local < C > function ( Local < C > arg0 ) { if ( arg0 == null || arg0 . isZERO ( ) ) { return arg0 ; } if ( num . isZERO ( ) ) { return this ; } if ( arg0 . isONE ( ) ) { return this ; } if ( this . isONE ( ) ) { return arg0 ; } C loc0 = num . multiply ( arg0 . num ) ; C loc1 = den . multiply ( arg0 . den ) ; return new Local < C > ( ring , loc0 , loc1 , false ) ; }"}, {"instruction": "Generate java code\nreturns an array of sortedmap objects . the sortedmap object key is the columnname and the value is the columnvalue . sortedmap was created using the case_insensitive_order comparator so the key is the case insensitive representation of the columnname . ", "input": " boolean isLimited \n String[] columnNames \n List rowMap \n List rowByIndex \n String[] getColumnNames \n int getRowCount \n Object[][] getRowsByIndex \n boolean isLimitedByMaxRows", "output": "SortedMap [ ] function ( ) { if ( rowMap == null ) { return null ; } return ( SortedMap [ ] ) rowMap . toArray ( new SortedMap [ 0 ] ) ; }"}, {"instruction": "Generate java code\nappends a rectangle to the current path as a complete subpath . ", "input": " List<Subpath> subpaths \n String START_PATH_ERR_MSG \n Point2D currentPoint \n Point2D getCurrentPoint \n void curveTo \n void curveTo \n boolean isEmpty \n Subpath getLastSubpath \n List<Subpath> getSubpaths \n void lineTo \n void closeSubpath \n void addSubpath \n void addSubpaths \n List<Integer> replaceCloseWithLine \n void closeAllSubpaths \n void curveFromTo \n void moveTo", "output": "void function ( final float arg0 , final float arg1 , final float arg2 , final float arg3 ) { moveTo ( arg0 , arg1 ) ; lineTo ( arg0 + arg2 , arg1 ) ; lineTo ( arg0 + arg2 , arg1 + arg3 ) ; lineTo ( arg0 , arg1 + arg3 ) ; closeSubpath ( ) ; }"}, {"instruction": "Generate java code\ncierra el libro y retorna numero paginas para finalizar ", "input": " String dimensiones \n int numeroPaginas \n String titulo \n String colorPortada \n String autor \n int marcador \n void setColorPortada \n void setDimensiones \n String getColorPortada \n String getAutor \n void setTitulo \n String getTitulo \n void setNumeroPaginas \n int getNumeroPaginas \n int leer \n String getDimensiones \n void setMarcador \n int escribir \n void setAutor \n Libro clone \n String toString \n int getMarcador \n int abrir", "output": "int function ( ) { return this . getNumeroPaginas ( ) - this . getMarcador ( ) ; }"}, {"instruction": "Generate java code\ncompare to biginteger b. ", "input": " java.math.BigInteger val \n BigInteger ONE \n BigInteger ZERO \n Random random \n BigInteger IRAND \n boolean isField \n boolean isCommutative \n BigInteger gcd \n BigInteger IPROD \n BigInteger sum \n BigInteger IABS \n java.math.BigInteger characteristic \n BigInteger random \n BigInteger random \n int hashCode \n BigInteger IDIF \n BigInteger divide \n BigInteger copy \n BigInteger multiply \n BigInteger IGCD \n int signum \n BigInteger ISUM \n boolean isONE \n BigInteger inverse \n java.math.BigInteger getVal \n BigInteger INEG \n BigInteger valueOf \n BigInteger valueOf \n boolean isUnit \n BigInteger subtract \n BigInteger IQ \n BigInteger[] IQR \n BigInteger parse \n BigInteger parse \n BigInteger[] egcd \n int ISIGN \n BigInteger abs \n BigInteger IREM \n BigInteger[] divideAndRemainder \n BigInteger negate \n boolean equals \n BigInteger clone \n BigInteger getONE \n BigInteger getZERO \n BigInteger fromInteger \n BigInteger fromInteger \n boolean isZERO \n boolean isAssociative \n String toString \n int ICOMP \n BigInteger remainder", "output": "int function ( BigInteger arg0 ) { return val . compareTo ( arg0 . val ) ; }"}, {"instruction": "Generate java code\ngiven a mouse accelerator , extract the button value . for use in synthesizing raw events . ", "input": " boolean BUTTONS_REMAPPED \n int SECONDARY_BUTTON \n int BUTTON_MASK \n int PRIMARY_BUTTON \n PlaybackSettings getPlaybackSettings", "output": "int function ( int arg0 ) { arg0 &= BUTTON_MASK ; if ( ( arg0 & SWT . BUTTON1 ) == SWT . BUTTON1 ) return MouseConfig . PRIMARY_BUTTON ; if ( ( arg0 & SWT . BUTTON2 ) == SWT . BUTTON2 ) return 2 ; if ( ( arg0 & SWT . BUTTON3 ) == SWT . BUTTON3 ) return MouseConfig . SECONDARY_BUTTON ; return 0 ; }"}, {"instruction": "Generate java code\nadds a string parameter to the request ", "input": " Map<String,Object> mParameters \n String boundary \n OutputStream mOutput \n URLConnection mConnection \n Map<String,String> mCookies \n Random random \n void boundary \n void writeName \n void setParameters \n void newline \n HttpURLConnection post \n String randomString \n void setParameter \n void postCookies \n void writeln \n void pipe \n void write \n void write", "output": "void function ( String arg0 , String arg1 ) { boundary ( ) ; writeName ( arg0 ) ; newline ( ) ; newline ( ) ; writeln ( arg1 ) ; }"}, {"instruction": "Generate java code\nreturns a booleancomparator instance that sorts false values before true values . clients are encouraged to use the value returned from this method instead of constructing a new instance to reduce allocation and garbage collection overhead when multiple booleancomparators may be used in the same virtual machine . ", "input": " BooleanComparator TRUE_FIRST \n long serialVersionUID \n BooleanComparator FALSE_FIRST \n boolean trueFirst \n BooleanComparator getTrueFirstComparator \n int compare \n int compare \n BooleanComparator getBooleanComparator \n int hashCode \n boolean equals \n boolean sortsTrueFirst", "output": "BooleanComparator function ( ) { return FALSE_FIRST ; }"}, {"instruction": "Generate java code\ntrim the collections used in this ppt . ", "input": " VarInfo[] var_infos \n List<Invariant> emptyInvList \n long serialVersionUID \n VarInfo find_var_by_name \n int compare \n String swap \n String name \n String varNames \n String varNames \n int indexOf \n boolean containsVar", "output": "void function ( ) { for ( VarInfo loc0 : var_infos ) { loc0 . trimToSize ( ) ; } }"}, {"instruction": "Generate java code\nadds part . ", "input": " String CONFORMANCE \n String PART \n void setConformance", "output": "void function ( XMPMeta arg0 , String arg1 ) { arg0 . setProperty ( XMPConst . NS_PDFA_ID , PdfAProperties . PART , arg1 ) ; }"}, {"instruction": "Generate java code\ncreate a name-not-found exception . ", "input": " PlaceHolder placeHolder \n Context createSubcontext \n void rebind \n void rebind \n void unbind \n void unbind \n boolean isEmpty \n String getLastComponent \n NameAlreadyBoundException nameAlreadyBoundException \n NotContextException notAContextException \n boolean isLastComponentEmpty \n NamingException namingException \n NamingException namingException \n CannotProceedException cannotProceedException \n InvalidNameException emptyNameException \n NamingEnumeration<T> namingEnumeration", "output": "NameNotFoundException function ( final String arg0 , final Name arg1 ) { return NamingLogger . ROOT_LOGGER . nameNotFoundInContext ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nset player color . ", "input": " Player playerTwo \n int gameType \n Facade theFacade \n Rules theRules \n Player passivePlayer \n boolean isTimerRunning \n Player activePlayer \n IMediator mediator \n Timer theTimer \n Player playerOne \n void endGame \n void setPlayerName \n IMediator getMediator \n void selectColors \n int getGameMode \n void ReceiveMessage \n void endTurn \n void setGameMode \n void RecievePassivePlayer \n void createPlayer \n void RecieveActivePlayer \n Notifier getTimerNotifier \n void requestActive \n void setMediator \n void requestPlayerName \n Player getOppositePlayer \n Facade getFacade \n void startGame \n void setTimer \n void SendMessage \n void requestPassive", "output": "void function ( int arg0 , Color arg1 ) { if ( arg0 == 1 ) { playerOne . setColor ( arg1 ) ; } else { playerTwo . setColor ( arg1 ) ; } }"}, {"instruction": "Generate java code\nasynchronously executes the specified batch statement . inputs will be passed to the #handler once query succeed or failed . ", "input": " AsyncResultHandler<T> handler \n AtomicInteger pending \n ExecutorService executorService \n Session session \n Logger LOG \n int getPendingTasksSize \n ExecutorService newSingleThreadExecutor \n void shutdown", "output": "SettableFuture < T > function ( final Statement arg0 , final T arg1 ) { return execAsync ( arg0 , arg1 , handler ) ; }"}, {"instruction": "Generate java code\ndebug-ausgabe ", "input": " Simple2DVisualization vis \n int SHIFT_AMOUNT \n void keyPressed \n void keyReleased \n void keyTyped", "output": "void function ( Object arg0 ) { }"}, {"instruction": "Generate java code\naccesses this card 's suit . ", "input": " int pointValue \n String rank \n String suit \n int pointValue \n String rank \n String toString \n boolean matches", "output": "String function ( ) { return suit ; }"}, {"instruction": "Generate java code\ncreates a box representing the glue type according to the `` glue rules '' based on the atom types between which the glue must be inserted . ", "input": " float stretch \n float shrink \n Glue[] glueTypes \n String name \n float space \n int[][][] glueTable \n String getName \n Box createBox", "output": "Box function ( int arg0 , int arg1 , TeXEnvironment arg2 ) { int loc0 = ( arg0 > TeXConstants . TYPE_INNER ? TeXConstants . TYPE_ORDINARY : arg0 ) ; int loc1 = ( arg1 > TeXConstants . TYPE_INNER ? TeXConstants . TYPE_ORDINARY : arg1 ) ; int loc2 = glueTable [ loc0 ] [ loc1 ] [ arg2 . getStyle ( ) / 2 ] ; return glueTypes [ loc2 ] . createBox ( arg2 ) ; }"}, {"instruction": "Generate java code\nsend a #verbose log message . ", "input": " int WARN \n Boolean sDebugLoggingEnabledForTests \n Pattern DATE_CLEANUP_PATTERN_WRONG_TIMEZONE \n int VERBOSE \n int MAX_ENABLED_LOG_LEVEL \n int ERROR \n int DEBUG \n int INFO \n String TAG \n boolean isLoggable \n int d \n int d \n int e \n int e \n int w \n int w \n int wtf \n int wtf \n String byteToHex \n StringBuilder byteToHex \n int i \n int i \n String cleanUpMimeDate \n boolean buildPreventsDebugLogging \n boolean isDebugLoggingEnabled \n void setDebugLoggingEnabledForTests", "output": "int function ( String arg0 , String arg1 , Object ... arg2 ) { if ( isLoggable ( arg0 , VERBOSE ) ) { return Log . v ( arg0 , String . arg1 ( arg1 , arg2 ) ) ; } return 0 ; }"}, {"instruction": "Generate java code\ncreate an floatlistiterator floatlistiterator wrappingthe specified listiterator listiterator . when the given iterator is null , returns null . ", "input": " ListIterator _iterator \n float next \n void add \n void set \n float previous \n boolean hasPrevious \n boolean hasNext \n int nextIndex \n int previousIndex \n void remove", "output": "FloatListIterator function ( ListIterator arg0 ) { return null == arg0 ? null : new ListIteratorFloatListIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the value of the structure property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the structure property . for example , to add a new item , do as follows : getstructure . add newitem ; objects of the following type s are allowed in the list applicationreleasebinding ", "input": " String fcLink \n String techStack \n String fcKey \n String outOfServiceByRelease \n ApplicationID id \n List<ApplicationReleaseBinding> structure \n String getFcLink \n void setTechStack \n String getTechStack \n String getFcKey \n void setOutOfServiceByRelease \n void setFcKey \n void setFcLink \n void setId \n ApplicationID getId \n String getOutOfServiceByRelease", "output": "List < ApplicationReleaseBinding > function ( ) { if ( structure == null ) { structure = new ArrayList < ApplicationReleaseBinding > ( ) ; } return this . structure ; }"}, {"instruction": "Generate java code\ntest method for com.flatironschool.javacs.mylinearmap #put java.lang.object , java.lang.object . ", "input": " Map<String,Integer> map \n void testContainsValue \n void testClear \n void testKeySet \n void testGet \n void testIsEmpty \n void testRemove \n void testSize \n void setUp \n void testContainsKey \n void testPutAll \n void testValues", "output": "void function ( ) { map . put ( \"srini_string\" , 11 ) ; assertThat ( map . size ( ) , is ( 4 ) ) ; assertThat ( map . get ( \"srini_string\" ) , is ( 11 ) ) ; map . put ( \"srini_string\" , 5 ) ; assertThat ( map . size ( ) , is ( 5 ) ) ; assertThat ( map . get ( \"srini_string\" ) , is ( 5 ) ) ; }"}, {"instruction": "Generate java code\ncheck whether the log4j logger used is enabled for error priority . ", "input": " String name \n boolean is12 \n Logger logger \n String FQCN \n void warn \n void warn \n void trace \n void trace \n void debug \n void debug \n boolean isInfoEnabled \n Logger getLogger \n boolean isTraceEnabled \n boolean isWarnEnabled \n boolean isDebugEnabled \n void error \n void error \n boolean isFatalEnabled \n void fatal \n void fatal \n void info \n void info", "output": "boolean function ( ) { if ( is12 ) { return getLogger ( ) . isEnabledFor ( ( Priority ) Level . ERROR ) ; } else { return getLogger ( ) . isEnabledFor ( Level . ERROR ) ; } }"}, {"instruction": "Generate java code\ninsert entity without transaction . ", "input": " Object LOCK \n OpenHelper helper \n Map<Class<?>,AbstractModel<?>> modelMap \n Orm orm \n T loadById \n int updateInTx \n int updateInTx \n boolean updateInTx \n AbstractModel<T> getRepository \n boolean update \n boolean delete \n long[] insertInTx \n long[] insertInTx \n long insertInTx \n T rawQuerySingle \n T rawQuerySingle \n int deleteById \n AbstractModel<T> getModelInstanceOrThrow \n Orm getInstance \n int deleteByIdInTx \n int deleteInTx \n int deleteInTx \n boolean deleteInTx \n List<T> rawQuery \n List<T> rawQuery", "output": "long function ( @ NonNull Class < T > arg0 , @ NonNull T arg1 ) { AbstractModel < T > loc0 = getModelInstanceOrThrow ( arg0 ) ; return loc0 . insert ( arg1 ) ; }"}, {"instruction": "Generate java code\nadds a reference to an embedded file . part of the richmediacontent . ", "input": " PdfDictionary richMediaSettings \n PdfArray configurations \n PdfArray views \n HashMap<String,PdfIndirectReference> assetsmap \n PdfDictionary richMediaContent \n PdfIndirectReference richMediaContentReference \n PdfWriter writer \n PdfAnnotation annot \n PdfIndirectReference getRichMediaContentReference \n PdfAnnotation createAnnotation \n void setActivation \n PdfIndirectReference addConfiguration \n PdfIndirectReference addConfiguration \n PdfIndirectReference addView \n PdfIndirectReference addView \n void setDeactivation", "output": "PdfIndirectReference function ( String arg0 , PdfIndirectReference arg1 ) { if ( views == null ) throw new IllegalPdfSyntaxException ( \"srini_string\" ) ; assetsmap . put ( arg0 , arg1 ) ; return arg1 ; }"}, {"instruction": "Generate java code\nreturns current position in output ", "input": " int BUFFER_DEFAULT_LENGTH \n int actualSize \n byte[] buffer \n int position \n void writeInt \n void writeLong \n byte[] getResult \n int getActualSize \n void ensureLength \n void write \n void write \n void write \n int writeString \n void setPosition \n void writeIntAt \n void writeDouble", "output": "int function ( ) { return position ; }"}, {"instruction": "Generate java code\naccess to invoke a method on the class that this fast class handles ", "input": " Class type \n Class[] EMPTY_CLASS_ARRAY \n String getName \n int getIndex \n int getIndex \n int hashCode \n boolean equals \n FastClass create \n Object newInstance \n Object newInstance \n Object newInstance \n String toString \n Class getJavaClass", "output": "Object function ( String arg0 , Class [ ] arg1 , Object arg2 , Object [ ] arg3 ) { return this . invoke ( this . getIndex ( arg0 , arg1 ) , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nreturns whether this save helper did actually save any files . ", "input": " boolean fFilesSaved \n int SAVE_ALL \n int SAVE_REFACTORING \n int fSaveMode \n int SAVE_NOTHING \n int SAVE_ALL_ALWAYS_ASK \n void triggerIncrementalBuild \n ILabelProvider createDialogLabelProvider \n boolean saveEditors \n boolean askSaveAllDirtyEditors", "output": "boolean function ( ) { return fFilesSaved ; }"}, {"instruction": "Generate java code\nadd an integrator to be applied to the bootstrap registry . ", "input": " LinkedHashSet<Integrator> providedIntegrators \n List<ClassLoader> providedClassLoaders \n boolean autoCloseRegistry \n ClassLoaderService providedClassLoaderService \n StrategySelectorBuilder strategySelectorBuilder \n BootstrapServiceRegistryBuilder withStrategySelector \n BootstrapServiceRegistryBuilder with \n BootstrapServiceRegistryBuilder with \n BootstrapServiceRegistryBuilder with \n BootstrapServiceRegistryBuilder applyClassLoader \n BootstrapServiceRegistryBuilder disableAutoClose \n BootstrapServiceRegistryBuilder applyStrategySelector \n BootstrapServiceRegistryBuilder applyClassLoaderService \n BootstrapServiceRegistryBuilder enableAutoClose \n BootstrapServiceRegistry build \n BootstrapServiceRegistryBuilder withStrategySelectors \n BootstrapServiceRegistryBuilder applyStrategySelectors", "output": "BootstrapServiceRegistryBuilder function ( Integrator arg0 ) { providedIntegrators . add ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nsend ws_subscribe command to wsservice to subscribe to topic in websocket . ", "input": " BroadcastReceiver mBroadcastReceiver \n WsManager sInstance \n long mHeartBeatPeriodInMillis \n String mPort \n boolean mIsLogOn \n WsCallbackListeners mWsCallbackListeners \n WsManager setLog \n void unregisterCallback \n void disconnect \n void onWsCloseCallbackListener \n void onWsOpenCallbackListener \n void onReceive \n WsManager setPort \n void call \n WsManager setHeartBeat \n void publish \n void onWsSubscribeCallbackListener \n void onWsCallCallbackListener \n WsManager getWsManager \n void connect \n void registerCallback", "output": "void function ( Context arg0 , String arg1 ) { arg0 . startService ( new Intent ( arg0 , WsService . class ) . putExtra ( Consts . WsConstant . WS_SUBSCRIBE , arg1 ) ) ; }"}, {"instruction": "Generate java code\nthe nin operator is similar to $ in except that it selects objects for which the specified field does not have any value in the specified array . ", "input": " List<Criteria> criteriaChain \n ValueNode left \n ValueNode right \n RelationalOperator criteriaType \n Criteria lt \n Criteria type \n String prefixPath \n Criteria empty \n void checkComplete \n Criteria and \n Criteria gte \n Criteria create \n Criteria where \n Criteria where \n Criteria lte \n Criteria all \n Criteria all \n boolean apply \n Criteria in \n Criteria in \n Criteria is \n Criteria parse \n Criteria eq \n Criteria gt \n Criteria matches \n Criteria regex \n Criteria contains \n Criteria size \n Criteria ne \n Criteria exists \n String toString \n Collection<RelationalExpressionNode> toRelationalExpressionNodes \n Criteria notEmpty", "output": "Criteria function ( Object ... arg0 ) { return nin ( Arrays . asList ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nif the given object is no array , it 's tostring - method is invoked . primitive type - arrays and object - arrays are introspected using java.lang.reflect.array . convention for creation fo string - representation : ", "input": " StringUtil instance \n void listOfArraysToString \n StringUtil instance \n String setSize \n int longestStringRepresentation \n boolean isEmpty \n void toLongestString \n String getNewLine \n String appendSpaces", "output": "String function ( final Object arg0 ) { String loc0 = StringUtil . arrayToString ( arg0 , \"srini_string\" ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturns the change used by this operation . this is either the change passed to the constructor or the one create by the createchangeoperation . method returns null if the create operation did not create a corresponding change or has n't been executed yet . ", "input": " Change fChange \n Change fUndoChange \n boolean fChangeExecutionFailed \n IUndoManager fUndoManager \n boolean fChangeExecuted \n CreateChangeOperation fCreateChangeOperation \n ISchedulingRule fSchedulingRule \n RefactoringStatus fValidationStatus \n String fUndoName \n RefactoringStatus getConditionCheckingStatus \n boolean changeExecutionFailed \n Change getUndoChange \n boolean createChange \n void setUndoManager \n void run \n void executeChange \n void setSchedulingRule \n boolean changeExecuted \n RefactoringStatus getValidationStatus", "output": "Change function ( ) { return fChange ; }"}, {"instruction": "Generate java code\ncurrently defaultkeyfactory returns just first element of list . ", "input": " PlaceHolder placeHolder \n placeholderType placeHolder", "output": "String function ( List < Object > arg0 ) { if ( arg0 . size ( ) != 1 ) throw new RuntimeException ( \"srini_string\" ) ; return ( String ) arg0 . get ( 0 ) ; }"}, {"instruction": "Generate java code\nreturn a base64-encoded string value as a byte array . ", "input": " JSONObject object \n JSONArray parseJSONArray \n JSONArray parseJSONArray \n org.json.simple.JSONArray getArray \n void put \n boolean remove \n void throwIfFieldsMissingOrMisTyped \n Long getTimestamp \n int hashCode \n Object get \n void putAll \n Integer getIntegerSafely \n Boolean getBoolean \n Set<String> keySet \n ExtendedJSONObject parseJSONObject \n ExtendedJSONObject parseJSONObject \n ExtendedJSONObject getObject \n String toJSONString \n Set<Entry<String,Object>> entrySet \n boolean containsKey \n String getString \n ExtendedJSONObject parseUTF8AsJSONObject \n ExtendedJSONObject deepCopy \n long getLong \n Long getLong \n JSONParser getJSONParser \n int size \n boolean equals \n ExtendedJSONObject clone \n Object parseRaw \n Object parseRaw \n String toString \n byte[] getByteArrayHex", "output": "byte [ ] function ( String arg0 ) { String loc0 = ( String ) this . object . get ( arg0 ) ; if ( loc0 == null ) { return null ; } return Base64 . decodeBase64 ( loc0 ) ; }"}, {"instruction": "Generate java code\ngets the value of the translation property . ", "input": " String translation \n Language language \n Language getLanguage \n void setTranslation \n void setLanguage", "output": "String function ( ) { return translation ; }"}, {"instruction": "Generate java code\nprovides a string representation of this instance suitable for human consumption . ", "input": " Date date \n Map<String,String> variantMap \n StatusLine statusLine \n HeaderGroup responseHeaders \n Resource resource \n Date requestDate \n long serialVersionUID \n Date responseDate \n Resource getResource \n Header[] getHeaders \n Header getFirstHeader \n Header[] getAllHeaders \n Map<String,String> getVariantMap \n String getReasonPhrase \n ProtocolVersion getProtocolVersion \n Date getResponseDate \n boolean hasVariants \n Date parseDate \n int getStatusCode \n StatusLine getStatusLine \n Date getDate \n Date getRequestDate", "output": "String function ( ) { return \"srini_string\" + this . requestDate + \"srini_string\" + this . responseDate + \"srini_string\" + this . statusLine + \"srini_string\" ; }"}, {"instruction": "Generate java code\nreturns how close randoop is to being done , as a percentage between 0 and 100 . ", "input": " int sequencesGenerated \n double percentDone \n int errorsRevealed \n long serialVersionUID \n int getSequencesGenerated \n int getNumErrors", "output": "double function ( ) { return percentDone ; }"}, {"instruction": "Generate java code\nmoves pos and lookat forward in the map plane ", "input": " VectorXYZ pos \n VectorXYZ lookAt \n VectorXYZ up \n void moveMapRight \n void setCamera \n void setCamera \n void moveForward \n void move \n void move \n void roll \n VectorXYZ getUp \n void yaw \n void moveMapUp \n void setPos \n void setPos \n void mapPitch \n VectorXYZ getRight \n void setLookAt \n void setLookAt \n VectorXYZ getViewDirection \n VectorXYZ getPos \n void moveRight \n VectorXYZ getLookAt \n String toString \n void pitch \n void rotateY \n void moveUp", "output": "void function ( double arg0 ) { VectorXYZ loc0 = getViewDirection ( ) ; VectorXZ loc1 = new VectorXZ ( loc0 . x , loc0 . z ) . normalize ( ) ; move ( loc1 . x * arg0 , 0 , loc1 . z * arg0 ) ; }"}, {"instruction": "Generate java code\ncreate a graph . this is just another method for creating the graph data structure . ", "input": " Vertex[] nodes \n int CONST_m1 \n int CONST_b \n int RANGE \n int random \n int mult \n void addEdges \n int computeDist \n Vertex firstNode", "output": "void function ( int arg0 ) { nodes = new Vertex [ arg0 ] ; Vertex loc0 = null ; for ( int loc1 = arg0 - 1 ; loc1 >= 0 ; loc1 -- ) { Vertex loc2 = nodes [ loc1 ] = new Vertex ( loc0 , arg0 ) ; loc0 = loc2 ; } addEdges ( arg0 ) ; }"}, {"instruction": "Generate java code\nconvert the abstract location into a concrete area , relative to the given component . if a point has been specified , returns a 1x1 rectangle , otherwise returns the a rectangle at 0 , 0 of the component 's size . ", "input": " Point where \n String CENTER \n Point getPoint \n boolean isValue \n String badFormat \n boolean equals \n String toString \n boolean isIndex \n String parseValue \n ComponentLocation parse \n int parseIndex \n String encodeIndex \n String encodeValue", "output": "Rectangle function ( Component arg0 ) { if ( where == null ) return new Rectangle ( 0 , 0 , arg0 . getWidth ( ) , arg0 . getHeight ( ) ) ; return new Rectangle ( where . x , where . y , 1 , 1 ) ; }"}, {"instruction": "Generate java code\nreturns a boolean indicating if the x ordinate value of the projcoordinate provided as an ordinate is equal to the x ordinate value of this projcoordinate . because we are working with floating point numbers the ordinates are considered equal if the difference between them is less than the specified tolerance . ", "input": " DecimalFormat DECIMAL_FORMAT \n double x \n String DECIMAL_FORMAT_PATTERN \n double y \n double z \n String toShortString \n boolean areZOrdinatesEqual \n boolean hasValidZOrdinate \n int hashCode \n int hashCode \n void setValue \n void setValue \n void setValue \n boolean areYOrdinatesEqual \n boolean equals \n String toString \n boolean hasValidXandYOrdinates \n void clearZ", "output": "boolean function ( ProjCoordinate arg0 , double arg1 ) { double loc0 = arg0 . x - this . x ; if ( loc0 > arg1 ) { return false ; } else { return true ; } }"}, {"instruction": "Generate java code\ndetermines if a candidate reflectclass is a collection ", "input": " GenericArrayReflector _array \n Collection4 _collectionPredicates \n Hashtable4 _classByClass \n ObjectContainerBase _stream \n KnownClassesRepository _repository \n Transaction _trans \n Reflector _delegate \n void setTransaction \n void registerCollection \n void registerCollection \n ReflectClass forName \n ReflectClass[] knownClasses \n void configuration \n GenericClass ensureDelegate \n GenericClass genericClass \n Reflector getDelegate \n ReflectClassPredicate classPredicate \n void registerPrimitiveClass \n boolean hasTransaction \n ReflectArray array \n Object deepClone \n ReflectClass forClass \n ReflectClass forGenericObject \n ObjectContainerBase getStream \n ReflectClass forObject \n void setParent \n T withLock \n void register", "output": "boolean function ( ReflectClass arg0 ) { Iterator4 loc0 = _collectionPredicates . iterator ( ) ; while ( loc0 . moveNext ( ) ) { if ( ( ( ReflectClassPredicate ) loc0 . current ( ) ) . match ( arg0 ) ) { return true ; } } return _delegate . isCollection ( arg0 . getDelegate ( ) ) ; }"}, {"instruction": "Generate java code\ndecrypt the encrypted jwt ", "input": " List<String> audiences \n Object decryptionKey \n boolean signed \n Object verifyKey \n boolean verifyAudiences \n AuthToken decodeFromBytes \n boolean verifyToken \n boolean isSigned \n JWSVerifier getVerifier \n AuthToken decodeFromString \n void setDecryptionKey \n void setDecryptionKey \n JWEDecrypter getDecrypter \n void setAudiences \n boolean verifySignedJWT \n boolean verifyExpiration \n void setVerifyKey \n void setVerifyKey", "output": "void function ( EncryptedJWT arg0 ) { try { JWEDecrypter loc0 = getDecrypter ( ) ; arg0 . decrypt ( loc0 ) ; } catch ( JOSEException | KrbException loc0 ) { throw new IOException ( \"srini_string\" , loc0 ) ; } }"}, {"instruction": "Generate java code\nis this instant after the millisecond instant passed in comparing solely by millisecond . ", "input": " PlaceHolder placeHolder \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n MutableDateTime toMutableDateTime \n Date toDate \n boolean isEqual \n boolean isEqual \n DateTimeZone getZone \n boolean isSupported \n int compareTo \n boolean isBeforeNow \n Instant toInstant \n boolean isBefore \n boolean isBefore \n boolean isEqualNow \n MutableDateTime toMutableDateTimeISO \n DateTime toDateTimeISO \n int hashCode \n int get \n int get \n boolean equals \n String toString \n String toString \n DateTime toDateTime \n DateTime toDateTime \n DateTime toDateTime \n boolean isAfterNow", "output": "boolean function ( long arg0 ) { return ( getMillis ( ) > arg0 ) ; }"}, {"instruction": "Generate java code\nset to allow tcp or not . ", "input": " KdcConfig kdcConfig \n BackendConfig backendConfig \n InternalKdcServer innerKdc \n KOptions startupOptions \n KdcSetting kdcSetting \n void init \n void enableDebug \n void setKdcHost \n void setKdcRealm \n KdcSetting getKdcSetting \n void setKdcTcpPort \n void start \n void setInnerKdcImpl \n BackendConfig getBackendConfig \n void stop \n IdentityBackend getIdentityService \n void setKdcUdpPort \n void setWorkDir \n KdcConfig getKdcConfig \n void setKdcPort \n void setAllowUdp", "output": "void function ( boolean arg0 ) { startupOptions . add ( KdcServerOption . ALLOW_TCP , arg0 ) ; }"}, {"instruction": "Generate java code\nchecking if the value of y is larger than variable ground . ", "input": " int HEIGHT \n int JUMP \n int x \n int y \n int ground \n int WIDTH \n int moveY \n int DOWN \n boolean isPassed \n void draw \n void down \n void jump", "output": "boolean function ( ) { if ( y > ground - 5 ) { y = ground + 5 ; return true ; } else { return false ; } }"}, {"instruction": "Generate java code\ninitializes resources . this must be called before dashboardresources #getresources . this allows us to avoid an evil static initializer that would pollute all the getresources call sites . ", "input": " Resources resources \n String graphOuterDiv \n Resources getResources \n Css dashboardCss", "output": "void function ( ) { resources = GWT . create ( Resources . class ) ; StyleInjector . inject ( resources . dashboardCss ( ) . getText ( ) + resources . latencyDashboardChartCss ( ) . getText ( ) + resources . rightPieChartCss ( ) . getText ( ) + resources . warningPaneCss ( ) . getText ( ) ) ; }"}, {"instruction": "Generate java code\nreturns a scheduledexecutorservice that wraps ables before submission to the passed in scheduledexecutorservice . ", "input": " Field causeField \n void handleException \n StackTraceElement[] getStackContext \n Throwable findRootCause \n Callable<T> makeContextCallable \n Runnable makeContextRunnable \n List<Callable<T>> makeContextWrappedCollection", "output": "ScheduledExecutorService function ( final ScheduledExecutorService arg0 ) { return new ContextScheduledExecutorService ( arg0 ) ; }"}, {"instruction": "Generate java code\nattempts to transform the object against the map of numbertransformers . otherwise it returns double.nan . ", "input": " NumberTransformer defaultTransformer \n Map map \n long serialVersionUID \n boolean containsTransformer \n Collection transformers \n NumberTransformer getTransformer \n Set classes \n void clear \n Object removeTransformer \n boolean containsClass \n Object putTransformer", "output": "double function ( Object arg0 ) { double loc0 = Double . NaN ; if ( arg0 instanceof Number || arg0 instanceof String ) { loc0 = defaultTransformer . transform ( arg0 ) ; } else { NumberTransformer loc1 = getTransformer ( arg0 . getClass ( ) ) ; if ( loc1 != null ) { loc0 = loc1 . transform ( arg0 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nreturns a transaction id which is based on tid calculated the same all the time . variables which are part of the calculation are inet local host address . xid format is static value 4660 . ", "input": " byte[] gtrid \n int formatId \n byte[] localIP \n byte[] bqual \n int txnUniqueID \n byte[] getGlobalTransactionId \n int getFormatId \n Xid getXid \n int hashCode \n byte[] getBranchQualifier \n boolean equals \n String toString \n Xid getUniqueXid", "output": "Xid function ( int arg0 ) { int loc0 = 0 ; int loc1 = arg0 ; int loc2 = 42 ; return getXid ( loc0 , loc1 , loc2 ) ; }"}, {"instruction": "Generate java code\nlock the chain so no more iterators can be added . this must be called from all iterator interface methods . ", "input": " Iterator lastUsedIterator \n boolean isLocked \n Iterator currentIterator \n List iteratorChain \n int currentIteratorIndex \n Object next \n void checkLocked \n int size \n void addIterator \n boolean isLocked \n boolean hasNext \n List getIterators \n void setIterator \n void updateCurrentIterator \n void remove", "output": "void function ( ) { if ( isLocked == false ) { isLocked = true ; } }"}, {"instruction": "Generate java code\nadds a return . ", "input": " List<NativeSQLQueryReturn> queryReturns \n String name \n String getName \n NativeSQLQueryReturn[] getQueryReturns \n String traceLoggableFormat", "output": "void function ( NativeSQLQueryReturn arg0 ) { queryReturns . add ( arg0 ) ; }"}]