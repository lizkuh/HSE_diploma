[{"instruction": "Generate java code\nactually walks the bag to make sure the count is correct and resets the running total ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n\n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "int function ( ) { _total = extractList ( ) . size ( ) ; return _total ; }"}, {"instruction": "Generate java code\ncontrols whether the compiler should perform statements recovery . to be effective , this method must be called before any of #getroot , #getastrewrite , #getimportremover . this method has no effect if the target object has been created with #compilationunitrewrite icompilationunit , compilationunit . defaults to true do perform statements recovery . ", "input": " ImportRewrite fImportRewrite \n ImportRemover fImportRemover \n WorkingCopyOwner fOwner \n ASTRewrite fRewrite \n boolean fStatementsRecovery \n List<TextEditGroup> fTextEditGroups \n ICompilationUnit fCu \n IDocument fRememberContent \n CompilationUnit fRoot \n boolean fResolveBindings \n boolean fBindingsRecovery \n\n void clearASTRewrite \n ASTRewrite getASTRewrite \n void rememberContent \n AST getAST \n void setBindingRecovery \n ImportRemover getImportRemover \n CompilationUnitChange createChange \n org.eclipse.jdt.internal.corext.refactoring.changes.CompilationUnitChange createChange \n CompilationUnitChange createChange \n CompilationUnitChange createChange \n void clearASTAndImportRewrites \n CompilationUnitChange attachChange \n CategorizedTextEditGroup createCategorizedGroupDescription \n TextEditGroup createGroupDescription \n void setResolveBindings \n ImportRewrite getImportRewrite \n ICompilationUnit getCu \n void clearImportRewrites \n void clearGroupDescriptionEdits \n CompilationUnit getRoot \n boolean isEmptyEdit", "output": "void function ( boolean arg0 ) { fStatementsRecovery = arg0 ; }"}, {"instruction": "Generate java code\noverride and return true for database updates that produce changed class metadata ", "input": " String _db4oVersion \n byte _db4oHeaderVersion \n\n String fileName \n String fileName \n String getTempPath \n void runDefrag \n void checkDatabaseFile \n void update \n int db4oMajorVersion \n void checkUpdatedDatabaseFile \n void investigateFileHeaderVersion \n boolean isApplicableForDb4oVersion \n void withDatabase \n void deconfigure \n void setUp \n String fileNamePrefix \n void assertObjectDeletion \n void assertObjectsAreReadable \n String databasePath \n void configureForStore \n void test \n void test \n void deconfigureForStore \n void configure \n void store \n void deconfigureForTest \n void tearDown \n void configureForTest \n void storeObject \n void createDatabase \n void createDatabase \n void assertObjectsAreUpdated \n void updateDatabaseFile \n String oldVersionFileName \n void createDatabaseFor \n byte db4oHeaderVersion \n int db4oMinorVersion \n String[] versionNames \n void runDeletionTests", "output": "boolean function ( ) { return false ; }"}, {"instruction": "Generate java code\nget identity znode . ", "input": " String ENCRYPTION_KEY_NO_ZNODE_NAME \n String KEY_VERSION_ZNODE_NAME \n String PRINCIPAL_NAME_ZNODE_NAME \n String baseZNode \n String CREATED_TIME_ZNODE_NAME \n String KDC_FLAGS_ZNODE_NAME \n String DISABLED_ZNODE_NAME \n String KEYS_ZNODE_NAME \n String IDENTITIES_ZNODE_NAME \n String KEY_ZNODE_NAME \n String EXPIRE_TIME_ZNODE_NAME \n String KEY_TYPE_ZNODE_NAME \n String LOCKED_ZNODE_NAME \n\n String getEncryptionKeyTypeZNode \n String getBaseZNode \n String getDisabledZNode \n String getKeyTypeZNode \n String getEncryptionKeyNoZNode \n String getEncryptionKeyZNode \n String getLockedZNode \n String getCreatedTimeZNode \n String getExpireTimeZNode \n String getKeyVersionZNode \n String getKeysZNode \n String getIdentitiesZNode \n List<String> getIdentityNames \n String getPrincipalNameZnode \n String getKdcFlagsZNode", "output": "String function ( String arg0 ) { return ZKUtil . joinZNode ( getIdentitiesZNode ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\ncompareto , lexicogaphical comparison . ", "input": " List<C> val \n Logger logger \n GenVectorModul<C> modul \n\n int signum \n GenVector<C> leftLinearCombination \n GenVector<C> rightScalarProduct \n GenVector<C> subtract \n GenVector<C> scalarMultiply \n GenVector<C> sum \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> leftScalarMultiply \n C scalarProduct \n GenVector<C> scalarProduct \n GenVector<C> abs \n int hashCode \n GenVector<C> negate \n boolean equals \n GenVector<C> clone \n boolean isZERO \n String toString", "output": "int function ( GenVector < C > arg0 ) { if ( ! modul . equals ( arg0 . modul ) ) { return - 1 ; } List < C > loc0 = arg0 . val ; int loc1 = 0 ; for ( C loc2 : val ) { int loc3 = loc2 . compareTo ( loc0 . get ( loc1 ++ ) ) ; if ( loc3 != 0 ) { return loc3 ; } } return 0 ; }"}, {"instruction": "Generate java code\nsets the tag position if one is associated with the nls element . ", "input": " Region fTagPosition \n String TAG_POSTFIX \n AccessorClassReference fAccessorClassReference \n boolean fIsEclipseNLS \n int TAG_PREFIX_LENGTH \n String TAG_PREFIX \n int fIndex \n int TAG_POSTFIX_LENGTH \n String fValue \n Region fPosition \n\n String getValue \n Region getPosition \n boolean isEclipseNLS \n boolean hasTag \n void setAccessorClassReference \n AccessorClassReference getAccessorClassReference \n void setValue \n String createTagText \n String getTagText \n String toString \n Region getTagPosition", "output": "void function ( int arg0 , int arg1 ) { fTagPosition = new Region ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nconvenience method to find a zero of a univariate real function . a default solver is used . ", "input": " UnivariateRealSolverFactory factory \n\n double[] bracket \n double[] bracket \n double midpoint \n void setup", "output": "double function ( UnivariateRealFunction arg0 , double arg1 , double arg2 ) { setup ( arg0 ) ; return factory . newDefaultSolver ( arg0 ) . solve ( arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\ndo we get multiple clicks even when the individual clicks are on different frames ? ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n\n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isWindows ( ) || Platform . isOSX ( ) || Platform . JAVA_VERSION < Platform . JAVA_1_3 ; }"}, {"instruction": "Generate java code\ngets the fractional second precision of the type qualifier of the interval data type descriptor of this field iff interval type . gets the interval type descriptor 's fractional second precision iff interval type . ", "input": " SqlIntervalQualifier intervalQualifier \n Integer precision \n Boolean isNullable \n String name \n Integer scale \n List<String> workspaceSchemaPath \n List<FieldType> fields \n SqlTypeName type \n String sql \n\n String getName \n String getName \n boolean isDynamic \n List<String> getWorkspaceSchemaPath \n SqlIntervalQualifier getIntervalQualifier \n boolean hasStar \n TimeUnit getEndUnit \n RelDataType getRowType \n Integer getPrecision \n void setSql \n String getSql \n TimeUnit getStartUnit \n List<FieldType> getFields \n Integer getScale \n SqlTypeName getType \n Boolean getIsNullable", "output": "Integer function ( ) { return null == intervalQualifier ? null : intervalQualifier . getFractionalSecondPrecisionPreservingDefault ( ) ; }"}, {"instruction": "Generate java code\nconvert drawable to byte array ", "input": " PlaceHolder placeHolder \n\n Drawable bitmapToDrawable \n void closeInputStream \n Bitmap drawableToBitmap \n Bitmap byteToBitmap \n Bitmap getBitmapFromUrl \n Bitmap getBitmapFromUrl \n Bitmap scaleImage \n byte[] bitmapToByte \n Bitmap scaleImageTo \n Drawable byteToDrawable \n Drawable getDrawableFromUrl \n Drawable getDrawableFromUrl \n InputStream getInputStreamFromUrl \n InputStream getInputStreamFromUrl", "output": "byte [ ] function ( Drawable arg0 ) { return bitmapToByte ( drawableToBitmap ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nresets migration flag . should only be used in tests . ", "input": " String APP_PREFS_NAME \n String PROFILE_PREFS_NAME_PREFIX \n String[] PROFILE_MIGRATIONS_0_TO_1 \n EnumSet<Flags> disableMigrations \n boolean migrationDone \n int PREFS_VERSION \n String LOGTAG \n String PREFS_VERSION_KEY \n\n int getVersion \n void migrateIfNecessary \n SharedPreferences forApp \n SharedPreferences forApp \n Editor migrateFromPreferenceManager \n void performMigration \n SharedPreferences forProfile \n SharedPreferences forProfile \n SharedPreferences forProfileName \n SharedPreferences forProfileName \n void putEntry", "output": "void function ( ) { migrationDone = false ; }"}, {"instruction": "Generate java code\ncomment f1z ", "input": " int I1z \n int I2z \n int I1 \n int I3 \n int I2 \n int I4 \n\n void fz \n void f \n void f11 \n void f1 \n void f2", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ncreates a dialog to present a refactoringstatus to the user . thefollowing values are returned from the dialogs open method : org.eclipse.jface.dialogs.idialogconstants #ok_id idialogconstants #ok_id : if the user has pressed the continue button . org.eclipse.jface.dialogs.idialogconstants #cancel_id idialogconstants #cancel_id : if the user has pressed the cancel button . org.eclipse.jface.dialogs.idialogconstants #back_id idialogconstants #back_id : if the user has pressed the back button . ", "input": " PlaceHolder placeHolder \n\n Dialog createRefactoringWizardDialog \n Composite createRefactoringHistoryControl \n Composite createSortableRefactoringHistoryControl \n PerformChangeOperation createUIAwareChangeOperation \n Dialog createLightWeightStatusDialog", "output": "Dialog function ( RefactoringStatus arg0 , Shell arg1 , String arg2 , boolean arg3 ) { return new RefactoringStatusDialog ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\ngets the current stroke color ", "input": " boolean knockout \n LineDashPattern lineDashPattern \n BaseColor fillColor \n float wordSpacing \n float leading \n BaseColor strokeColor \n int lineJoinStyle \n float miterLimit \n int lineCapStyle \n float lineWidth \n int renderMode \n PdfName colorSpaceFill \n PdfName colorSpaceStroke \n float fontSize \n float rise \n Matrix ctm \n float horizontalScaling \n float characterSpacing \n CMapAwareDocumentFont font \n\n float getFontSize \n int getRenderMode \n void setLineDashPattern \n int getLineJoinStyle \n PdfName getColorSpaceStroke \n float getCharacterSpacing \n void setLineWidth \n Matrix getCtm \n void setLineCapStyle \n PdfName getColorSpaceFill \n float getMiterLimit \n float getLineWidth \n float getWordSpacing \n boolean isKnockout \n BaseColor getFillColor \n CMapAwareDocumentFont getFont \n void setMiterLimit \n float getRise \n int getLineCapStyle \n float getLeading \n LineDashPattern getLineDashPattern \n float getHorizontalScaling \n void setLineJoinStyle", "output": "BaseColor function ( ) { return strokeColor ; }"}, {"instruction": "Generate java code\ntest method for org.jboss.security.config.securityconfiguration #getapplicationpolicy java.lang.string . ", "input": " PlaceHolder placeHolder \n\n void testGetCipherAlgorithm \n void testSetIterationCount \n void testGetKeyStoreURL \n void testGetSalt \n void testGetTrustStoreType \n void testGetKeyStoreType \n void testSetTrustStoreURL \n void testSetKeyStoreURL \n void testSetSalt \n void testLoadPassword \n void testSetCipherSpec \n void testGetExternalPasswordCacheInstance \n void testSetKeyStoreType \n void testIsDeepCopySubjectMode \n void testGetKeyStorePass \n WebArchive deployment \n void testSetTrustStorePass \n void testGetTrustStorePass \n void testSetCipherAlgorithm \n void testSetTrustStoreType \n void testGetTrustStoreURL \n void testSetDeepCopySubjectMode \n void testGetCipherSpec \n void testAddApplicationPolicy \n void testSetKeyStorePass \n void testRemoveApplicationPolicy \n void testSetCipherKey \n void testGetIterationCount \n void testGetCipherKey", "output": "void function ( ) { SecurityConfiguration . getApplicationPolicy ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncopy method ", "input": " PlaceHolder placeHolder \n\n void validateMin2 \n void validate \n Predicate[] validate \n void validate \n void validate", "output": "Transformer [ ] function ( Transformer [ ] arg0 ) { if ( arg0 == null ) { return null ; } return ( Transformer [ ] ) arg0 . clone ( ) ; }"}, {"instruction": "Generate java code\nabre el libro y retorna el marcador con la pagina actual ", "input": " String dimensiones \n int numeroPaginas \n String titulo \n String colorPortada \n String autor \n int marcador \n\n void setColorPortada \n void setDimensiones \n String getColorPortada \n String getAutor \n void setTitulo \n int cerrar \n String getTitulo \n void setNumeroPaginas \n int getNumeroPaginas \n int leer \n String getDimensiones \n void setMarcador \n int escribir \n void setAutor \n Libro clone \n String toString \n int getMarcador", "output": "int function ( ) { return this . getMarcador ( ) ; }"}, {"instruction": "Generate java code\nreturns the element surrounding the selection of the given editor . ", "input": " IJavaElement[] EMPTY_RESULT \n\n IJavaElement selectJavaElement \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] performForkedCodeResolve \n boolean canOperateOn \n IStructuredSelection getStructuredSelection \n IClassFile getInputAsClassFile \n IJavaElement[] codeResolveForked \n ITypeRoot getInput \n ITypeRoot getInput \n IType getTypeAtOffset \n IJavaElement[] codeResolveOrInputForked \n ICompilationUnit getInputAsCompilationUnit \n IJavaElement[] getElements \n IJavaElement resolveEnclosingElement \n IJavaElement resolveEnclosingElement", "output": "IJavaElement function ( JavaEditor arg0 , boolean arg1 ) { ITypeRoot loc0 = getInput ( arg0 , arg1 ) ; if ( loc0 != null ) return getElementAtOffset ( loc0 , ( ITextSelection ) arg0 . getSelectionProvider ( ) . getSelection ( ) ) ; return null ; }"}, {"instruction": "Generate java code\ncoordinates building a loadplan that defines just a single root entity return may have fetches . typically this includes building load plans for entity loading or cascade loading . ", "input": " PlaceHolder placeHolder \n\n LoadPlan buildRootCollectionLoadPlan", "output": "LoadPlan function ( LoadPlanBuildingAssociationVisitationStrategy arg0 , EntityPersister arg1 ) { MetamodelGraphWalker . visitEntity ( arg0 , arg1 ) ; return arg0 . buildLoadPlan ( ) ; }"}, {"instruction": "Generate java code\ncompute a single body-body or body-cell interaction ", "input": " MathVector acc0 \n MathVector pos \n double mass \n int IMAX \n MathVector pos0 \n double phi0 \n double EPS \n Body pskip \n\n Node loadTree \n int oldSubindex \n String toString \n double hackcofm \n HG walkSubTree", "output": "HG function ( HG arg0 ) { MathVector loc0 = new MathVector ( ) ; loc0 . subtraction ( pos , arg0 . pos0 ) ; double loc1 = loc0 . dotProduct ( ) + ( EPS * EPS ) ; double loc2 = Math . sqrt ( loc1 ) ; double loc3 = mass / loc2 ; arg0 . phi0 -= loc3 ; double loc4 = loc3 / loc1 ; loc0 . multScalar ( loc4 ) ; arg0 . acc0 . addition ( loc0 ) ; return arg0 ; }"}, {"instruction": "Generate java code\nset the name of the catalog to be searched , ornull to search the default catalog . ", "input": " String name \n String catalogName \n boolean optional \n String nameKey \n\n void setName \n String getNameKey \n String getName \n void setNameKey \n String getCatalogName \n boolean postprocess \n Command getCommand \n boolean isOptional \n boolean execute \n void setOptional", "output": "void function ( String arg0 ) { this . catalogName = arg0 ; }"}, {"instruction": "Generate java code\nreturn an iterator over values in a column . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n\n ColumnMetaData[] getColumnMetaData \n ColumnMetaData getColumnMetaData \n ColumnMetaData getColumnMetaData \n long getRowCount \n List<ColumnMetaData> getRoots \n void readColumnMetaData \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n ColumnFileMetaData getMetaData \n void readHeader \n void readMagic \n void close", "output": "ColumnValues < T > function ( int arg0 ) { return new ColumnValues < T > ( columns [ arg0 ] ) ; }"}, {"instruction": "Generate java code\nwhen the login machine terminates , we might not be in the married state , and therefore we ca n't sync . this method messages as much to the user . to avoid stopping us syncing altogether , we set a soft error rather than a hard error . in future , we would like to set a hard error if we are in , for example , the separated state , and then have some user initiated activity mark the android account as ready to sync again . this is tricky , though , so we play it safe for now . ", "input": " BlockingQueue<Result> latch \n SyncResult syncResult \n\n void setSyncResultSuccess \n void postponeSync \n void setSyncResultSoftError \n void handleError \n void handleSuccess \n void rejectSync \n void setSyncResultHardError", "output": "void function ( State arg0 ) { setSyncResultSoftError ( ) ; latch . offer ( Result . Error ) ; }"}, {"instruction": "Generate java code\nconverts the handle . handle need not exist , but must be a source reference . ", "input": " IType fOldType \n IType fNewType \n Map<IJavaElement,String> fRefactoredSimilarElements \n\n IMember resolveTypeInMember \n String resolveTypeName \n IMember[] convertElements \n void addElements \n String[] resolveParameterTypes \n String resolveElementName \n String replaceAll", "output": "IMember function ( IMember arg0 ) { final LinkedList < IMember > loc0 = new LinkedList < > ( ) ; addElements ( arg0 , loc0 ) ; final IMember [ ] loc1 = convertElements ( loc0 . toArray ( new IMember [ 0 ] ) ) ; return loc1 [ loc1 . length - 1 ] ; }"}, {"instruction": "Generate java code\nreturns the sampleduration of the track in seconds . ", "input": " Buffer outputBuffer \n Codec codec \n Buffer inputBuffer \n ArrayList<VideoTrack> tracks \n String nameFormat \n Format videoFormat \n int count \n int width \n Format fileFormat \n File dir \n int height \n\n boolean isVFRSupported \n Format getFileFormat \n boolean isEmpty \n void writeSamples \n int getTrackCount \n int addTrack \n int addVideoTrack \n void writeSample \n boolean isDataLimitReached \n Format getFormat \n void createCodec \n void write \n void write \n void close", "output": "Rational function ( int arg0 ) { VideoTrack loc0 = tracks . get ( arg0 ) ; return new Rational ( loc0 . count , 30 ) ; }"}, {"instruction": "Generate java code\ndoes a popularity reorder on this document set . ", "input": " boolean configured \n Distribution reorderIntvlDist \n boolean useRanks \n double zipfExp \n long meanReorderIntvl \n RandomGenerator rand \n String name \n ZipfDistribution dist \n int startRank \n Logger log \n List<Integer> keyPopularity \n int size \n\n void setName \n String getName \n int getKeyForPublish \n void checkConfigure \n void setMeanReorderIntvl \n void setZipfExp \n void configure \n int getSize \n boolean containsResourcesOf \n void setSize \n Distribution getReorderDistribution \n int getKeyForLookup \n void setBeginRank", "output": "void function ( ) { int loc0 = rand . nextInt ( size ) ; int loc1 = rand . nextInt ( size ) ; log . debug ( \"srini_string\" + Simulator . getCurrentTime ( ) + \"srini_string\" + loc0 + \"srini_string\" + loc1 ) ; keyPopularity . add ( loc1 , keyPopularity . remove ( loc0 ) ) ; getKeyForLookup ( ) ; }"}, {"instruction": "Generate java code\ngets the child scripts that make up this block . this list is live so that it can be modified if requried ", "input": " List list \n\n void addScript \n Script compile \n void trimWhitespace \n String toString \n void run \n void removeScript", "output": "List function ( ) { return list ; }"}, {"instruction": "Generate java code\nanalyzes if the given resource is the best matching for the given release . returns true if so , false otherwise . ", "input": " ResourceReleaseComparator resourceReleaseComparator \n\n List<ResourceEntity> getAllFutureReleases \n int compare \n boolean isBestMatchingPastReleaseTime \n Set<ResourceEntity> getResourceEntitiesByRelease \n Boolean isBestMatchingFutureReleaseTime \n Set<ConsumedResourceRelationEntity> getConsumedMasterRelationsForRelease \n Set<ProvidedResourceRelationEntity> getProvidedMasterRelationsForRelease \n Set<ResourceEntity> getConsumedRelatedResourcesByResourceType \n Set<ProvidedResourceRelationEntity> getProvidedSlaveRelationsForRelease \n ReleaseEntity findMostRelevantRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity findMostRelevantResource", "output": "boolean function ( @ NotNull ResourceEntity arg0 , @ NotNull ReleaseEntity arg1 ) { return arg0 . equals ( getResourceEntityForRelease ( arg0 . getResourceGroup ( ) , arg1 ) ) ; }"}, {"instruction": "Generate java code\nget the docker rest uri . ", "input": " String address \n int port \n String host \n String DEFAULT_HOST \n String DEFAULT_UNIX_ENDPOINT \n int DEFAULT_PORT \n URI uri \n String dockerCertPath \n\n int defaultPort \n DockerHost fromEnv \n String address \n int port \n String host \n DockerHost from \n String toString \n String dockerCertPath", "output": "URI function ( ) { return uri ; }"}, {"instruction": "Generate java code\ngets the value of the getcontentlanguage property . ", "input": " Owner owner \n PrincipalURL principalURL \n Creationdate creationdate \n Getlastmodified getlastmodified \n Getcontentlanguage getcontentlanguage \n Getetag getetag \n Getcontentlength getcontentlength \n SupportedReportSet supportedReportSet \n Acl acl \n PrincipalCollectionSet principalCollectionSet \n Resourcetype resourcetype \n List<Element> any \n QuotaUsedBytes quotaUsedBytes \n Lockdiscovery lockdiscovery \n QuotaAvailableBytes quotaAvailableBytes \n Getcontenttype getcontenttype \n Displayname displayname \n Supportedlock supportedlock \n Group group \n\n PrincipalCollectionSet getPrincipalCollectionSet \n Creationdate getCreationdate \n void setCreationdate \n void setQuotaAvailableBytes \n Getcontentlength getGetcontentlength \n Displayname getDisplayname \n void setGetcontenttype \n void setAcl \n Owner getOwner \n Getlastmodified getGetlastmodified \n Supportedlock getSupportedlock \n void setLockdiscovery \n void setOwner \n SupportedReportSet getSupportedReportSet \n void setSupportedReportSet \n void setSupportedlock \n void setPrincipalCollectionSet \n QuotaUsedBytes getQuotaUsedBytes \n Acl getAcl \n void setQuotaUsedBytes \n void setPrincipalURL \n PrincipalURL getPrincipalURL \n void setGetetag \n Resourcetype getResourcetype \n void setResourcetype \n Getetag getGetetag \n void setGroup \n Getcontenttype getGetcontenttype \n Group getGroup \n void setGetcontentlanguage \n Lockdiscovery getLockdiscovery \n void setGetlastmodified \n QuotaAvailableBytes getQuotaAvailableBytes \n void setDisplayname \n void setGetcontentlength \n List<Element> getAny", "output": "Getcontentlanguage function ( ) { return getcontentlanguage ; }"}, {"instruction": "Generate java code\nindicates whether or not the factory is configured to produce parsers which converts cdata nodes to text nodes and appends it to the adjacent if any text node . ", "input": " boolean validating \n boolean namespaceAware \n boolean whitespace \n boolean expandEntityRef \n boolean coalescing \n boolean ignoreComments \n\n void setCoalescing \n boolean isIgnoringElementContentWhitespace \n void setIgnoringElementContentWhitespace \n boolean isNamespaceAware \n void setNamespaceAware \n DocumentBuilderFactory newInstance \n boolean isValidating \n void setAttribute \n Object getAttribute \n boolean isExpandEntityReferences \n DocumentBuilder newDocumentBuilder \n void setValidating \n void setIgnoringComments \n void setExpandEntityReferences \n boolean isIgnoringComments", "output": "boolean function ( ) { return coalescing ; }"}, {"instruction": "Generate java code\ngets the number of persistent connections tracked by the connection manager currently being used to execute requests . the total number of connections in the pool is equal to available plus leased . ", "input": " int leased \n int max \n int pending \n int available \n\n int getMax \n String toString \n int getPending \n int getAvailable", "output": "int function ( ) { return this . leased ; }"}, {"instruction": "Generate java code\nlog an error to the log4j logger with error priority . ", "input": " String name \n boolean is12 \n Logger logger \n String FQCN \n\n void warn \n void warn \n void trace \n void trace \n void debug \n void debug \n boolean isInfoEnabled \n boolean isErrorEnabled \n Logger getLogger \n boolean isTraceEnabled \n boolean isWarnEnabled \n boolean isDebugEnabled \n boolean isFatalEnabled \n void fatal \n void fatal \n void info \n void info", "output": "void function ( Object arg0 , Throwable arg1 ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . ERROR , arg0 , arg1 ) ; } else { getLogger ( ) . log ( FQCN , Level . ERROR , arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nreturns the first child element of a node that matches the given tag name . ", "input": " PlaceHolder placeHolder \n\n List<Element> getAllChildElemsMatching", "output": "Element function ( Node arg0 , String arg1 ) { NodeList loc0 = arg0 . getChildNodes ( ) ; for ( int loc1 = 0 ; loc1 < loc0 . getLength ( ) ; loc1 ++ ) { Node loc2 = loc0 . item ( loc1 ) ; if ( loc2 . getNodeType ( ) == Node . ELEMENT_NODE && arg1 . equals ( loc2 . getNodeName ( ) ) ) return ( Element ) loc2 ; } return null ; }"}, {"instruction": "Generate java code\ngets the value of the fclink property . ", "input": " String fcLink \n String localPortID \n String displayName \n String fcKey \n ProvidedPortID id \n List<PropertyDeclaration> properties \n String resourceType \n\n String getFcKey \n String getDisplayName \n List<PropertyDeclaration> getProperties \n void setFcKey \n String getResourceType \n void setFcLink \n String getLocalPortID \n void setResourceType \n void setId \n ProvidedPortID getId \n void setLocalPortID \n void setDisplayName", "output": "String function ( ) { return fcLink ; }"}, {"instruction": "Generate java code\nchecks if this pdfobject is of the type pdfdictionary . ", "input": " int INDIRECT \n int STRING \n int DICTIONARY \n int NULL \n int NUMBER \n int type \n int NAME \n String NOTHING \n int BOOLEAN \n int ARRAY \n byte[] bytes \n String TEXT_UNICODE \n String TEXT_PDFDOCENCODING \n PRIndirectReference indRef \n int STREAM \n\n void toPdf \n void setContent \n void setIndRef \n int length \n boolean isStream \n PRIndirectReference getIndRef \n int type \n byte[] getBytes \n boolean isBoolean \n boolean isName \n boolean isNumber \n boolean isNull \n boolean isString \n String toString \n boolean canBeInObjStm \n boolean isArray \n boolean isIndirect", "output": "boolean function ( ) { return ( type == DICTIONARY ) ; }"}, {"instruction": "Generate java code\nset removed pair number . ", "input": " boolean useCriterion4 \n ColorPolynomial<C> pi \n int i \n ColorPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n\n int getPairNumber \n int hashCode \n void setUseCriterion3 \n boolean equals \n boolean getUseCriterion3 \n void setZero \n boolean isZero \n void setUseCriterion4 \n String toString \n int compareTo \n boolean getUseCriterion4", "output": "void function ( int arg0 ) { this . n = arg0 ; }"}, {"instruction": "Generate java code\ntwosided groebner base using pairlist class . ", "input": " SolvableGroebnerBase<C> sbb \n boolean debug \n Logger logger \n\n List<GenSolvablePolynomial<C>> leftGB \n ModuleList<C> leftGB \n boolean isTwosidedGB \n boolean isTwosidedGB \n List<GenSolvablePolynomial<C>> rightGB \n ModuleList<C> rightGB \n boolean isLeftGB \n boolean isLeftGB \n boolean isRightGB \n boolean isRightGB", "output": "List < GenSolvablePolynomial < C >> function ( int arg0 , List < GenSolvablePolynomial < C >> arg1 ) { return sbb . twosidedGB ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ncontrols whether the compiler should provide binding information for the ast nodes it creates . to be effective , this method must be called before any of #getroot , #getastrewrite , #getimportremover . this method has no effect if the target object has been created with #compilationunitrewrite icompilationunit , compilationunit . defaults to true do resolve bindings . ", "input": " ImportRewrite fImportRewrite \n ImportRemover fImportRemover \n WorkingCopyOwner fOwner \n ASTRewrite fRewrite \n boolean fStatementsRecovery \n List<TextEditGroup> fTextEditGroups \n ICompilationUnit fCu \n IDocument fRememberContent \n CompilationUnit fRoot \n boolean fResolveBindings \n boolean fBindingsRecovery \n\n void clearASTRewrite \n ASTRewrite getASTRewrite \n void rememberContent \n AST getAST \n void setBindingRecovery \n void setStatementsRecovery \n ImportRemover getImportRemover \n CompilationUnitChange createChange \n org.eclipse.jdt.internal.corext.refactoring.changes.CompilationUnitChange createChange \n CompilationUnitChange createChange \n CompilationUnitChange createChange \n void clearASTAndImportRewrites \n CompilationUnitChange attachChange \n CategorizedTextEditGroup createCategorizedGroupDescription \n TextEditGroup createGroupDescription \n ImportRewrite getImportRewrite \n ICompilationUnit getCu \n void clearImportRewrites \n void clearGroupDescriptionEdits \n CompilationUnit getRoot \n boolean isEmptyEdit", "output": "void function ( boolean arg0 ) { fResolveBindings = arg0 ; }"}, {"instruction": "Generate java code\ndispatch a keyup event . ", "input": " Point pointT \n abbot.swt.Robot _robot \n\n void robotKeyClick \n void doKeyDown \n void doKeyUp \n void mouseMove \n void mouseMove \n void mouseDown \n abbot.swt.Robot getAbbotRobot \n void mouseDoubleClick \n void pause \n boolean needsShift \n int[] extractKeys \n void mouseUp \n void keyClick \n void keyClick \n void keyDown \n void keyDown \n Event createClickEvent \n void enterText", "output": "void function ( int arg0 ) { int [ ] loc0 = extractKeys ( arg0 ) ; for ( int loc1 = loc0 . length - 1 ; loc1 >= 0 ; -- loc1 ) doKeyUp ( loc0 [ loc1 ] ) ; }"}, {"instruction": "Generate java code\nlocal absolute value . ", "input": " Logger logger \n LocalRing<C> ring \n boolean debug \n C num \n int isunit \n C den \n\n int signum \n boolean isONE \n Local<C> inverse \n boolean isUnit \n Local<C> subtract \n Local<C> gcd \n Local<C> sum \n int compareTo \n Local<C>[] egcd \n int hashCode \n Local<C> negate \n boolean equals \n Local<C> clone \n boolean isZERO \n String toString \n Local<C> divide \n Local<C> multiply \n Local<C> remainder", "output": "Local < C > function ( ) { return new Local < C > ( ring , num . abs ( ) , den , true ) ; }"}, {"instruction": "Generate java code\ncompare two object ", "input": " PlaceHolder placeHolder \n\n String nullStrToEmpty \n Long[] transformLongArray \n long[] transformLongArray \n int compare \n Integer[] transformIntArray \n int[] transformIntArray", "output": "boolean function ( Object arg0 , Object arg1 ) { return arg0 == arg1 || ( arg0 == null ? arg1 == null : arg0 . equals ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nsets all probes to false . ", "input": " String name \n boolean[] probes \n long id \n\n String getName \n void merge \n void merge \n boolean[] getProbes \n long getId \n String toString \n void assertCompatibility", "output": "void function ( ) { Arrays . fill ( probes , false ) ; }"}, {"instruction": "Generate java code\ncreate an instance of providedportid ", "input": " QName _PropertyDeclaration_QNAME \n QName _ProvidedPort_QNAME \n QName _ApplicationPayload_QNAME \n QName _Application_QNAME \n QName _ApplicationID_QNAME \n QName _ApplicationReleaseBinding_QNAME \n QName _ConsumedPort_QNAME \n QName _ProvidedPortID_QNAME \n\n ConsumedPort createConsumedPort \n JAXBElement<ConsumedPort> createConsumedPort \n ApplicationPayload createApplicationPayload \n JAXBElement<ApplicationPayload> createApplicationPayload \n ApplicationReleaseBinding createApplicationReleaseBinding \n JAXBElement<ApplicationReleaseBinding> createApplicationReleaseBinding \n Application createApplication \n JAXBElement<Application> createApplication \n PropertyDeclaration createPropertyDeclaration \n JAXBElement<PropertyDeclaration> createPropertyDeclaration \n ApplicationID createApplicationID \n JAXBElement<ApplicationID> createApplicationID \n ProvidedPort createProvidedPort \n JAXBElement<ProvidedPort> createProvidedPort", "output": "ProvidedPortID function ( ) { return new ProvidedPortID ( ) ; }"}, {"instruction": "Generate java code\nadds the given locator . locators are queried in the sequence they have been added . ", "input": " int tabWidth \n List<ISourceFileLocator> delegates \n\n int getTabWidth \n Reader getSourceFile", "output": "void function ( final ISourceFileLocator arg0 ) { delegates . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nget a constant univpowerseries from a java.math.biginteger . ", "input": " UnivPowerSeries<C> ZERO \n String DEFAULT_NAME \n int truncate \n String var \n int DEFAULT_TRUNCATE \n UnivPowerSeries<C> ONE \n RingFactory<C> coFac \n Random random \n\n UnivPowerSeries<C> getTAN \n boolean isField \n boolean isCommutative \n UnivPowerSeries<C> getSIN \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> parse \n UnivPowerSeries<C> fromPolynomial \n java.math.BigInteger characteristic \n UnivPowerSeries<C> getEXP \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n UnivPowerSeries<C> random \n int hashCode \n boolean equals \n UnivPowerSeries<C> getONE \n UnivPowerSeries<C> getZERO \n UnivPowerSeries<C> getCOS \n String toString \n boolean isAssociative \n UnivPowerSeries<C> copy \n UnivPowerSeries<C> fixPoint", "output": "UnivPowerSeries < C > function ( java . math . BigInteger arg0 ) { return ONE . multiply ( coFac . fromInteger ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nbrings the passed shell to the top of the drawing order so that it receives keyboard focus . ", "input": " String copyright \n\n IWorkbenchWindow getWorkbenchWindow \n void bringWorkbenchToFront \n IWorkbench getWorkbench", "output": "void function ( final Shell arg0 ) { Robot . syncExec ( arg0 . getDisplay ( ) , null , new Runnable ( ) { public void run ( ) { arg0 . forceActive ( ) ; arg0 . setFocus ( ) ; } } ) ; Robot . waitForIdle ( arg0 . getDisplay ( ) ) ; }"}, {"instruction": "Generate java code\ncreates and adds a new limit . ", "input": " WildcardMatcher excludesMatcher \n String excludes \n String includes \n WildcardMatcher includesMatcher \n List<Limit> limits \n ElementType element \n\n List<Limit> getLimits \n ElementType getElement \n void setExcludes \n void setLimits \n String getIncludes \n String getExcludes \n void setElement \n boolean matches \n void setIncludes", "output": "Limit function ( ) { final Limit loc0 = new Limit ( ) ; this . limits . add ( loc0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nskips the next char . ", "input": " String str \n int pos \n\n char ch \n char ch \n int pos \n int length \n boolean hasNext \n XMPDateTime parse \n XMPDateTime parse \n String render \n int gatherInt", "output": "void function ( ) { pos ++ ; }"}, {"instruction": "Generate java code\nmain method execution steps : 1 . configure jaxb for the classes in the com.cooksys.serialization.assignment.model package 2 . read a session object from the / input/memphis / directory using the methods defined above 3 . write the session object to the / output/session.xml file . jaxb annotations and configuration : you will have to add jaxb annotations to the classes in the com.cooksys.serialization.assignment.model package check the xml files in the / input / directory to determine how to configure the contact jaxb annotations the session object should marshal to look like the following : ... ... ... ... ", "input": " PlaceHolder placeHolder \n\n Instructor readInstructor \n void writeSession \n Session readSession \n Student readStudent \n List<Student> readStudents", "output": "void function ( String [ ] arg0 ) { JAXBContext loc0 = JAXBContext . newInstance ( Session . class ) ; writeSession ( readSession ( new File ( \"srini_string\" ) , loc0 ) , new File ( \"srini_string\" ) , loc0 ) ; }"}, {"instruction": "Generate java code\nthe `` friendly '' name for this machine ", "input": " Map<String,JsonBall> metadata \n Date created \n Type type \n Set<String> ips \n ImmutableSet.Builder<String> ips \n ImmutableMap.Builder<String,JsonBall> metadata \n String name \n String id \n State state \n Function<JsonBall,String> unquoteString \n String dataset \n int memorySizeMb \n Date updated \n int diskSizeGb \n\n Builder toBuilder \n Builder metadata \n String getId \n int compareTo \n Builder type \n Date getUpdated \n Map<String,String> getMetadataAsJsonLiterals \n int hashCode \n Builder builder \n Builder id \n Builder state \n String value \n String value \n Builder memorySizeMb \n Type fromValue \n State fromValue \n Map<String,String> getMetadata \n String apply \n Builder created \n int getDiskSizeGb \n String getDatasetURN \n Date getCreated \n Builder addMetadata \n Builder ips \n Builder addIp \n int getMemorySizeMb \n State getState \n Builder fromMachine \n Machine build \n Type getType \n boolean equals \n Builder name \n String toString \n String toString \n String toString \n Builder dataset \n Builder updated \n Set<String> getIps \n Builder diskSizeGb", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nset usecriterion4 . ", "input": " boolean useCriterion4 \n ColorPolynomial<C> pi \n int i \n ColorPolynomial<C> pj \n int j \n boolean useCriterion3 \n int n \n boolean toZero \n\n int getPairNumber \n int hashCode \n void setUseCriterion3 \n boolean equals \n boolean getUseCriterion3 \n void setZero \n boolean isZero \n String toString \n int compareTo \n void pairNumber \n boolean getUseCriterion4", "output": "void function ( boolean arg0 ) { this . useCriterion4 = arg0 ; }"}, {"instruction": "Generate java code\nlook for fields in the specified class that begin with the specified prefix . ", "input": " String lineSep \n RootDoc root \n Map<ClassDoc,Set<ClassDoc>> cmap \n boolean dump_class_tree \n\n void gather_derived_classes \n void process_class_sorted_texinfo \n void process \n int find_enabled \n boolean start \n int optionLength \n void process_class_tree_txt", "output": "Vector < FieldDoc > function ( ClassDoc arg0 , String arg1 ) { Vector < FieldDoc > loc0 = new Vector < FieldDoc > ( ) ; for ( FieldDoc loc1 : arg0 . fields ( ) ) { if ( loc1 . name ( ) . startsWith ( arg1 ) ) loc0 . add ( loc1 ) ; } return ( loc0 ) ; }"}, {"instruction": "Generate java code\nthe violated property . ", "input": " String xmlname \n Time onExit \n HashMap<Integer,Violation> violationsMap \n Time onEntry \n Property property \n String name \n long serialVersionUID \n Time time \n\n Object readResolve \n Object readResolve \n Violation[] findViolations \n String toStringWithMethod \n String xmlString \n String xmlString \n Violation[] viosWithConfGEQ \n Violation[] withKind \n int hashCode \n int hashCode \n boolean equals \n boolean equals \n Violation get \n Violation get \n Violation get \n String toNiceString \n String toNiceString \n String toString \n String toString \n Time time \n Violation[] viosWithConfLT \n Violation[] withTime", "output": "Property function ( ) { return property ; }"}, {"instruction": "Generate java code\ndoes a single lookup . added by leo nobach ", "input": " Node<T> myNode \n PeerStatus peerStatus \n Logger log \n ComponentsConfig config \n boolean lookupEnabled \n\n void enablePeriodicLookup \n void connectivityChanged \n void beginPeriodicLookups \n void doConnect \n void routingTableBuilt \n void doDisconnect \n PeerStatus getPeerStatus \n double getSimSec", "output": "void function ( KademliaOverlayKey arg0 , OperationCallback < DHTObject > arg1 ) { KademliaOperation < DHTObject > loc0 = myNode . getOperationFactory ( ) . getDataLookupOperation ( arg0 , arg1 ) ; loc0 . scheduleImmediately ( ) ; }"}, {"instruction": "Generate java code\ncollects all received messages ", "input": " long receivedBytes \n int sentMsg \n int receivedMsg \n StatisticGenerationEvent event \n long sentBytes \n Logger log \n\n double[] getSentBytes \n void addReceivedMsg \n void stop \n double[] getSentMsg \n double[] getReceivedMsg \n void start \n void netMsgSend \n void netMsgDrop \n double[] getReceivedBytes \n void addSentMsg", "output": "void function ( NetMessage arg0 , NetID arg1 ) { addReceivedMsg ( arg0 ) ; receivedMsg ++ ; }"}, {"instruction": "Generate java code\nlog the specified exception . ", "input": " boolean sendToConsole \n\n placeholderType placeHolder", "output": "void function ( Throwable arg0 ) { if ( Platform . isRunning ( ) ) Logger . log ( arg0 ) ; else { if ( sendToConsole ) arg0 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\nreturn the items for this channel . ", "input": " String managingEditor \n String title \n String language \n String link \n ArrayList skipDays \n TextInput textInput \n String rating \n String pubDate \n String description \n String lastBuildDate \n String webMaster \n String copyright \n ArrayList skipHours \n ArrayList items \n Image image \n String docs \n double version \n\n void addSkipDay \n void removeItem \n void setCopyright \n String getWebMaster \n void setDescription \n String getDescription \n void addSkipHour \n String getDocs \n void addItem \n Item[] getItems \n String getTitle \n String[] getSkipHours \n String[] findSkipHours \n String[] findSkipDays \n void render \n void render \n void render \n void render \n void render \n void render \n String[] getSkipDays \n void setManagingEditor \n double getVersion \n String getLanguage \n String getCopyright \n void setVersion \n String getPubDate \n void setWebMaster \n void setTitle \n void setTextInput \n void setPubDate \n void setLink \n String getLink \n String getLastBuildDate \n void setDocs \n void removeSkipHour \n void removeSkipDay \n TextInput getTextInput \n Image getImage \n void setLastBuildDate \n void setRating \n String getManagingEditor \n void setImage \n void setLanguage \n String getRating", "output": "Item [ ] function ( ) { synchronized ( items ) { Item loc0 [ ] = new Item [ this . items . size ( ) ] ; return ( ( Item [ ] ) this . items . toArray ( loc0 ) ) ; } }"}, {"instruction": "Generate java code\ngetter for property ` name ' . ", "input": " CoreMessageLogger LOG \n boolean containsJoinFetchedCollection \n Fetch bagJoinFetch \n String name \n boolean containsJoinFetchedBag \n Map<String,Fetch> fetches \n\n Map<String,Fetch> getFetches \n boolean isContainsJoinFetchedBag \n void addFetch \n void addFetch \n void addFetch \n Fetch getFetchByRole \n boolean isContainsJoinFetchedCollection", "output": "String function ( ) { return name ; }"}, {"instruction": "Generate java code\nretrieves and removes the top of the stack . ", "input": " Charset charset \n TagProcessorFactory tagFactory \n Map<String,Object> memory \n List<Element> ctn \n LinkProvider linkprovider \n boolean autoBookmark \n boolean acceptUnknown \n List<String> roottags \n String BOOKMARK_TREE \n String LAST_MARGIN_BOTTOM \n Rectangle pageSize \n String resourcesRootPath \n LinkedList<StackKeeper> queue \n CssAppliers cssAppliers \n ImageProvider imageProvider \n\n ImageProvider getImageProvider \n HtmlPipelineContext setTagFactory \n HtmlPipelineContext setAcceptUnknown \n boolean acceptUnknown \n LinkProvider getLinkProvider \n String getResourcesRootPath \n CssAppliers getCssAppliers \n HtmlPipelineContext charSet \n Charset charSet \n void setLastMarginBottom \n HtmlPipelineContext setImageProvider \n boolean isEmpty \n void setResourcesRootPath \n HtmlPipelineContext setCssApplier \n Map<String,Object> getMemory \n StackKeeper peek \n boolean autoBookmark \n HtmlPipelineContext autoBookmark \n HtmlPipelineContext setLinkProvider \n Float getLastMarginBottom \n Rectangle getPageSize \n List<Element> currentContent \n TagProcessor resolveProcessor \n HtmlPipelineContext clone \n List<String> getRootTags \n void setCssAppliers \n HtmlPipelineContext setRootTags \n void addFirst \n HtmlPipelineContext setPageSize", "output": "StackKeeper function ( ) { try { return this . queue . removeFirst ( ) ; } catch ( NoSuchElementException loc0 ) { throw new NoStackException ( ) ; } }"}, {"instruction": "Generate java code\ngetzero . ", "input": " GenVector<C> ZERO \n Logger logger \n RingFactory<C> coFac \n float density \n int cols \n List<GenVector<C>> BASIS \n Random random \n float DEFAULT_DENSITY \n\n GenVector<C> random \n GenVector<C> random \n GenVector<C> random \n GenVector<C> random \n GenVector<C> fromList \n int hashCode \n boolean equals \n GenVector<C> fromInteger \n GenVector<C> fromInteger \n String toString \n GenVector<C> copy \n GenVector<C> parse \n GenVector<C> parse", "output": "GenVector < C > function ( ) { return ZERO ; }"}, {"instruction": "Generate java code\nset level of section . ", "input": " List<Section> subsections \n Section parent \n List<Sentence> headerContent \n int level \n List<ListBlock> lists \n List<Paragraph> paragraphs \n\n void appendListElement \n ListBlock getListBlock \n int getNumberOfLists \n int getHeaderContentsListSize \n Paragraph getParagraph \n void appendSubSection \n Sentence getHeaderContent \n int getNumberOfSubsections \n Section getParentSection \n int getLevel \n List<Paragraph> getParagraphs \n int getNumberOfParagraphs \n List<ListBlock> getListBlocks \n void setParentSection \n List<Sentence> getHeaderContents \n Section getSubSection \n void appendListBlock \n Sentence getJoinedHeaderContents \n void appendParagraph", "output": "void function ( int arg0 ) { this . level = arg0 ; }"}, {"instruction": "Generate java code\nthis method is invoked at the server before the response is executed , but before the response has been formulated ", "input": " PlaceHolder placeHolder \n\n void clientStartConnect \n void clientFinishConnect \n void clientSendRequest \n void serverReceiveRequest \n void serverConnecting \n void clientReceiveResponse", "output": "void function ( RPCContext arg0 ) { }"}, {"instruction": "Generate java code\nadds a parameter to the request ; if the parameter is a file , the file is uploaded , otherwise the string value of the parameter is passed in the request ", "input": " Map<String,Object> mParameters \n String boundary \n OutputStream mOutput \n URLConnection mConnection \n Map<String,String> mCookies \n Random random \n\n void boundary \n void writeName \n void setParameters \n void newline \n void writeParameter \n void writeParameter \n void writeParameter \n HttpURLConnection post \n String randomString \n void postCookies \n void writeln \n void pipe \n void write \n void write", "output": "void function ( String arg0 , Object arg1 ) { mParameters . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns the namespace uris found in the given xml file ", "input": " SAXParserFactory factory \n\n void setFactory \n XmlNamespaceFinder createNamespaceFinder \n SAXParserFactory getFactory", "output": "Set < String > function ( InputSource arg0 ) { XmlNamespaceFinder loc0 = createNamespaceFinder ( ) ; Set < String > loc1 = loc0 . parseContents ( arg0 ) ; if ( factory == null ) { factory = loc0 . getFactory ( ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nput list of task id to its queue ", "input": " ReentrantLock takeLock \n LinkedList<List<Integer>> taskIdsQueue \n Condition notEmpty \n LinkedBlockingQueue<BoltMsg> boltMsgQueue \n\n void putBoltMsg \n Object poll", "output": "void function ( List < Integer > arg0 ) { takeLock . lock ( ) ; try { taskIdsQueue . add ( arg0 ) ; notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } }"}, {"instruction": "Generate java code\nenable or disable debug mode by default , debug mode is enabled for development builds and disabled for exported apks - see buildconfig.debug ", "input": " int LOG_GENERAL \n OnLogListener logListener \n int LOG_COMMAND \n int LOG_NONE \n int LOG_ALL \n int logTypes \n int LOG_OUTPUT \n boolean sanityChecks \n boolean debug \n String TAG \n\n void setOnLogListener \n boolean getSanityChecksEnabled \n OnLogListener getOnLogListener \n void log \n void logCommon \n void onLog \n void setSanityChecksEnabled \n boolean getLogTypeEnabledEffective \n boolean getDebug \n void logCommand \n boolean getLogTypeEnabled \n void logOutput \n void setLogTypeEnabled \n boolean getSanityChecksEnabledEffective \n boolean onMainThread", "output": "void function ( boolean arg0 ) { debug = arg0 ; }"}, {"instruction": "Generate java code\nreturns the label of a path . ", "input": " String CODE_DELIMITERS \n String FILE_PATTERN_DELIMITERS \n String URL_DELIMITERS \n\n String getJavaCodeString \n String getWorkingSetLabel \n String getURLPart \n String getJavaElementName \n String getFilePattern \n String getResourceName \n String getResourceName \n String getVersionName \n String getFileName", "output": "String function ( IPath arg0 , boolean arg1 ) { String loc0 ; if ( arg1 ) { loc0 = arg0 . toOSString ( ) ; } else { loc0 = arg0 . makeRelative ( ) . toString ( ) ; } return Strings . markLTR ( loc0 ) ; }"}, {"instruction": "Generate java code\nanswer the condition monitor ", "input": " ConditionMonitor INSTANCE \n\n void add \n void add \n void removeAll \n int process \n com.windowtester.runtime.condition.ICondition[] getConditions \n void removeHandler", "output": "ConditionMonitor function ( ) { return INSTANCE ; }"}, {"instruction": "Generate java code\ngets the value of ours ", "input": " long theirs \n long ours \n String description \n int iterations \n\n int getIterations \n void setIterations \n void setOurs \n long getOurAvg \n String toString \n void setDescription \n void setTheirs \n long getTheirs \n String getDescription \n long getTheirAvg", "output": "long function ( ) { return this . ours ; }"}, {"instruction": "Generate java code\ncharacteristic of this ring . ", "input": " int blocksize \n GenMatrix<C> ZERO \n int DEFAULT_BSIZE \n GenMatrix<C> ONE \n Logger logger \n RingFactory<C> coFac \n float density \n int rows \n int cols \n Random random \n float DEFAULT_DENSITY \n\n GenMatrix<C> randomUpper \n GenMatrix<C> randomUpper \n GenMatrix<C> randomLower \n GenMatrix<C> randomLower \n GenMatrixRing<C> product \n GenMatrix<C> fromList \n boolean isField \n boolean isCommutative \n GenMatrix<C> parse \n GenMatrix<C> parse \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n GenMatrix<C> random \n int hashCode \n boolean equals \n GenMatrix<C> getONE \n GenMatrix<C> getZERO \n GenMatrix<C> fromInteger \n GenMatrix<C> fromInteger \n String toString \n boolean isAssociative \n GenMatrixRing<C> transpose \n GenMatrix<C> copy", "output": "java . math . BigInteger function ( ) { return coFac . characteristic ( ) ; }"}, {"instruction": "Generate java code\ntests that a class available in a jar , which is added as a class-path manifest attribute of a . rar is available for access from within a class in a . war deployment , belonging to the same . ear top level deployment . this tests section 8.3 of java ee6 spec ", "input": " PlaceHolder placeHolder \n\n Archive<?> createDeployment", "output": "void function ( @ ArquillianResource URL arg0 ) { final String loc0 = \"srini_string\" + arg0 . getHost ( ) + \"srini_string\" + arg0 . getPort ( ) + \"srini_string\" + JarClass . class . getName ( ) ; final String loc1 = HttpRequest . get ( loc0 , 2 , TimeUnit . SECONDS ) ; Assert . assertEquals ( Servlet . SUCCESS , loc1 ) ; }"}, {"instruction": "Generate java code\ninserts all the fonts recognized by itext in the directory into the map . the encoding will be basefont.cp1252 but can be changed later . ", "input": " HashMap<String,String> aliases \n String fontName \n byte pfb[] \n HashMap<String,BaseFontParameters> mapper \n boolean cached \n byte ttfAfm[] \n String encoding \n boolean embedded \n\n void putName \n HashMap<String,String> getAliases \n BaseFont awtToPdf \n void putAlias \n Font pdfToAwt \n int insertFile \n HashMap<String,BaseFontParameters> getMapper \n BaseFontParameters getBaseFontParameters \n void insertNames", "output": "int function ( String arg0 ) { File loc0 = new File ( arg0 ) ; if ( ! loc0 . exists ( ) || ! loc0 . isDirectory ( ) ) return 0 ; File loc1 [ ] = loc0 . listFiles ( ) ; if ( loc1 == null ) return 0 ; int loc2 = 0 ; for ( int loc3 = 0 ; loc3 < loc1 . length ; ++ loc3 ) { loc2 += insertFile ( loc1 [ loc3 ] ) ; } return loc2 ; }"}, {"instruction": "Generate java code\nlog the specified message and object ", "input": " ILog sysOutLog \n PrintWriter sysOut \n ILog log \n String PRODUCT_ID \n\n void setLog \n void printLogObject \n void removeLogListener \n void logNoHeader \n void logStackTrace \n void printLogStatus \n IStatus createLogStatus \n void printLogMessage \n void printLog \n void close \n void addLogListener \n org.osgi.framework.Bundle getBundle", "output": "void function ( String arg0 , Object arg1 ) { if ( Tracer . isDebugging ( ) ) printLog ( sysOut , arg0 , arg1 ) ; IStatus loc0 = createLogStatus ( arg0 , arg1 , \"srini_string\" ) ; try { log . log ( loc0 ) ; } catch ( Throwable loc1 ) { } }"}, {"instruction": "Generate java code\nsets the value of the nresults property . ", "input": " BigInteger nresults \n\n BigInteger getNresults", "output": "void function ( BigInteger arg0 ) { this . nresults = arg0 ; }"}, {"instruction": "Generate java code\nstore an invalid script exception describing the proper script usage . this should be used by derived classes whenever parsing indicates invalid input . ", "input": " String description \n Resolver resolver \n String copyright \n Throwable invalidScriptError \n WidgetTester tester \n\n String toXMLString \n String getXMLTag \n Widget resolve \n Element addAttributes \n void run \n Element toXML \n void setDescription \n String simpleClassName \n String getDescription \n String getDefaultDescription \n void runStep \n WidgetTester resolveTester \n void setScriptError \n HashMap createAttributeMap \n HashMap getAttributes \n void writeObject \n Element addContent \n void parseStepAttributes \n String getUsage \n void readObject \n String toEditableString \n Step createStep \n Step createStep \n Class resolveClass \n WidgetFinder getFinder \n Resolver getResolver", "output": "void function ( String arg0 ) { String loc0 = getUsage ( ) ; if ( arg0 != null ) { MessageFormat loc1 = new MessageFormat ( Strings . get ( \"srini_string\" ) ) ; loc0 = loc1 . format ( new Object [ ] { loc0 , arg0 } ) ; } setScriptError ( new InvalidScriptException ( loc0 ) ) ; }"}, {"instruction": "Generate java code\ntest whether the widget in question is showing . ", "input": " IUIContext ui \n IWidgetLocator locator \n\n placeholderType placeHolder", "output": "boolean function ( ) { return ui . findAll ( locator ) . length == 1 ; }"}, {"instruction": "Generate java code\nreturns a unit vector based on an angular direction . for example , angle 0 creates vector 0,1 , angle pi/2 creates vector 1,0 . ", "input": " VectorXZ NULL_VECTOR \n VectorXZ Z_UNIT \n double x \n VectorXZ X_UNIT \n double z \n\n VectorXZ add \n Function<VectorXZ,VectorXYZ> xyzFunction \n double angleTo \n VectorXZ mult \n List<VectorXYZ> listXYZ \n double lengthSquared \n double distance \n VectorXZ invert \n VectorXZ subtract \n double dot \n double length \n double distanceTo \n double angleBetween \n double distanceSquared \n double getX \n double getY \n double getZ \n int hashCode \n VectorXZ normalize \n boolean equals \n VectorXYZ xyz \n double angle \n String toString \n VectorXZ rightNormal", "output": "VectorXZ function ( double arg0 ) { return new VectorXZ ( sin ( arg0 ) , cos ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreads 16-bit rgb and converts it to 24-bit rgb . endian is defined by input stream . ", "input": " byte[] byteBuf \n\n void writeInt24LE \n void readRGBs555to24 \n void readInts24LE \n void writeInts24LE \n void readRGBs565to24 \n void writeInts24 \n int readInt24LE \n int readRGB555to24 \n void readRGBs555to24LE \n int readRGB555to24LE \n void writeInt24", "output": "int function ( ImageInputStream arg0 ) { int loc0 = arg0 . readUnsignedShort ( ) ; return ( ( loc0 & 0xf800 ) << 8 ) | ( ( loc0 & 0x3800 ) << 5 ) | ( ( loc0 & 0x07e0 ) << 5 ) | ( ( loc0 & 0x0060 ) << 3 ) | ( ( loc0 & 0x001f ) << 3 ) | ( ( loc0 & 0x0007 ) ) ; }"}, {"instruction": "Generate java code\nexecutes the closure whose matching predicate returns true ", "input": " Closure[] iClosures \n Predicate[] iPredicates \n long serialVersionUID \n Closure iDefault \n\n Closure getDefaultClosure \n Closure[] getClosures \n Closure getInstance \n Closure getInstance \n Predicate[] getPredicates", "output": "void function ( Object arg0 ) { for ( int loc0 = 0 ; loc0 < iPredicates . length ; loc0 ++ ) { if ( iPredicates [ loc0 ] . evaluate ( arg0 ) == true ) { iClosures [ loc0 ] . execute ( arg0 ) ; return ; } } iDefault . execute ( arg0 ) ; }"}, {"instruction": "Generate java code\nread the random bytes from an input file and store them into an arraylist . ", "input": " File inputFile \n ArrayList<Byte> bytes \n File outputImage \n\n BufferedImage getGrayscale \n boolean create", "output": "boolean function ( ArrayList < Byte > arg0 ) { try { FileInputStream loc0 = new FileInputStream ( inputFile ) ; byte [ ] loc1 = new byte [ 1 ] ; while ( loc0 . read ( loc1 ) != - 1 ) { arg0 . add ( new Byte ( loc1 [ 0 ] ) ) ; } loc0 . close ( ) ; return true ; } catch ( Exception loc3 ) { loc3 . printStackTrace ( ) ; } return false ; }"}, {"instruction": "Generate java code\nreturns the derivative of the polynomial spline function as a univariaterealfunction ", "input": " int n \n long serialVersionUID \n PolynomialFunction polynomials[] \n double knots[] \n\n double[] getKnots \n boolean isStrictlyIncreasing \n PolynomialSplineFunction polynomialSplineDerivative \n int getN \n PolynomialFunction[] getPolynomials \n double value", "output": "UnivariateRealFunction function ( ) { return polynomialSplineDerivative ( ) ; }"}, {"instruction": "Generate java code\nalways throw an exception . ", "input": " Closure INSTANCE \n long serialVersionUID \n\n Closure getInstance", "output": "void function ( Object arg0 ) { throw new FunctorException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the type of the rightermost child atom . most atoms have no child atoms , so the `` left type '' and the `` right type '' are the same : the atom 's type . this also is the default implementation . but some atoms are composed of child atoms put one after another in a horizontal row . these atoms must override this method . ", "input": " int type \n int type_limits \n int alignment \n\n int getLeftType \n Box createBox \n Atom clone", "output": "int function ( ) { return type ; }"}, {"instruction": "Generate java code\ngetter for property mu . ", "input": " int DIGEST_MODE \n BufferedReader filePointer \n int CONSTANT_MODE \n int mode \n double mu \n EmpiricalDistribution empiricalDistribution \n URL valuesFileURL \n double sigma \n RandomDataImpl randomData \n int REPLAY_MODE \n int EXPONENTIAL_MODE \n int GAUSSIAN_MODE \n int UNIFORM_MODE \n\n EmpiricalDistribution getEmpiricalDistribution \n double getNextUniform \n void closeReplayFile \n void setMode \n double getNext \n void fill \n double[] fill \n double getSigma \n void computeDistribution \n void computeDistribution \n void setMu \n void setValuesFileURL \n void setValuesFileURL \n double getNextReplay \n URL getValuesFileURL \n void setSigma \n void resetReplayFile \n double getNextGaussian \n int getMode \n double getNextDigest \n double getNextExponential", "output": "double function ( ) { return mu ; }"}, {"instruction": "Generate java code\ncreate an doublelistiterator doublelistiterator wrappingthe specified listiterator listiterator . when the given iterator is null , returns null . ", "input": " ListIterator _iterator \n\n double next \n void add \n void set \n double previous \n boolean hasPrevious \n boolean hasNext \n int nextIndex \n int previousIndex \n void remove", "output": "DoubleListIterator function ( ListIterator arg0 ) { return null == arg0 ? null : new ListIteratorDoubleListIterator ( arg0 ) ; }"}, {"instruction": "Generate java code\nremove all countries that are not defined in the set ", "input": " HashMap<String,String[]> countryLookup \n ArrayList<String> pingErCountry \n ArrayList<String> pingErRegion \n long serialVersionUID \n Logger log \n HashMap<String,String> pingErCountryRegions \n String pingErCountryRegionFilename \n\n void importPingErCountryRegionFile \n String getGeoIpCountryName \n String getPingErCountryName \n boolean containsPingErCountryOrRegion \n ArrayList<String> getPingErRegions \n void addCountryFromGeoIP \n String getPingErCountryRegionFilename \n Element exportToXML \n void assignCountryCodeToPingErData \n Set<String> getCountryCodes \n String getPingErRegionName \n ArrayList<String> getPingErCountrys \n void importFromXML \n void importFromXML", "output": "void function ( Set < String > arg0 ) { countryLookup . keySet ( ) . retainAll ( arg0 ) ; }"}, {"instruction": "Generate java code\nset the parser for a given class . returns the old one , if any . ", "input": " String copyright \n HashMap parsers \n\n Object[] eval \n Object eval \n Parser getParser \n String replace \n String[] parseArgumentList \n String unescapeBrackets \n Parser findParser \n String substitute \n boolean isExtension", "output": "Parser function ( Class arg0 , Parser arg1 ) { Parser loc0 = ( Parser ) parsers . get ( arg0 ) ; parsers . put ( arg0 , arg1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn a unmodifiable list that has all elements of the given collection . ", "input": " PlaceHolder placeHolder \n\n T getNthIteratedElement \n T getNthIteratedElement \n boolean containsIdentical \n List<String> prefix \n T removeMatching \n String toStringInLines \n List<String> toStringLines \n SortedSet<Integer> findAll \n String toStringInSortedLines \n List<List<T>> chunkUp \n boolean areDisjoint \n Set<T> intersection \n Set<T> xor \n String join \n List<T> map \n Set<T> getAll \n boolean containsEquivalent \n Set<T> diff \n Map<Integer,Set<Object[]>> createPerArityGroups \n Set<T> union \n List<T> concat \n List<String> sort \n List<T> concatAll \n boolean allInstancesOf \n List<T> unique \n List<List<T>> allCombinations \n T[] addToArray", "output": "List < T > function ( Collection < T > arg0 ) { return Collections . unmodifiableList ( new ArrayList < T > ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nget kdc tcp port ", "input": " KdcConfig kdcConfig \n BackendConfig backendConfig \n KOptions startupOptions \n\n int getKdcPort \n String getKdcRealm \n int checkGetKdcTcpPort \n int getKdcUdpPort \n int checkGetKdcUdpPort \n boolean allowTcp \n boolean allowUdp \n KdcConfig getKdcConfig \n String getKdcHost \n BackendConfig getBackendConfig", "output": "int function ( ) { int loc0 = startupOptions . getIntegerOption ( KdcServerOption . KDC_TCP_PORT ) ; if ( loc0 < 1 ) { loc0 = kdcConfig . getKdcTcpPort ( ) ; } if ( loc0 < 1 ) { loc0 = getKdcPort ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nload a map for the current locale to translate a character into a corresponding virtual keycode-based keystroke . ", "input": " KeyStrokeMapProvider generator \n Map chars \n boolean loaded \n Map characterMap \n Map keyStrokeMap \n Map keycodes \n\n Map generateKeyStrokeMappings \n void loadMaps \n Map getKeyStrokeMap \n Map getCharacterMap \n InputStream findMap \n void main \n KeyStroke getKeyStroke \n String[] getMapNames \n String[] getMapDescriptions \n String getOSType \n char getChar \n String getFilename \n Map generateCharacterMappings \n KeyStrokeMapProvider getGenerator \n Map loadKeyStrokeMap \n String[] getMapStrings", "output": "Map function ( ) { loadMaps ( ) ; return characterMap ; }"}, {"instruction": "Generate java code\ncleans str by replacing all characters that are not valid java indentifier parts with '' _ '' . ", "input": " int dkconfig_compile_timeout \n Logger debug \n FileCompiler fileCompiler \n boolean dkconfig_delete_splitters_on_exit \n String tempdir \n int guid \n String dkconfig_compiler \n\n boolean matchPptRegex \n void compileFiles \n SpinfoFileParser parse_spinfofile \n void loadSplitters \n String createTempDir \n void load_splitters \n boolean matchPpt \n String getFileName \n String getTempDir \n void printAll \n void debugPrintln", "output": "String function ( String arg0 ) { char [ ] loc0 = arg0 . toCharArray ( ) ; for ( int loc1 = 0 ; loc1 < loc0 . length ; loc1 ++ ) { char loc2 = loc0 [ loc1 ] ; if ( ! Character . isJavaIdentifierPart ( loc2 ) ) { loc0 [ loc1 ] = '_' ; } } return new String ( loc0 ) ; }"}, {"instruction": "Generate java code\nmodinteger comparison . ", "input": " java.math.BigInteger val \n ModIntegerRing ring \n\n ModInteger MIREM \n java.math.BigInteger getSymmetricVal \n int MISIGN \n ModInteger gcd \n ModInteger sum \n ModInteger MINEG \n ModInteger MISUM \n int hashCode \n ModInteger MIDIF \n ModInteger divide \n ModInteger multiply \n int signum \n boolean isONE \n ModInteger inverse \n int MICOMP \n java.math.BigInteger getVal \n boolean isUnit \n ModInteger subtract \n ModInteger MIABS \n ModInteger MIINV \n ModInteger[] egcd \n java.math.BigInteger getModul \n ModInteger abs \n ModInteger MIQ \n ModInteger negate \n boolean equals \n ModInteger clone \n boolean isZERO \n String toString \n ModInteger MIPROD \n ModInteger remainder", "output": "int function ( ModInteger arg0 ) { java . math . BigInteger loc0 = arg0 . val ; if ( ring != arg0 . ring ) { loc0 = loc0 . mod ( ring . modul ) ; } return val . compareTo ( loc0 ) ; }"}, {"instruction": "Generate java code\nunambiguous identification of a account ", "input": " Pattern bicRegex \n\n PartyIdentification32 createParty \n RemittanceInformation5 createRmtInf_struct \n XMLGregorianCalendar createXMLGregorianCalendarDate \n RemittanceInformation5 createRmtInf \n BranchAndFinancialInstitutionIdentification4 createFinInstnId \n XMLGregorianCalendar createXMLGregorianCalendar \n AmountType3Choice createAmount", "output": "CashAccount16 function ( String arg0 ) { CashAccount16 loc0 = new CashAccount16 ( ) ; AccountIdentification4Choice loc1 = new AccountIdentification4Choice ( ) ; loc1 . setIBAN ( arg0 ) ; loc0 . setId ( loc1 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncreates an unmarshaller from the sardineutil #jaxb_context . note : the unmarshaller is not thread safe , so it must be created for every request . ", "input": " JAXBContext JAXB_CONTEXT \n String CUSTOM_NAMESPACE_URI \n String DEFAULT_NAMESPACE_URI \n String DEFAULT_NAMESPACE_PREFIX \n List<ThreadLocal<SimpleDateFormat>> DATETIME_FORMATS \n String CUSTOM_NAMESPACE_PREFIX \n String[] SUPPORTED_DATE_FORMATS \n DocumentBuilderFactory factory \n\n Marshaller createMarshaller \n Date parseDate \n T unmarshal \n Map<QName,String> toQName \n List<QName> toQName \n QName toQName \n QName createQNameWithCustomNamespace \n String toXml \n Element createElement \n Element createElement \n Document createDocument \n QName createQNameWithDefaultNamespace", "output": "Unmarshaller function ( ) { try { return JAXB_CONTEXT . createUnmarshaller ( ) ; } catch ( JAXBException loc0 ) { throw new RuntimeException ( loc0 . getMessage ( ) , loc0 ) ; } }"}, {"instruction": "Generate java code\ndiscards any characters outside of the base64 alphabet see page 25 of rfc 2045 `` any characters outside of the base64 alphabet are to be ignored in base64 encoded data . '' ", "input": " byte[] decodingTable \n byte[] encodingTable \n\n void encode \n byte[] encode \n int computeEncodedSize \n byte[] decode \n byte[] decode \n String decode \n String decode \n boolean isValidBase64Byte \n String discardNonBase64Chars", "output": "byte [ ] function ( byte [ ] arg0 ) { byte loc0 [ ] = new byte [ arg0 . length ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0 . length ; loc2 ++ ) { if ( isValidBase64Byte ( arg0 [ loc2 ] ) ) { loc0 [ loc1 ++ ] = arg0 [ loc2 ] ; } } byte loc3 [ ] = new byte [ loc1 ] ; System . arraycopy ( loc0 , 0 , loc3 , 0 , loc1 ) ; return loc3 ; }"}, {"instruction": "Generate java code\nget a message with one parameter as an primitive int . the parameter will replace the string '' 1 '' found in the message . ", "input": " String BASE_PATH \n HashMap<String,String> currentLanguage \n HashMap<String,String> defaultLanguage \n\n HashMap<String,String> getLanguageMessages \n String getMessage \n String getMessage \n void setMessages \n HashMap<String,String> readLanguageStream \n HashMap<String,String> readLanguageStream \n boolean setLanguage", "output": "String function ( String arg0 , int arg1 ) { return getComposedMessage ( arg0 , String . valueOf ( arg1 ) , null , null , null ) ; }"}, {"instruction": "Generate java code\nattach a non-null propertychangelistener to this object . ", "input": " IPropertyDescriptor[] EMPTY_ARRAY \n PropertyChangeSupport pcsDelegate \n long serialVersionUID \n\n void firePropertyChange \n Object getPropertyValue \n void setPropertyValue \n Object getEditableValue \n IPropertyDescriptor[] getPropertyDescriptors \n void resetPropertyValue \n boolean isPropertySet \n void removePropertyChangeListener \n void readObject", "output": "void function ( PropertyChangeListener arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( ) ; } pcsDelegate . addPropertyChangeListener ( arg0 ) ; }"}, {"instruction": "Generate java code\ncreates a new instance . ", "input": " ReflectConstructor _constructor \n Object[] _args \n ReflectConstructorSpec UNSPECIFIED_CONSTRUCTOR \n TernaryBool _canBeInstantiated \n ReflectConstructorSpec INVALID_CONSTRUCTOR \n\n TernaryBool canBeInstantiated", "output": "Object function ( ) { if ( _constructor == null ) { return null ; } return _constructor . newInstance ( _args ) ; }"}, {"instruction": "Generate java code\ninterpret a short as its binary form ", "input": " PlaceHolder placeHolder \n\n long asLong \n int toInt \n String toBinaryString \n String toBinaryString \n String toBinaryString \n byte[] fromInt \n byte[] fromLong", "output": "byte [ ] function ( int arg0 ) { byte [ ] loc0 = new byte [ 2 ] ; loc0 [ 0 ] = ( byte ) ( arg0 >> 8 ) ; loc0 [ 1 ] = ( byte ) ( ( arg0 << 8 ) >> 8 ) ; return loc0 ; }"}]