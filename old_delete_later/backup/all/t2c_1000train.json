[{"instruction": "Generate java code\ncan we tell when we 're at the start of the first page when there is only one page ? ", "input": " PlaceHolder placeHolder \n\n void testCalculateTotalPages02 \n void testCalculatePageNumber01 \n void testCalculateTotalPages03 \n void testCalculatePageNumber03 \n void testCalculateTotalPages01 \n void testCalculatePageNumber04 \n void testCalculatePageNumber05 \n void testCalculateTotalPages04", "output": "void function ( ) { int loc0 = 0 ; int loc1 = 9 ; int loc2 = 1 ; int loc3 = ResponseHeader . calculatePageNumber ( loc0 , loc1 , loc2 ) ; assertThat ( loc3 , is ( 1 ) ) ; }"}, {"instruction": "Generate java code\nthe number of reservations available for the price . ", "input": " Double price \n Integer count \n\n PricingDetail withPrice \n PricingDetail withCount \n int hashCode \n boolean equals \n PricingDetail clone \n String toString \n void setPrice \n Integer getCount \n Double getPrice", "output": "void function ( Integer arg0 ) { this . count = arg0 ; }"}, {"instruction": "Generate java code\nreturns a clone of the instance . ", "input": " long serialVersionUID \n double upperBound \n List lookupTable \n Paint paint \n double lowerBound \n long serialVersionUID \n Paint defaultPaint \n double value \n\n void add \n void add \n void writeObject \n void writeObject \n boolean equals \n boolean equals \n Paint getDefaultPaint \n int compareTo \n double getLowerBound \n double getUpperBound \n Paint getPaint \n void readObject \n void readObject", "output": "Object function ( ) { LookupPaintScale loc0 = ( LookupPaintScale ) super . loc0 ( ) ; loc0 . lookupTable = new java . util . ArrayList ( this . lookupTable ) ; return loc0 ; }"}, {"instruction": "Generate java code\nreturn the der encoding of the object , null if the der encoding can not be made . ", "input": " String DER \n String BER \n\n DERObject getDERObject \n byte[] getEncoded \n byte[] getEncoded \n int hashCode \n boolean equals \n DERObject toASN1Object", "output": "byte [ ] function ( ) { try { return this . getEncoded ( DER ) ; } catch ( IOException loc0 ) { return null ; } }"}, {"instruction": "Generate java code\nadds together two sets of schema locations ", "input": " PlaceHolder placeHolder \n\n String buildSchemaLocation \n void registerNamespaces", "output": "String [ ] function ( String [ ] arg0 , String [ ] arg1 ) { String [ ] loc0 = new String [ arg0 . length + arg1 . length ] ; System . arraycopy ( arg0 , 0 , loc0 , 0 , arg0 . length ) ; System . arraycopy ( arg1 , 0 , loc0 , arg0 . length , arg1 . length ) ; return loc0 ; }"}, {"instruction": "Generate java code\nadds a url to the set associated with ` term ` . ", "input": " Jedis jedis \n\n boolean isIndexed \n void deleteAllKeys \n Map<String,Integer> getCounts \n Set<String> urlSetKeys \n void main \n void printIndex \n String termCounterKey \n Set<String> termSet \n List<Object> pushTermCounterToRedis \n void loadIndex \n void deleteTermCounters \n String urlSetKey \n Integer getCount \n void indexPage \n void deleteURLSets \n Set<String> termCounterKeys \n Set<String> getURLs \n Map<String,Integer> getCountsFaster", "output": "void function ( String arg0 , TermCounter arg1 ) { jedis . sadd ( urlSetKey ( arg0 ) , arg1 . getLabel ( ) ) ; }"}, {"instruction": "Generate java code\nthe iscsi initiator that connects to the target . ", "input": " String initiatorName \n String targetARN \n\n String getTargetARN \n DeleteChapCredentialsResult withTargetARN \n String getInitiatorName \n DeleteChapCredentialsResult withInitiatorName \n int hashCode \n boolean equals \n DeleteChapCredentialsResult clone \n String toString \n void setTargetARN", "output": "void function ( String arg0 ) { this . initiatorName = arg0 ; }"}, {"instruction": "Generate java code\ngets the name . ", "input": " CstString name \n Constant value \n\n Constant getValue \n int hashCode \n boolean equals \n String toString \n int compareTo", "output": "CstString function ( ) { return name ; }"}, {"instruction": "Generate java code\nmethod to create required json payload as a string according to the required optional parameters ", "input": " Log log \n\n int sendRequestToRetrieveHeaders \n Properties getConnectorConfigProperties \n void uploadConnector \n JSONObject sendRequest \n String getFileContent", "output": "String function ( String arg0 , String [ ] arg1 ) { JSONObject loc0 = new JSONObject ( arg0 ) ; for ( String loc1 : arg1 ) { loc0 . remove ( loc1 ) ; } return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\njava.util.map implementation but transparently activates the members as required . ", "input": " int _size \n V[] _values \n Activator _activator \n long serialVersionUID \n K[] _keys \n\n V defaultValue \n Collection<V> values \n V replace \n void insert \n V valueAt \n V delete \n boolean containsValue \n V put \n V remove \n void bind \n int hashCode \n V get \n V putInternal \n void putAll \n K defaultKeyValue \n Set<K> keySet \n int indexOf \n V[] allocateValueStorage \n K keyAt \n K[] allocateKeyStorage \n Set<Map.Entry<K,V>> entrySet \n boolean containsKey \n void clear \n int size \n int indexOfKey \n boolean equals \n void activate \n ArrayMap4<K,V> clone \n void ensureCapacity \n boolean containsKeyImpl \n void initializeBackingArray", "output": "boolean function ( ) { return size ( ) == 0 ; }"}, {"instruction": "Generate java code\ngets the value of the accent3 property . ", "input": " STColorSchemeIndex hyperlink \n STColorSchemeIndex followedHyperlink \n Object parent \n STColorSchemeIndex accent6 \n STColorSchemeIndex accent4 \n STColorSchemeIndex accent5 \n STColorSchemeIndex accent2 \n STColorSchemeIndex accent3 \n STColorSchemeIndex accent1 \n STColorSchemeIndex bg2 \n STColorSchemeIndex bg1 \n STColorSchemeIndex t1 \n STColorSchemeIndex t2 \n\n void setT2 \n STColorSchemeIndex getHyperlink \n void afterUnmarshal \n void setBg1 \n void setBg2 \n STColorSchemeIndex getFollowedHyperlink \n void setFollowedHyperlink \n void setParent \n STColorSchemeIndex getBg1 \n STColorSchemeIndex getBg2 \n Object getParent \n void setAccent5 \n void setAccent4 \n void setAccent6 \n STColorSchemeIndex getT1 \n void setAccent1 \n STColorSchemeIndex getAccent4 \n STColorSchemeIndex getAccent5 \n void setAccent3 \n STColorSchemeIndex getAccent6 \n void setAccent2 \n STColorSchemeIndex getAccent1 \n void setHyperlink \n STColorSchemeIndex getAccent2 \n STColorSchemeIndex getT2 \n void setT1", "output": "STColorSchemeIndex function ( ) { return accent3 ; }"}, {"instruction": "Generate java code\na percentage value indicating the size of the policy in packed form . the service rejects policies for which the packed size is greater than 100 percent of the allowed value . ", "input": " FederatedUser federatedUser \n Credentials credentials \n Integer packedPolicySize \n\n FederatedUser getFederatedUser \n GetFederationTokenResult withFederatedUser \n GetFederationTokenResult withCredentials \n int hashCode \n void setPackedPolicySize \n boolean equals \n GetFederationTokenResult clone \n Credentials getCredentials \n String toString \n void setFederatedUser \n void setCredentials \n Integer getPackedPolicySize", "output": "GetFederationTokenResult function ( Integer arg0 ) { setPackedPolicySize ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nif we did save away the value , then just access it , but if we did n't save it away , then we 'll want the most up-to-date value ", "input": " Object savedValue \n Object submittedValue \n Log log \n String name \n boolean haveSavedValue \n boolean setSubmittedInLocalValue \n boolean setLocalValueInValueBinding \n Object value \n\n void restoreState \n void clearSubmittedValue \n Object[] saveState \n void saveValue \n Object getSubmittedValue \n void discontinueSettingLocalValueInValueBinding \n void clearValue \n Object getValue \n void updateModel \n void setValue \n void setSubmittedValue \n boolean isComponentValid \n String getDesc \n void setInvalid \n void validate", "output": "Object function ( FacesContext arg0 , UIComponent arg1 ) { if ( haveSavedValue ) return savedValue ; else return getValue ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the host member . ", "input": " Integer port \n Host host \n\n String encode \n int getPort \n boolean hasPort \n boolean equals \n Object clone \n void removePort \n void setPort \n Host getHost", "output": "void function ( Host arg0 ) { host = arg0 ; }"}, {"instruction": "Generate java code\nmakes a clone of a byte array ", "input": " int size \n byte[] h \n byte[] skey \n int index \n\n void init \n byte[] sub \n String asHex \n byte[] encrypt \n byte[] cat \n byte[] update \n void update \n void main \n byte[] decrypt \n byte[] hash", "output": "byte [ ] function ( byte [ ] arg0 ) { byte [ ] loc0 = new byte [ arg0 . length ] ; for ( int loc1 = 0 ; loc1 < arg0 . length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }"}, {"instruction": "Generate java code\nsets the value of the statuscode property . ", "input": " String reason \n String usageContext \n TimePeriod effectivePeriod \n String subStatusCode \n String description \n long serialVersionUID \n String statusCode \n\n void setEffectivePeriod \n String getSubStatusCode \n String getStatusCode \n String getReason \n String getUsageContext \n void setReason \n void setDescription \n void setUsageContext \n TimePeriod getEffectivePeriod \n void setSubStatusCode \n String getDescription", "output": "void function ( String arg0 ) { this . statusCode = arg0 ; }"}, {"instruction": "Generate java code\nfind context with the given name in the context array without conversions . ", "input": " int RTCorbaPriority \n int CodeSets \n int FORWARDED_IDENTITY \n int ChainBypassCheck \n int LogicalThreadId \n int UnknownExceptionInfo \n int SendingContextRunTime \n int ExceptionDetailMessage \n byte[] context_data \n int RTCorbaPriorityRange \n int TransactionService \n int FT_GROUP_VERSION \n int ActivityService \n int ChainBypassInfo \n int context_id \n int BI_DIR_IIOP \n int INVOCATION_POLICIES \n int FT_REQUEST \n long serialVersionUID \n int SecurityAttributeService \n\n void add \n ServiceContext[] add \n void writeSequence \n ServiceContext read \n ServiceContext[] readSequence \n String toString \n void write \n org.omg.IOP.ServiceContext findContext \n org.omg.IOP.ServiceContext findContext", "output": "ServiceContext function ( int arg0 , ServiceContext [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1 . length ; loc0 ++ ) if ( arg1 [ loc0 ] . context_id == arg0 ) return arg1 [ loc0 ] ; return null ; }"}, {"instruction": "Generate java code\nthis will get the current clipping path . do not modify this area object ! ", "input": " double nonStrokingAlphaConstant \n boolean isClippingPathDirty \n boolean alphaSource \n double smoothness \n PDColor nonStrokingColor \n PDSoftMask softMask \n RenderingIntent renderingIntent \n double alphaConstant \n boolean overprint \n PDColorSpace strokingColorSpace \n PDLineDashPattern lineDashPattern \n double overprintMode \n PDColor strokingColor \n PDColorSpace nonStrokingColorSpace \n Region clippingPath \n PDTextState textState \n Paint.Join lineJoin \n Paint.Cap lineCap \n BlendMode blendMode \n double flatness \n float miterLimit \n boolean strokeAdjustment \n float lineWidth \n Matrix currentTransformationMatrix \n\n void setAlphaConstant \n PDTextState getTextState \n void setNonStrokingColor \n PDSoftMask getSoftMask \n double getOverprintMode \n void setLineDashPattern \n double getFlatness \n void setStrokingColorSpace \n double getSmoothness \n PDColor getStrokingColor \n void setLineWidth \n Paint.Cap getLineCap \n RenderingIntent getRenderingIntent \n BlendMode getBlendMode \n float getLineWidth \n void setFlatness \n void setSoftMask \n Paint.Join getLineJoin \n boolean isStrokeAdjustment \n void setSmoothness \n PDColorSpace getNonStrokingColorSpace \n void setTextState \n void setNonStrokeAlphaConstant \n void setRenderingIntent \n void setOverprint \n void setOverprintMode \n void setNonStrokingColorSpace \n void setLineJoin \n double getAlphaConstant \n void setStrokingColor \n Matrix getCurrentTransformationMatrix \n PDColorSpace getStrokingColorSpace \n void setAlphaSource \n double getNonStrokeAlphaConstant \n void intersectClippingPath \n void intersectClippingPath \n void setBlendMode \n float getMiterLimit \n void setLineCap \n void setStrokeAdjustment \n PDGraphicsState clone \n void setMiterLimit \n boolean isAlphaSource \n void setCurrentTransformationMatrix \n boolean isOverprint \n PDLineDashPattern getLineDashPattern \n PDColor getNonStrokingColor", "output": "Region function ( ) { return clippingPath ; }"}, {"instruction": "Generate java code\nreturns the line with the given number ", "input": " List<String> lines \n Map<String,Integer> tags \n Pattern TAG_PATTERN \n\n int getLineNumber \n void addLine \n Source getSourceFor \n List<String> getLines", "output": "String function ( int arg0 ) { return lines . get ( arg0 - 1 ) ; }"}, {"instruction": "Generate java code\nreturns the distance from the source to the given vertex . if the vertex is unreachable , the distance returned is double.positive _ infinity . ", "input": " int[] edgeTo \n double[] distTo \n IndexMinPriorityQueue<Double> indexMinPQ \n double INFINITY \n\n void relax \n boolean hasPathTo \n void checkNegativeEdges \n Iterable<Integer> pathTo", "output": "double function ( int arg0 ) { return distTo [ arg0 ] ; }"}, {"instruction": "Generate java code\ncall init at the beginning of every request rendering . this should also work to refresh session-scoped beans , but it 's only been tested with request scope . ", "input": " Log logger \n boolean notValidated \n\n void setNotValidated \n void init \n void endProcessUpdates \n void setConfigured \n boolean isNotValidated \n void endProcessValidators", "output": "void function ( ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( \"srini_string\" + isNotValidated ( ) ) ; init ( ) ; }"}, {"instruction": "Generate java code\nreturns the value for the setting id , or 0 if unset . ", "input": " int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS \n int DOWNLOAD_BANDWIDTH \n int set \n int DEFAULT_INITIAL_WINDOW_SIZE \n int UPLOAD_BANDWIDTH \n int CLIENT_CERTIFICATE_VECTOR_SIZE \n int[] values \n int PERSISTED \n int FLOW_CONTROL_OPTIONS \n int COUNT \n int MAX_CONCURRENT_STREAMS \n int persistValue \n int CURRENT_CWND \n int DOWNLOAD_RETRANS_RATE \n int ROUND_TRIP_TIME \n int persisted \n int PERSIST_VALUE \n int INITIAL_WINDOW_SIZE \n int FLOW_CONTROL_OPTIONS_DISABLED \n\n int getDownloadRetransRate \n void set \n boolean isSet \n int getUploadBandwidth \n int flags \n int getCurrentCwnd \n boolean isPersisted \n int size \n int getInitialWindowSize \n boolean persistValue \n int getDownloadBandwidth \n void merge \n boolean isFlowControlDisabled \n int getMaxConcurrentStreams \n int getRoundTripTime \n int getClientCertificateVectorSize", "output": "int function ( int arg0 ) { return values [ arg0 ] ; }"}, {"instruction": "Generate java code\ndetaches this adapter from the wrapped connection . this adapter becomes useless . ", "input": " long duration \n ClientConnectionManager connManager \n OperatedClientConnection wrappedConnection \n boolean markedReusable \n boolean released \n\n void setSocketTimeout \n void setIdleDuration \n int getLocalPort \n void releaseConnection \n void abortConnection \n boolean isMarkedReusable \n HttpConnectionMetrics getMetrics \n void assertValid \n int getRemotePort \n InetAddress getLocalAddress \n void setAttribute \n void bind \n void unmarkReusable \n Object getAttribute \n void flush \n boolean isReleased \n Object removeAttribute \n void assertNotAborted \n void markReusable \n ClientConnectionManager getManager \n InetAddress getRemoteAddress \n boolean isSecure \n OperatedClientConnection getWrappedConnection \n int getSocketTimeout \n SSLSession getSSLSession \n boolean isOpen \n Socket getSocket \n boolean isResponseAvailable \n boolean isStale \n HttpResponse receiveResponseHeader \n void sendRequestEntity \n void receiveResponseEntity \n void sendRequestHeader", "output": "void function ( ) { wrappedConnection = null ; duration = Long . MAX_VALUE ; }"}, {"instruction": "Generate java code\nset the non full screen page mode preference . ", "input": " String NON_FULL_SCREEN_PAGE_MODE_USE_NONE \n String BOUNDARY_BLEED_BOX \n String NON_FULL_SCREEN_PAGE_MODE_USE_OPTIONAL_CONTENT \n String READING_DIRECTION_L2R \n String BOUNDARY_CROP_BOX \n String BOUNDARY_ART_BOX \n String NON_FULL_SCREEN_PAGE_MODE_USE_OUTLINES \n String BOUNDARY_TRIM_BOX \n String READING_DIRECTION_R2L \n String NON_FULL_SCREEN_PAGE_MODE_USE_THUMBS \n String BOUNDARY_MEDIA_BOX \n COSDictionary prefs \n\n String getNonFullScreenPageMode \n boolean fitWindow \n void setHideMenubar \n void setViewArea \n void setViewArea \n void setViewClip \n void setViewClip \n void setPrintArea \n void setPrintArea \n void setPrintClip \n void setPrintClip \n boolean hideToolbar \n void setReadingDirection \n void setReadingDirection \n boolean hideMenubar \n void setHideToolbar \n String getViewArea \n String getViewClip \n void setDuplex \n String getDuplex \n COSBase getCOSObject \n String getReadingDirection \n void setCenterWindow \n String getPrintScaling \n boolean hideWindowUI \n void setPrintScaling \n void setDisplayDocTitle \n boolean centerWindow \n COSDictionary getDictionary \n void setHideWindowUI \n String getPrintArea \n String getPrintClip \n boolean displayDocTitle \n void setFitWindow", "output": "void function ( NON_FULL_SCREEN_PAGE_MODE arg0 ) { prefs . setName ( COSName . NON_FULL_SCREEN_PAGE_MODE , arg0 . toString ( ) ) ; }"}, {"instruction": "Generate java code\nget column of mysql type : varchar , char , enum , set , text , tinytext , mediumtext , longtext ", "input": " Map<String,Object> columns \n long serialVersionUID \n\n Record setColumns \n Record setColumns \n String[] getColumnNames \n java.sql.Time getTime \n void processColumnsMap \n Double getDouble \n java.math.BigDecimal getBigDecimal \n Float getFloat \n Record remove \n Record remove \n byte[] getBytes \n Map<String,Object> getColumns \n Number getNumber \n java.sql.Timestamp getTimestamp \n int hashCode \n T get \n T get \n java.util.Date getDate \n Boolean getBoolean \n Record setContainerFactoryByConfigName \n java.math.BigInteger getBigInteger \n Record set \n Object[] getColumnValues \n Record clear \n Long getLong \n Integer getInt \n void setColumnsMap \n Record removeNullValueColumns \n String toJson \n Record keep \n Record keep \n boolean equals \n String toString", "output": "String function ( String arg0 ) { return ( String ) getColumns ( ) . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nappends the channel type to the channel to build ", "input": " ChannelTypeUID channelTypeUID \n Configuration configuration \n ChannelKind kind \n ChannelUID channelUID \n String description \n String acceptedItemType \n String label \n Set<String> defaultTags \n Map<String,String> properties \n\n ChannelBuilder withConfiguration \n ChannelBuilder withKind \n ChannelBuilder withProperties \n Channel build \n ChannelBuilder create \n ChannelBuilder withDescription \n ChannelBuilder withDefaultTags \n ChannelBuilder withLabel", "output": "ChannelBuilder function ( ChannelTypeUID arg0 ) { this . channelTypeUID = arg0 ; return this ; }"}, {"instruction": "Generate java code\nthis will print out a message telling how to use this example . ", "input": " PlaceHolder placeHolder \n\n void main", "output": "void function ( ) { System . err . println ( \"srini_string\" + PrintURLs . class . getName ( ) + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the globally accessible resizablewidgetcollection . in most cases , the global collection can be used for all resizablewidget s. ", "input": " ResizableWidget widget \n int curOffsetHeight \n int curClientWidth \n Map<ResizableWidget,ResizableWidgetInfo> widgets \n ResizableWidgetCollection staticCollection \n int resizeCheckDelay \n HandlerRegistration windowHandler \n boolean resizeCheckingEnabled \n int curOffsetWidth \n int DEFAULT_RESIZE_CHECK_DELAY \n int windowHeight \n int curClientHeight \n Timer resizeCheckTimer \n int windowWidth \n\n void add \n void updateWidgetSize \n int getClientWidth \n boolean isResizeCheckingEnabled \n void run \n int getOffsetWidth \n boolean updateSizes \n void remove \n void setResizeCheckingEnabled \n int getResizeCheckDelay \n int getOffsetHeight \n void onResize \n Iterator<ResizableWidget> iterator \n void setResizeCheckDelay \n int getClientHeight \n void checkWidgetSize", "output": "ResizableWidgetCollection function ( ) { if ( staticCollection == null ) { staticCollection = new ResizableWidgetCollection ( ) ; } return staticCollection ; }"}, {"instruction": "Generate java code\ndisable some features in the status bar . pass the bitwise-or of the disable _ flags . to re-enable everything , pass #disable_none . ", "input": " int DISABLE_SYSTEM_INFO \n int DISABLE_CLOCK \n int DISABLE_NAVIGATION \n int DISABLE_RECENT \n int DISABLE_NONE \n Context mContext \n int DISABLE_NOTIFICATION_TICKER \n IStatusBarService mService \n int DISABLE_MASK \n int DISABLE_HOME \n int DISABLE_BACK \n int DISABLE_EXPAND \n int DISABLE_NOTIFICATION_ALERTS \n IBinder mToken \n int DISABLE_NOTIFICATION_ICONS \n\n void setIcon \n void expand \n void removeIcon \n void setIconVisibility \n IStatusBarService getService \n void collapse", "output": "void function ( int arg0 ) { try { final IStatusBarService loc0 = getService ( ) ; if ( loc0 != null ) { loc0 . disable ( arg0 , mToken , mContext . getPackageName ( ) ) ; } } catch ( RemoteException loc0 ) { throw new RuntimeException ( loc0 ) ; } }"}, {"instruction": "Generate java code\nkeeps records if their value is not equal to the provided value . nulls are treated the same way the java programming language does . for example : noteq column , null will keep all records whose value is not null . noteq column , 7 will keep all records whose value is not 7 , including records whose value is null . note : this is different from how some query languages handle null . for example , sql and pig will drop nulls when you filter by not equal to 7 . to achieve similar behavior in this api , do : and noteq column , 7 , noteq column , null note : be sure to read the #lt , #lteq , #gt , #gteq operator 's docsfor how they handle nulls ", "input": " PlaceHolder placeHolder \n\n FilterPredicate or \n LtEq<T> ltEq \n UserDefined<T,U> userDefined \n UserDefined<T,U> userDefined \n Lt<T> lt \n BooleanColumn booleanColumn \n GtEq<T> gtEq \n IntColumn intColumn \n Eq<T> eq \n Gt<T> gt \n DoubleColumn doubleColumn \n BinaryColumn binaryColumn \n FilterPredicate not \n FilterPredicate and \n LongColumn longColumn \n FloatColumn floatColumn", "output": "NotEq < T > function ( C arg0 , T arg1 ) { return new NotEq < T > ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns true if this object is equal to the specified object , and false otherwise . ", "input": " RectangleAnchor LEFT \n RectangleAnchor RIGHT \n RectangleAnchor TOP_LEFT \n RectangleAnchor TOP_RIGHT \n RectangleAnchor BOTTOM_RIGHT \n RectangleAnchor BOTTOM_LEFT \n String name \n RectangleAnchor TOP \n long serialVersionUID \n RectangleAnchor CENTER \n RectangleAnchor BOTTOM \n\n Rectangle2D createRectangle \n Object readResolve \n int hashCode \n Point2D coordinates \n String toString", "output": "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if ( ! ( arg0 instanceof RectangleAnchor ) ) { return false ; } final RectangleAnchor loc0 = ( RectangleAnchor ) arg0 ; if ( ! this . name . equals ( loc0 . name ) ) { return false ; } return true ; }"}, {"instruction": "Generate java code\ngets the value of the factor property . ", "input": " BigInteger radix \n String unit \n BigInteger factor \n BigDecimal value \n\n BigDecimal getValue \n void setFactor \n void setValue \n void setUnit \n String getUnit \n void setRadix \n BigInteger getRadix", "output": "BigInteger function ( ) { return factor ; }"}, {"instruction": "Generate java code\nget custom deserializer ", "input": " java.lang.Long adxBuyerNetworkId \n java.lang.Object __equalsCalc \n org.apache.axis.description.TypeDesc typeDesc \n boolean __hashCodeCalc \n com.google.api.ads.dfp.axis.v201405.BuyerPlatform buyerPlatform \n java.lang.Long buyerId \n com.google.api.ads.dfp.axis.v201405.BillingTermsType billingTermsType \n com.google.api.ads.dfp.axis.v201405.ProgrammaticStatus status \n\n org.apache.axis.description.TypeDesc getTypeDesc \n void setBuyerId \n com.google.api.ads.dfp.axis.v201405.BuyerPlatform getBuyerPlatform \n com.google.api.ads.dfp.axis.v201405.ProgrammaticStatus getStatus \n void setStatus \n java.lang.Long getAdxBuyerNetworkId \n org.apache.axis.encoding.Serializer getSerializer \n void setBuyerPlatform \n void setBillingTermsType \n int hashCode \n java.lang.Long getBuyerId \n boolean equals \n void setAdxBuyerNetworkId \n com.google.api.ads.dfp.axis.v201405.BillingTermsType getBillingTermsType", "output": "org . apache . axis . encoding . Deserializer function ( java . lang . String arg0 , java . lang . Class arg1 , javax . xml . namespace . QName arg2 ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( arg1 , arg2 , typeDesc ) ; }"}, {"instruction": "Generate java code\ngets the value of the description property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the description property . for example , to add a new item , do as follows : getdescription . add newitem ; objects of the following type s are allowed in the list descriptiontype ", "input": " EjbRefTypeType ejbRefType \n EjbLinkType ejbLink \n List<InjectionTargetType> injectionTarget \n List<DescriptionType> description \n java.lang.String id \n EjbRefNameType ejbRefName \n RemoteType remote \n XsdStringType mappedName \n HomeType home \n\n void setEjbRefName \n XsdStringType getMappedName \n EjbRefTypeType getEjbRefType \n EjbRefNameType getEjbRefName \n void setHome \n java.lang.String getId \n void setEjbLink \n EjbLinkType getEjbLink \n List<InjectionTargetType> getInjectionTarget \n HomeType getHome \n void setMappedName \n void setEjbRefType \n void setId \n RemoteType getRemote \n void setRemote", "output": "List < DescriptionType > function ( ) { if ( description == null ) { description = new ArrayList < DescriptionType > ( ) ; } return this . description ; }"}, {"instruction": "Generate java code\nlike add stats but min , max , and avg are all equal . ", "input": " int min \n int max \n int avg \n int num \n\n void merge \n void merge \n Stats create \n String toString \n void dump", "output": "void function ( int arg0 ) { min += arg0 ; avg += arg0 ; max += arg0 ; num = 1 ; }"}, {"instruction": "Generate java code\nget preferred reset method ", "input": " long fSoptAddress \n ResetMethods fResetMethods \n String fSubFamily \n FileList fFileList \n TargetType fTargetType \n Vector<MemoryRegion> fMemoryRegions \n int fClockTrimFrequency \n boolean fDefaultDevice \n EraseMethods fEraseMethods \n String fFamily \n int fClockAddres \n String fName \n String fHardware \n ClockTypes fClockType \n int fClockNvAddress \n String fAlias \n boolean fHidden \n\n ClockTypes getClockType \n void addMemoryRegion \n void setFamily \n String getName \n PrintStream toXML \n void setSubFamily \n String getHardware \n int getClockTrimFrequency \n long getSoptAddress \n int getClockAddres \n int getDefaultClockTrimFreq \n int getDefaultClockTrimFreq \n PrintStream doIndent \n ProjectActionList getProjectActionList \n void setResetMethod \n int getDefaultClockTrimNVAddress \n int getDefaultClockTrimNVAddress \n int getClockNvAddress \n void setHidden \n FileList getFileListMap \n EraseMethods getEraseMethods \n void setClockNvAddress \n void setEraseMethod \n Device shallowCopy \n void setHardware \n void setClockType \n TargetType getTargetType \n void setPreferredResetMethod \n ResetMethods getResetMethods \n EraseMethod getPreferredEraseMethod \n void setSoptAddress \n Iterator<MemoryRegion> getMemoryRegionIterator \n void setDefault \n boolean isHidden \n boolean isDefault \n boolean isDefaultDevice \n void addToFileList \n boolean isAlias \n void setClockAddres \n void setClockTrimFrequency \n String getFamily \n Object clone \n String toString \n String getSubFamily \n void setPreferredEraseMethod \n void setAlias \n String getAlias", "output": "ResetMethod function ( ) { return fResetMethods . getPreferredMethod ( ) ; }"}, {"instruction": "Generate java code\nthe name of the option group option . returns a reference to this object so that method calls can be chained together . ", "input": " String applyType \n String allowedValues \n String settingDescription \n String defaultValue \n Boolean isModifiable \n String settingName \n\n void setDefaultValue \n OptionGroupOptionSetting withIsModifiable \n String getApplyType \n void setAllowedValues \n void setSettingName \n String getSettingDescription \n Boolean isModifiable \n String getSettingName \n String getDefaultValue \n void setApplyType \n void setIsModifiable \n Boolean getIsModifiable \n OptionGroupOptionSetting withSettingDescription \n OptionGroupOptionSetting withApplyType \n int hashCode \n boolean equals \n void setSettingDescription \n OptionGroupOptionSetting clone \n String toString \n OptionGroupOptionSetting withDefaultValue \n String getAllowedValues \n OptionGroupOptionSetting withAllowedValues", "output": "OptionGroupOptionSetting function ( String arg0 ) { this . settingName = arg0 ; return this ; }"}, {"instruction": "Generate java code\nserialize an instance , restore it , and check for equality . ", "input": " PlaceHolder placeHolder \n\n void testCloning \n void testEventNotification \n void testFindRangeBounds \n void testPublicCloneable \n void testGetLegendItem \n void testHashcode \n void testGetLegendItemSeriesIndex \n void testEquals", "output": "void function ( ) { BarRenderer loc0 = new BarRenderer ( ) ; BarRenderer loc1 = ( BarRenderer ) TestUtilities . serialised ( loc0 ) ; assertEquals ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nallows to check if current change is within the given bounds . ", "input": " char[] myChars \n int myEnd \n StringBuilder myText \n int myStart \n\n int getStart \n int getDiff \n void setStart \n CharSequence getText \n char[] getChars \n int hashCode \n boolean equals \n String toString \n void setEnd \n int getEnd \n void advance", "output": "boolean function ( int arg0 , int arg1 ) { return myStart >= arg0 && myEnd <= arg1 && myStart <= myEnd ; }"}, {"instruction": "Generate java code\nset the result . any handler will be called , if there is one ", "input": " T result \n Handler<AsyncResult<T>> handler \n Throwable throwable \n boolean failed \n boolean succeeded \n\n T result \n void checkComplete \n Future<T> setHandler \n void fail \n void fail \n Throwable cause \n Handler<AsyncResult<T>> completer \n void handle \n void handle \n boolean failed \n void checkCallHandler \n boolean succeeded \n boolean isComplete", "output": "void function ( T arg0 ) { checkComplete ( ) ; this . result = arg0 ; succeeded = true ; checkCallHandler ( ) ; }"}, {"instruction": "Generate java code\ntests if the block is marked to move out of its current dir in this view . ", "input": " BlockMetadataManager mMetadataManager \n BitSet mInUseLocks \n Set<Long> mPinnedInodes \n Map<String,StorageTierView> mAliasToTierViews \n List<StorageTierView> mTierViews \n\n List<StorageTierView> getTierViews \n List<StorageTierView> getTierViewsBelow \n StorageTierView getTierView \n BlockMeta getBlockMeta \n void clearBlockMarks \n StorageTierView getNextTier \n boolean isBlockPinned \n long getAvailableBytes \n boolean isBlockLocked \n boolean isBlockEvictable", "output": "boolean function ( long arg0 ) { for ( StorageTierView loc0 : mTierViews ) { for ( StorageDirView loc1 : loc0 . getDirViews ( ) ) { if ( loc1 . isMarkedToMoveOut ( arg0 ) ) { return true ; } } } return false ; }"}, {"instruction": "Generate java code\nremoves filter . ", "input": " StructuredViewer viewer \n boolean isCreated \n ReviewFilterManager theInstance \n ViewerFilter viewerFilter \n\n ViewerFilter createFilterFromProperty \n void addFilter \n ViewerFilter createFilterFromPreference \n ReviewFilterManager getInstance \n ReviewFilterManager getInstance \n void setFilter", "output": "void function ( ) { this . viewer . removeFilter ( this . viewerFilter ) ; }"}, {"instruction": "Generate java code\na setter to activate , deactivate the formatted output ", "input": " boolean successFullParsing \n Logger logger \n BQConnection connection \n boolean formatted \n String queryToParse \n Node myNode \n\n Connection getConnection \n boolean isFormatted \n void setQueryToParse \n void setConnection \n String parse", "output": "void function ( boolean arg0 ) { this . formatted = arg0 ; }"}, {"instruction": "Generate java code\napi level check to see if the new api 17 textclock is available ", "input": " String TAG \n boolean D \n\n float getScaleRatio \n boolean isNetworkAvailable", "output": "boolean function ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ; }"}, {"instruction": "Generate java code\nthis implementation is empty . ", "input": " PlaceHolder placeHolder \n\n void configureDefaultServletHandling \n void configureViewResolvers \n void configureContentNegotiation \n void addFormatters \n void extendMessageConverters \n MessageCodesResolver getMessageCodesResolver \n void addArgumentResolvers \n void configureMessageConverters \n void configureHandlerExceptionResolvers \n void addCorsMappings \n void configureAsyncSupport \n void addResourceHandlers \n void addViewControllers \n Validator getValidator \n void configurePathMatch \n void addInterceptors \n void extendHandlerExceptionResolvers", "output": "void function ( List < HandlerMethodReturnValueHandler > arg0 ) { }"}, {"instruction": "Generate java code\ndonne le nombre total d'arguments fournis par l'utilisateur . ", "input": " ArrayList<CommandLineArgument> arguments \n\n String getValue \n Integer getIntegerValue \n boolean isDefined \n String getLastOrphanValue \n String getInvalidArgument", "output": "int function ( ) { return this . arguments . size ( ) ; }"}, {"instruction": "Generate java code\nre-sets the string . this is intented to be used in search keys only . ", "input": " String string \n FontRenderContext fontRenderContext \n Font font \n\n void setFontRenderContext \n int hashCode \n boolean equals \n void setFont", "output": "void function ( String arg0 ) { string = arg0 ; }"}, {"instruction": "Generate java code\nbuilds a new com.lightbend.lagom.internal.registry.registeredservice registeredservice . ", "input": " long INIT_BIT_URL \n long initBits \n long INIT_BIT_NAME \n String name \n String url \n\n void setName \n String formatRequiredAttributesMessage \n boolean equalTo \n RegisteredService withUrl \n RegisteredService copyOf \n String url \n String url \n Builder url \n void setUrl \n void checkRequiredAttributes \n int hashCode \n boolean equals \n RegisteredService of \n String name \n String name \n Builder name \n RegisteredService.Builder builder \n RegisteredService fromJson \n boolean nameIsSet \n String toString \n Builder from \n RegisteredService withName \n boolean urlIsSet", "output": "RegisteredService function ( ) { checkRequiredAttributes ( ) ; return new RegisteredService ( null , name , url ) ; }"}, {"instruction": "Generate java code\ngets a persistent record with the devices to be notified using a multicast message . ", "input": " Logger LOG \n\n void deleteMulticast \n Long createMulticast \n void updateMulticast", "output": "MulticastMessage function ( Long arg0 ) { return ofy ( ) . load ( ) . type ( MulticastMessage . class ) . arg0 ( arg0 ) . get ( ) ; }"}, {"instruction": "Generate java code\nreturns the definition with the primary key or returns null if it could not be found . ", "input": " DefinitionPersistence _persistence \n\n int countAll \n void cacheResult \n void cacheResult \n List<Definition> findWithDynamicQuery \n List<Definition> findWithDynamicQuery \n List<Definition> findWithDynamicQuery \n Definition update \n Definition update \n void clearCache \n void clearCache \n long countWithDynamicQuery \n List<Definition> findAll \n List<Definition> findAll \n List<Definition> findAll \n List<Definition> findAll \n Definition remove \n void removeAll \n DefinitionPersistence getPersistence \n Definition create \n java.util.Map<java.io.Serializable,Definition> fetchByPrimaryKeys \n Definition findByPrimaryKey \n void setPersistence \n Definition updateImpl", "output": "Definition function ( long arg0 ) { return getPersistence ( ) . fetchByPrimaryKey ( arg0 ) ; }"}, {"instruction": "Generate java code\nrelease state . ", "input": " Tag parent \n PageContext pageContext \n Hashtable values \n String id \n\n Tag getParent \n Enumeration getValues \n String getId \n int doAfterBody \n int doEndTag \n int doStartTag \n Object getValue \n void setPageContext \n void removeValue \n Tag findAncestorWithClass \n void setValue \n void setId \n void setParent", "output": "void function ( ) { parent = null ; id = null ; if ( values != null ) { values . clear ( ) ; } values = null ; }"}, {"instruction": "Generate java code\nreturns the frame checksum as contained in the frame . the returned checksum is taken from the frame `` as is '' , it is not recalculated for validation nor checked for correctness . the length and structure of the returned checksum depends on the communication medium . ", "input": " boolean ext \n Priority p \n int hopcount \n KNXAddress dst \n IndividualAddress src \n int fcs \n byte[] tpdu \n int type \n boolean repetition \n\n byte getHopcount \n boolean isRepetition \n KNXAddress getDestination \n IndividualAddress getSource \n byte[] getTPDU \n int readCtrlEx \n Priority getPriority \n int getFrameType \n String toString \n void setDestination", "output": "int function ( ) { return fcs ; }"}, {"instruction": "Generate java code\nreturns a doublefunction returning the given value if this function throws an exception . ", "input": " PlaceHolder placeHolder \n\n R apply \n ThrowingDoubleFunction<R> orTryWith \n ThrowingDoubleFunction<R> orTryWith \n DoubleFunction<R> fallbackTo \n DoubleFunction<R> fallbackTo \n R applyThrowing \n ThrowingDoubleFunction<R> orThrow \n ThrowingDoubleFunction<R> orThrow", "output": "DoubleFunction < R > function ( R arg0 , Consumer < Exception > arg1 ) { return argument -> { try { return applyThrowing ( argument ) ; } catch ( Exception loc0 ) { if ( arg1 != null ) { arg1 . accept ( loc0 ) ; } return arg0 ; } } ; }"}, {"instruction": "Generate java code\nserializes the given point ", "input": " PlaceHolder placeHolder \n\n void serialize \n void serializeRectangle \n void serializeLineString \n void serializePolygon \n void serializeMulitPolygon \n void serializePolygonCoordinates \n void serializeMultiPoint \n void serializeCoordinate", "output": "void function ( Point arg0 , XContentBuilder arg1 ) { arg1 . field ( \"srini_string\" , \"srini_string\" ) . startArray ( \"srini_string\" ) . value ( arg0 . getX ( ) ) . value ( arg0 . getY ( ) ) . endArray ( ) ; }"}, {"instruction": "Generate java code\nsets the value of the rval property . ", "input": " UpdateResult rval \n\n UpdateResult getRval", "output": "void function ( UpdateResult arg0 ) { this . rval = arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the ref property . ", "input": " IsoformType.Sequence sequence \n IsoformType.Note note \n String ref \n String evidence \n List<Name> name \n List<String> id \n String type \n String value \n\n void setSequence \n String getEvidence \n String getEvidence \n List<Name> getName \n List<String> getId \n IsoformType.Note getNote \n void setType \n String getValue \n String getValue \n void setRef \n String getType \n void setValue \n void setValue \n void setNote \n IsoformType.Sequence getSequence \n void setEvidence \n void setEvidence", "output": "String function ( ) { return ref ; }"}, {"instruction": "Generate java code\nget dtometadata field ", "input": " Item item \n ItemService itemService \n List<DtoMetadata> undoDtomList \n Transformer transformer \n String DUBLIN_CORE_XML \n File dir \n HandleService handleService \n Logger log \n String dirname \n DocumentBuilder builder \n List<DtoMetadata> dtomList \n List<UUID> undoAddContents \n\n void addUndoMetadataField \n List<DtoMetadata> getMetadataFields \n Transformer getTransformer \n void addUndoDeleteContents \n String getDirectoryName \n Item getItem \n Item itemFromMetadataField \n ItemArchive create \n File getDirectory \n Item itemFromHandleInput \n DocumentBuilder getDocumentBuilder \n void writeUndo", "output": "DtoMetadata function ( String arg0 ) { for ( DtoMetadata loc0 : dtomList ) { if ( loc0 . matches ( arg0 , false ) ) { return loc0 ; } } return null ; }"}, {"instruction": "Generate java code\ncheck if your app is the default system sms app . ", "input": " PlaceHolder placeHolder \n\n boolean hasKitKat \n void setDefaultSmsApp \n boolean hasJellyBeanMR2", "output": "boolean function ( Context arg0 ) { if ( hasKitKat ( ) ) { return arg0 . getPackageName ( ) . equals ( Telephony . Sms . getDefaultSmsPackage ( arg0 ) ) ; } return true ; }"}, {"instruction": "Generate java code\nsee #diagnosticdata ", "input": " XmlDom signingCertificate \n String contextName \n XmlDom bvData \n POEExtraction poe \n ValidationPolicy countersignatureValidationPolicy \n XmlDom ltvData \n XmlDom tsData \n Date currentTime \n ValidationPolicy currentValidationPolicy \n XmlDom contextElement \n XmlDom adestData \n DiagnosticData diagnosticData \n XmlDom signatureContext \n XmlDom basicBuildingBlocksReport \n XmlDom certPool \n String signingCertificateId \n ValidationPolicy validationPolicy \n\n XmlDom getTsData \n XmlDom getCertPool \n void setContextElement \n void setBvData \n void setLtvData \n void setPOE \n void setValidationPolicy \n XmlDom getSigningCertificate \n XmlDom getBasicBuildingBlocksReport \n ValidationPolicy getValidationPolicy \n void setContextName \n XmlDom getCertificate \n XmlDom getCertificate \n String getContextName \n XmlDom getContextElement \n POEExtraction getPOE \n Date getCurrentTime \n String getSigningCertificateId \n void setSigningCertificateId \n void setCurrentValidationPolicy \n XmlDom getBvData \n void setCountersignatureValidationPolicy \n XmlDom getDiagnosticData \n void setBBBData \n XmlDom getSignatureContext \n void setSigningCertificate \n void setCertPool \n XmlDom getAdestData \n void setAdestData \n void setCurrentTime \n ValidationPolicy getCurrentValidationPolicy \n void setTsData \n String toString \n ValidationPolicy getCountersignatureValidationPolicy \n XmlDom getLtvData \n void setSignatureContext", "output": "void function ( final DiagnosticData arg0 ) { this . diagnosticData = arg0 ; }"}, {"instruction": "Generate java code\ncheck whether the object has been invalidated . ", "input": " Throwable invalidated \n Logger log \n boolean USE_CHECKS \n Object monitorable \n\n boolean check \n void invalidate", "output": "boolean function ( ) { return invalidated != null ; }"}, {"instruction": "Generate java code\nget the server capabilities . ", "input": " String password \n HttpServletRequest request \n SecurityContext security \n Capabilities capabilities \n String auth \n HttpServletResponse response \n String username \n ServletConfig config \n String VERSION \n\n String getClientPassword \n String getServerCapability \n HttpServletRequest getRequest \n HttpServletResponse getResponse \n String getClientUsername \n void configureAuthorization \n void configureCapabilities \n SecurityContext getSecurityContext", "output": "Capabilities function ( ) { if ( capabilities == null ) { configureCapabilities ( ) ; } return capabilities ; }"}, {"instruction": "Generate java code\nset the location of a quartz job definition xml file that follows the `` job_scheduling_data_1_5 '' xsd or better . can be specified to automatically register jobs that are defined in such a file , possibly in addition to jobs defined directly on this schedulerfactorybean . ", "input": " Log logger \n Map<String,Calendar> calendars \n String[] jobSchedulingDataLocations \n TriggerListener[] globalTriggerListeners \n PlatformTransactionManager transactionManager \n SchedulerListener[] schedulerListeners \n ResourceLoader resourceLoader \n boolean overwriteExistingJobs \n List<JobDetail> jobDetails \n List<Trigger> triggers \n JobListener[] globalJobListeners \n\n void setSchedulerListeners \n void setJobSchedulingDataLocations \n void registerJobsAndTriggers \n void setGlobalJobListeners \n void setOverwriteExistingJobs \n boolean addTriggerToScheduler \n void setResourceLoader \n void setTransactionManager \n void setCalendars \n void registerListeners \n void setTriggers \n void setJobDetails \n void setGlobalTriggerListeners \n Scheduler getScheduler \n boolean addJobToScheduler", "output": "void function ( String arg0 ) { this . jobSchedulingDataLocations = new String [ ] { arg0 } ; }"}, {"instruction": "Generate java code\ncalculates the y-coordinate of the top edge given the other sides of the rectangle and an aspect ratio . ", "input": " PlaceHolder placeHolder \n\n float calculateAspectRatio \n float calculateAspectRatio \n float calculateWidth \n float calculateLeft \n float calculateRight \n float calculateHeight \n float calculateBottom", "output": "float function ( float arg0 , float arg1 , float arg2 , float arg3 ) { final float loc0 = arg1 - arg0 ; final float loc1 = arg2 - ( loc0 / arg3 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nreturns the point that is at the specified length along the path . ", "input": " float startOffset \n PathLength pathLength \n\n float angleAtLength \n void setStartOffset \n float getStartOffset \n float lengthOfPath", "output": "Point2D function ( float arg0 ) { return pathLength . pointAtLength ( arg0 ) ; }"}, {"instruction": "Generate java code\nclients should invoke this method when they encounter a connectivity failure on a connection returned by this route selector . ", "input": " int nextSocketAddressIndex \n List<Route> postponedRoutes \n int TLS_MODE_MODERN \n Address address \n Iterator<Proxy> proxySelectorProxies \n ConnectionPool pool \n Dns dns \n RouteDatabase routeDatabase \n URI uri \n int socketPort \n int TLS_MODE_NULL \n ProxySelector proxySelector \n int nextTlsMode \n Proxy lastProxy \n InetAddress[] socketAddresses \n Proxy userSpecifiedProxy \n boolean hasNextProxy \n int TLS_MODE_COMPATIBLE \n InetSocketAddress lastInetSocketAddress \n\n Connection next \n void resetNextInetSocketAddress \n int nextTlsMode \n Proxy nextProxy \n void resetNextProxy \n boolean hasNextPostponed \n boolean hasNext \n InetSocketAddress nextInetSocketAddress \n void resetNextTlsMode \n boolean hasNextTlsMode \n boolean hasNextInetSocketAddress \n Route nextPostponed \n boolean hasNextProxy", "output": "void function ( Connection arg0 , IOException arg1 ) { Route loc0 = arg0 . getRoute ( ) ; if ( loc0 . getProxy ( ) . type ( ) != Proxy . Type . DIRECT && proxySelector != null ) { proxySelector . connectFailed ( uri , loc0 . getProxy ( ) . address ( ) , arg1 ) ; } routeDatabase . failed ( loc0 , arg1 ) ; }"}, {"instruction": "Generate java code\nadd an item view at the given index . ", "input": " MenuView mMenuView \n int mMenuLayoutRes \n Context mSystemContext \n MenuBuilder mMenu \n LayoutInflater mSystemInflater \n int mItemLayoutRes \n int mId \n Callback mCallback \n boolean IS_HONEYCOMB \n LayoutInflater mInflater \n Context mContext \n\n MenuView getMenuView \n View getItemView \n void initForMenu \n boolean onSubMenuSelected \n void setCallback \n int getId \n boolean flagActionItems \n void updateMenuView \n boolean shouldIncludeItem \n boolean collapseItemActionView \n void bindItemView \n MenuView.ItemView createItemView \n void setId \n boolean filterLeftoverView \n boolean expandItemActionView \n void onCloseMenu", "output": "void function ( View arg0 , int arg1 ) { final ViewGroup loc0 = ( ViewGroup ) arg0 . getParent ( ) ; if ( loc0 != null ) { loc0 . removeView ( arg0 ) ; } ( ( ViewGroup ) mMenuView ) . addView ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ntransaction sync is not affected by the current invocation , as multiple ejb methods may be invoked from aftercompletion ", "input": " AllowedMethodsInformation INSTANCE_CMT \n boolean beanManagedTransaction \n MethodType methodType \n AllowedMethodsInformation INSTANCE_BMT \n Set<DeniedMethodKey> denied \n Set<DeniedSyncMethodKey> deniedSyncMethods \n CurrentSynchronizationCallback.CallbackType callbackType \n\n void add \n void add \n void checkAllowed \n int hashCode \n void realCheckPermission \n boolean equals \n void setup \n void throwException \n void throwException", "output": "void function ( MethodType arg0 ) { final CurrentSynchronizationCallback . CallbackType loc0 = CurrentSynchronizationCallback . get ( ) ; if ( loc0 != null ) { if ( deniedSyncMethods . contains ( new DeniedSyncMethodKey ( loc0 , arg0 ) ) ) { throwException ( arg0 , loc0 ) ; } } }"}, {"instruction": "Generate java code\nparses an sps nal unit . ", "input": " int[] AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE \n int[] AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE \n byte[] NAL_START_CODE \n int SPS_NAL_UNIT_TYPE \n\n int findNalStartCode \n byte[][] splitNalUnits \n byte[] buildAacAudioSpecificConfig \n byte[] buildAacAudioSpecificConfig \n boolean isNalStartCode \n int parseAvcLevel \n int parseAvcProfile \n byte[] buildNalUnit \n Pair<Integer,Integer> parseAacAudioSpecificConfig", "output": "Pair < Integer , Integer > function ( byte [ ] arg0 ) { if ( isNalStartCode ( arg0 , 0 ) && arg0 . length == 8 && ( arg0 [ 5 ] & 0x1F ) == SPS_NAL_UNIT_TYPE ) { return Pair . create ( parseAvcProfile ( arg0 ) , parseAvcLevel ( arg0 ) ) ; } return null ; }"}, {"instruction": "Generate java code\nget the next value . the value can be wrapped in quotes . the value can be empty . ", "input": " PlaceHolder placeHolder \n\n JSONObject rowToJSONObject \n JSONArray toJSONArray \n JSONArray toJSONArray \n JSONArray toJSONArray \n JSONArray toJSONArray \n String rowToString \n String toString \n String toString \n JSONArray rowToJSONArray", "output": "String function ( JSONTokener arg0 ) { }"}, {"instruction": "Generate java code\nmethod setinfo ", "input": " String m_Info \n Object m_Parameter \n String m_Info_To \n String m_ParameterName \n Object m_Parameter_To \n long serialVersionUID \n\n String getParameterName \n String getInfo \n String getParameterAsString \n Object getParameter_To \n void setParameterName \n String getParameterToAsString \n boolean getParameterAsBoolean \n Timestamp getParameterAsTimestamp \n boolean getParameter_ToAsBoolean \n Timestamp getParameterToAsTimestamp \n String getInfo_To \n int getParameterAsInt \n void setParameter \n void setInfo_To \n void setParameter_To \n String toString \n BigDecimal getParameterAsBigDecimal \n int getParameter_ToAsInt \n BigDecimal getParameterToAsBigDecimal \n Object getParameter", "output": "void function ( String arg0 ) { if ( arg0 == null ) m_Info = \"srini_string\" ; else m_Info = arg0 ; }"}, {"instruction": "Generate java code\nset current path ", "input": " int FA_HIDDEN \n int FA_DIRECTORY \n File pwd \n int FA_READONLY \n\n void deleteFile \n void copyFile \n ClarionString getShortPath \n boolean isFile \n void getDirectoryListing \n File resolveFile \n ClarionString getPath", "output": "void function ( String arg0 ) { arg0 = arg0 . trim ( ) ; File loc0 = ClarionFileFactory . getInstance ( ) . getFile ( arg0 ) ; if ( loc0 . isDirectory ( ) ) { CErrorImpl . getInstance ( ) . clearError ( ) ; pwd = loc0 ; } else { CErrorImpl . getInstance ( ) . setError ( 03 , \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nreads a char starting at the given offset from base of this native object . ", "input": " Unsafe unsafe \n long address \n int pageSize \n ByteOrder byteOrder \n long allocationAddress \n\n NativeObject getObject \n long address \n byte getByte \n short getShort \n void putInt \n void putChar \n double getDouble \n void putDouble \n int pageSize \n float getFloat \n void putLong \n long allocationAddress \n NativeObject subObject \n long getLong \n int getInt \n void putFloat \n int addressSize \n void putByte \n void putObject \n void putShort \n ByteOrder byteOrder", "output": "char function ( int arg0 ) { return unsafe . getChar ( arg0 + address ) ; }"}, {"instruction": "Generate java code\nreturns the allow finish date of this course result . ", "input": " CourseResult _courseResult \n\n java.util.Date getStartDate \n void setExpandoBridgeAttributes \n void setPassedDate \n boolean isEscapedModel \n void setCourseId \n void setResult \n boolean isCachedModel \n com.liferay.portlet.expando.model.ExpandoBridge getExpandoBridge \n void setPassed \n int compareTo \n CourseResult getWrappedModel \n void setModelAttributes \n CourseResult getWrappedCourseResult \n Map<String,Object> getModelAttributes \n com.liferay.portal.model.CacheModel<com.liferay.lms.model.CourseResult> toCacheModel \n int hashCode \n void setPrimaryKey \n java.lang.String getComments \n void setUserUuid \n void persist \n void setComments \n void setNew \n long getCrId \n void setStartDate \n boolean isPassed \n void setCrId \n boolean getPassed \n java.lang.String getUserUuid \n void resetOriginalValues \n long getCourseId \n java.util.Date getPassedDate \n boolean isNew \n java.io.Serializable getPrimaryKeyObj \n Class<?> getModelClass \n long getPrimaryKey \n com.liferay.lms.model.CourseResult toEscapedModel \n void setAllowStartDate \n long getResult \n java.lang.String toXmlString \n void setPrimaryKeyObj \n java.lang.Object clone \n void setCachedModel \n java.util.Date getAllowStartDate \n java.lang.String toString \n String getModelClassName \n void setAllowFinishDate \n long getUserId \n void setUserId", "output": "java . util . Date function ( ) { return _courseResult . getAllowFinishDate ( ) ; }"}, {"instruction": "Generate java code\nset the resource adapter ", "input": " String property \n long serialVersionUID \n PrintWriter logwriter \n ResourceAdapter ra \n\n ManagedConnection createManagedConnection \n String getProperty \n void setLogWriter \n int hashCode \n void setProperty \n Object createConnectionFactory \n Object createConnectionFactory \n ManagedConnection matchManagedConnections \n boolean equals \n ResourceAdapter getResourceAdapter \n PrintWriter getLogWriter", "output": "void function ( ResourceAdapter arg0 ) { this . ra = arg0 ; }"}, {"instruction": "Generate java code\nspecify the name of the target database to operate on . the supported values are vendor-dependent platform identifiers . ", "input": " boolean generateDdl \n boolean showSql \n Database database \n String databasePlatform \n\n void setGenerateDdl \n boolean isGenerateDdl \n void postProcessEntityManagerFactory \n void setDatabase \n Map<String,?> getJpaPropertyMap \n JpaDialect getJpaDialect \n boolean isShowSql \n Class<? extends EntityManager> getEntityManagerInterface \n Database getDatabase \n void setShowSql \n String getPersistenceProviderRootPackage \n Class<? extends EntityManagerFactory> getEntityManagerFactoryInterface \n String getDatabasePlatform", "output": "void function ( String arg0 ) { this . databasePlatform = arg0 ; }"}, {"instruction": "Generate java code\nimplements pathhandler #curvetoquadraticsmoothrel float , float . ", "input": " float[] p \n LinkedList cs \n LinkedList ps \n short[] c \n int cindex \n int pcount \n int pindex \n int ccount \n\n void curvetoCubicRel \n void curvetoQuadraticAbs \n void closePath \n void linetoHorizontalAbs \n void curvetoCubicAbs \n void curvetoQuadraticRel \n void command \n void linetoVerticalAbs \n void endPath \n void linetoHorizontalRel \n void movetoAbs \n float[] getPathParameters \n short[] getPathCommands \n void linetoAbs \n void curvetoCubicSmoothRel \n void startPath \n void param \n void linetoVerticalRel \n void curvetoQuadraticSmoothAbs \n void movetoRel \n void arcAbs \n void curvetoCubicSmoothAbs \n void arcRel \n void linetoRel", "output": "void function ( float arg0 , float arg1 ) { command ( SVGPathSeg . PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL ) ; param ( arg0 ) ; param ( arg1 ) ; }"}, {"instruction": "Generate java code\nsets the optional sort specification object ", "input": " DBObject _query \n int _limit \n Map<String,Object> _scope \n OutputType _outputType \n long _maxTimeMS \n DBObject _sort \n String _outputDB \n String _map \n String _outputTarget \n DBObject _extra \n String _reduce \n ReadPreference _readPref \n Boolean _verbose \n String _finalize \n String _input \n\n void setOutputDB \n void setMaxTime \n String getReduce \n OutputType getOutputType \n void setReadPreference \n int getLimit \n void addExtraOption \n long getMaxTime \n ReadPreference getReadPreference \n Boolean isVerbose \n DBObject getExtraOptions \n String getFinalize \n String getInput \n void setVerbose \n String getMap \n DBObject getSort \n void setLimit \n void setFinalize \n String toString \n DBObject toDBObject \n void setScope \n DBObject getQuery \n String getOutputTarget \n Map<String,Object> getScope", "output": "void function ( DBObject arg0 ) { _sort = arg0 ; }"}, {"instruction": "Generate java code\nreturns the path depth number if the element is in the current path or -1 if it is n't . ", "input": " int linkCount \n Map myVisitedElements \n Iterator myElements \n boolean done \n\n boolean isVisited \n void beginVisit \n Iterator getElementLinks \n void endVisit \n void perform \n void perform \n void perform \n void perform \n void setVisited \n int visit", "output": "int function ( Object arg0 ) { if ( myVisitedElements . containsKey ( arg0 ) ) { return ( ( Integer ) myVisitedElements . get ( arg0 ) ) . intValue ( ) ; } return - 1 ; }"}, {"instruction": "Generate java code\nassume that a particular testgroup has been specified . ", "input": " Set<TestGroup> GROUPS \n\n void canLoadNativeDirFonts \n void execute \n void notLogging \n void group \n void group", "output": "void function ( TestGroup arg0 ) { if ( ! GROUPS . contains ( arg0 ) ) { throw new AssumptionViolatedException ( \"srini_string\" + arg0 + \"srini_string\" + GROUPS ) ; } }"}, {"instruction": "Generate java code\nmethod to get the tag id . ", "input": " long tagID \n String resourcePath \n long taggedTime \n String tagName \n String taggedUserName \n\n void setTagName \n void setResourcePath \n String getTagName \n String getTaggedUserName \n Date getTaggedTime \n void setTaggedTime \n String getResourcePath \n void setTaggedUserName \n void setTagID", "output": "Long function ( ) { return tagID ; }"}, {"instruction": "Generate java code\ncause the current thread to wait until at least the time of the next event , as near as possible , unless interrupted . ", "input": " long period \n long nextFiring \n int SEC \n\n placeholderType placeHolder", "output": "void function ( ) { long loc0 ; while ( ( loc0 = nextFiring - System . currentTimeMillis ( ) ) > 0 ) Thread . sleep ( loc0 ) ; nextFiring += period ; }"}, {"instruction": "Generate java code\nsets the value of the isaspectratio property . ", "input": " Boolean isAspectRatio \n Integer width \n Integer height \n\n Integer getHeight \n Boolean isIsAspectRatio \n Integer getWidth \n void setWidth \n void setHeight", "output": "void function ( Boolean arg0 ) { this . isAspectRatio = arg0 ; }"}, {"instruction": "Generate java code\nthe value of the filter . ", "input": " String value \n String key \n\n String getKey \n String getValue \n DocumentFilter withValue \n int hashCode \n boolean equals \n DocumentFilter clone \n String toString \n DocumentFilter withKey \n DocumentFilter withKey \n void setKey \n void setKey", "output": "void function ( String arg0 ) { this . value = arg0 ; }"}, {"instruction": "Generate java code\ninformation about the runs . ", "input": " String nextToken \n java.util.List<Run> runs \n\n ListRunsResult withRuns \n ListRunsResult withRuns \n void setRuns \n void setNextToken \n int hashCode \n boolean equals \n ListRunsResult clone \n String toString \n String getNextToken \n ListRunsResult withNextToken", "output": "java . util . List < Run > function ( ) { return runs ; }"}, {"instruction": "Generate java code\ndefines the y coordinate of the second parameter point . ", "input": " float y1 \n float x1 \n float y2 \n float x2 \n float y3 \n float x3 \n int segmentType \n\n void setSegmentType \n float getX3 \n float getX2 \n float getY3 \n float getX1 \n float getY2 \n float getY1 \n void setX2 \n void setY3 \n void setX3 \n int getSegmentType \n void setY1 \n void setX1", "output": "void function ( final float arg0 ) { this . y2 = arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the statement property . ", "input": " Statement statement \n ProductPackageItemAction productPackageItemAction \n\n void setProductPackageItemAction \n void setStatement \n ProductPackageItemAction getProductPackageItemAction", "output": "Statement function ( ) { return statement ; }"}, {"instruction": "Generate java code\ngets the value of the templateref property . ", "input": " Tlds tlds \n ResourceType templateRef \n Documents documents \n Tutorials tutorials \n\n void setTemplateRef \n Tutorials getTutorials \n void setTutorials \n Documents getDocuments \n void setDocuments \n Tlds getTlds \n void setTlds", "output": "ResourceType function ( ) { return templateRef ; }"}, {"instruction": "Generate java code\nwrite the 16-bit int to standard output . ", "input": " int buffer \n int n \n BufferedOutputStream out \n\n void writeByte \n void flush \n void clearBuffer \n void main \n void close \n void writeBit", "output": "void function ( short arg0 ) { writeByte ( ( arg0 >>> 8 ) & 0xff ) ; writeByte ( ( arg0 >>> 0 ) & 0xff ) ; }"}, {"instruction": "Generate java code\nchecks if the given interval is a subset of this interval . ", "input": " double lowValue \n double highValue \n Logger logger \n\n double getSize \n void setInterval \n double getLow \n Vector<Interval> subtract \n Vector<Interval> subtract \n double getHigh \n boolean isEmpty \n String toString \n Interval intersectWith", "output": "boolean function ( Interval arg0 ) { return getLow ( ) <= arg0 . getLow ( ) && getHigh ( ) >= arg0 . getHigh ( ) ; }"}, {"instruction": "Generate java code\nconvert the given object to string with each line indented by 4 spaces except the first line . ", "input": " String name \n List<String> photoUrls \n List<Tag> tags \n Category category \n Long id \n String value \n StatusEnum status \n\n void setName \n Pet addTagsItem \n List<String> getPhotoUrls \n void setPhotoUrls \n String getName \n Pet photoUrls \n Category getCategory \n Long getId \n List<Tag> getTags \n void setTags \n Pet addPhotoUrlsItem \n StatusEnum getStatus \n void setStatus \n Pet tags \n void setCategory \n int hashCode \n boolean equals \n Pet name \n void setId \n String toString \n String toString \n Pet id \n Pet category \n Pet status", "output": "String function ( java . lang . Object arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0 . toString ( ) . replace ( \"srini_string\" , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns the http headers , such as `` content-length : 0 '' . ", "input": " SocketPolicy socketPolicy \n long bodyDelayAmount \n Headers.Builder headers \n List<PushPromise> promises \n String CHUNKED_BODY_HEADER \n TimeUnit bodyDelayUnit \n Buffer body \n String status \n long throttlePeriodAmount \n WebSocketListener webSocketListener \n long throttleBytesPerPeriod \n TimeUnit throttlePeriodUnit \n\n MockResponse clearHeaders \n String getStatus \n MockResponse setHeader \n WebSocketListener getWebSocketListener \n MockResponse setBodyDelay \n long getBodyDelay \n List<PushPromise> getPushPromises \n MockResponse addHeaderLenient \n long getThrottleBytesPerPeriod \n SocketPolicy getSocketPolicy \n MockResponse setHeaders \n MockResponse addHeader \n MockResponse addHeader \n Buffer getBody \n MockResponse setSocketPolicy \n MockResponse setResponseCode \n MockResponse setBody \n MockResponse setBody \n MockResponse withPush \n MockResponse setStatus \n MockResponse removeHeader \n MockResponse throttleBody \n MockResponse setChunkedBody \n MockResponse setChunkedBody \n MockResponse clone \n MockResponse withWebSocketUpgrade \n String toString \n long getThrottlePeriod", "output": "Headers function ( ) { return headers . build ( ) ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable map mapping key names in braillekeybinding objects to localized user-friendly key names . ", "input": " Parcelable.Creator<BrailleDisplayProperties> CREATOR \n Map<String,String> mFriendlyKeyNames \n int mNumTextCells \n int mNumStatusCells \n BrailleKeyBinding[] mKeyBindings \n\n BrailleKeyBinding[] getKeyBindings \n BrailleDisplayProperties[] newArray \n String toString \n BrailleDisplayProperties createFromParcel \n int getNumStatusCells \n int describeContents \n void writeToParcel \n int getNumTextCells", "output": "Map < String , String > function ( ) { return mFriendlyKeyNames ; }"}, {"instruction": "Generate java code\nthis hook method will be invoked when the dfs begins the visit of an element . since there is no return parameter this method will not effect the algorithms behaviour . ", "input": " int linkCount \n Map myVisitedElements \n Iterator myElements \n boolean done \n\n boolean isVisited \n Iterator getElementLinks \n void endVisit \n void perform \n void perform \n void perform \n void perform \n void setVisited \n int visit \n int getVisitedDepth", "output": "void function ( Object arg0 , int arg1 ) { }"}, {"instruction": "Generate java code\nutility to scale the image to a rough size of 96x96 pixels but still maintaining the original aspect ratio . ", "input": " Logger logger \n Media soundIconSmall \n Media movieIconSmall \n Media BROKEN_ICON \n Media MOVIE_ICON \n String thumbConvertCommand \n Media SOUND_ICON \n String audioConvertCommand \n String videoConvertCommand \n\n File processFile \n void init \n double calculateSmallImageSize \n Media getSoundIconSmall \n Media getMovieIcon \n double calculateThumbNailSize \n double calculateImageSize \n void processUploadedImage \n Media createPhoto \n Media createPhoto \n Media getSoundIcon \n Media getMovieIconSmall \n void processUploadedAudio \n Media createMedia \n void processUploadedVideo \n Media getBrokenIcon", "output": "double function ( int arg0 , int arg1 ) { double loc0 = 16.0 ; return calculateImageSize ( loc0 , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngets the password . ", "input": " String password \n String userName \n\n void setPassword \n void setUserName \n String getUserName", "output": "String function ( ) { return password ; }"}, {"instruction": "Generate java code\nset the jdo dialect to use for this proxy . default is a defaultjdodialect based on the persistencemanagerfactory 's underlying datasource , if any . ", "input": " PersistenceManager proxy \n PersistenceManagerFactory persistenceManagerFactory \n JdoDialect jdoDialect \n Class<? extends PersistenceManager> persistenceManagerInterface \n boolean allowCreate \n\n JdoDialect getJdoDialect \n PersistenceManager getObject \n boolean isAllowCreate \n PersistenceManagerFactory getPersistenceManagerFactory \n void setAllowCreate \n void afterPropertiesSet \n Class<? extends PersistenceManager> getObjectType \n boolean isSingleton \n Object invoke \n void setPersistenceManagerInterface \n void setPersistenceManagerFactory \n Class<? extends PersistenceManager> getPersistenceManagerInterface", "output": "void function ( JdoDialect arg0 ) { this . jdoDialect = arg0 ; }"}, {"instruction": "Generate java code\nto set the set of case mediators ", "input": " AnonymousListMediator caseMediator \n Pattern regex \n Log log \n\n void init \n Pattern getRegex \n void setRegex \n boolean mediate \n void destroy \n AnonymousListMediator getCaseMediator \n boolean matches \n void setStatisticIdForMediators", "output": "void function ( AnonymousListMediator arg0 ) { this . caseMediator = arg0 ; }"}, {"instruction": "Generate java code\nreturns ` true ` if the application is ` test ` mode . ", "input": " play.api.Environment env \n\n Mode mode \n ClassLoader classLoader \n URL resource \n boolean isProd \n boolean isDev \n InputStream resourceAsStream \n Environment simple \n File rootPath \n play.api.Environment underlying \n File getFile", "output": "boolean function ( ) { return mode ( ) . equals ( Mode . TEST ) ; }"}, {"instruction": "Generate java code\nthe certificate chain that contains the root certificate issued by the certificate authority ca . ", "input": " String certificateChain \n String certificate \n\n String getCertificate \n String getCertificateChain \n int hashCode \n boolean equals \n GetCertificateResult withCertificate \n GetCertificateResult clone \n String toString \n GetCertificateResult withCertificateChain \n void setCertificate", "output": "void function ( String arg0 ) { this . certificateChain = arg0 ; }"}, {"instruction": "Generate java code\nstatic file parsing methods ", "input": " String _s \n\n ArrayList ParseFileInt \n String toString \n boolean matches", "output": "ArrayList function ( String arg0 ) { try { TokenStream loc0 = new TokenStream ( ) ; loc0 . open ( arg0 ) ; return ParseFileInt ( loc0 , 0 ) ; } catch ( TokenStreamException loc0 ) { System . out . println ( \"srini_string\" + loc0 ) ; return null ; } }"}, {"instruction": "Generate java code\ndisplay @param array 's content to console ", "input": " Formatter formatter \n\n void printDoubleArrayToFile \n void print2DTabbedDoubleArrayToConole \n void printFloatArrayToFile \n void printFloatArrayToConole \n void print2DDoubleArrayToFile \n void printStringArrayToFile \n void print2DDoubleArrayToConole \n void printIntArrayToFile \n void printStringArrayToConole \n void printIntArrayToConole \n void printFrameWise2DDoubleArrayToConole", "output": "void function ( double [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0 . length ; loc0 ++ ) { System . out . println ( arg0 [ loc0 ] ) ; } }"}, {"instruction": "Generate java code\nreturns feature vector ", "input": " double[][] featureVector \n double[][] mfccFeature \n int noOfFrames \n int noOfFeatures \n\n void setFeatureVector \n double[][] getMfccFeature \n void setNoOfFeatures \n int getNoOfFeatures \n void setMfccFeature \n int getNoOfFrames \n void setNoOfFrames", "output": "double [ ] [ ] function ( ) { return featureVector ; }"}, {"instruction": "Generate java code\nset the interface 's device name ", "input": " String name \n Network net \n\n String getName \n Network getNetwork", "output": "void function ( String arg0 ) { this . name = arg0 ; }"}, {"instruction": "Generate java code\ngets the time , in millis , that the last instance of this alert state was received . ", "input": " Long latestTimestamp \n MaintenanceState maintenanceState \n AlertDefinitionEntity alertDefinition \n Long historyId \n AlertHistoryEntity alertHistory \n Long alertId \n String latestText \n Long originalTimestamp \n Long definitionId \n\n void setAlertHistory \n void setLatestText \n String getLatestText \n Long getDefinitionId \n MaintenanceState getMaintenanceState \n void setLatestTimestamp \n void setOriginalTimestamp \n Long getOriginalTimestamp \n int hashCode \n void setHistoryId \n boolean equals \n Long getAlertId \n void setMaintenanceState \n String toString \n void setDefinitionId \n void setAlertId \n Long getHistoryId \n AlertHistoryEntity getAlertHistory", "output": "Long function ( ) { return latestTimestamp ; }"}, {"instruction": "Generate java code\nreturns true if this element was already visited . ", "input": " int linkCount \n Map myVisitedElements \n Iterator myElements \n boolean done \n\n void beginVisit \n Iterator getElementLinks \n void endVisit \n void perform \n void perform \n void perform \n void perform \n void setVisited \n int visit \n int getVisitedDepth", "output": "boolean function ( Object arg0 ) { return myVisitedElements . containsKey ( arg0 ) ; }"}, {"instruction": "Generate java code\nresets #nexttlsmode to the first option . ", "input": " int nextSocketAddressIndex \n List<Route> postponedRoutes \n int TLS_MODE_MODERN \n Address address \n Iterator<Proxy> proxySelectorProxies \n ConnectionPool pool \n Dns dns \n RouteDatabase routeDatabase \n URI uri \n int socketPort \n int TLS_MODE_NULL \n ProxySelector proxySelector \n int nextTlsMode \n Proxy lastProxy \n InetAddress[] socketAddresses \n Proxy userSpecifiedProxy \n boolean hasNextProxy \n int TLS_MODE_COMPATIBLE \n InetSocketAddress lastInetSocketAddress \n\n Connection next \n void resetNextInetSocketAddress \n int nextTlsMode \n Proxy nextProxy \n void resetNextProxy \n boolean hasNextPostponed \n boolean hasNext \n InetSocketAddress nextInetSocketAddress \n void connectFailed \n boolean hasNextTlsMode \n boolean hasNextInetSocketAddress \n Route nextPostponed \n boolean hasNextProxy", "output": "void function ( ) { nextTlsMode = ( address . getSslSocketFactory ( ) != null ) ? TLS_MODE_MODERN : TLS_MODE_COMPATIBLE ; }"}, {"instruction": "Generate java code\ngets string representation of header ", "input": " String name \n String value \n\n String getValue \n String getName \n boolean equals \n void setValue \n Object clone", "output": "String function ( ) { return name + \"srini_string\" + value + \"srini_string\" ; }"}, {"instruction": "Generate java code\nget the event type ", "input": " TaskStarted datum \n\n TaskID getTaskId \n String getSplitLocations \n Object getDatum \n void setDatum \n long getStartTime \n TaskType getTaskType", "output": "EventType function ( ) { return EventType . TASK_STARTED ; }"}, {"instruction": "Generate java code\nget the xsd schema object for the cii d16a1 document type of the passed implementation class . ", "input": " ICommonsMap<String,ECIID16A1DocumentType> s_aNamespace2DocType \n ICommonsMap<String,ECIID16A1DocumentType> s_aLocalName2DocType \n CIID16A1DocumentTypes s_aInstance \n\n Schema getSchemaOfLocalName \n Schema getSchemaOfLocalName \n ECIID16A1DocumentType getDocumentTypeOfLocalName \n Class<?> getImplementationClassOfNamespace \n ICommonsSet<String> getAllNamespaces \n ECIID16A1DocumentType getDocumentTypeOfNamespace \n Class<?> getImplementationClassOfLocalName \n Schema getSchemaOfNamespace \n Schema getSchemaOfNamespace \n ICommonsSet<String> getAllLocalNames \n ECIID16A1DocumentType getDocumentTypeOfImplementationClass", "output": "Schema function ( @ Nullable final Class < ? > arg0 ) { return getSchemaOfImplementationClass ( arg0 , ( ClassLoader ) null ) ; }"}, {"instruction": "Generate java code\ngets the value of the etfcontracttype property . ", "input": " CodeAndDescription reason \n Integer durationInMonths \n String associatedDealer \n String contractType \n XMLGregorianCalendar commitEndDate \n Long contractId \n String etfContractType \n long serialVersionUID \n XMLGregorianCalendar effectiveDate \n XMLGregorianCalendar commitStartDate \n Integer originalTermInMonths \n\n CodeAndDescription getReason \n void setCommitStartDate \n XMLGregorianCalendar getCommitEndDate \n Integer getDurationInMonths \n void setDurationInMonths \n XMLGregorianCalendar getCommitStartDate \n void setContractType \n Integer getOriginalTermInMonths \n void setOriginalTermInMonths \n void setEffectiveDate \n void setEtfContractType \n XMLGregorianCalendar getEffectiveDate \n void setContractId \n Long getContractId \n void setReason \n String getAssociatedDealer \n void setCommitEndDate \n String getContractType \n void setAssociatedDealer", "output": "String function ( ) { return etfContractType ; }"}, {"instruction": "Generate java code\ncreates a new object object . ", "input": " List<ClassLoader> resourceClassLoaders \n List<ClassLoader> externalClassLoaders \n\n URL getResource \n CommentGenerator createCommentGenerator \n IntrospectedTable createIntrospectedTableForValidation \n IntrospectedTable createIntrospectedTable \n Class<?> internalClassForName \n JavaFormatter createJavaFormatter \n Object createExternalObject \n void addResourceClassLoader \n JavaTypeResolver createJavaTypeResolver \n Plugin createPlugin \n ConnectionFactory createConnectionFactory \n Class<?> externalClassForName \n IntrospectedColumn createIntrospectedColumn \n void reset \n Object createInternalObject \n void addExternalClassLoader", "output": "XmlFormatter function ( Context arg0 ) { String loc0 = arg0 . getProperty ( PropertyRegistry . CONTEXT_XML_FORMATTER ) ; if ( ! stringHasValue ( loc0 ) ) { loc0 = DefaultXmlFormatter . class . getName ( ) ; } XmlFormatter loc1 = ( XmlFormatter ) createInternalObject ( loc0 ) ; loc1 . setContext ( arg0 ) ; return loc1 ; }"}, {"instruction": "Generate java code\nconverts the specified date to an iso 8601 timestamp string and returns it . ", "input": " DateUtils dateUtils \n\n String fromBigDecimal \n String replace \n BigInteger toBigInteger \n String fromLong \n BigDecimal toBigDecimal \n String fromBoolean \n String fromBigInteger \n Integer toInteger \n String fromByteBuffer \n Boolean toBoolean \n String fromInteger \n String fromFloat \n String fromDouble \n String toString \n String fromByte \n String fromString \n String join", "output": "String function ( Date arg0 ) { return dateUtils . formatIso8601Date ( arg0 ) ; }"}, {"instruction": "Generate java code\nadds a header with name and value . prefer this method for multiply-valued headers like `` cookie '' . ", "input": " RawHeaders headers \n String method \n RawHeaders headers \n String method \n Object tag \n Body body \n URL url \n\n List<String> headers \n String headerName \n String method \n Builder method \n Set<String> headerNames \n String urlString \n String headerValue \n int headerCount \n Body body \n Builder newBuilder \n URL url \n Builder url \n Builder url \n Builder put \n RawHeaders rawHeaders \n Builder rawHeaders \n Builder head \n void writeTo \n Builder post \n Request build \n Builder get \n String header \n Builder header \n Body create \n Body create \n Body create \n long contentLength \n Object tag \n Builder tag \n MediaType contentType", "output": "Builder function ( String arg0 , String arg1 ) { headers . add ( arg0 , arg1 ) ; return this ; }"}, {"instruction": "Generate java code\nset the system property ", "input": " PlaceHolder placeHolder \n\n String getSystemProperty \n URL loadResource \n void setTCCL \n Class<?> loadClass \n Class<?> loadClass \n ClassLoader getTCCL", "output": "void function ( final String arg0 , final String arg1 ) { SecurityManager loc0 = System . getSecurityManager ( ) ; if ( loc0 != null ) { AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { public Object run ( ) { System . setProperty ( arg0 , arg1 ) ; return null ; } } ) ; } else { System . setProperty ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nhigher placed line ", "input": " List<Integer> minDepth \n Mat originalM \n int[] projX \n int upperBound \n int centerLine \n double width \n int lowerBound \n List<Integer> minimums \n List<Integer> maximums \n\n int getCenterLine \n void setUpperBound \n List<Integer> getMinimums \n void legacyExtremums \n double getWidth \n void calculateVerticalCrop \n void calculateMinimums \n void setWidth \n void calculateProjection \n void calculateMinDepth \n int[] getProjection \n Mat getOriginalMat \n void setLowerBound \n String toString \n int getLowerBound \n void calculateMaximums \n void setVerticalBounds \n List<Integer> getMaximums \n void addEdgesToMinimums", "output": "int function ( ) { return upperBound ; }"}, {"instruction": "Generate java code\ngets the offset within the full collection where this collection 's items begin . ", "input": " long offset \n long fullSize \n long limit \n Collection<E> collection \n\n boolean add \n long fullSize \n boolean containsAll \n void clear \n boolean isEmpty \n boolean remove \n boolean contains \n Iterator<E> iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n boolean equals \n long limit \n Object[] toArray \n T[] toArray \n boolean retainAll", "output": "long function ( ) { return this . offset ; }"}, {"instruction": "Generate java code\nnotifies the listeners that a contact has been updated . ", "input": " List<RosterEventListener> listeners \n\n boolean addingContact \n void contactDeleted \n void removeListener \n void rosterLoaded \n void contactAdded \n void addListener", "output": "void function ( Roster arg0 , RosterItem arg1 ) { if ( ! listeners . isEmpty ( ) ) { for ( RosterEventListener loc0 : listeners ) { loc0 . contactUpdated ( arg0 , arg1 ) ; } } }"}, {"instruction": "Generate java code\nthe current version of the streaming distribution created . ", "input": " String location \n String eTag \n StreamingDistribution streamingDistribution \n\n void setStreamingDistribution \n String getLocation \n StreamingDistribution getStreamingDistribution \n CreateStreamingDistributionResult withLocation \n void setLocation \n String getETag \n int hashCode \n boolean equals \n CreateStreamingDistributionResult clone \n String toString \n CreateStreamingDistributionResult withStreamingDistribution \n void setETag", "output": "CreateStreamingDistributionResult function ( String arg0 ) { setETag ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nremoves a unit of data to the current chart data model . ", "input": " String LINE_CHART_NAME \n String CUSTOM_CHART_NAME \n String PIE2D_CHART_NAME \n Map chartDataModels \n String AREA_CHART_NAME \n String BAR_CLUSTERED_CHART_NAME \n SelectItem[] chartList \n String BAR_STACKED_CHART_NAME \n String PIE3D_CHART_NAME \n AbstractChartData currentChartModel \n String AREA_STACKED_CHART_NAME \n String POINT_CHART_NAME \n String currentChartType \n String BAR_CHART_NAME \n\n void init \n void removeChartData \n Map getChartDataModels \n void chartTypeChange \n void resetChartData \n void setCurrentChartType \n void chartAreaClicked \n SelectItem[] getChartList \n AbstractChartData getCurrentChartModel \n String getCurrentChartType", "output": "void function ( ActionEvent arg0 ) { if ( currentChartModel != null ) { currentChartModel . addData ( ) ; } }"}, {"instruction": "Generate java code\ndelete source file for given class from project . ", "input": " Class<?>[] ALWAYS_INCLUDE \n File sourceFolder \n TestCompiler compiler \n Set<File> sourceFiles \n\n void add \n void replaceText \n void addSourceCode \n void putContents \n File getOriginalSourceFile \n void revert \n ConfigurationMetadata fullBuild \n ConfigurationMetadata incrementalBuild \n void deleteFolderContents \n File getSourceFile \n String getContents \n void copySources \n void copySources \n File getOutputFile", "output": "void function ( Class < ? > arg0 ) { File loc0 = getSourceFile ( arg0 ) ; loc0 . delete ( ) ; this . sourceFiles . remove ( loc0 ) ; }"}, {"instruction": "Generate java code\nincrement the pending message count in a slot ", "input": " boolean isAnOverlappingSlot \n long messageCount \n List<SlotState> slotStates \n String destinationOfMessagesInSlot \n String storageQueueName \n AtomicInteger pendingMessageCount \n Log log \n long startMessageId \n ConcurrentHashMap<Long,DeliverableAndesMetadata> messagesOfSlot \n long endMessageId \n boolean isSlotActive \n\n long getMessageCount \n long getEndMessageId \n boolean checkIfMessageIsAlreadyAdded \n String encodeSlotStates \n String getId \n int compareTo \n void setMessageCount \n void setEndMessageId \n void addMessageToSlotIfAbsent \n boolean isAnOverlappingSlot \n void decodeAndSetSlotStates \n long getStartMessageId \n int hashCode \n void setStartMessageId \n SlotState getCurrentState \n void setStorageQueueName \n void deleteAllMessagesInSlot \n boolean addState \n void setAnOverlappingSlot \n void removeMessageFromSlot \n void setDestinationOfMessagesInSlot \n String getStorageQueueName \n boolean equals \n void decrementPendingMessageCount \n void markMessagesOfSlotAsReturned \n void setSlotInactive \n String toString \n List<DeliverableAndesMetadata> getAllMessagesOfSlot \n String getDestinationOfMessagesInSlot \n boolean isSlotActive", "output": "void function ( int arg0 ) { pendingMessageCount . addAndGet ( arg0 ) ; }"}, {"instruction": "Generate java code\nwarning log message . ", "input": " int WARN \n int VERBOSE \n int ERROR \n int LOGLEVEL \n int DEBUG \n int INFO \n\n boolean isLoggable \n void d \n void d \n void d \n void setLogLevel \n void setLogLevel \n void e \n void e \n void e \n void v \n void v \n void v \n void i \n void i \n void i", "output": "void function ( String arg0 , String arg1 ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ndecodes and returns the grabbed video frame . the methods/functions decode and return the just grabbed frame . if no frames has been grabbed camera has been disconnected , or there are no more frames in video file , the methods return false and the functions return null pointer . note : opencv 1.x functions cvretrieveframe and cv.retrieveframe return image stored inside the video capturing structure . it is not allowed to modify or release the image ! you can copy the frame using `` cvcloneimage '' and then do whatever you want with the copy . ", "input": " long nativeObj \n\n boolean n_isOpened \n boolean n_read \n boolean isOpened \n boolean read \n boolean set \n void release \n boolean n_set \n void n_delete \n void n_release \n List<Size> getSupportedPreviewSizes \n String n_getSupportedPreviewSizes \n boolean n_retrieve \n boolean n_retrieve \n double get \n boolean n_open \n boolean n_open \n void finalize \n boolean grab \n long n_VideoCapture \n long n_VideoCapture \n long n_VideoCapture \n boolean n_grab \n boolean open \n double n_get", "output": "boolean function ( Mat arg0 ) { boolean loc0 = n_retrieve ( nativeObj , arg0 . nativeObj ) ; return loc0 ; }"}, {"instruction": "Generate java code\ngets the value of the imagetrigger property . ", "input": " Image image \n Pushbutton pushbutton \n Urltrigger urltrigger \n Switch _switch \n Pagejump pagejump \n Toggle toggle \n Multitrigger multitrigger \n Trigger trigger \n Imagetrigger imagetrigger \n Info info \n\n void setImagetrigger \n Trigger getTrigger \n Urltrigger getUrltrigger \n Info getInfo \n void setTrigger \n void setPagejump \n void setUrltrigger \n Pagejump getPagejump \n void setPushbutton \n void setMultitrigger \n Switch getSwitch \n Pushbutton getPushbutton \n void setInfo \n void setToggle \n Multitrigger getMultitrigger \n Image getImage \n void setSwitch \n Toggle getToggle \n void setImage", "output": "Imagetrigger function ( ) { return imagetrigger ; }"}, {"instruction": "Generate java code\nsets the value of the provincename property . ", "input": " String cityName \n String streetAddress \n String provinceCode \n String countryCode \n String postalCode \n String streetAddress2 \n String provinceName \n\n String getCountryCode \n String getProvinceName \n void setProvinceCode \n void setCityName \n String getPostalCode \n void setCountryCode \n String getCityName \n void setStreetAddress2 \n void setStreetAddress \n String getStreetAddress2 \n String getProvinceCode \n void setPostalCode \n String getStreetAddress", "output": "void function ( String arg0 ) { this . provinceName = arg0 ; }"}, {"instruction": "Generate java code\nadd additional high priority values to an environment . name-value pairs can be specified with colon '' : '' or equals '' = '' separators . ", "input": " PlaceHolder placeHolder \n\n placeholderType placeHolder", "output": "void function ( ConfigurableEnvironment arg0 , String ... arg1 ) { org . springframework . boot . test . util . EnvironmentTestUtils . addEnvironment ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nsplits file names separated by comma character . file names can contain comma characters escaped by backslash ' \\ ' ", "input": " String LUCENE_MATCH_VERSION_PARAM \n Pattern ITEM_PATTERN \n boolean isExplicitLuceneMatchVersion \n Version luceneMatchVersion \n String CLASS_NAME \n Map<String,String> originalArgs \n\n Set<String> getSet \n boolean isExplicitLuceneMatchVersion \n float requireFloat \n List<String> getLines \n String require \n String require \n String require \n boolean requireBoolean \n float getFloat \n String getClassArg \n char requireChar \n void setExplicitLuceneMatchVersion \n int getInt \n char getChar \n CharArraySet getWordSet \n Version getLuceneMatchVersion \n String get \n String get \n String get \n String get \n String get \n boolean getBoolean \n Pattern getPattern \n Map<String,String> getOriginalArgs \n int requireInt \n CharArraySet getSnowballWordSet", "output": "List < String > function ( String arg0 ) { if ( arg0 == null ) return Collections . < String > emptyList ( ) ; List < String > loc0 = new ArrayList < > ( ) ; for ( String loc1 : arg0 . split ( \"srini_string\" ) ) { loc0 . add ( loc1 . replaceAll ( \"srini_string\" , \"srini_string\" ) ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ninvoke a java hook . the xenv is the representation of the current execution environment the jni_env_t ", "input": " JkHandler next \n WorkerEnv wEnv \n int JK_STATUS_HEAD \n Object notes[] \n int JK_STATUS_CLOSED \n long xEnvP \n long jkEndpointP \n int TIMER_POST_REQUEST \n Object control \n JkChannel source \n int type \n Msg msgs[] \n long timers[] \n int JK_STATUS_NEW \n C2BConverter c2b \n int TIMER_RECEIVED \n org.apache.juli.logging.Log log \n org.apache.juli.logging.Log logTime \n JkInputStream jkIS \n int JK_STATUS_ERROR \n int status \n Request req \n int TIMER_PRE_REQUEST \n\n void setRequest \n void setSource \n Msg getMsg \n byte[] getBuffer \n Request getRequest \n long getJniEnv \n int getStatus \n void setJniContext \n void recycle \n WorkerEnv getWorkerEnv \n void setWorkerEnv \n void action \n long getJniContext \n Object getControl \n void setJniEnv \n boolean isLogTimeEnabled \n Object getNote \n JkHandler getNext \n void setType \n JkInputStream getInputStream \n void setStatus \n void setControl \n void logTime \n long getLong \n void setLong \n int getType \n JkChannel getSource \n void setConverter \n void setNext \n void setNote \n void setMsg \n C2BConverter getConverter", "output": "int function ( ) { int loc0 = next . invoke ( msgs [ 0 ] , this ) ; return loc0 ; }"}, {"instruction": "Generate java code\nthe multipageeditorsite implementation of this iworkbenchpartsite method forwards to the multi-page editor for registration . ", "input": " ISelectionProvider selectionProvider \n IEditorPart editor \n ISelectionChangedListener selectionChangedListener \n MultiPageModelEditor multiPageEditor \n\n IEditorPart getEditor \n MultiPageModelEditor getMultiPageEditor \n Object getAdapter \n IEditorActionBarContributor getActionBarContributor \n void handleSelectionChanged \n IWorkbenchPage getPage \n String getPluginId \n IWorkbenchWindow getWorkbenchWindow \n ISelectionChangedListener getSelectionChangedListener \n String getId \n IWorkbenchPart getPart \n Object getService \n IKeyBindingService getKeyBindingService \n ISelectionProvider getSelectionProvider \n String getRegisteredName \n IActionBars getActionBars \n void setSelectionProvider \n Shell getShell \n void dispose \n boolean hasService \n ILabelDecorator getDecoratorManager", "output": "void function ( final MenuManager arg0 , final ISelectionProvider arg1 , final boolean arg2 ) { registerContextMenu ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ncompute the intra-set similarity of an item collection . ", "input": " CorrelationMatrix itemCorrelations \n\n List<Integer> diversifySequential", "output": "double function ( Collection < Integer > arg0 , CorrelationMatrix arg1 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0 . size ( ) ; loc1 ++ ) for ( int loc2 = loc1 + 1 ; loc2 < arg0 . size ( ) ; loc2 ++ ) loc0 += arg1 . get ( loc1 , loc2 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nrelease ownership of the native instance , causing the native object not to be deleted when this object gets out of scope . ", "input": " boolean swigCMemOwn \n boolean destroyed \n int refCount \n long cPointer \n boolean disposed \n String className \n\n void obtain \n void takeOwnership \n void release \n void destroy \n void construct \n boolean hasOwnership \n void delete \n int hashCode \n long getCPointer \n boolean equals \n boolean isDisposed \n boolean isObtained \n void reset \n void dispose \n String toString \n void finalize", "output": "void function ( ) { swigCMemOwn = false ; }"}, {"instruction": "Generate java code\nreturns the buffer computed for a geometry for a given buffer distance . ", "input": " Geometry argGeom \n BufferParameters bufParams \n int MAX_PRECISION_DIGITS \n RuntimeException saveException \n double distance \n int CAP_FLAT \n int CAP_SQUARE \n int CAP_BUTT \n int CAP_ROUND \n Geometry resultGeometry \n\n void bufferReducedPrecision \n void bufferReducedPrecision \n Geometry bufferOp \n Geometry bufferOp \n Geometry bufferOp \n Geometry bufferOp \n double OLDprecisionScaleFactor \n void setEndCapStyle \n void setQuadrantSegments \n void bufferFixedPrecision \n void computeGeometry \n double precisionScaleFactor \n void bufferOriginalPrecision", "output": "Geometry function ( double arg0 ) { this . distance = arg0 ; computeGeometry ( ) ; return resultGeometry ; }"}, {"instruction": "Generate java code\nthe failure message , null if it did not fail . ", "input": " ActionResponse response \n Failure failure \n String opType \n String index \n int id \n String type \n String message \n RestStatus status \n\n long getVersion \n String getOpType \n String getIndex \n String getIndex \n boolean isFailed \n void readFrom \n BulkItemResponse readBulkItem \n T getResponse \n String getMessage \n String getId \n String getId \n RestStatus getStatus \n void writeTo \n int getItemId \n String getType \n String getType \n Failure getFailure", "output": "String function ( ) { if ( failure != null ) { return failure . getMessage ( ) ; } return null ; }"}, {"instruction": "Generate java code\nformat readable feedback ", "input": " String feedback \n int correct \n int TESTS \n\n void runSpecialTest \n String appendFeedback \n List<Integer> readCorrect \n void main \n void run \n String printList \n void judge \n void runTest", "output": "String function ( double arg0 , String arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1 ; }"}, {"instruction": "Generate java code\ngenerates the clickable map info and sends that to the response . ", "input": " boolean awtProblem \n AbstractBuild build \n Run<?,?> run \n double CHEBYSHEV_N \n Throwable awtProblemCause \n\n void adjustChebyshev \n int hashCode \n boolean equals \n void generateGraph \n void generateGraph \n String toString \n int compareTo \n Run<?,?> getRun", "output": "void function ( StaplerRequest arg0 , StaplerResponse arg1 , final JFreeChart arg2 , int arg3 , int arg4 ) { new Graph ( - 1 , arg3 , arg4 ) { protected JFreeChart createGraph ( ) { return arg2 ; } } . doMap ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nstring ", "input": " Object parent \n String value \n String space \n\n void setSpace \n Object getParent \n String getSpace \n void afterUnmarshal \n void setValue \n void setParent", "output": "String function ( ) { return value ; }"}, {"instruction": "Generate java code\nby default , there is no post processing to be done . ", "input": " Map nameFeatureMap \n Object NULL_TOKEN \n\n boolean shouldOverrideCopyOperation \n void setName \n boolean canContain \n XMLResource getResource \n String getName \n OverrideCopyOperation getOverrideCopyOperation \n boolean isCopyAlways \n boolean shouldSaveContainmentFeature \n void destroy \n PasteAction getPasteCollisionAction \n boolean hasPasteOption \n boolean shouldOverrideChildPasteOperation \n OverridePasteChildOperation getOverrideChildPasteOperation \n void sendCreateNotification \n EAttribute getNameAttribute \n Collection getExcludedCopyObjects \n boolean isNameable", "output": "void function ( Set arg0 ) { }"}, {"instruction": "Generate java code\nhandle the procesing instruction . ", "input": " ContentHandler nextHandler \n\n void characters \n void startPrefixMapping \n void endElement \n void endPrefixMapping \n ContentHandler getNextHandler \n void startElement \n void skippedEntity \n void setDocumentLocator \n void startDocument \n void endDocument \n void ignorableWhitespace", "output": "void function ( final String arg0 , final String arg1 ) { nextHandler . processingInstruction ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngets the value of the id property . this accessor method returns a reference to the live list , not a snapshot . therefore any modification you make to the returned list will be present inside the jaxb object . this is why there is not a set method for the id property . for example , to add a new item , do as follows : getid . add newitem ; objects of the following type s are allowed in the list string ", "input": " IsoformType.Sequence sequence \n IsoformType.Note note \n String ref \n List<Integer> evidence \n List<IsoformType.Name> name \n List<String> id \n String type \n String value \n\n void setSequence \n List<Integer> getEvidence \n List<Integer> getEvidence \n String getValue \n String getValue \n List<IsoformType.Name> getName \n void setRef \n String getType \n String getRef \n void setValue \n void setValue \n void setNote \n IsoformType.Note getNote \n void setType \n IsoformType.Sequence getSequence", "output": "List < String > function ( ) { if ( id == null ) { id = new ArrayList < String > ( ) ; } return this . id ; }"}, {"instruction": "Generate java code\nproduce the boolean value false . ", "input": " Timeout globalTimeout \n\n void test_and \n void test_le \n void test_lt \n void test_true \n void test_ne \n void test_or \n void test_ge \n void test_not \n void test_gt \n void test_eq", "output": "void function ( ) { assertStack ( \"srini_string\" , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nset the id or position of this effect in a sequence ", "input": " boolean fired \n boolean submit \n boolean queued \n float fps \n boolean sync \n int sequenceId \n float duration \n String sequence \n float delay \n boolean transitory \n float from \n float to \n String id \n EffectsArguments ea \n boolean queueEnd \n String queue \n\n void setDuration \n void setSequence \n int getSequenceId \n float getDelay \n String getId \n boolean isSync \n void setSync \n boolean isFired \n float getDuration \n void setQueue \n void setFired \n int hashCode \n String getQueue \n void setId \n void setOptions \n boolean isQueueEnd \n boolean isQueued \n void setDelay \n float getFrom \n String getFunctionName \n void setTransitory \n void setQueueEnd \n void setFps \n void setFrom \n int getIntfromString \n float getTo \n boolean isTransitory \n boolean isSubmit \n void setSubmit \n void setQueued \n boolean equals \n void setTo \n String toString \n String toString \n float getFps \n String getSequence", "output": "void function ( int arg0 ) { this . sequenceId = arg0 ; }"}, {"instruction": "Generate java code\nconvert the given object to string with each line indented by 4 spaces except the first line . ", "input": " String description \n Long code \n String moreInfo \n String message \n List<ErrorListItemDTO> error \n\n ErrorDTO code \n void setMoreInfo \n void setCode \n String getMessage \n ErrorDTO description \n void setDescription \n ErrorDTO message \n void setMessage \n ErrorDTO error \n String getDescription \n ErrorDTO moreInfo \n List<ErrorListItemDTO> getError \n String getMoreInfo \n void setError \n int hashCode \n boolean equals \n String toString \n Long getCode \n ErrorDTO addErrorItem", "output": "String function ( java . lang . Object arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0 . toString ( ) . replace ( \"srini_string\" , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nprint query results . ", "input": " String PARTITIONED_CACHE_NAME \n int idGen \n String REPLICATED_CACHE_NAME \n Map<Integer,DimProduct> dataProduct \n Map<Integer,DimStore> dataStore \n\n void populateFacts \n void queryStorePurchases \n T rand \n void populateDimensions \n void queryProductPurchases \n void main", "output": "void function ( String arg0 , Iterable < Cache . Entry < Integer , V >> arg1 ) { System . out . println ( arg0 ) ; for ( Cache . Entry < ? , ? > loc0 : arg1 ) System . out . println ( \"srini_string\" + loc0 . getValue ( ) . toString ( ) ) ; }"}, {"instruction": "Generate java code\nmake equals reflect value-identity instead of object-identity ", "input": " int[] iV \n\n void add \n int innerProduct \n int hashCode \n void addMultiple \n void subtract \n IntMathVec clone \n String toString \n void check \n boolean zeroEntry \n void assign", "output": "boolean function ( Object arg0 ) { if ( arg0 instanceof IntMathVec ) { IntMathVec loc0 = ( IntMathVec ) arg0 ; if ( loc0 . iV . length != iV . length ) return false ; for ( int loc1 = 0 ; loc1 < iV . length ; loc1 ++ ) { if ( iV [ loc1 ] != loc0 . iV [ loc1 ] ) return false ; } return true ; } return false ; }"}, {"instruction": "Generate java code\nactionlistener called from the ` audio ' button in home.xhtml ", "input": " String RENDER_GROUP \n UploadModel uploadModel \n PortableRenderer portableRenderer \n String BEAN_NAME \n MediaHelper mediaHelper \n String MEDIA_FILE_KEY \n MediaStore mediaStore \n boolean showHelpPopup \n MediaView mediaView \n Logger LOGGER \n\n boolean isShowHelpPopup \n void init \n void setMediaStore \n void upload \n void chooseCamera \n void chooseCamcorder \n void processUpload \n void setUploadModel \n void setMediaView \n String viewMediaDetail \n String deleteCurrentMedia \n void setMediaHelper \n void setShowHelpPopup \n void uploadsCompleted \n void uploadsCompleted \n void cancelUpload", "output": "void function ( ActionEvent arg0 ) { LOGGER . finer ( \"srini_string\" ) ; uploadModel . setSelectedMediaInput ( MediaMessage . MEDIA_TYPE_AUDIO ) ; uploadModel . setUploadFeedbackMessage ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nchecks if is e id cross border share . ", "input": " String consentAuthnReq \n String eIDSectorShare \n String protocolBinding \n String formatEntity \n boolean friendlyName \n Properties samlCoreProp \n boolean oneTimeUse \n Integer timeNotOnOrAfter \n String responder \n String eIDCrossBordShare \n Logger LOGGER \n boolean ipValidation \n boolean isRequired \n String requester \n String consentAuthnResp \n String eIDCrossSectShare \n String SAML_ENGINE_LITERAL \n\n void setProtocolBinding \n void setRequired \n void setEIDCrossSectShare \n boolean isFriendlyName \n boolean isIpValidation \n void seteIDSectorShare \n String getConsentAuthnResp \n String iseIDCrossSectShare \n void setConsentAuthnResp \n String getRequester \n String iseIDSectorShare \n void setFormatEntity \n String getFormatEntity \n String getResponder \n void setOneTimeUse \n boolean isOneTimeUse \n void setEIDCrossBordShare \n String getConsentAuthnResponse \n void setFriendlyName \n String iseIDCrossBorderShare \n void setIpValidation \n void setTimeNotOnOrAfter \n boolean isRequired \n void loadConsentAuthResp \n String getProperty \n String getProtocolBinding \n void loadProtocolBiding \n void setRequester \n void setResponder \n void loadConfiguration \n Integer getTimeNotOnOrAfter \n String iseIDCrossSectorShare \n String getConsentAuthnRequest", "output": "String function ( ) { return eIDCrossBordShare ; }"}, {"instruction": "Generate java code\nget all the groups on this server ", "input": " EntityManagerFactory emf \n\n T call \n List<GroupEntity> findGroupsForMember \n Set<MemberEntity> removeGroup \n GroupEntity getGroup \n boolean hasGroup \n Set<MemberEntity> updateGroup \n List<GroupEntity> findGroups \n T runInTransaction \n UserTransaction getUtx", "output": "List < GroupEntity > function ( ) { EntityManager loc0 = emf . createEntityManager ( ) ; Query loc1 = loc0 . createNamedQuery ( \"srini_string\" ) ; return ( List < GroupEntity > ) loc1 . getResultList ( ) ; }"}, {"instruction": "Generate java code\nconvert the given object to string with each line indented by 4 spaces except the first line . ", "input": " Map<String,String> mapProperty \n Map<String,Map<String,String>> mapOfMapProperty \n\n int hashCode \n void setMapProperty \n boolean equals \n Map<String,String> getMapProperty \n Map<String,Map<String,String>> getMapOfMapProperty \n void setMapOfMapProperty \n AdditionalPropertiesClass mapOfMapProperty \n String toString \n AdditionalPropertiesClass mapProperty", "output": "String function ( Object arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0 . toString ( ) . replace ( \"srini_string\" , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nlogs informational messages . ", "input": " PlaceHolder placeHolder \n\n void logSevereWarning", "output": "void function ( String arg0 , String arg1 ) { Logger . getLogger ( arg0 ) . info ( arg1 ) ; }"}, {"instruction": "Generate java code\nsimulate a remote error for the given requestid ", "input": " DiscoveryNode node \n TransportRequest request \n TransportServiceAdapter adapter \n BlockingQueue<CapturedRequest> capturedRequests \n long requestId \n String action \n\n Lifecycle.State lifecycleState \n void connectToNode \n CapturedRequest[] getCapturedRequestsAndClear \n long serverOpen \n Map<String,List<CapturedRequest>> getCapturedRequestsByTargetNodeAndClear \n void clear \n boolean nodeConnected \n void disconnectFromNode \n Transport start \n void removeLifecycleListener \n List<String> getLocalAddresses \n void addLifecycleListener \n boolean addressSupported \n TransportAddress[] addressesFromString \n Map<String,BoundTransportAddress> profileBoundAddresses \n Transport stop \n void connectToNodeLight \n CapturedRequest[] capturedRequests \n Map<String,List<CapturedRequest>> capturedRequestsByTargetNode \n void sendRequest \n void close \n BoundTransportAddress boundAddress \n void transportServiceAdapter", "output": "void function ( final long arg0 , final Throwable arg1 ) { adapter . onResponseReceived ( arg0 ) . handleException ( new RemoteTransportException ( \"srini_string\" , arg1 ) ) ; }"}, {"instruction": "Generate java code\ngets the outputprogressmodel for this instance . ", "input": " Log log \n long PROCCESS_SLEEP_LENGTH \n OutputProgressModel outputProgressModel \n OutputProgressModel ouputProgressModel \n PersistentFacesState persistentFacesState \n String sessionId \n RenderManager renderManager \n PersistentFacesState state \n ThreadPoolExecutor longRunningTaskThreadPool \n\n PersistentFacesState getState \n void renderingException \n void setRenderManager \n void startLongProcress \n void contextInitialized \n void run \n void dispose \n void contextDestroyed", "output": "OutputProgressModel function ( ) { return outputProgressModel ; }"}, {"instruction": "Generate java code\ntestvalue tests the specified value for validity against this indexquery . the helper classes in org.dbxml.core.indexer.helpers should be used for optimized performance . ", "input": " int EQ \n int op \n int GT \n int NBW \n Value[] vals \n int ANY \n int RANGE \n int LEQ \n int NBWX \n int GEQ \n int NEQ \n int TRUNC_RIGHT \n int REGEXP \n int NIN \n int BWX \n int TRUNC_LEFT \n int BW \n int IN \n int LT \n\n Value getValue \n Value[] getValues \n int getLength \n int getOperator", "output": "boolean function ( String arg0 ) { return testValue ( new Value ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns a new pixelformat object with the same properties as this pixelformat and the new auxiliary buffers value . ", "input": " int bpp \n int accum_bpp \n int accum_alpha \n int colorSamples \n int samples \n boolean sRGB \n int num_aux_buffers \n int depth \n boolean floating_point_packed \n int alpha \n boolean stereo \n int stencil \n boolean floating_point \n\n PixelFormat withStereo \n PixelFormat withDepthBits \n int getSamples \n int getAccumulationBitsPerPixel \n PixelFormat withStencilBits \n PixelFormat withSamples \n int getAccumulationAlpha \n int getAlphaBits \n boolean isFloatingPoint \n boolean isSRGB \n PixelFormat withSRGB \n int getStencilBits \n PixelFormat withBitsPerPixel \n PixelFormat withFloatingPointPacked \n int getAuxBuffers \n int getDepthBits \n PixelFormat withAccumulationAlpha \n PixelFormat withFloatingPoint \n PixelFormat withCoverageSamples \n PixelFormat withCoverageSamples \n PixelFormat withAlphaBits \n PixelFormat withAccumulationBitsPerPixel \n int getBitsPerPixel \n boolean isStereo", "output": "PixelFormat function ( final int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; final PixelFormat loc0 = new PixelFormat ( this ) ; loc0 . arg0 = arg0 ; return loc0 ; }"}, {"instruction": "Generate java code\ntwo objects that are equal are required to return the same hashcode . ", "input": " Quarter q1Y1900 \n Quarter q4Y9999 \n Quarter q2Y1900 \n Quarter q3Y9999 \n\n void testParseQuarter \n void testDateConstructor1 \n void testGetStart \n void testGetLastMillisecond \n void testGetSerialIndex \n void testGetFirstMillisecondWithTimeZone \n void testNext \n void testGetLastMillisecondWithTimeZone \n void testGetFirstMillisecond \n void testSerialization \n void testConstructor \n void testDateConstructor2 \n void testQ1Y1900Previous \n void testQ1Y1900Next \n void testEqualsSelf \n void testQ4Y9999Previous \n void testGetLastMillisecondWithCalendar \n void testGetFirstMillisecondWithCalendar \n void setUp \n void testGetEnd \n void testQ4Y9999Next \n void testNotCloneable \n void testEquals", "output": "void function ( ) { Quarter loc0 = new Quarter ( 2 , 2003 ) ; Quarter loc1 = new Quarter ( 2 , 2003 ) ; assertTrue ( loc0 . equals ( loc1 ) ) ; int loc2 = loc0 . hashCode ( ) ; int loc3 = loc1 . hashCode ( ) ; assertEquals ( loc2 , loc3 ) ; }"}, {"instruction": "Generate java code\nit checks whether the specified character is choseong . ", "input": " int ENCODING_UNICODE \n char[] JONGSEONG_LIST \n int JAMO_JONGSEONG \n int ENCODING_TRIPLE \n char HANGUL_FILLER \n byte[] CHOSEONG_LIST_REV \n byte[] JONGSEONG_LIST_REV \n int JAMO_CHOSEONG \n int JAMO_JUNGSEONG \n char[] CHOSEONG_LIST \n\n void convertFile \n boolean isJongseong \n char toCompatibilityJamo \n char toJamo \n String toTripleString \n boolean isJungseong \n String toString \n String toString \n char toSyllable \n char[] toTripleArray \n char toChoseong", "output": "boolean function ( char arg0 ) { if ( arg0 >= 0x1100 && arg0 <= 0x1112 ) { return true ; } else { return false ; } }"}, {"instruction": "Generate java code\ngets number of last item ", "input": " int count \n int first \n\n boolean contains \n int getFirst \n int getCount", "output": "int function ( ) { return getFirst ( ) + getCount ( ) - 1 ; }"}, {"instruction": "Generate java code\nreturns a random item from the array , or zero if the array is empty . ", "input": " boolean ordered \n int size \n float[] items \n\n void add \n void set \n void shrink \n void clear \n void insert \n float removeIndex \n void sort \n void reverse \n float peek \n float pop \n boolean contains \n boolean removeValue \n void truncate \n void addAll \n void addAll \n void addAll \n void addAll \n float get \n float[] toArray \n float[] resize \n String toString \n String toString \n float[] ensureCapacity \n void shuffle \n int indexOf", "output": "float function ( ) { if ( size == 0 ) return 0 ; return items [ MathUtils . random ( 0 , size - 1 ) ] ; }"}, {"instruction": "Generate java code\nrefer to remapuri added in cordova-android@4.0.0 ", "input": " CordovaPreferences preferences \n CordovaInterface cordova \n CordovaWebView webView \n String serviceName \n\n boolean onReceivedClientCertRequest \n boolean onOverrideUrlLoading \n CordovaResourceApi.OpenForReadResult handleOpenForRead \n Uri remapUri \n String getServiceName \n Boolean shouldAllowBridgeAccess \n void onPause \n boolean onReceivedHttpAuthRequest \n void onReset \n void onActivityResult \n void onStart \n Boolean shouldAllowRequest \n Boolean shouldOpenExternalUrl \n void onStop \n void onDestroy \n Boolean shouldAllowNavigation \n boolean execute \n boolean execute \n boolean execute \n void onResume \n void privateInitialize \n void pluginInitialize \n Uri fromPluginUri \n void onNewIntent \n Object onMessage \n void initialize \n void onConfigurationChanged", "output": "Uri function ( Uri arg0 ) { return new Uri . Builder ( ) . scheme ( CordovaResourceApi . PLUGIN_URI_SCHEME ) . authority ( serviceName ) . appendQueryParameter ( \"srini_string\" , arg0 . toString ( ) ) . build ( ) ; }"}, {"instruction": "Generate java code\ndetermines whether there any precomposed unicode characters not yet returned by #next . ", "input": " int nextChar \n Normalizer2Impl n2impl \n char DONE \n String decompBuf \n int curChar \n\n char next \n String decomposition \n void findNextChar", "output": "boolean function ( ) { if ( nextChar == Normalizer . DONE ) { findNextChar ( ) ; } return nextChar != Normalizer . DONE ; }"}, {"instruction": "Generate java code\nthe imageid that will be used for creating a node . values depend on the actual cloud provider . ", "input": " String container \n String blobName \n String imageId \n String directory \n JcloudsCommand command \n String hardwareId \n String nodeState \n String providerId \n String locationId \n String operation \n String nodeId \n String user \n String group \n\n String getLocationId \n String getUser \n void setDirectory \n String getHardwareId \n void setBlobName \n String getProviderId \n void setUser \n String getBlobName \n void setHardwareId \n String getImageId \n String getNodeId \n String getContainer \n JcloudsCommand getCommand \n void setCommand \n void setProviderId \n String getNodeState \n void setGroup \n void setNodeId \n void setNodeState \n String getGroup \n void setLocationId \n String getOperation \n void setOperation \n String getDirectory \n void setContainer", "output": "void function ( String arg0 ) { this . imageId = arg0 ; }"}, {"instruction": "Generate java code\nsets the value of the returnval property . ", "input": " ManagedObjectReference returnval \n\n ManagedObjectReference getReturnval", "output": "void function ( ManagedObjectReference arg0 ) { this . returnval = arg0 ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable collection of all chat listeners currently registered with this manager . ", "input": " Set<ChatManagerListener> chatManagerListeners \n Map<String,Chat> threadChats \n Map<String,Chat> jidChats \n Map<PacketInterceptor,PacketFilter> interceptors \n XMPPConnection connection \n String prefix \n long id \n\n Chat createChat \n Chat createChat \n Chat createChat \n Chat createChat \n String nextID \n PacketCollector createPacketCollector \n void deliverMessage \n void addChatListener \n Chat getUserChat \n void sendMessage \n void removeChatListener \n void addOutgoingMessageInterceptor \n void addOutgoingMessageInterceptor \n Chat getThreadChat", "output": "Collection < ChatManagerListener > function ( ) { return Collections . unmodifiableCollection ( chatManagerListeners ) ; }"}, {"instruction": "Generate java code\ndescribes an availability zone . ", "input": " String subnetIdentifier \n String subnetStatus \n AvailabilityZone subnetAvailabilityZone \n\n void setSubnetIdentifier \n String getSubnetIdentifier \n String getSubnetStatus \n Subnet withSubnetStatus \n int hashCode \n boolean equals \n Subnet clone \n Subnet withSubnetAvailabilityZone \n void setSubnetAvailabilityZone \n String toString \n Subnet withSubnetIdentifier \n void setSubnetStatus", "output": "AvailabilityZone function ( ) { return subnetAvailabilityZone ; }"}, {"instruction": "Generate java code\nthe function that checks whether there exists an entry foo in the set so that foo < = addr . ", "input": " HostSet includes \n Multimap<InetAddress,Integer> addrs \n Log LOG \n HostSet excludes \n\n void add \n InetSocketAddress parseEntry \n boolean isExcluded \n boolean match \n boolean isEmpty \n void refresh \n InetSocketAddress resolvedAddressFromDatanodeID \n boolean hasIncludes \n Iterator<InetSocketAddress> iterator \n int size \n HostSet readFile \n HostSet getIncludes \n HostSet getExcludes \n String toString \n boolean isIncluded", "output": "boolean function ( InetSocketAddress arg0 ) { Collection < Integer > loc0 = addrs . get ( arg0 . getAddress ( ) ) ; return arg0 . getPort ( ) == 0 ? ! loc0 . isEmpty ( ) : loc0 . contains ( arg0 . getPort ( ) ) ; }"}, {"instruction": "Generate java code\nextracts the attribute name form a field . any underscore will be removed ; and the first letter will be made to lower case . ", "input": " Logger log \n\n int getArrayDimension \n int getArrayDimension \n Method findMatchingMethod \n Method findMatchingMethod \n Class getArrayClass \n Class getArrayClass \n String getAttributeNameFromMethod \n void main \n String getClassName \n boolean isMethodStatic \n Vector findMatchingMethods \n boolean isFieldStatic \n boolean isValidSetMethod \n Class getImplementationClass \n boolean isValidGetMethod", "output": "String function ( Field arg0 ) { String loc0 = arg0 . getName ( ) ; if ( loc0 . startsWith ( \"srini_string\" ) ) loc0 = loc0 . substring ( 1 , loc0 . length ( ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\nrenderes an image with highlighted states ", "input": " PlaceHolder placeHolder \n\n Resource reload \n void highlightActiveStates \n Diagram getDiagramCopy \n Diagram getDiagramCopy", "output": "Image function ( IFile arg0 , ExecutionContext arg1 ) { Diagram loc0 = getDiagramCopy ( arg0 ) ; return renderImage ( loc0 , arg1 ) ; }"}, {"instruction": "Generate java code\nsent when a shell is un-minimized . the default behavior is to do nothing . ", "input": " PlaceHolder placeHolder \n\n void shellClosed \n void shellIconified \n void shellDeactivated \n void shellActivated", "output": "void function ( ShellEvent arg0 ) { }"}, {"instruction": "Generate java code\nget the status of the checksum error . ", "input": " String filetype \n boolean noOp \n boolean checksumError \n String filepath \n String destination \n String onBehalfOf \n String packaging \n String userAgent \n boolean corruptRequest \n boolean useMD5 \n String slug \n boolean verbose \n\n void setCorruptRequest \n String getDestination \n void setFilepath \n String getSlug \n String getOnBehalfOf \n boolean isVerbose \n void setOnBehalfOf \n boolean getCorruptRequest \n void setNoOp \n void setChecksumError \n void setUserAgent \n boolean isNoOp \n void setVerbose \n void setDestination \n void setFormatNamespace \n void setUseMD5 \n void setFiletype \n String getFilename \n boolean isUseMD5 \n String getFilepath \n String getUserAgent \n String getPackaging \n String getFiletype \n void setSlug", "output": "boolean function ( ) { return checksumError ; }"}, {"instruction": "Generate java code\nreturns a comparator that compares contained numbers based on their numeric values and compares other parts based on each character 's unicode value . ", "input": " Comparator<String> IGNORE_CASE_NATURAL_COMPARATOR_ASCII \n Comparator<String> NATURAL_COMPARATOR_ASCII \n\n int compare \n int compare \n int compareNaturalAscii \n Comparator<String> getNaturalComparator \n Comparator<String> getNaturalComparator \n int compareNatural \n int compareNatural \n int compareNatural \n int compareNaturalIgnoreCaseAscii \n Comparator<String> getNaturalComparatorIgnoreCaseAscii", "output": "Comparator < String > function ( ) { return NATURAL_COMPARATOR_ASCII ; }"}, {"instruction": "Generate java code\nform a new set that is the difference of this set with another set . ", "input": " int MAX_SIZE \n int _size \n int ndv \n int _shift \n int[] _values \n int _mask \n int NBIT \n int _nmax \n int _nhi \n int i \n int _nlo \n\n boolean add \n int next \n int[] getValues \n IntHashSet intersect \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n IntHashSet union \n boolean containsSome \n boolean remove \n boolean contains \n IntIterator iterator \n void diagnosticDump \n int size \n int getFirst \n int hashCode \n boolean equals \n void setCapacity \n IntHashSet copy \n int indexOf \n int hash", "output": "IntHashSet function ( IntHashSet arg0 ) { IntHashSet loc0 = new IntHashSet ( ( int ) size ( ) ) ; IntIterator loc1 = iterator ( ) ; while ( loc1 . hasNext ( ) ) { int loc2 = loc1 . next ( ) ; if ( ! arg0 . contains ( loc2 ) ) { loc0 . add ( loc2 ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nreturns the national language version nlv for this cover letter . ", "input": " AS400 system_ \n int preInstructions_ \n String path_ \n String nlv_ \n int SPECIAL_INSTRUCTIONS_NO \n int SPECIAL_INSTRUCTIONS_IPL \n int postInstructions_ \n int SPECIAL_INSTRUCTIONS_YES \n int ccsid_ \n int SPECIAL_INSTRUCTIONS_IMMEDIATE \n String copyright \n int SPECIAL_INSTRUCTIONS_UNKNOWN \n\n int getPreSpecialInstructions \n AS400 getSystem \n String getPath \n Reader getContents \n String toString \n int getPostSpecialInstructions", "output": "String function ( ) { return nlv_ ; }"}, {"instruction": "Generate java code\nadds an itembean . ", "input": " ArrayList itemBeans \n String sequence \n long serialVersionUID \n String partName \n\n void setSequence \n void setPartName \n ArrayList getItemBeans \n void setItemBeans \n String getSequence \n String getPartName", "output": "void function ( HistogramQuestionScoresBean arg0 ) { if ( itemBeans == null ) itemBeans = new ArrayList ( ) ; itemBeans . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nextract the simp session attributes from the given message , wrap them in a simpattributes instance and bind it to the current thread , ", "input": " ThreadLocal<SimpAttributes> attributesHolder \n\n SimpAttributes getAttributes \n void setAttributes \n SimpAttributes currentAttributes \n void resetAttributes", "output": "void function ( Message < ? > arg0 ) { setAttributes ( SimpAttributes . fromMessage ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nproduce a jsonarray of jsonobjects from a comma delimited text string using a supplied jsonarray as the source of element names . ", "input": " PlaceHolder placeHolder \n\n String getValue \n JSONObject rowToJSONObject \n String rowToString \n String toString \n String toString \n JSONArray rowToJSONArray", "output": "JSONArray function ( JSONArray arg0 , JSONTokener arg1 ) { if ( arg0 == null || arg0 . length ( ) == 0 ) { return null ; } JSONArray loc0 = new JSONArray ( ) ; for ( ; ; ) { JSONObject loc1 = rowToJSONObject ( arg0 , arg1 ) ; if ( loc1 == null ) { break ; } loc0 . put ( loc1 ) ; } if ( loc0 . length ( ) == 0 ) { return null ; } return loc0 ; }"}, {"instruction": "Generate java code\nasserts that filters with the given configuration accept the given record . ", "input": " PlaceHolder placeHolder \n\n GlobFilter newGlobFilter \n void shouldReject \n void shouldReject \n void shouldReject \n void shouldReject \n void shouldAcceptImpl \n void shouldAcceptUnmatchedWhenBothAreConfigured \n MetricsRecord mockMetricsRecord \n void emptyConfigShouldAccept \n RegexFilter newRegexFilter \n void excludeOnlyShouldOnlyExcludeMatched \n void includeShouldOverrideExclude \n void includeOnlyShouldOnlyIncludeMatched", "output": "void function ( SubsetConfiguration arg0 , MetricsRecord arg1 ) { assertTrue ( \"srini_string\" + arg1 , newGlobFilter ( arg0 ) . accepts ( arg1 ) ) ; assertTrue ( \"srini_string\" + arg1 , newRegexFilter ( arg0 ) . accepts ( arg1 ) ) ; }"}, {"instruction": "Generate java code\nsets the font render context . this is intented to be used in search keys only . ", "input": " String string \n FontRenderContext fontRenderContext \n Font font \n\n void setString \n int hashCode \n boolean equals \n void setFont", "output": "void function ( FontRenderContext arg0 ) { fontRenderContext = arg0 ; }"}, {"instruction": "Generate java code\nplace ", "input": " UnitWorks uw \n EventListener el \n int x \n TurnManager tm \n int y \n MapWorks mw \n int type \n UnitMap map \n PanelManager pm \n\n void cancel \n boolean isNextPoint \n void setSelectBody \n void leftPressed \n void mouseMoved \n void accept", "output": "void function ( int arg0 , int arg1 ) { pm . displayPlace ( tm , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngets the status ", "input": " String districtCode \n String phoneNumber \n String address \n String school \n String city \n String district \n String testCoordinator \n String schoolCode \n String siteType \n String status \n\n void setSchoolCode \n void setTestCoordinator \n void setAddress \n void setCity \n String getSchoolCode \n void setDistrictCode \n int compareTo \n String getSiteType \n String getTestCoordinator \n void setStatus \n String getSchool \n void setSiteType \n void setPhoneNumber \n String getDistrict \n boolean equals \n String getDistrictCode \n String getPhoneNumber \n String getAddress \n String toString \n void setDistrict \n void setSchool \n String getCity", "output": "String function ( ) { return ( this . status ) ; }"}, {"instruction": "Generate java code\nreplace the top value on the stack with the given value . this is equivalent to stack.pop ; stack.push value ; ", "input": " int top \n int[] values \n int DEFAULT_INITIAL_CAPACITY \n\n int pop \n int size \n void clear \n boolean isEmpty \n void increment \n String toString \n void push \n int peek", "output": "void function ( int arg0 ) { if ( top == 0 ) { throw new EmptyStackException ( ) ; } values [ top - 1 ] = arg0 ; }"}, {"instruction": "Generate java code\nclear all styles . ", "input": " List<CSSStyleHierarchy> styles \n AbstractMTApplication app \n boolean globallyDisabled \n List<CSSStylableComponent> components \n IFont defaultFont \n boolean globallyEnabled \n\n void setStyles \n void registerComponent \n void loadStylesAndOverrideSelector \n void setGloballyDisabled \n List<CSSStyleHierarchy> getRelevantStyles \n boolean isGloballyDisabled \n void loadStyles \n void loadStyles \n boolean isGloballyEnabled \n void loadStylesFromSrcFolder \n CSSStyle getFirstStyleForSelector \n void setGloballyEnabled \n List<CSSStyleHierarchy> getStyles \n void applyStyles \n void removeStyle \n void addStyle \n void addStyle \n IFont getDefaultFont", "output": "void function ( ) { this . styles . clear ( ) ; applyStyles ( ) ; }"}, {"instruction": "Generate java code\nsets the given bit to true . ", "input": " int width \n int[] bits \n int height \n int rowSize \n\n void setRegion \n int getHeight \n int[] getTopLeftOnBit \n int hashCode \n boolean get \n boolean equals \n void clear \n String toString \n int getWidth \n BitArray getRow \n void flip \n int[] getBottomRightOnBit", "output": "void function ( int arg0 , int arg1 ) { int loc0 = arg1 * rowSize + ( arg0 >> 5 ) ; bits [ loc0 ] |= 1 << ( arg0 & 0x1f ) ; }"}, {"instruction": "Generate java code\ngets the y-coordinate . ", "input": " int y \n String mode \n String dummy \n Effect effectPanelGroup \n Effect effectSelectManyListBox \n Effect effectInputText \n Effect effectCommandButton \n Effects effectsBean \n int x \n Effect effectOutputText \n Effect effectSelectOneMenu \n\n void setY \n void setX \n void setDummy \n String getDummy \n void setMode \n Effect getEffectSelectManyListBox \n void setEffectSelectOneMenu \n Effect getEffectOutputText \n void setEffectSelectManyListBox \n String invokeEffect \n Effect getEffectCommandButton \n String dummy \n int getX \n Effect getEffectPanelGroup \n Effect getEffectInputText \n void setEffectOutputText \n Effect getEffectSelectOneMenu \n void setEffectCommandButton \n String reset \n String getMode \n void setEffectPanelGroup \n void setEffectInputText", "output": "int function ( ) { return y ; }"}, {"instruction": "Generate java code\nsets the mensagem value for this ossturbonetupdateradiusout . ", "input": " org.apache.axis.description.TypeDesc typeDesc \n com.gvt.www.ws.eai.oss.ossturbonet.OSSTurbonetOut mensagem \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n\n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n com.gvt.www.ws.eai.oss.ossturbonet.OSSTurbonetOut getMensagem \n int hashCode \n boolean equals", "output": "void function ( com . gvt . www . ws . eai . oss . ossturbonet . OSSTurbonetOut arg0 ) { this . mensagem = arg0 ; }"}, {"instruction": "Generate java code\ngets first value of the attribute from item . ", "input": " String MISSING_IMAGE_URL \n int IMAGE_CELL_WIDTH \n int MISSING_IMAGE_WIDTH \n\n String getAuthors \n String format \n void outputBookDetailsCell \n void outputImageCell", "output": "String function ( AmazonItem arg0 , String arg1 ) { List loc0 = arg0 . getAttributeValues ( arg1 ) ; return loc0 == null || loc0 . size ( ) == 0 ? null : loc0 . get ( 0 ) . toString ( ) ; }"}, {"instruction": "Generate java code\nthis probably should be hided in the getquery method . ", "input": " SearchIntegrator searchFactory \n TimeoutExceptionFactory timeoutExceptionFactory \n AdvancedCache<?,?> cache \n QueryInterceptor queryInterceptor \n\n Statistics getStatistics \n EntityContext buildQueryBuilderForClass \n Analyzer getAnalyzer \n Analyzer getAnalyzer \n void setTimeoutExceptionFactory \n MassIndexer getMassIndexer \n void purge \n void registerKeyTransformer \n CacheQuery<E> getQuery \n CacheQuery<E> getQuery \n T unwrap", "output": "CacheQuery < E > function ( Query arg0 , Class < ? > ... arg1 ) { queryInterceptor . enableClasses ( arg1 ) ; ExecutorService loc0 = queryInterceptor . getAsyncExecutor ( ) ; return new ClusteredCacheQueryImpl < > ( arg0 , searchFactory , loc0 , cache , queryInterceptor . getKeyTransformationHandler ( ) , arg1 ) ; }"}, {"instruction": "Generate java code\nthis input parameter is ignored for the moment . ", "input": " Entropy entropy \n long keySize \n String computedKeyAlgorithm \n String c14nAlgorithm \n ReceivedKey receivedKey \n String encryptWith \n String keywrapAlgorithm \n String authenticationType \n String keyType \n String signWith \n String encryptionAlgorithm \n String signatureAlgorithm \n\n void setAuthenticationType \n String getComputedKeyAlgorithm \n String getEncryptionAlgorithm \n void setSignWith \n void setKeywrapAlgorithm \n void setC14nAlgorithm \n String getEncryptWith \n String getAuthenticationType \n void setEntropy \n String getKeyType \n String getSignWith \n void setKeyType \n Entropy getEntropy \n ReceivedKey getReceivedKey \n void setComputedKeyAlgorithm \n void setEncryptWith \n String getSignatureAlgorithm \n void setSignatureAlgorithm \n String getKeywrapAlgorithm \n long getKeySize \n void setEncryptionAlgorithm \n void setKeySize \n void setReceivedKey", "output": "String function ( ) { return c14nAlgorithm ; }"}, {"instruction": "Generate java code\nreturns the next available packet . the method call will block not return until a packet is available . ", "input": " ArrayBlockingQueue<Packet> resultQueue \n boolean cancelled \n PacketFilter packetFilter \n Connection connection \n\n void cancel \n Packet pollResult \n void processPacket \n PacketFilter getPacketFilter", "output": "Packet function ( ) { try { return resultQueue . take ( ) ; } catch ( InterruptedException loc0 ) { throw new RuntimeException ( loc0 ) ; } }"}, {"instruction": "Generate java code\ntest if focus is defined for a certain element . ", "input": " Pattern ClientIdPattern \n\n void setFocus \n String getFocus \n String getReceivedFocus", "output": "boolean function ( FacesContext arg0 ) { return arg0 . getExternalContext ( ) . getRequestMap ( ) . containsKey ( FocusController . class . getName ( ) ) ; }"}, {"instruction": "Generate java code\n#### description removes given behavior from given component if it was added before #### usage if behavior was added to component : `` ` java mycomponent.add mybehavior ; / / ... behaviors.remove mycomponent , mybehavior ; / / = true `` ` if behavior was n't added to component before : `` ` java behaviors.remove mycomponent , mybehavior ; / / = false `` ` ", "input": " PlaceHolder placeHolder \n\n boolean contains \n boolean contains", "output": "boolean function ( final Component arg0 , final Behavior arg1 ) { Args . notNull ( arg0 , \"srini_string\" ) ; for ( Behavior loc0 : arg0 . getBehaviors ( ) ) { if ( loc0 . equals ( arg1 ) ) { arg0 . remove ( loc0 ) ; return true ; } } return false ; }"}, {"instruction": "Generate java code\naddstatebasedeffect . ", "input": " HashMap<String,Integer> stateBasedMap \n HashMap<String,String[]> cardToEffectsList \n\n HashMap<String,String[]> getCardToEffectsList \n void removeStateBasedEffect \n void reset \n HashMap<String,Integer> getStateBasedMap \n void initStateBasedEffectsList \n void rePopulateStateBasedList", "output": "void function ( String arg0 ) { if ( stateBasedMap . containsKey ( arg0 ) ) stateBasedMap . put ( arg0 , stateBasedMap . get ( arg0 ) + 1 ) ; else stateBasedMap . put ( arg0 , 1 ) ; }"}, {"instruction": "Generate java code\nstart a trace span with a given description with the given sampler . ", "input": " PlaceHolder placeHolder \n\n Span trace \n void data \n void offNoFlush \n Span start \n boolean isTracing \n long currentTraceId \n Span currentTrace \n Runnable wrap \n void off \n T wrapAll \n T wrapAll", "output": "Span function ( String arg0 , Sampler < T > arg1 ) { return new Span ( org . apache . htrace . Trace . startSpan ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nfields correspond directly to item.addmetadata calls so they are simply executed . ", "input": " PlaceHolder placeHolder \n\n boolean canDisseminate \n List<Element> disseminateList \n Namespace[] getNamespaces \n Element disseminateElement \n String getSchemaLocation \n boolean preferList", "output": "void function ( Context arg0 , DSpaceObject arg1 , List < Element > arg2 , boolean arg3 ) { XSLTIngestionCrosswalk . ingestDIM ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nidentifies whether the metacard is a registry identity node ", "input": " PlaceHolder placeHolder \n\n boolean getBooleanAttribute \n boolean isRegistryMetacard \n boolean isRegistryMetacard \n List<String> getListOfStringAttribute \n boolean isLocalNode \n String getStringAttribute \n boolean hasAttribute \n boolean isInternalRegistryMetacard \n String getRegistryId", "output": "boolean function ( Metacard arg0 ) { return getBooleanAttribute ( arg0 , RegistryObjectMetacardType . REGISTRY_IDENTITY_NODE ) ; }"}, {"instruction": "Generate java code\nprints a character to this output stream and flushes this output stream . ", "input": " String CHARSET_NAME \n Locale LOCALE \n PrintWriter out \n\n void println \n void println \n void println \n void println \n void println \n void println \n void println \n void println \n void println \n void main \n void close \n void printf \n void printf", "output": "void function ( char arg0 ) { out . print ( arg0 ) ; out . flush ( ) ; }"}, {"instruction": "Generate java code\ngets the singleton instance . ", "input": " ReviewerIdManager theInstance \n ReviewerId reviewerId \n\n void elementChanged \n ReviewerId getReviewerId \n void setReviewerId", "output": "ReviewerIdManager function ( ) { return theInstance ; }"}, {"instruction": "Generate java code\ny = ax + b ", "input": " Point _end \n Point _start \n float _a \n boolean _vertical \n float _b \n\n boolean isVertical \n Point getStart \n String toString \n boolean isInside \n float getB \n Point getEnd", "output": "float function ( ) { return _a ; }"}, {"instruction": "Generate java code\nsetter for the used event worker ", "input": " int baud \n String port \n SerialEventWorker eventWorker \n InputStream inputStream \n SerialPort serialPort \n Logger logger \n OutputStream outputStream \n CommPortIdentifier portId \n int DEFAULT_PORT \n\n void serialEvent \n void unsetEventWorker \n String getPort \n void initialize \n void writeString \n void close", "output": "void function ( SerialEventWorker arg0 ) { this . eventWorker = arg0 ; }"}, {"instruction": "Generate java code\nget the user object that will be used for all requests . ", "input": " User viewer \n\n boolean dominates \n boolean dominates \n boolean dominates \n ProvenanceCollection getGraph \n ProvenanceCollection getGraph \n ProvenanceCollection getGraph \n ProvenanceCollection query \n List<PLUSWorkflow> listWorkflows \n boolean canSeeDisjunctive \n PLUSObject getSingleNode \n ProvenanceCollection getActors \n ProvenanceCollection getActors \n ProvenanceCollection search \n ProvenanceCollection search \n boolean authorizedFor \n PLUSActor actorExists \n boolean report \n PLUSObject exists \n PLUSObject exists \n PLUSActor actorExistsByName \n ProvenanceCollection getWorkflowMembers \n boolean canSee \n boolean canSee \n void setUser \n ProvenanceCollection latest", "output": "User function ( ) { return viewer ; }"}, {"instruction": "Generate java code\nget one ticket by id . ", "input": " TicketSearchRepository ticketSearchRepository \n Logger log \n TicketRepository ticketRepository \n UserRepository userRepository \n\n int getQueueNumber \n List<Ticket> search \n List<Ticket> findByUser_Id \n Ticket save \n List<Ticket> findByFoodJoint_Id \n Ticket getNewTicket \n Ticket getNextTicket \n ZonedDateTime getEstimateWaitingTime \n List<Ticket> findAll \n void delete \n TicketGo getGoTicket \n List<TicketGo> findByUser_Login", "output": "Ticket function ( Long arg0 ) { log . debug ( \"srini_string\" , arg0 ) ; Ticket loc0 = ticketRepository . findOne ( arg0 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ntransform the given attribute name , eg : `` foo '' to `` foo '' , `` firstname '' to `` firstname '' ", "input": " PlaceHolder placeHolder \n\n String integerToString \n String buildGetter \n String buildGetter \n String bigDecimalToString \n String trim \n int intValue \n String buildSetter \n String shortestType \n boolean inList", "output": "String function ( String arg0 ) { return arg0 . substring ( 0 , 1 ) . toUpperCase ( ) + arg0 . substring ( 1 , arg0 . length ( ) ) ; }"}, {"instruction": "Generate java code\ntest of getid method , of class pelikan . ", "input": " PlaceHolder placeHolder \n\n void testIncrTime \n void testGetKekuatan \n void testGetChar \n void testGetPosisi", "output": "void function ( ) { System . out . println ( \"srini_string\" ) ; int loc0 = 10 ; Pelikan loc1 = new Pelikan ( loc0 ) ; int loc2 = loc1 . getID ( ) ; assertTrue ( loc2 >= 0 ) ; }"}, {"instruction": "Generate java code\nreturns the longest prefix from a given set of ` prefixes ' that are contained in ` path ' . i.e the closest ancestor directory containing path . returns null if none found . ", "input": " Logger LOG \n boolean LOG_FINER \n Path workspace \n String[] prefixes \n ImmutableMap<PackageIdentifier,Path> packageRoots \n String productName \n\n PackageIdentifier getParent \n PackageIdentifier createInRepo \n void plantSymlinkForest \n void deleteTreesBelowNotPrefixed", "output": "PackageIdentifier function ( PackageIdentifier arg0 , ImmutableSet < PackageIdentifier > arg1 ) { for ( int loc0 = arg0 . getPackageFragment ( ) . segmentCount ( ) ; loc0 >= 0 ; loc0 -- ) { PackageIdentifier loc1 = createInRepo ( arg0 , arg0 . getPackageFragment ( ) . subFragment ( 0 , loc0 ) ) ; if ( arg1 . contains ( loc1 ) ) { return loc1 ; } } return null ; }"}, {"instruction": "Generate java code\nget the source . ", "input": " String bitstreamFormat \n String internalId \n int storeNumber \n boolean deleted \n long size \n int bitstreamId \n String name \n String checksumAlgorithm \n String source \n String userFormatDescription \n String storedChecksum \n\n void setName \n void setSource \n String getName \n void getName \n void setBitstreamFormatId \n String getInternalId \n String getChecksumAlgorithm \n int getStoreNumber \n void setStoreNumber \n String getBitstreamFormatId \n int getBitstreamId \n long getSize \n void setSize \n boolean getDeleted \n String getUserFormatDescription \n void setInternalId \n int hashCode \n boolean equals \n void setChecksumAlgorithm \n void setUserFormatDescription \n String toString \n String getStoredChecksum \n void setDeleted \n void setStoredChecksum", "output": "String function ( ) { return source ; }"}, {"instruction": "Generate java code\nthis function fills a rectangle with a vertical gradient . this implementation does not use the gradient mechanism based on background patterns since they do not work stable on all systems . ", "input": " PlaceHolder placeHolder \n\n void fillVerticalGradientRoundedRectangle \n Color mixColor", "output": "void function ( Graphics arg0 , Rectangle arg1 , Color arg2 , Color arg3 ) { arg0 . pushState ( ) ; arg0 . setForegroundColor ( arg3 ) ; arg0 . setBackgroundColor ( arg2 ) ; arg0 . fillGradient ( arg1 . x , arg1 . y , arg1 . width , arg1 . height , true ) ; arg0 . popState ( ) ; }"}, {"instruction": "Generate java code\nlookup an object in the given context ", "input": " PlaceHolder placeHolder \n\n void bind \n void bind \n Context createSubcontext \n Context createSubcontext \n void unbind \n void unbind \n void deleteSubContext \n void checkObject \n void appendClassInfo", "output": "Object function ( Context arg0 , String arg1 , Class arg2 ) { Object loc0 = arg0 . lookup ( arg1 ) ; checkObject ( arg0 , arg1 , loc0 , arg2 ) ; return loc0 ; }"}, {"instruction": "Generate java code\ndecrements the iterator 's index by one and returns the character at the new index . specified by : java.text.characteriterator . ", "input": " int END_RUN \n ArrayList mapList \n int START_RUN \n int MID_RUN \n Set allAttributes \n CharacterIterator iter \n String simpleString \n int currentIndex \n int[] charInRun \n int SINGLETON \n\n char next \n void setAttributeArray \n Map getAttributes \n int getIndex \n char last \n int getRunLimit \n int getRunLimit \n int getRunLimit \n int getBeginIndex \n void setString \n void setString \n char current \n Object getAttribute \n void buildAttributeTables \n void buildAttributeTables \n int getEndIndex \n char setIndex \n Object clone \n int getRunStart \n int getRunStart \n int getRunStart \n AttributedCharacterIterator mutateAttributes \n Set getAllAttributeKeys \n char first", "output": "char function ( ) { return iter . previous ( ) ; }"}, {"instruction": "Generate java code\nreturns the error of the command processing . if #issuccess return true , this method returns null . ", "input": " String commandIdentifier \n boolean success \n byte[] serializedResult \n String resultType \n String resultRevision \n\n Object getReturnValue \n String getResultRevision \n String getCommandIdentifier \n Object deserializeResult \n String getResultType \n byte[] getSerializedResult \n int hashCode \n boolean equals \n String toString \n boolean isSuccess", "output": "Throwable function ( Serializer arg0 ) { if ( success || resultType == null ) { return null ; } return ( Throwable ) deserializeResult ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturn the token for the connection back to the application . you can not use this directly , it must be converted to a inputconnection for you . ", "input": " int mUid \n Parcelable.Creator<InputBinding> CREATOR \n int mPid \n InputConnection mConnection \n IBinder mConnectionToken \n String TAG \n\n InputConnection getConnection \n int getUid \n InputBinding[] newArray \n String toString \n InputBinding createFromParcel \n int getPid \n void writeToParcel \n int describeContents", "output": "IBinder function ( ) { return mConnectionToken ; }"}, {"instruction": "Generate java code\nparse . ", "input": " Integer maximum \n\n boolean check", "output": "Integer function ( String arg0 ) { try { return Integer . parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }"}, {"instruction": "Generate java code\nreturns a clone of the map . ", "input": " Comparable defaultGroup \n long serialVersionUID \n Map keyToGroupMap \n List groups \n\n int getGroupIndex \n int getGroupCount \n Comparable getGroup \n boolean equals \n int getKeyCount \n void mapKeyToGroup \n List getGroups", "output": "Object function ( ) { KeyToGroupMap loc0 = ( KeyToGroupMap ) super . clone ( ) ; loc0 . defaultGroup = ( Comparable ) KeyToGroupMap . clone ( this . defaultGroup ) ; loc0 . groups = ( List ) KeyToGroupMap . clone ( this . groups ) ; loc0 . keyToGroupMap = ( Map ) KeyToGroupMap . clone ( this . keyToGroupMap ) ; return loc0 ; }"}, {"instruction": "Generate java code\ngets the selected all state of the doucment pages view . ", "input": " ArrayList<WeakReference<AbstractPageViewComponent>> selectedPageText \n float oldUserZoom \n float userZoom \n int MAX_PAGE_SIZE_READ_AHEAD \n UndoCaretaker undoCaretaker \n int oldPageIndex \n Logger log \n int pageBoundary \n List<AbstractPageViewComponent> pageComponents \n int userToolModeFlag \n float oldUserRotation \n boolean selectAll \n int oldUserToolModeFlag \n AnnotationComponent currentAnnotation \n Document currentDocument \n float userRotation \n int currentPageIndex \n\n AnnotationComponent getCurrentAnnotation \n boolean setViewRotation \n int getViewCurrentPageIndex \n List<AbstractPageViewComponent> getPageComponents \n boolean setViewZoom \n Document getDocument \n float getViewRotation \n boolean isViewToolModeSelected \n void clearSelectedPageText \n boolean setViewToolMode \n UndoCaretaker getAnnotationCareTaker \n float getViewZoom \n boolean setViewCurrentPageIndex \n void invalidate \n int getPageBoundary \n Rectangle getPageBounds \n void setCurrentAnnotation \n int getViewToolMode \n void addMemento \n void setPageBoundary \n void setSelectAll \n void addSelectedPageText \n void dispose \n ArrayList<WeakReference<AbstractPageViewComponent>> getSelectedPageText", "output": "boolean function ( ) { return selectAll ; }"}, {"instruction": "Generate java code\nreturns a string representation of the card . ", "input": " String[] SUITS \n int rank \n int suit \n String[] RANKS \n\n int getRank \n int getSuit \n boolean equals \n int compareTo \n int position", "output": "String function ( ) { return RANKS [ this . rank ] + \"srini_string\" + SUITS [ this . suit ] ; }"}, {"instruction": "Generate java code\ntests for next line ", "input": " String output \n File inputFile \n File outputFile \n Scanner inputScanner \n PrintWriter printer \n String input \n\n String getNextLine \n void closeOutput \n void writeOutput", "output": "boolean function ( ) { return inputScanner . hasNextLine ( ) ; }"}, {"instruction": "Generate java code\nsets a specific location in the bar ", "input": " byte[] row \n int currentLocation \n\n void addBar \n byte[] getScaledRow", "output": "void function ( int arg0 , byte arg1 ) { row [ arg0 ] = arg1 ; }"}, {"instruction": "Generate java code\nget int64 ", "input": " byte[] _byte \n String password \n BigDecimal number \n Float _float \n Integer integer \n Double _double \n String string \n DateTime dateTime \n byte[] binary \n Integer int32 \n String uuid \n Long int64 \n LocalDate date \n\n FormatTest date \n FormatTest dateTime \n Integer getInt32 \n void setBinary \n void setPassword \n void setByte \n byte[] getByte \n FormatTest string \n void setInteger \n Double getDouble \n Integer getInteger \n FormatTest integer \n Float getFloat \n void setInt64 \n FormatTest uuid \n FormatTest _byte \n BigDecimal getNumber \n void setDouble \n FormatTest number \n FormatTest password \n FormatTest int64 \n int hashCode \n FormatTest _double \n LocalDate getDate \n String toIndentedString \n void setFloat \n DateTime getDateTime \n void setInt32 \n String getString \n void setUuid \n void setNumber \n void setDateTime \n FormatTest _float \n void setString \n String getPassword \n FormatTest int32 \n FormatTest binary \n String getUuid \n boolean equals \n void setDate \n byte[] getBinary \n String toString", "output": "Long function ( ) { return int64 ; }"}, {"instruction": "Generate java code\nputs a header given a key into the hashmap . overwrites potential existing entry . ", "input": " int RESIZE_INCR \n short[] ids \n Header[] hdrs \n\n void init \n Map<Short,Header> getHeaders \n String printHeaders \n short[] getRawIDs \n Header getHeader \n int capacity \n int size \n int size \n String printObjectHeaders \n void resize \n String toString \n Header _putHeader \n Header[] getRawHeaders \n Headers copy \n Header putHeaderIfAbsent \n int marshalledSize", "output": "void function ( short arg0 , Header arg1 ) { _putHeader ( arg0 , arg1 , 0 , true ) ; }"}, {"instruction": "Generate java code\ncreate a while statement and add it to this block ", "input": " boolean bracesRequired \n boolean indentRequired \n int pos \n List<Object> content \n\n JVar decl \n JVar decl \n JVar decl \n T insert \n JInvocation invoke \n JInvocation invoke \n JInvocation invoke \n JInvocation invoke \n JTryBlock _try \n void _continue \n void _continue \n void generateBody \n int pos \n int pos \n void _throw \n List<Object> getContents \n JBlock block \n void state \n void generate \n JBlock add \n JForLoop _for \n JForEach forEach \n boolean isEmpty \n JDoLoop _do \n JLabel label \n void _return \n void _return \n void _break \n void _break \n JBlock assignPlus \n JSwitch _switch \n JStatement directStatement \n JInvocation staticInvoke \n JConditional _if \n JBlock assign", "output": "JWhileLoop function ( JExpression arg0 ) { return insert ( new JWhileLoop ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nreturns the base64 encoded command string to be sent via the max ! protocol . ", "input": " boolean[] bits \n String rfAddress \n int roomId \n String baseString \n\n placeholderType placeHolder", "output": "String function ( ) { String loc0 = baseString + rfAddress + Utils . toHex ( roomId ) + Utils . toHex ( bits ) ; String loc1 = Base64 . encodeBase64String ( Utils . hexStringToByteArray ( loc0 ) ) ; return \"srini_string\" + loc1 ; }"}, {"instruction": "Generate java code\nmethod to match the current token to a specified token type and value throws a syntaxexception if token does n't match . ", "input": " URL inputfile \n Token currentToken \n StreamTokenizer st \n String ALIAS \n int ttype \n String sval \n boolean DEBUG \n\n void logln \n void nextToken \n void parse", "output": "void function ( int arg0 , String arg1 ) { if ( ( currentToken . arg0 == arg0 ) && ( currentToken . sval . compareTo ( arg1 ) == 0 ) ) { logln ( \"srini_string\" + arg0 + \"srini_string\" + currentToken . sval ) ; nextToken ( ) ; } else { throw new SyntaxException ( st . lineno ( ) ) ; } }"}, {"instruction": "Generate java code\ncreate restrictions , projections and specify order for a property of the revision entity , corresponding to an audited entity . ", "input": " PlaceHolder placeHolder \n\n AuditProperty<RevisionType> revisionType \n AuditProperty<RevisionType> revisionType \n AuditCriterion not \n AuditProjection selectEntity \n AuditCriterion or \n AuditConjunction conjunction \n AuditProperty<Number> revisionNumber \n AuditProperty<Number> revisionNumber \n AuditDisjunction disjunction \n AuditCriterion and \n AuditProperty<Object> property \n AuditProperty<Object> property \n AuditId id \n AuditId id \n AuditRelatedId relatedId \n AuditRelatedId relatedId", "output": "AuditProperty < Object > function ( String arg0 , String arg1 ) { return new AuditProperty < > ( arg0 , new RevisionPropertyPropertyName ( arg1 ) ) ; }"}, {"instruction": "Generate java code\ncalled to inform the adapter of which item is currently considered to be the `` primary '' , that is the one show to the user as the current page . ", "input": " int POSITION_NONE \n int POSITION_UNCHANGED \n DataSetObservable mObservable \n\n void restoreState \n void startUpdate \n void startUpdate \n Parcelable saveState \n Object instantiateItem \n Object instantiateItem \n float getPageWidth \n int getItemPosition \n void registerDataSetObserver \n CharSequence getPageTitle \n void notifyDataSetChanged \n void finishUpdate \n void finishUpdate \n void unregisterDataSetObserver \n int getCount \n void destroyItem \n void destroyItem \n boolean isViewFromObject", "output": "void function ( View arg0 , int arg1 , Object arg2 ) { }"}, {"instruction": "Generate java code\nthe time , in seconds , that the connection is allowed to be idle no data has been sent over the connection before it is closed by the load balancer . ", "input": " Integer idleTimeout \n\n Integer getIdleTimeout \n int hashCode \n boolean equals \n ConnectionSettings clone \n String toString \n void setIdleTimeout", "output": "ConnectionSettings function ( Integer arg0 ) { setIdleTimeout ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nreturn true if the method takes a variable number of arguments . ", "input": " com.badlogic.gwtref.client.Method method \n\n boolean isAccessible \n boolean isStatic \n String getName \n void setAccessible \n boolean isAnnotationPresent \n boolean isDefaultAccess \n Class[] getParameterTypes \n Object invoke \n boolean isPrivate \n boolean isAbstract \n boolean isNative \n Annotation[] getDeclaredAnnotations \n Class getDeclaringClass \n boolean isProtected \n Class getReturnType \n Annotation getDeclaredAnnotation \n boolean isPublic \n boolean isFinal", "output": "boolean function ( ) { return method . isVarArgs ( ) ; }"}, {"instruction": "Generate java code\nsets the last zone record for this time zone . ", "input": " List<RuleRec> usedRuleRecs \n int UNDEF_DST \n ZoneRec lastZoneRec \n int lastSaving \n List<ZoneRec> usedZoneRecs \n int dstType \n List<RuleRec> lastRules \n List<Long> transitions \n int LAST_DST \n int X_DST \n int NO_DST \n List<Integer> offsets \n int rawOffset \n List<Integer> gmtOffsets \n boolean willRawOffsetChange \n String name \n int DST \n int crc32 \n List<Integer> dstOffsets \n\n List<Long> getTransitions \n String getName \n void addUsedRec \n void addUsedRec \n int getNTransitions \n List<Integer> getOffsets \n int getCRC32 \n void setDSTType \n int getDSTType \n void optimize \n List<Integer> getDstOffsets \n int getLastDSTSaving \n void checksum \n List<ZoneRec> getZones \n List<RuleRec> getRules \n ZoneRec getLastZoneRec \n void setLastDSTSaving \n int getOffsetIndex \n int getOffsetIndex \n int getDstOffsetIndex \n List<Integer> getGmtOffsets \n void setLastRules \n void setRawOffset \n void setRawOffset \n void addTransition \n List<RuleRec> getLastRules \n boolean willGMTOffsetChange \n int getRawOffset", "output": "void function ( ZoneRec arg0 ) { lastZoneRec = arg0 ; }"}, {"instruction": "Generate java code\nstart client connection and return immediately . ", "input": " Set<String> subscriptions \n ByteBuffer readBuffer \n List<FanoutListener> listeners \n SocketChannel socketCh \n AtomicBoolean isAutomaticReconnect \n AtomicBoolean isConnected \n int reconnectTimeout \n CharsetDecoder decoder \n ByteBuffer writeBuffer \n int clientTimeout \n Thread clientThread \n int port \n AtomicBoolean isRunning \n boolean resubscribe \n String host \n Selector selector \n String id \n Logger logger \n\n String read \n void setAutomaticReconnect \n void subscribe \n void ping \n boolean isAutomaticReconnect \n boolean isConnected \n void resetState \n void fireAnnouncement \n boolean processReply \n void main \n void run \n void removeListener \n void pong \n void pong \n void firePong \n void announce \n void startSynchronously \n void stop \n void closeChannel \n void unsubscribe \n void confirmConnection \n boolean write \n void announcement \n void announcement \n void addListener \n void status", "output": "void function ( ) { if ( isRunning . get ( ) ) { logger . warn ( \"srini_string\" ) ; return ; } clientThread = new Thread ( this , \"srini_string\" ) ; clientThread . start ( ) ; }"}, {"instruction": "Generate java code\nwhether this state is a final state , meaning the application is not running anymore once it 's reached . ", "input": " boolean isFinal \n\n void infoChanged \n void disconnect \n State getState \n void stop \n void kill \n void stateChanged \n void addListener \n String getAppId", "output": "boolean function ( ) { return isFinal ; }"}, {"instruction": "Generate java code\nsets the source entity of the resource in case the resource is resolved . ", "input": " String sourceEntity \n String searchPath \n ResourceInfo instance \n boolean isResolved \n URL url \n\n void setResolved \n URL getURL \n ResourceInfoBuilder with \n ResourceInfoBuilder as \n String getSourceEntity \n void setSearchPath \n ResourceInfo build \n String getSearchPath \n ResourceInfoBuilder builder \n void setSourceEntity \n boolean isResolved \n void setURL", "output": "ResourceInfoBuilder function ( String arg0 ) { instance . setSourceEntity ( instance . isResolved ( ) ? arg0 : \"srini_string\" ) ; return this ; }"}, {"instruction": "Generate java code\nreturns a list of files affected by this refactoring . ", "input": " RefactoringHelper helper \n List<T> contextObjects \n\n TransactionalEditingDomain getEditingDomain \n Resource getResource \n boolean internalDoUndo \n String getCommandLabel \n T getContextObject \n boolean isExecutable \n void setContextObjects \n void execute \n void internalExecute \n void executeCommand \n List<T> getContextObjects", "output": "List < ? > function ( ) { return Collections . EMPTY_LIST ; }"}, {"instruction": "Generate java code\nthe main method of the class . create a graph and draw a random lines and points in it . ", "input": " int numOfLines \n int width \n int height \n\n Point generateRandomPoint \n void drawPoint \n Line generateRandomLine \n void drawGraph \n Line[] lineList \n void drawLine", "output": "void function ( String [ ] arg0 ) { AbstractArtDrawing loc0 = new AbstractArtDrawing ( 500 , 500 , 10 ) ; loc0 . drawGraph ( ) ; }"}, {"instruction": "Generate java code\nauto generated axis2 error handler override this method for handling error response from createentity operation ", "input": " Object clientData \n\n void receiveErrorenumScenarios \n void receiveResultopenEntity \n void receiveResultenumAccounts \n void receiveResultsetEntityDataCells \n void receiveErrorgetEntityDataCells \n void receiveResultenumScenarios \n void receiveResultenumCustomMembers \n void receiveResultgetEntityLockInfo \n void receiveErrorgetScenarioInfo \n void receiveResultreleaseEntityLock \n void receiveResultenumCustomDimensions \n void receiveResultcloseEntity \n void receiveErrorcalculate \n void receiveResultsetForecastInfo \n void receiveResultenumMeasures \n void receiveResultsetScenarioInfo \n void receiveResultgetScenarioInfo \n void receiveErroropenEntity \n Object getClientData \n void receiveErrorenumAccounts \n void receiveErrorenumCustomMembers \n void receiveErrorenumMeasures \n void receiveResultenumTimePeriods \n void receiveErrorenumTimePeriods \n void receiveResultexportExtendedAnalytics \n void receiveErrorgetEntityLockInfo \n void receiveErrorenumCustomDimensions \n void receiveResultcreateEntity \n void receiveResultcalculate \n void receiveErrorsetEntityDataCells \n void receiveErrorexportExtendedAnalytics \n void receiveErrorreleaseEntityLock \n void receiveErrorsetForecastInfo \n void receiveErrorsetScenarioInfo \n void receiveResultgetEntityDataCells \n void receiveErrorcloseEntity", "output": "void function ( java . lang . Exception arg0 ) { }"}, {"instruction": "Generate java code\nweight returns the weight of u , v . returns zero if u , v is not an edge including the case where either of the parameters u and v does not represent a vertex of the graph . note : a well-behaved application should try to avoid calling this method for an edge that is not in the graph , and should certainly not treat the result as if it actually represents an edge with weight zero . however , some sort of default response is necessary for missing edges , so we return zero . an exception would be more appropriate , but also more annoying . running time : o 1 . ", "input": " DList vertList \n HashTableChained vertices \n HashTableChained edgesTable \n int numEdge \n int numVert \n\n boolean isVertex \n void removeVertex \n boolean isEdge \n Vertex VertFromTable \n int edgeCount \n int degree \n int vertexCount \n Neighbors getNeighbors \n void removeEdge \n Edge EdgeFromTable \n Object[] getVertices \n void addVertex \n void addEdge", "output": "int function ( Object arg0 , Object arg1 ) { int loc0 = 0 ; Edge loc1 = EdgeFromTable ( new VertexPair ( arg0 , arg1 ) ) ; if ( loc1 != null ) { loc0 = loc1 . weight ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ngets the prog . ", "input": " String name \n String dimension \n Integer prog \n Date creationDate \n byte[] content \n Integer biobjId \n Integer binId \n Boolean active \n Integer id \n String creationUser \n Logger logger \n\n void setName \n void setBinId \n void setContent \n String getName \n byte[] getContent \n void setCreationUser \n Integer getId \n Date getCreationDate \n void setBiobjId \n void setProg \n Integer getBiobjId \n void setCreationDate \n void setActive \n Integer getBinId \n String getDimension \n void setDimension \n ObjTemplate clone \n void setId \n Boolean getActive \n String getCreationUser", "output": "Integer function ( ) { return prog ; }"}, {"instruction": "Generate java code\nget the state of the currently active display . ", "input": " int FEATURE_STATE_OFF \n int mScanState \n WifiDisplay[] mDisplays \n WifiDisplaySessionInfo mSessionInfo \n int FEATURE_STATE_ON \n int DISPLAY_STATE_CONNECTING \n WifiDisplay mActiveDisplay \n int FEATURE_STATE_UNAVAILABLE \n int SCAN_STATE_NOT_SCANNING \n int SCAN_STATE_SCANNING \n Creator<WifiDisplayStatus> CREATOR \n int mActiveDisplayState \n int DISPLAY_STATE_NOT_CONNECTED \n int mFeatureState \n int FEATURE_STATE_DISABLED \n int DISPLAY_STATE_CONNECTED \n\n WifiDisplaySessionInfo getSessionInfo \n int getScanState \n WifiDisplayStatus[] newArray \n WifiDisplayStatus createFromParcel \n String toString \n int getFeatureState \n void writeToParcel \n int describeContents \n WifiDisplay getActiveDisplay \n WifiDisplay[] getDisplays", "output": "int function ( ) { return mActiveDisplayState ; }"}, {"instruction": "Generate java code\nsets the value of the type property . ", "input": " String role \n String arcrole \n String show \n String actuate \n JAXBElement<? extends EngineeringCRSType> engineeringCRS \n List<String> nilReason \n String href \n String remoteSchema \n String type \n String title \n\n String getRemoteSchema \n String getHref \n List<String> getNilReason \n JAXBElement<? extends EngineeringCRSType> getEngineeringCRS \n void setHref \n String getRole \n String getArcrole \n void setTitle \n void setActuate \n void setArcrole \n void setEngineeringCRS \n String getActuate \n void setRemoteSchema \n void setShow \n String getTitle \n String getType \n String getShow \n void setRole", "output": "void function ( String arg0 ) { this . type = arg0 ; }"}, {"instruction": "Generate java code\ntest of npara method , of class poisson . ", "input": " PlaceHolder placeHolder \n\n void setUpClass \n void testVar \n void testEntropy \n void testCdf \n void tearDownClass \n void testQuantile \n void tearDown \n void testPoissonDistribution \n void testSd \n void testMean \n void testPdf \n void setUp \n void testLogPdf", "output": "void function ( ) { System . out . println ( \"srini_string\" ) ; PoissonDistribution loc0 = new PoissonDistribution ( 3.5 ) ; loc0 . rand ( ) ; assertEquals ( 1 , loc0 . npara ( ) ) ; }"}, {"instruction": "Generate java code\na patch operation whose value indicates the operation to perform . its value must be one of `` add '' , `` remove '' , `` replace '' , `` move '' , `` copy '' , or `` test '' ; other values are errors . ", "input": " String op \n String path \n String from \n String value \n\n PatchOperation withPath \n void setFrom \n void setOp \n void setOp \n void setPath \n String getOp \n String getValue \n PatchOperation withValue \n int hashCode \n void setValue \n PatchOperation withFrom \n boolean equals \n String getPath \n PatchOperation clone \n String toString \n String getFrom", "output": "PatchOperation function ( Op arg0 ) { setOp ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nreturn a predicate which rethrows possible checked exceptions as runtime exception . ", "input": " PlaceHolder placeHolder \n\n Predicate<T> predicate \n boolean test \n T apply \n Function<F,T> function \n Consumer<T> consumer \n void accept", "output": "Predicate < T > function ( CheckedPredicate < T > arg0 ) { return input -> { try { return arg0 . test ( input ) ; } catch ( Exception loc0 ) { if ( loc0 instanceof RuntimeException ) { throw ( RuntimeException ) loc0 ; } throw new RuntimeException ( loc0 ) ; } } ; }"}, {"instruction": "Generate java code\nremoves from the underlying collection the last element returned by this iterator optional operation . this method can be called only once per call to #next . the behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method . ", "input": " List<List<byte[]>> dictionaryChunks \n int iteratorIndex \n int size \n int outerIndex \n int currentIndex \n\n byte[] next \n int getSize \n boolean hasNext", "output": "void function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nunconditionally sets the value of both the reference and mark . ", "input": " T reference \n boolean mark \n Pair<V> pair \n\n boolean weakCompareAndSet \n boolean compareAndSet \n boolean casPair \n Pair<T> of \n V get \n V getReference \n boolean isMarked \n boolean attemptMark", "output": "void function ( V arg0 , boolean arg1 ) { Pair < V > loc0 = pair ; if ( arg0 != loc0 . reference || arg1 != loc0 . mark ) this . pair = Pair . of ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nadds an unnamed value to the formatted output . it is strongly encouraged to use #add string , int insteadand give value a readable name . ", "input": " ValueHolder next \n ValueHolder holderTail \n String name \n String className \n boolean omitNullValues \n ValueHolder holderHead \n Object value \n\n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper omitNullValues \n ValueHolder addHolder \n ToStringHelper addHolder \n ToStringHelper addHolder \n T firstNonNull \n ToStringHelper toStringHelper \n ToStringHelper toStringHelper \n ToStringHelper toStringHelper \n String toString", "output": "ToStringHelper function ( int arg0 ) { return addHolder ( String . valueOf ( arg0 ) ) ; }"}, {"instruction": "Generate java code\na shortcut for calling #setidgenerator org.springframework.util.idgenerator with an id generation strategy to disable id generation completely . ", "input": " IdGenerator idGenerator \n IdGenerator ID_VALUE_NONE_GENERATOR \n boolean enableTimestamp \n\n IdGenerator getIdGenerator \n void setIdGenerator \n boolean isEnableTimestamp \n void initHeaders \n UUID generateId \n void setEnableTimestamp", "output": "void function ( ) { this . idGenerator = ID_VALUE_NONE_GENERATOR ; }"}, {"instruction": "Generate java code\nconfigure , how the handler handles links found in custom xml . if hyperlinkstyleid is set to null , strings containing ` http : / / ' or ` https : / / ' are not converted to w : hyperlink . this is the default behavior . if hyperlinkstyleid is set to `` somewordhyperlinkstylename '' , strings containing ` http : / / ' or ` https : / / ' or or ` mailto : ' are converted to w : hyperlink . the default word hyperlink style name is `` hyperlink '' . due to the architecture of this class , this is a static flag changing the behavior of all following calls to #applybindings . ", "input": " BindingHyperlinkResolver hyperlinkResolver \n String CORE_PROPERTIES_STOREITEMID \n String COVERPAGE_PROPERTIES_STOREITEMID \n AtomicInteger bookmarkId \n Logger log \n WordprocessingMLPackage wordMLPackage \n String EXTENDED_PROPERTIES_STOREITEMID \n\n AtomicInteger initBookmarkIdStart \n String getHyperlinkStyleId \n String xpathGetString \n String xpathGetString \n void setHyperlinkResolver \n BindingHyperlinkResolver getHyperlinkResolver \n void setStartingIdForNewBookmarks \n void applyBindings \n void applyBindings \n void applyBindings", "output": "void function ( String arg0 ) { getHyperlinkResolver ( ) . setHyperlinkStyle ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets flag indicating whether tcp_nodelay option should be setfor accepted client connections . ", "input": " boolean DFLT_TCP_NODELAY \n int DFLT_PORT_RANGE \n IgniteLogger log \n int DFLT_TCP_PORT \n int portRange \n boolean noDelay \n long idleTimeout \n Collection<String> srvrs \n String DFLT_TCP_HOST \n int port \n SecurityCredentialsProvider credsProvider \n Collection<String> DFLT_SERVERS \n String host \n boolean sslClientAuth \n GridSslContextFactory sslCtxFactory \n\n void setHost \n void setPortRange \n long getIdleTimeout \n void setSslClientAuth \n IgniteLogger getLogger \n Collection<String> getServers \n int getPortRange \n void setServers \n void setPort \n boolean isNoDelay \n void setSecurityCredentialsProvider \n int getPort \n SecurityCredentialsProvider getSecurityCredentialsProvider \n boolean isSslClientAuth \n void setLogger \n GridSslContextFactory getSslContextFactory \n void setSslContextFactory \n String toString \n void setIdleTimeout \n String getHost", "output": "void function ( boolean arg0 ) { this . noDelay = arg0 ; }"}, {"instruction": "Generate java code\nreturns the subclass of regulartimeperiod that should be usedto generate the date labels . ", "input": " Class periodClass \n Paint dividerPaint \n RectangleInsets padding \n Stroke DEFAULT_DIVIDER_STROKE \n Font labelFont \n DateFormat dateFormat \n Paint DEFAULT_LABEL_PAINT \n boolean drawDividers \n long serialVersionUID \n Paint DEFAULT_DIVIDER_PAINT \n Stroke dividerStroke \n Paint labelPaint \n Font DEFAULT_FONT \n RectangleInsets DEFAULT_INSETS \n\n Font getLabelFont \n RegularTimePeriod createInstance \n Paint getDividerPaint \n RectangleInsets getPadding \n void writeObject \n void readObject \n Paint getLabelPaint \n boolean getDrawDividers \n int hashCode \n boolean equals \n Object clone \n DateFormat getDateFormat \n Stroke getDividerStroke", "output": "Class function ( ) { return this . periodClass ; }"}, {"instruction": "Generate java code\ngetter for items ", "input": " String preferredPrefix \n String sellerId \n BasicAmountType bucketSubtotalAmt \n BasicAmountType bucketShippingAmt \n String bucketId \n String externalSellerId \n BasicAmountType bucketInsuranceAmt \n List<IncentiveItemType> items \n BasicAmountType bucketTotalAmt \n String nameSpace \n BasicAmountType bucketSalesTaxAmt \n\n void setSellerId \n BasicAmountType getBucketSubtotalAmt \n String toXMLString \n void setBucketShippingAmt \n void setBucketSubtotalAmt \n BasicAmountType getBucketShippingAmt \n void setExternalSellerId \n void setBucketId \n void setBucketSalesTaxAmt \n BasicAmountType getBucketSalesTaxAmt \n BasicAmountType getBucketInsuranceAmt \n void setBucketInsuranceAmt \n String getBucketId \n String getSellerId \n void setItems \n BasicAmountType getBucketTotalAmt \n String getExternalSellerId \n void setBucketTotalAmt", "output": "List < IncentiveItemType > function ( ) { return items ; }"}, {"instruction": "Generate java code\nto get maximum request ", "input": " int accessState \n int maximumRequest \n long prohibitTimePeriod \n long unitTime \n\n void setAccessState \n int getAccessState \n void setMaximumRequestPerUnitTime \n void setUnitTime \n int getType \n void setProhibitTimePeriod \n void setID \n String getID \n long getProhibitTimePeriod \n long getUnitTime", "output": "int function ( ) { return maximumRequest ; }"}, {"instruction": "Generate java code\nadds the given provider to the collection of providers at thenext available position . ", "input": " Properties secprops \n\n List<String> getAliases \n String getProperty \n Provider[] getProviders \n Provider[] getProviders \n Provider[] getProviders \n void setProperty \n Provider getProvider \n int insertProviderAt \n void registerDefaultProviders \n String getAlgorithmProperty \n void renumProviders \n void renumProviders \n Set<String> getAlgorithms \n Provider.Service getService \n void removeProvider", "output": "int function ( Provider arg0 ) { return insertProviderAt ( arg0 , 0 ) ; }"}, {"instruction": "Generate java code\nattempts to load the transformation referred by this executor and checks if it is valid for execution . remark : only the first performs the actual transformation loading , subsequent calls to this method will return the existing diagnostic . ", "input": " URI debuggableURI \n ResourceSet fCompilationRs \n IVMContext vmContext \n VMExecutor vmExecutor \n CompiledUnit fCompiledUnit \n ExecutionDiagnosticImpl fLoadDiagnostic \n\n IVMContext getVMContext \n EvaluationContext createInternalContext \n ExecutionDiagnostic doExecute \n ExecutionDiagnostic createExecutionFailure \n ExecutionDiagnostic execute \n VMExecutor getVMExecutor \n void doLoad \n void cleanup \n ResourceSet getResourceSet \n VMExecutor createVMExecutor \n String toString \n CompiledUnit getUnit \n NamedElement getDebuggable \n URI getURI \n boolean isSuccess", "output": "Diagnostic function ( ) { if ( fLoadDiagnostic == null ) { doLoad ( ) ; } return fLoadDiagnostic ; }"}, {"instruction": "Generate java code\nspecifies the solverid to user for the solver instance key ", "input": " boolean async \n String solverId \n String configFile \n int threadPoolSize \n\n int getThreadPoolSize \n void setAsync \n boolean isAsync \n String getSolverId \n void setThreadPoolSize \n String getConfigFile \n void setConfigFile", "output": "void function ( String arg0 ) { this . solverId = arg0 ; }"}, {"instruction": "Generate java code\nconverts readablearray to an array of float . returns newly created array . ", "input": " PlaceHolder placeHolder \n\n placeholderType placeHolder", "output": "float [ ] function ( @ Nullable ReadableArray arg0 ) { if ( arg0 != null ) { float [ ] loc0 = new float [ arg0 . size ( ) ] ; toFloatArray ( arg0 , loc0 ) ; return loc0 ; } return null ; }"}, {"instruction": "Generate java code\nsets the value of the version property . ", "input": " MetadataType metadata \n List<RteType> rte \n ExtensionsType extensions \n String creator \n List<WptType> wpt \n List<TrkType> trk \n String version \n\n String getVersion \n void setMetadata \n MetadataType getMetadata \n List<RteType> getRte \n void setCreator \n List<WptType> getWpt \n ExtensionsType getExtensions \n void setExtensions \n String getCreator \n List<TrkType> getTrk", "output": "void function ( String arg0 ) { this . version = arg0 ; }"}, {"instruction": "Generate java code\ntranlates unspecified no_system_exit property to false , the default typically required when a server is started from the command line . ", "input": " PlaceHolder placeHolder \n\n int getDefaultPort \n String[] listLocalInetAddressNames \n void translateDefaultDatabaseProperty \n void translateAddressProperty \n ServerProperties getPropertiesFromFile \n ServerProperties newDefaultProperties", "output": "void function ( HsqlProperties arg0 ) { if ( arg0 == null ) { return ; } arg0 . setPropertyIfNotExists ( SC_KEY_NO_SYSTEM_EXIT , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nused to communicate a progress update between a plugin tool and the main whitebox user interface . ", "input": " String[] args \n boolean cancelOp \n WhiteboxPluginHost myHost \n String previousProgressLabel \n int previousProgress \n boolean amIActive \n\n String getName \n void setPluginHost \n String[] getToolbox \n String getDescriptiveName \n void setCancelOp \n void returnData \n String getToolDescription \n void setArgs \n void run \n void cancelOperation \n boolean isActive \n void showFeedback", "output": "void function ( String arg0 , int arg1 ) { if ( myHost != null && ( ( arg1 != previousProgress ) || ( ! arg0 . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( arg0 , arg1 ) ; } previousProgress = arg1 ; previousProgressLabel = arg0 ; }"}, {"instruction": "Generate java code\nensures that the lineinfo array can contain the specified index . this enlarges it if necessary . no action is taken if the array is large enough already . it should be unnecessary to call this under normal circumstances ; insertline should take care of enlarging the line info array automatically . ", "input": " Token lastToken \n Token firstToken \n boolean nextLineRequested \n int lastLine \n LineInfo[] lineInfo \n Object obj \n int length \n byte token \n\n void addToken \n void deleteLines \n int getLineCount \n byte markTokensImpl \n boolean isNextLineRequested \n boolean supportsMultilineTokens \n Token markTokens \n void insertLines", "output": "void function ( int arg0 ) { if ( lineInfo == null ) { lineInfo = new LineInfo [ arg0 + 1 ] ; } else if ( lineInfo . length <= arg0 ) { LineInfo [ ] loc0 = new LineInfo [ ( arg0 + 1 ) * 2 ] ; System . arraycopy ( lineInfo , 0 , loc0 , 0 , lineInfo . length ) ; lineInfo = loc0 ; } }"}, {"instruction": "Generate java code\nreturn object representing prototype for class ", "input": " PlaceHolder placeHolder \n\n Object resolveAddress \n int tie \n int tied \n int instance \n int address \n int address \n void untie \n int getAddressPrototype \n int size \n Object castTo \n void clear \n void poke \n int peek", "output": "Object function ( Object arg0 , String arg1 ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nthe event type associated with this operation . ", "input": " String eventId \n String code \n String description \n String eventType \n\n void setEventId \n VolumeStatusAction withEventType \n void setCode \n VolumeStatusAction withDescription \n void setDescription \n String getDescription \n String getEventType \n VolumeStatusAction withCode \n int hashCode \n boolean equals \n VolumeStatusAction withEventId \n VolumeStatusAction clone \n String toString \n String getCode \n String getEventId", "output": "void function ( String arg0 ) { this . eventType = arg0 ; }"}, {"instruction": "Generate java code\nhandles newly resolved server groups and metadata attributes from name resolution system . servers contained in resolvedserverinfogroup should be considered equivalentbut may be flattened into a single list if needed . implementations should not modify the given servers . ", "input": " PlaceHolder placeHolder \n\n T pickTransport \n void handleTransportReady \n LoadBalancer<T> newLoadBalancer \n void handleTransportShutdown \n void handleNameResolutionError \n void shutdown", "output": "void function ( List < ResolvedServerInfoGroup > arg0 , Attributes arg1 ) { }"}, {"instruction": "Generate java code\nget the channel package list for a channel ", "input": " PlaceHolder placeHolder \n\n Collection<PackageCapabilityDto> getPackageCapabilityDtos \n Collection<PackageChangelogDto> getPackageChangelogDtos \n DataResult getTaskStatusInfo", "output": "DataResult < PackageDto > function ( Channel arg0 ) { SelectMode loc0 = ModeFactory . getMode ( TaskConstants . MODE_NAME , TaskConstants . TASK_QUERY_REPOMD_GENERATOR_CHANNEL_PACKAGES ) ; Map < String , Object > loc1 = new HashMap < String , Object > ( ) ; loc1 . put ( \"srini_string\" , arg0 . getId ( ) ) ; return loc0 . execute ( loc1 ) ; }"}, {"instruction": "Generate java code\nsafer variant of #impersonate authentication that does not require a finally-block . ", "input": " String SYSTEM_USERNAME \n Sid EVERYONE \n String ANONYMOUS_USERNAME \n Sid ANONYMOUS \n Sid[] AUTOMATIC_SIDS \n Authentication SYSTEM \n\n void checkPermission \n void checkCreatePermission \n ACLContext as \n ACLContext as \n boolean hasCreatePermission \n boolean hasPermission \n boolean hasPermission \n String toString", "output": "void function ( @ Nonnull Authentication arg0 , @ Nonnull Runnable arg1 ) { SecurityContext loc0 = impersonate ( arg0 ) ; try { arg1 . run ( ) ; } finally { SecurityContextHolder . setContext ( loc0 ) ; } }"}, {"instruction": "Generate java code\nfills the meta data in the specified buffer ", "input": " int END_OF_METADATA \n int MONITOR_VERSION_OFFSET \n int COUNTER_LABELS_BUFFER_LENGTH_OFFSET \n int META_DATA_LENGTH \n int MONITOR_VERSION \n int COUNTER_VALUES_BUFFER_LENGTH_OFFSET \n int META_DATA_OFFSET \n\n int monitorVersionOffset \n UnsafeBuffer createMetaDataBuffer \n int counterLabelsBufferLengthOffset \n int computeMonitorTotalFileLength \n UnsafeBuffer createCounterValuesBuffer \n int counterValuesBufferLengthOffset \n UnsafeBuffer createCounterLabelsBuffer", "output": "void function ( final UnsafeBuffer arg0 , final int arg1 , final int arg2 ) { arg0 . putInt ( monitorVersionOffset ( 0 ) , MONITOR_VERSION ) ; arg0 . putInt ( counterLabelsBufferLengthOffset ( 0 ) , arg1 ) ; arg0 . putInt ( counterValuesBufferLengthOffset ( 0 ) , arg2 ) ; }"}, {"instruction": "Generate java code\nreturns bad jobs , i.e. jobs that are not assigned to any vehicle route . ", "input": " Collection<VehicleRoute> routes \n double cost \n Collection<Job> unassignedJobs \n\n Collection<VehicleRoute> getRoutes \n void setCost \n String toString \n VehicleRoutingProblemSolution copyOf \n double getCost", "output": "Collection < Job > function ( ) { return unassignedJobs ; }"}, {"instruction": "Generate java code\nclear the read set by resetting its size ", "input": " ReadFieldAccess[] entries \n int size \n\n void add \n int getSize \n boolean contains \n int size \n void initArray \n void copy \n boolean validate", "output": "void function ( ) { size = 0 ; }"}, {"instruction": "Generate java code\ndefines or reset a listener for the given method signature . ", "input": " MethodListener sDefaultListener \n HashMap<String,MethodListener> sMethods \n\n long invokeL \n int invokeI \n void invokeV \n float invokeF \n double invokeD \n void setDefaultListener \n Object invokeA", "output": "void function ( String arg0 , MethodListener arg1 ) { if ( arg1 == null ) { sMethods . remove ( arg0 ) ; } else { sMethods . put ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nreturns the prop . ", "input": " Single single \n String string \n String prop \n String id \n\n Single getSingle \n void setString \n void setId \n String getId \n void setProp \n String getString \n void setSingle", "output": "String function ( ) { return prop ; }"}, {"instruction": "Generate java code\nsynonym for seturl string . ", "input": " String description \n String dataSourceName \n String password \n String serverName \n int loginTimeout \n String user \n String networkProtocol \n PrintWriter logWriter \n Properties connectionProps \n String url \n\n void setPassword \n void setLogWriter \n void setLoginTimeout \n String getUser \n void setProperties \n java.util.logging.Logger getParentLogger \n String getDatabaseName \n String getNetworkProtocol \n String getServerName \n String getDescription \n void setUrl \n void setURL \n String getDataSourceName \n String getUrl \n String getURL \n String getDatabase \n void setDatabaseName \n int getLoginTimeout \n void setUser \n PrintWriter getLogWriter", "output": "void function ( String arg0 ) { this . url = arg0 ; }"}, {"instruction": "Generate java code\nreset the loop counter . ", "input": " StringBuilder builder \n int index \n\n void appendExceptFirst \n int length \n void appendOnlyFirst \n String toString \n StatementBuilder append \n StatementBuilder append \n StatementBuilder append", "output": "StatementBuilder function ( ) { index = 0 ; return this ; }"}, {"instruction": "Generate java code\nreturns the next record in the master file . this will process any directives before the next record . ", "input": " Tokenizer st \n long currentTTL \n int currentType \n int currentDClass \n Name origin \n Generator generator \n Master included \n Record last \n File file \n boolean needSOATTL \n long defaultTTL \n List generators \n boolean noExpandGenerate \n\n long parseUInt32 \n Name parseName \n Record _nextRecord \n void endGenerate \n Record nextGenerated \n void expandGenerate \n Iterator generators \n void finalize \n void startGenerate \n void parseTTLClassAndType", "output": "Record function ( ) { Record loc0 = null ; try { loc0 = _nextRecord ( ) ; } finally { if ( loc0 == null ) { st . close ( ) ; } } return loc0 ; }"}, {"instruction": "Generate java code\nreturn the next-hop node for the shortest path from the root node to the given node . ", "input": " int cost \n PriorityQueue<SPFnode<N,E>> q \n Graph<N,E> g \n N root \n HashMap<N,SPFnode<N,E>> spfnodes \n N n \n LinkedList<Edge<N,L>> parents \n\n List<Edge<N,E>> path \n void explore \n N root \n String toString \n void run \n int compareTo", "output": "N function ( N arg0 ) { SPFnode < N , E > loc0 ; N loc1 = null ; while ( ( loc0 = spfnodes . get ( arg0 ) ) != null && loc0 . parents . size ( ) > 0 ) { loc1 = arg0 ; arg0 = loc0 . parents . getFirst ( ) . from ( ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nset a view object for this modelandview . will override any pre-existing view name or view . the given view object will usually be a servlet mvc view object . this is nevertheless typed as object to avoid a servlet api dependency in the portlet modelandview class . ", "input": " Object view \n ModelMap model \n boolean cleared \n\n boolean wasCleared \n Map<String,Object> getModel \n void setViewName \n Map<String,Object> getModelInternal \n void clear \n boolean isEmpty \n boolean hasView \n String getViewName \n ModelAndView addObject \n ModelAndView addObject \n boolean isReference \n String toString \n ModelAndView addAllObjects \n Object getView \n ModelMap getModelMap", "output": "void function ( Object arg0 ) { this . view = arg0 ; }"}, {"instruction": "Generate java code\nremove the properties added to collection or resource ", "input": " String sessionCookie \n JMXClient jmxClient \n String userName \n String userNameWithoutDomain \n AutomationContext automationContext \n String backEndUrl \n\n boolean init \n boolean JMXSubscribe \n void disconnect \n boolean update \n boolean getJMXNotification", "output": "void function ( String arg0 ) { PropertiesAdminServiceClient loc0 = new PropertiesAdminServiceClient ( backEndUrl , sessionCookie ) ; loc0 . removeProperty ( arg0 , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nwhen a file fails uploading , after the upload is complete , which can only happen when the fileentrycallback 's end method throws a runtimeexception . ", "input": " String fileName \n long totalSize \n File file \n long size \n ArrayList<FileInfo> fileInfos \n boolean viaCallback \n String contentType \n FileEntryStatus status \n\n void prefail \n boolean isViaCallback \n FileEntryStatus getStatus \n ArrayList<FileInfo> getFiles \n File getFile \n void addCompletedFile \n long getSize \n boolean isLifecycleAndUploadsSuccessful \n void updateStatus \n void updateStatus \n boolean isSaved \n int hashCode \n boolean equals \n boolean equals \n Object clone \n Object clone \n String getContentType \n String toString \n String toString \n long getAvailableTotalSize \n void finish \n void begin \n String getFileName", "output": "void function ( FileEntryStatus arg0 ) { this . status = arg0 ; }"}, {"instruction": "Generate java code\ncreates a new region that is the same as this region but expanded in all directions by the given amount ", "input": " Vector3i next \n Region3i other \n Vector3i pos \n Iterator<Vector3i> innerIterator \n Vector3i min \n Vector3i size \n Region3i EMPTY \n\n Vector3i next \n Vector3i next \n int maxZ \n void updateNext \n Region3i createEncompassing \n int maxY \n Region3i createFromMinAndSize \n int maxX \n Region3i createFromMinMax \n void remove \n void remove \n Iterator<Vector3i> iterator \n Vector3i min \n int hashCode \n Region3i createBounded \n Region3i move \n boolean encompasses \n boolean encompasses \n Region3i intersect \n Vector3i max \n Iterator<Vector3i> subtract \n Vector3f center \n boolean isEmpty \n boolean hasNext \n boolean hasNext \n int sizeX \n Region3i createFromCenterExtents \n Region3i createFromCenterExtents \n Region3i createFromCenterExtents \n int minY \n Vector3i size \n int minX \n Vector3i getNearestPointTo \n boolean equals \n Region3i expandToContain \n String toString \n int minZ \n int sizeY \n int sizeZ", "output": "Region3i function ( int arg0 ) { Vector3i loc0 = min ( ) ; loc0 . sub ( arg0 , arg0 , arg0 ) ; Vector3i loc1 = max ( ) ; loc1 . add ( arg0 , arg0 , arg0 ) ; return createFromMinMax ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nbinds an id generator for unique acl rule id generation . note : a generator can not be bound if there is already a generator bound . ", "input": " Ip4Prefix srcIp \n IdGenerator idGenerator \n Ip4Prefix dstIp \n byte ipProto \n byte ipProto \n Action action \n Ip4Prefix srcIp \n RuleId id \n Ip4Prefix dstIp \n Action action \n short dstTpPort \n short dstTpPort \n\n boolean checkCidrInCidr \n Builder srcIp \n Ip4Prefix srcIp \n Builder ipProto \n byte ipProto \n boolean checkMatch \n AclRule build \n int hashCode \n boolean equals \n Builder builder \n Builder action \n Action action \n String toString \n Builder dstIp \n Ip4Prefix dstIp \n RuleId id \n Builder dstTpPort \n short dstTpPort", "output": "void function ( IdGenerator arg0 ) { checkState ( idGenerator == null , \"srini_string\" ) ; idGenerator = checkNotNull ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the value of the notonorafter property . ", "input": " String address \n Object anyType \n String inResponseTo \n String recipient \n XMLGregorianCalendar notOnOrAfter \n Map<QName,String> otherAttributes \n XMLGregorianCalendar notBefore \n\n void setAddress \n void setAnyType \n void setNotBefore \n String getRecipient \n void removeOtherAttribute \n void setNotOnOrAfter \n void setInResponseTo \n XMLGregorianCalendar getNotBefore \n void setRecipient \n String getAddress \n void addOtherAttribute \n Map<QName,String> getOtherAttributes \n String getInResponseTo \n Object getAnyType", "output": "XMLGregorianCalendar function ( ) { return notOnOrAfter ; }"}, {"instruction": "Generate java code\nde-reference the output eventadapter service dependency . ", "input": " ServiceRegistration serviceRegistration \n Log log \n\n void activate \n void setOutputEventAdapterService \n void deactivate", "output": "void function ( OutputEventAdapterService arg0 ) { DeviceTypeManagementDataHolder . getInstance ( ) . setOutputEventAdapterService ( null ) ; }"}, {"instruction": "Generate java code\nget bounding face rectangle infrared ", "input": " KRectangle rectColor \n KRectangle rectInfrared \n PVector[] faceInfraredPoints \n boolean faceTracked \n float roll \n FaceFeatures[] facefeatures \n PVector[] faceColorPoints \n float pitch \n float yaw \n\n FaceFeatures[] getFaceFeatures \n void createFaceData \n PVector[] getFacePointsInfraredMap \n KRectangle getBoundingRectColor \n PVector[] getFacePointsColorMap \n boolean isFaceTracked", "output": "KRectangle function ( ) { return rectInfrared ; }"}, {"instruction": "Generate java code\nthe number of errored entities . ", "input": " Integer total \n Integer stopped \n Integer warned \n Integer passed \n Integer failed \n Integer errored \n Integer skipped \n\n void setTotal \n Counters withPassed \n Counters withFailed \n Integer getPassed \n void setStopped \n Counters withSkipped \n void setPassed \n Integer getStopped \n Counters withWarned \n void setWarned \n Integer getWarned \n void setSkipped \n Integer getErrored \n Counters withStopped \n int hashCode \n Integer getSkipped \n Counters withTotal \n boolean equals \n Counters clone \n Integer getTotal \n String toString \n void setFailed \n Counters withErrored \n Integer getFailed", "output": "void function ( Integer arg0 ) { this . errored = arg0 ; }"}, {"instruction": "Generate java code\ncopies all of the mappings from the specified map to this map . ", "input": " LocalContext.Reference _mapRef \n\n FastMap newLocalMap \n Set entrySet \n boolean containsKey \n Collection values \n boolean isEmpty \n void clear \n LocalMap setValueComparator \n Object putDefault \n boolean containsValue \n Object put \n Object remove \n LocalMap setKeyComparator \n int size \n Object get \n FastMap localMap \n Set keySet", "output": "void function ( Map arg0 ) { localMap ( ) . putAll ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets the value of the price property . ", "input": " XMLGregorianCalendar endDate \n BigDecimal price \n String description \n long serialVersionUID \n String type \n XMLGregorianCalendar startDate \n\n XMLGregorianCalendar getStartDate \n void setStartDate \n String getType \n XMLGregorianCalendar getEndDate \n void setDescription \n void setType \n String getDescription \n void setEndDate \n BigDecimal getPrice", "output": "void function ( BigDecimal arg0 ) { this . price = arg0 ; }"}, {"instruction": "Generate java code\ndecode the base 64 encoded string data writing it to the given output stream , whitespace characters will be ignored . ", "input": " byte[] encodingTable \n Base64Encoder encoder \n byte padding \n byte[] decodingTable \n\n byte[] encode \n int encode \n int encode \n int encode \n void initialiseDecodingTable \n int decodeLastBlock \n boolean ignore \n int nextI \n int nextI", "output": "int function ( String arg0 , OutputStream arg1 ) { return encoder . decode ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nthis method was generated by mybatis generator . this method returns the value of the database column public.questions.name _ e ", "input": " String nameF \n String nameE \n String nameS \n String nameC \n Integer deleted \n Integer id \n String nameR \n Integer type \n String title \n String nameA \n Integer order \n\n void setNameS \n void setNameR \n String getNameR \n void setTitle \n Integer getId \n String getNameS \n void setType \n void setOrder \n void setNameC \n void setNameA \n String getTitle \n Integer getDeleted \n Integer getType \n Integer getOrder \n void setId \n String getNameA \n String getNameC \n String getNameF \n void setNameF \n void setNameE \n void setDeleted", "output": "String function ( ) { return nameE ; }"}, {"instruction": "Generate java code\nreturns a doubletolongfunction returning the given value if this function throws an exception . ", "input": " PlaceHolder placeHolder \n\n long applyAsLong \n ThrowingDoubleToLongFunction orTryWith \n ThrowingDoubleToLongFunction orTryWith \n long applyAsLongThrowing \n DoubleToLongFunction fallbackTo \n DoubleToLongFunction fallbackTo \n ThrowingDoubleToLongFunction orThrow \n ThrowingDoubleToLongFunction orThrow", "output": "DoubleToLongFunction function ( long arg0 , Consumer < Exception > arg1 ) { return argument -> { try { return applyAsLongThrowing ( argument ) ; } catch ( Exception loc0 ) { if ( arg1 != null ) { arg1 . accept ( loc0 ) ; } return arg0 ; } } ; }"}, {"instruction": "Generate java code\nmake a request to the facebook graph api without any parameters . see http://developers.facebook.com/docs/api note that this method is asynchronous and the callback will be invoked in a background thread ; operations that affect the ui will need to be posted to the ui thread or an appropriate handler . this method is deprecated . see facebook and com.facebook.request for more info . ", "input": " Facebook fb \n\n void onFileNotFoundException \n void logout \n void logout \n void onComplete \n void onIOException \n void onMalformedURLException \n void onFacebookError", "output": "void function ( String arg0 , RequestListener arg1 , final Object arg2 ) { request ( arg0 , new Bundle ( ) , \"srini_string\" , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nget the keyset of map ", "input": " JexlContext jContext \n Genotype g \n VariantContext vc \n Map<JexlVCMatchExp,Boolean> jexl \n\n void addAttributesToMap \n Set<Entry<JexlVCMatchExp,Boolean>> entrySet \n boolean containsKey \n Collection<Boolean> values \n boolean isEmpty \n void evaluateExpression \n void clear \n void createContext \n Boolean put \n boolean containsValue \n Boolean remove \n int size \n Boolean get \n void putAll \n void initialize", "output": "Set < JexlVCMatchExp > function ( ) { return jexl . keySet ( ) ; }"}, {"instruction": "Generate java code\nconfigure one more simple patterns as described in patternmatchutils #simplematch to use in order to recognize custom redirect prefixes in addition to `` redirect : '' . note that simply configuring this property will not make a custom redirect prefix work . there must be a custom view that recognizes the prefix as well . ", "input": " String[] redirectPatterns \n\n boolean supportsReturnType \n void handleReturnValue \n String[] getRedirectPatterns \n boolean isRedirectViewName", "output": "void function ( String ... arg0 ) { this . redirectPatterns = arg0 ; }"}, {"instruction": "Generate java code\nthis method returns the list of all levels ", "input": " PlaceHolder placeHolder \n\n List findAllCircle \n boolean editAgent \n List findAllDepartment \n List findAllDepartment \n List findDepartment \n boolean findByLoginId \n boolean createAgent \n boolean changePassword \n List findAllAgentType \n AgentVO viewAgent \n List searchAgent \n List findAgentType \n List getPartnerDetails \n List findAllAgents \n List findLevel \n int getCount \n List findCircle", "output": "List function ( ) { List loc0 = new ArrayList ( ) ; AgentUtilityDAO loc1 = new AgentUtilityDAO ( ) ; loc0 = loc1 . findAllLevel ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\ncalculate a hash using all bytes from the input argument , and a provided seed value . ", "input": " int JENKINS_HASH \n int INVALID_HASH \n int MURMUR_HASH \n\n int getHashType \n Hash getInstance \n Hash getInstance \n int parseHashType", "output": "int function ( byte [ ] arg0 , int arg1 ) { return hash ( arg0 , arg0 . length , arg1 ) ; }"}, {"instruction": "Generate java code\nreturn the offset attribute of the type from the schema ", "input": " String semanticType \n int offsetAttribute \n String name \n String description \n Presence presence \n\n int encodedLength \n String semanticType \n String name \n String description \n Presence presence \n boolean isVariableLength", "output": "int function ( ) { return offsetAttribute ; }"}, {"instruction": "Generate java code\nhas the iterator not reached the end character yet ? ", "input": " boolean negated \n char current \n String iToString \n char start \n CharRange range \n char end \n boolean hasNext \n long serialVersionUID \n\n Character next \n CharRange isNotIn \n char getStart \n void prepareNext \n boolean isNegated \n CharRange is \n char getEnd \n void remove \n boolean contains \n boolean contains \n Iterator<Character> iterator \n CharRange isNot \n int hashCode \n boolean equals \n String toString \n CharRange isIn", "output": "boolean function ( ) { return hasNext ; }"}, {"instruction": "Generate java code\nmethod declaration ", "input": " String scriptHelp[] \n String testDataSql[] \n String insertHelp[] \n String createTableHelp[] \n String dropIndexHelp[] \n String testHelp[] \n String deleteHelp[] \n String selectHelp[] \n Random rRandom \n String shutdownHelp[] \n String checkpointHelp[] \n String updateHelp[] \n String setHelp[] \n String createIndexHelp[] \n String dropTableHelp[] \n\n String random \n int random \n String createTestData \n String readFile \n void createTestTables \n long testStatement", "output": "void function ( String arg0 , String arg1 ) { try { FileWriter loc0 = new FileWriter ( arg0 ) ; loc0 . loc0 ( arg1 . toCharArray ( ) ) ; loc0 . close ( ) ; } catch ( IOException loc0 ) { loc0 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\ndecode an entry id value from its database representation . note that this method will throw an arrayindexoutofboundsexception if the bytes array length is less than 8 . ", "input": " byte FORMAT_VERSION \n byte TAG_DATABASE_ENTRY \n DebugTracer TRACER \n byte TAG_DIRECTORY_SERVER_ENTRY \n\n byte[] entryIDToDatabase \n byte[] entryIDUndefinedSizeToDatabase \n byte[] dnToDNKey \n void formatRDNKey \n byte[] entryIDListToDatabase \n DN dnFromDNKey \n int[] intArrayFromDatabaseBytes \n int findDNKeyParent \n long entryIDUndefinedSizeFromDatabase \n long[] entryIDListFromDatabase", "output": "long function ( byte [ ] arg0 ) { long loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 8 ; loc1 ++ ) { loc0 <<= 8 ; loc0 |= ( arg0 [ loc1 ] & 0xFF ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturn a sorted vector of the stored keys . ", "input": " VectorAdapter values \n boolean ignoreCase \n VectorAdapter keys \n\n void add \n void add \n void add \n void add \n int compare \n Enumeration sortedValues \n VectorAdapter sortedVector \n int size \n Enumeration keys \n Object get \n void remove", "output": "VectorAdapter function ( ) { return ( keys ) ; }"}, {"instruction": "Generate java code\ntest this pair for equality with another object . if the object to be tested is not a pair or is null , then this method returns false . two pairs are considered equal if and only if both the names and values are equal . ", "input": " V value \n K key \n\n K getKey \n V getValue \n int hashCode \n String toString", "output": "boolean function ( Object arg0 ) { if ( this == arg0 ) return true ; if ( arg0 instanceof Pair ) { Pair loc0 = ( Pair ) arg0 ; if ( key != null ? ! key . equals ( loc0 . key ) : loc0 . key != null ) return false ; if ( value != null ? ! value . equals ( loc0 . value ) : loc0 . value != null ) return false ; return true ; } return false ; }"}, {"instruction": "Generate java code\ninvalidates the authentication state by resetting its parameters . ", "input": " Credentials credentials \n AuthScheme authScheme \n AuthScope authScope \n\n AuthScheme getAuthScheme \n AuthScope getAuthScope \n boolean isValid \n void setAuthScheme \n Credentials getCredentials \n void setAuthScope \n String toString \n void setCredentials", "output": "void function ( ) { this . authScheme = null ; this . authScope = null ; this . credentials = null ; }"}, {"instruction": "Generate java code\nreturns the real path of the given uri . if the given uri is a content : / / uri , the real path is retrieved from the media store . ", "input": " String _DATA \n String LOG_TAG \n\n String stripFileProtocol \n String getMimeType \n String getMimeTypeForExtension \n InputStream getInputStreamFromUriString", "output": "String function ( Uri arg0 , CordovaInterface arg1 ) { return FileHelper . getRealPath ( arg0 . toString ( ) , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns a result that indicates that the component will not print at the current position in the generated report , but requires an overflow so that it can print on a new column/page . ", "input": " boolean overflow \n int stretchHeight \n FillPrepareResult NO_PRINT_NO_OVERFLOW \n boolean toPrint \n FillPrepareResult PRINT_NO_STRETCH \n\n boolean isToPrint \n boolean willOverflow \n FillPrepareResult printStretch \n int getStretchHeight", "output": "FillPrepareResult function ( int arg0 ) { return new FillPrepareResult ( false , arg0 , true ) ; }"}, {"instruction": "Generate java code\ncopies the data into a new array of at least capacity size . ", "input": " char[] c \n int length \n\n void shrink \n void clear \n int length \n String toString \n char[] getCharacters \n void append \n void append \n void append \n void append \n void append \n char charAt \n int capacity \n void trimTrailingWhitespace", "output": "void function ( final int arg0 ) { if ( c . length >= arg0 ) { return ; } int loc0 = ( ( arg0 * 3 ) >> 1 ) + 1 ; char [ ] loc1 = new char [ loc0 ] ; System . arraycopy ( c , 0 , loc1 , 0 , length ) ; c = loc1 ; }"}, {"instruction": "Generate java code\ngets the value of the act property . ", "input": " String tpl \n Boolean can \n String ptd \n String act \n String wta \n String wtd \n String planAct \n Short rdelay \n String pta \n\n boolean isSetWtd \n boolean isSetWta \n void unsetRdelay \n boolean isSetPtd \n boolean isSetPlanAct \n boolean isSetPta \n boolean isSetRdelay \n void setCan \n void setAct \n boolean getCan \n void setRdelay \n short getRdelay \n boolean isSetTpl \n void setPta \n void setPtd \n void setWta \n String getPtd \n String getWta \n void setWtd \n void setPlanAct \n void setTpl \n String getPlanAct \n String getPta \n String getTpl \n boolean isSetAct \n boolean isSetCan \n String getWtd \n void unsetCan", "output": "String function ( ) { if ( act == null ) { return \"srini_string\" ; } else { return act ; } }"}, {"instruction": "Generate java code\nquick check for login ", "input": " Editor editor \n String PREF_NAME \n String KEY_ID \n String KEY_LASTLOGIN \n String KEY_NAME \n String KEY_EMAIL \n String KEY_PASSWORD \n String KEY_REGSITERAT \n int PRIVATE_MODE \n Context _context \n SharedPreferences pref \n String IS_LOGIN \n String KEY_USERNAME \n\n User getUserDetails \n void logoutUser \n void createLoginSession \n boolean checkLogin", "output": "boolean function ( ) { return pref . getBoolean ( IS_LOGIN , false ) ; }"}, {"instruction": "Generate java code\nget this node 's width , as defined in the style . ", "input": " CSSNodeDEPRECATED mParent \n CSSStyle style \n CSSNodeDEPRECATED nextChild \n ArrayList<CSSNodeDEPRECATED> mChildren \n int lineIndex \n Object mData \n boolean mIsTextNode \n MeasureFunction mMeasureFunction \n CachedCSSLayout lastLayout \n LayoutState mLayoutState \n CSSLayout layout \n\n float getBorder \n CSSPositionType getPositionType \n void markHasNewLayout \n float getStyleMaxHeight \n void markLayoutSeen \n float getMargin \n float getStyleMinWidth \n void toStringWithIndentation \n void setStyleMaxWidth \n void setPosition \n CSSOverflow getOverflow \n float getFlexBasis \n void setStyleMaxHeight \n void setStyleMinHeight \n int indexOf \n boolean isMeasureDefined \n void setWrap \n void setOverflow \n float getStyleHeight \n boolean valuesEqual \n void setFlexGrow \n float getLayoutHeight \n int getChildCount \n void setFlex \n long measure \n void addChildAt \n boolean hasNewLayout \n void setAlignItems \n void reset \n void setAlignSelf \n CSSAlign getAlignContent \n void setJustifyContent \n void setFlexShrink \n CSSJustify getJustifyContent \n float getLayoutWidth \n void setPositionType \n CSSAlign getAlignItems \n CSSDirection getStyleDirection \n void setFlexDirection \n boolean isDirty \n void calculateLayout \n float getStyleMaxWidth \n void setIsTextNode \n void setDirection \n void setStyleMinWidth \n void setStyleWidth \n float getStyleMinHeight \n Object getData \n void dirty \n void setPadding \n CSSNodeDEPRECATED getParent \n void setData \n float getPadding \n void setMargin \n float getLayoutY \n void setAlignContent \n float getLayoutX \n float getFlexGrow \n void setFlexBasis \n float getFlexShrink \n void setMeasureFunction \n CSSFlexDirection getFlexDirection \n CSSDirection getLayoutDirection \n CSSNodeDEPRECATED getChildAt \n float getPosition \n void setBorder \n CSSNodeDEPRECATED removeChildAt \n String toString \n CSSAlign getAlignSelf \n boolean isTextNode \n void setStyleHeight", "output": "float function ( ) { return style . dimensions [ DIMENSION_WIDTH ] ; }"}, {"instruction": "Generate java code\nget password ", "input": " byte[] _byte \n String password \n BigDecimal number \n Float _float \n Integer integer \n Double _double \n String string \n OffsetDateTime dateTime \n byte[] binary \n Integer int32 \n String uuid \n Long int64 \n LocalDate date \n\n FormatTest date \n FormatTest dateTime \n Integer getInt32 \n void setBinary \n void setPassword \n void setByte \n byte[] getByte \n FormatTest string \n void setInteger \n Double getDouble \n Integer getInteger \n FormatTest integer \n Float getFloat \n void setInt64 \n FormatTest uuid \n FormatTest _byte \n BigDecimal getNumber \n void setDouble \n FormatTest number \n FormatTest password \n FormatTest int64 \n int hashCode \n FormatTest _double \n LocalDate getDate \n String toIndentedString \n void setFloat \n OffsetDateTime getDateTime \n void setInt32 \n String getString \n void setUuid \n Long getInt64 \n void setNumber \n void setDateTime \n FormatTest _float \n void setString \n FormatTest int32 \n FormatTest binary \n String getUuid \n boolean equals \n void setDate \n byte[] getBinary \n String toString", "output": "String function ( ) { return password ; }"}, {"instruction": "Generate java code\nshortcut to the local currency ", "input": " boolean tor \n Map<String,Object> other \n LanguageConfiguration language \n LoggingConfiguration logging \n BitcoinConfiguration bitcoin \n WalletConfiguration wallet \n String configurationVersion \n boolean licenceAccepted \n SoundConfiguration sound \n AppearanceConfiguration appearance \n\n String getVersion \n void setLicenceAccepted \n LanguageConfiguration getLanguage \n AppearanceConfiguration getAppearance \n void set \n void setBitcoin \n String getConfigurationVersion \n BitcoinConfiguration getBitcoin \n boolean isLicenceAccepted \n void setConfigurationVersion \n Map<String,Object> any \n Configuration deepCopy \n boolean isTor \n void setTor \n void setLogging \n void setSound \n void setAppearance \n Locale getLocale \n LoggingConfiguration getLogging \n void setWallet \n WalletConfiguration getWallet \n void setLanguage \n SoundConfiguration getSound", "output": "Currency function ( ) { return Currency . getInstance ( getBitcoin ( ) . getLocalCurrencyCode ( ) ) ; }"}, {"instruction": "Generate java code\nclears the event log . ", "input": " List<String> eventBuffer \n int MAX_BUFFER_SIZE \n\n void addEvent \n String getDebugData \n String getDebugData \n String getDebugData \n String getData", "output": "void function ( ) { this . eventBuffer . clear ( ) ; }"}, {"instruction": "Generate java code\nreturn the fully-qualified name of the command line argument . this is used as a command-line optional argument , as in : - prefix.name = value . prefix is typically a java package and class like `` com.twitter.myapp.myclass '' . the difference between a canonical name and a regular name is that it is in some circumstances for two names to collide ; the canonical name , then , disambiguates . ", "input": " Annotation annotation \n String help \n boolean argFile \n ImmutableSet<String> HELP_ARGS \n Class<? extends Parser<? extends T>> parser \n List<Annotation> verifierAnnotations \n Verifier<? super T> verifier \n Arg<T> arg \n String name \n TypeToken<T> type \n String canonicalName \n\n String getName \n boolean argFile \n Arg<?> getArgForField \n Arg<T> getArg \n ImmutableList<String> collectConstraints \n TypeToken<T> getType \n int hashCode \n Iterable<ValueVerifier<T>> getVerifiers \n String getHelp \n void setValue \n boolean equals \n Parser<? extends T> getParser \n void verify \n void verify \n String toString", "output": "String function ( ) { return canonicalName ; }"}, {"instruction": "Generate java code\nsets age of animal . ", "input": " int xCoordinate \n Color color \n int yCoordinate \n int age \n\n int getAge \n void setColor \n void performAction \n void setCoordinates \n void setCoordinates \n int getYCoordinate \n Color getColor \n int getXCoordinate", "output": "void function ( int arg0 ) { this . age = arg0 ; }"}, {"instruction": "Generate java code\nthe destination port that the client should connect to . -1 is returned if not yet known ", "input": " InetAddress sourceNetworkAddress \n String destinationAddress \n byte sourceNetworkMaskBits \n int destinationPort \n\n int getSourceNetworkMaskBits \n InetAddress getSourceNetworkAddress \n void updatePortIfUnknown \n String getDestinationAddress", "output": "int function ( ) { return destinationPort ; }"}, {"instruction": "Generate java code\nreturns the number of settings that have values assigned . ", "input": " int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS \n int DOWNLOAD_BANDWIDTH \n int set \n int DEFAULT_INITIAL_WINDOW_SIZE \n int UPLOAD_BANDWIDTH \n int CLIENT_CERTIFICATE_VECTOR_SIZE \n int[] values \n int PERSISTED \n int FLOW_CONTROL_OPTIONS \n int COUNT \n int MAX_CONCURRENT_STREAMS \n int persistValue \n int CURRENT_CWND \n int DOWNLOAD_RETRANS_RATE \n int ROUND_TRIP_TIME \n int persisted \n int PERSIST_VALUE \n int INITIAL_WINDOW_SIZE \n int FLOW_CONTROL_OPTIONS_DISABLED \n\n int getDownloadRetransRate \n void set \n boolean isSet \n int getUploadBandwidth \n int flags \n int getCurrentCwnd \n boolean isPersisted \n int getInitialWindowSize \n boolean persistValue \n int getDownloadBandwidth \n int get \n void merge \n boolean isFlowControlDisabled \n int getMaxConcurrentStreams \n int getRoundTripTime \n int getClientCertificateVectorSize", "output": "int function ( ) { return Integer . bitCount ( set ) ; }"}, {"instruction": "Generate java code\nget the requestid value . ", "input": " String dataServiceId \n String clientRequestId \n String requestId \n String eTag \n DateTimeRfc1123 lastModified \n\n JobEnableHeaders withDataServiceId \n JobEnableHeaders withLastModified \n String dataServiceId \n String clientRequestId \n JobEnableHeaders withClientRequestId \n String eTag \n DateTime lastModified \n JobEnableHeaders withETag \n JobEnableHeaders withRequestId", "output": "String function ( ) { return this . requestId ; }"}, {"instruction": "Generate java code\nswitch to previous page . will stay on first page if already on first page . ", "input": " Date refreshDate \n int page \n SortDefinition sortUsed \n int DEFAULT_MAX_LINKED_PAGES \n List<E> source \n SortDefinition sort \n int maxLinkedPages \n boolean newPageSet \n int DEFAULT_PAGE_SIZE \n int pageSize \n\n int getNrOfElements \n void setSource \n SortDefinition copySortDefinition \n void doSort \n int getPageCount \n int getPage \n void nextPage \n void setMaxLinkedPages \n int getFirstLinkedPage \n int getLastLinkedPage \n Date getRefreshDate \n void setSort \n SortDefinition getSort \n int getPageSize \n int getLastElementOnPage \n List<E> getPageList \n int getFirstElementOnPage \n List<E> getSource \n int getMaxLinkedPages \n boolean isLastPage \n void resort \n boolean isFirstPage \n void setPageSize \n void setPage", "output": "void function ( ) { if ( ! isFirstPage ( ) ) { this . page -- ; } }"}, {"instruction": "Generate java code\nconvenience method for asserting that this session has not been @linkplain #invalidate invalidated . ", "input": " long lastAccessedTime \n boolean invalid \n int nextId \n int maxInactiveInterval \n Map<String,Object> attributes \n boolean isNew \n ServletContext servletContext \n String id \n String SESSION_COOKIE_NAME \n long creationTime \n\n void access \n ServletContext getServletContext \n void clearAttributes \n int getMaxInactiveInterval \n String getId \n void invalidate \n boolean isNew \n boolean isInvalid \n void setMaxInactiveInterval \n Object getValue \n long getLastAccessedTime \n void setAttribute \n Serializable serializeState \n Object getAttribute \n void removeValue \n Enumeration<String> getAttributeNames \n String changeSessionId \n long getCreationTime \n void putValue \n void removeAttribute \n void setNew \n void deserializeState \n javax.servlet.http.HttpSessionContext getSessionContext \n String[] getValueNames", "output": "void function ( ) { Assert . state ( ! isInvalid ( ) , \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns the id route of this race . ", "input": " Race _race \n\n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n boolean isEscapedModel \n Race getWrappedRace \n boolean isCachedModel \n com.liferay.portlet.expando.model.ExpandoBridge getExpandoBridge \n int compareTo \n Race getWrappedModel \n void setModelAttributes \n long getIdUser \n Map<String,Object> getModelAttributes \n com.liferay.portal.model.CacheModel<es.eina.tfg.model.Race> toCacheModel \n int hashCode \n void setPrimaryKey \n es.eina.tfg.model.Race toUnescapedModel \n void persist \n void setNew \n void setIdRoute \n void resetOriginalValues \n long getIdRace \n void setIdUser \n boolean isNew \n void setType \n java.io.Serializable getPrimaryKeyObj \n Class<?> getModelClass \n void setIdRace \n long getPrimaryKey \n es.eina.tfg.model.Race toEscapedModel \n java.lang.String getType \n java.lang.String toXmlString \n boolean equals \n void setPrimaryKeyObj \n java.lang.Object clone \n void setCachedModel \n java.lang.String toString \n String getModelClassName", "output": "long function ( ) { return _race . getIdRoute ( ) ; }"}, {"instruction": "Generate java code\nresets the input for this content source , so that the test would behave as if it was just started , input-wise . note : the default implementation resets the number of bytes and items generated since the last reset , so it 's important to call super.resetinputs in case you override this method . ", "input": " long bytesCount \n long lastPrintedNumUniqueBytes \n int lastPrintedNumUniqueTexts \n int printNum \n boolean forever \n String encoding \n Config config \n int logStep \n long totalBytesCount \n int itemCount \n int totalItemCount \n boolean verbose \n\n void addItem \n boolean shouldLog \n void printStatistics \n int getItemsCount \n int getTotalItemsCount \n void collectFiles \n void addBytes \n long getTotalBytesCount \n void close \n Config getConfig \n long getBytesCount \n void setConfig", "output": "void function ( ) { bytesCount = 0 ; itemCount = 0 ; }"}, {"instruction": "Generate java code\ninterrupts and stops all threads . ", "input": " int PORT \n\n void serverLoop \n void pruneThreads \n Thread startClientThread \n void main \n void close", "output": "void function ( LinkedList < Thread > arg0 ) { for ( Thread loc0 : arg0 ) { loc0 . interrupt ( ) ; try { loc0 . join ( ) ; } catch ( InterruptedException loc1 ) { System . err . println ( \"srini_string\" ) ; return ; } } }"}, {"instruction": "Generate java code\nreturns the recommended minimum error correction level as described in annex e of iso/iec 15438:2001 e . ", "input": " int[][] EC_COEFFICIENTS \n\n int getErrorCorrectionCodewordCount \n String generateErrorCorrection", "output": "int function ( int arg0 ) { if ( arg0 <= 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 <= 40 ) { return 2 ; } if ( arg0 <= 160 ) { return 3 ; } if ( arg0 <= 320 ) { return 4 ; } if ( arg0 <= 863 ) { return 5 ; } throw new WriterException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets number of last item ", "input": " int count \n int first \n\n boolean contains \n int getFirst \n int getCount", "output": "int function ( ) { return getFirst ( ) + getCount ( ) - 1 ; }"}, {"instruction": "Generate java code\nreturns an unmodifiable set of this dispatcher 's handlers . thisis provided for access by subclasses . ", "input": " Log logger \n MessageHandler theOneHandler \n int maxSubscribers \n OrderedAwareCopyOnWriteArraySet<MessageHandler> handlers \n\n boolean addHandler \n boolean tryOptimizedDispatch \n void setMaxSubscribers \n String toString \n boolean removeHandler \n int getHandlerCount \n RuntimeException wrapExceptionIfNecessary", "output": "Set < MessageHandler > function ( ) { return this . handlers . asUnmodifiableSet ( ) ; }"}, {"instruction": "Generate java code\nreturns the correct client socketchannel class based on iomode . ", "input": " PlaceHolder placeHolder \n\n PooledByteBufAllocator createPooledByteBufAllocator \n ByteToMessageDecoder createFrameDecoder \n EventLoopGroup createEventLoop \n ThreadFactory createThreadFactory \n String getRemoteAddress \n int getPrivateStaticField \n Class<? extends ServerChannel> getServerChannelClass", "output": "Class < ? extends Channel > function ( IOMode arg0 ) { switch ( arg0 ) { case NIO : return NioSocketChannel . class ; case EPOLL : return EpollSocketChannel . class ; default : throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }"}, {"instruction": "Generate java code\nsets mem limit . ", "input": " double memPerNode \n String IGNITE_HOSTNAME_CONSTRAINT \n double DEFAULT_CPU_PER_NODE \n String clusterName \n Logger log \n double DEFAULT_MINIMUM_MEM_OVERHEAD_PER_NODE \n double nodeCnt \n String IGNITE_CONFIG_XML \n double DEFAULT_MEM_PER_NODE \n String IGNITE_RUN_CPU_PER_NODE \n String IGNITE_LOCAL_WORK_DIR \n String EMPTY_STRING \n String userLibs \n String DEFAULT_IGNITE_RELEASES_DIR \n String ignitePath \n String igniteLocalWorkDir \n Pattern hostnameConstraint \n String igniteCfg \n double cpuPerNode \n String igniteUrl \n String LICENCE_PATH \n String IGNITE_NODE_COUNT \n String licencePath \n String DEFAULT_IGNITE_WORK_DIR \n String IGNITE_WORKING_DIR \n String IGNITE_MEMORY_PER_NODE \n String IGNITE_RELEASES_DIR \n double memOverHeadPerNode \n String igniteWorkDir \n String IGNITE_MEMORY_OVERHEAD_PER_NODE \n String IGNITE_JVM_OPTS \n String IGNITE_USERS_LIBS \n String IGNITE_PATH \n String DEFAULT_IGNITE_LOCAL_WORK_DIR \n String IGNITE_URL \n String IGNITE_CLUSTER_NAME \n double DEFAULT_IGNITE_NODE_COUNT \n String jvmOpts \n String igniteReleasesDir \n String DEFAULT_CLUSTER_NAME \n\n ClusterProperties fromProperties \n String userLibs \n double instances \n void instances \n String igniteWorkDir \n double memoryOverHeadPerNode \n void memoryOverHeadPerNode \n String igniteReleasesDir \n double cpusPerNode \n void cpusPerNode \n String igniteCfg \n String licencePath \n Map<String,String> toEnvs \n String toEnvVal \n String ignitePath \n String igniteUrl \n void hostnameConstraint \n Pattern hostnameConstraint \n String clusterName \n String jvmOpts \n double getDoubleProperty \n ClusterProperties from \n ClusterProperties from \n String getStringProperty \n String igniteLocalWorkDir \n double totalMemoryPerNode", "output": "void function ( double arg0 ) { this . memPerNode = arg0 ; }"}, {"instruction": "Generate java code\nappends compilation problems to summary message if object is an array of compilationproblem separated with backspaces ", "input": " String DEFAULT_SEPARATOR \n\n StringBuilder appendProblems \n String fillSummary", "output": "String function ( Object arg0 , String arg1 ) { return getProblemMessage ( arg0 , arg1 , DEFAULT_SEPARATOR ) ; }"}, {"instruction": "Generate java code\nreturns true if the given state is currently active otherwise false . ", "input": " boolean event1 \n SCInterfaceImpl sCInterface \n int nextStateIndex \n State[] stateVector \n\n void init \n SCInterface getSCInterface \n void exitAction \n void raiseEvent1 \n void raiseEvent1 \n void runCycle \n void reactMain_region_A \n void exit \n void reactMain_region__final_0 \n void reactMain_region_B \n void clearEvents \n void clearEvents \n void enter \n void clearOutEvents \n void entryAction", "output": "boolean function ( State arg0 ) { switch ( arg0 ) { case main_region_A : return stateVector [ 0 ] == State . main_region_A ; case main_region_B : return stateVector [ 0 ] == State . main_region_B ; case main_region__final_ : return stateVector [ 0 ] == State . main_region__final_ ; default : return false ; } }"}, {"instruction": "Generate java code\nsets the value of the filterstatement property . ", "input": " Statement filterStatement \n\n Statement getFilterStatement", "output": "void function ( Statement arg0 ) { this . filterStatement = arg0 ; }"}, {"instruction": "Generate java code\ngets name of the class implementing midlet interface for this midlet . ", "input": " Object midletStartLock \n AutoSuiteDescriptorImpl suite \n boolean isStarted \n MIDletInfo midletInfo \n\n void midletDestroyed \n AutoMIDlet start \n AutoSuiteDescriptor getSuiteDescriptor \n String getMIDletName", "output": "String function ( ) { suite . guaranteeSuiteValid ( \"srini_string\" ) ; return midletInfo . classname ; }"}, {"instruction": "Generate java code\nreturns whether the tileset is derived from a tileset image . ", "input": " int tileMargin \n TileCutter tileCutter \n List<Tile> tiles \n int tilesPerRow \n int tileSpacing \n String externalSource \n Image tileSetImage \n Rectangle tileDimensions \n Color transparentColor \n File tilebmpFile \n String name \n long tilebmpFileLastModified \n String base \n\n void setName \n void setSource \n int getTileWidth \n String getName \n String getTilebmpFile \n void checkUpdate \n void setTransparentColor \n void setBaseDir \n Iterator<Tile> iterator \n Tile getFirstTile \n Color getTransparentColor \n void refreshImportedTileBitmap \n void refreshImportedTileBitmap \n int getTileHeight \n Tile getTile \n int addTile \n void removeTile \n int getMaxTileId \n int getTileSpacing \n int getTilesPerRow \n int getTileMargin \n void setTilesetImageFilename \n void importTileBitmap \n void importTileBitmap \n int size \n void addNewTile \n String getSource \n String toString \n String getBaseDir", "output": "boolean function ( ) { return tileSetImage != null ; }"}, {"instruction": "Generate java code\nan java.util.concurrent.executor that executes tasks containedin parallel . ", "input": " Executor immediate \n ThreadLocal<Integer> executionDepth \n ExecutorService background \n BoltsExecutors INSTANCE \n int MAX_DEPTH \n\n boolean isAndroidRuntime \n int incrementDepth \n Executor immediate \n void execute \n int decrementDepth", "output": "ExecutorService function ( ) { return INSTANCE . background ; }"}, {"instruction": "Generate java code\nsetrequirements . ", "input": " Card card \n SpellAbility ability \n SpellAbility_Requirements req \n boolean bDoneTarget \n boolean bCancel \n Target target \n\n Target getTgt \n boolean isCanceled \n boolean doesTarget \n SpellAbility getAbility \n boolean matchSpellAbility \n void setDoneTarget \n void chooseCardFromStack \n void chooseCardFromList \n Input input_targetSpecific \n boolean matchesValid \n void resetTargets \n void chooseValidInput \n void setCancel \n Card getCard \n boolean chooseTargets \n ArrayList<SpellAbility> getTargetableOnStack", "output": "void function ( SpellAbility_Requirements arg0 ) { req = arg0 ; }"}, {"instruction": "Generate java code\nsets this field 's offset in the object . ", "input": " int offset \n boolean unshared \n boolean isDeserialized \n String name \n String typeString \n Object type \n\n String getName \n void resolve \n char typeCodeOf \n int getOffset \n Class<?> getTypeInternal \n int compareTo \n boolean writeField \n void setUnshared \n String getTypeString \n Class<?> getType \n boolean defaultResolve \n String toString \n boolean isUnshared \n boolean isPrimitive \n char getTypeCode", "output": "void function ( int arg0 ) { this . offset = arg0 ; }"}, {"instruction": "Generate java code\nreturns the array of strings . ", "input": " String META_BLOGS_CLEANUP_PERIOD \n String META_DISCOVERERS_LIST \n String DEPLOY_PATH \n String META_MIN_BLOGS_IN_DATABASE \n String OPML_EXPERTS_URL \n String META_TECHNORATI_DISCOVERER_KEY \n String META_UPDATE_INCOMPLETED_PERIOD \n String META_UPDATE_INCOMPLETED_TASK_PERIOD \n String META_BLOG_LIFE_SPAN \n String META_UPDATE_SCHEDULED_TASK_PERIOD \n Logger LOG \n String DEPLOY_URL \n Properties props \n String REPORTING_URL \n String OPML_STARTING_POINTS_URL \n String META_IGNORE \n String META_UPDATE_SCHEDULED_PERIOD \n String BASE_FORUM_URL \n String META_DISCOVERER_PREFIX \n\n long getLong \n String get \n int getInteger \n List<String> getKeys", "output": "String [ ] function ( String arg0 ) { List < String > loc0 = getKeys ( arg0 ) ; String [ ] loc1 = new String [ loc0 . size ( ) ] ; int loc2 = 0 ; for ( String loc3 : loc0 ) loc1 [ loc2 ++ ] = get ( loc3 , null ) ; return loc1 ; }"}, {"instruction": "Generate java code\ncreates a sql insert function . ", "input": " Supplier<Result<SQLiteDatabase>> databaseSupplier \n Function<Cursor,T> cursorToItem \n Merger<SQLiteDatabase,R,Result<T>> databaseWithSqlArgument \n\n Function<SqlRequest,Result<List<T>>> databaseQueryFunction \n Function<SqlDeleteRequest,Result<Integer>> databaseDeleteFunction \n Result<T> apply \n Result<Long> merge \n Result<Integer> merge \n Result<Integer> merge \n Result<List<T>> merge \n Function<SqlUpdateRequest,Result<Integer>> databaseUpdateFunction", "output": "Function < SqlInsertRequest , Result < Long >> function ( @ NonNull final Supplier < Result < SQLiteDatabase >> arg0 ) { return new DatabaseFunction < > ( arg0 , new DatabaseInsertMerger ( ) ) ; }"}, {"instruction": "Generate java code\nsets the result value for this fileidresult . ", "input": " int[] result \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n com.omniture.www.Status status \n org.apache.axis.description.TypeDesc typeDesc \n\n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n int hashCode \n int[] getResult \n boolean equals \n com.omniture.www.Status getStatus \n void setStatus", "output": "void function ( int [ ] arg0 ) { this . result = arg0 ; }"}, {"instruction": "Generate java code\nsets the password for the user name . ", "input": " String description \n String dataSourceName \n String password \n String serverName \n int loginTimeout \n String user \n String networkProtocol \n PrintWriter logWriter \n Properties connectionProps \n String url \n\n void setLogWriter \n void setLoginTimeout \n void setDatabase \n String getUser \n void setProperties \n java.util.logging.Logger getParentLogger \n String getDatabaseName \n String getNetworkProtocol \n String getServerName \n String getDescription \n void setUrl \n String getDataSourceName \n String getUrl \n String getDatabase \n void setDatabaseName \n int getLoginTimeout \n void setUser \n PrintWriter getLogWriter", "output": "void function ( String arg0 ) { this . password = arg0 ; connectionProps . setProperty ( \"srini_string\" , arg0 ) ; }"}, {"instruction": "Generate java code\nremoves all points from the quadtree ", "input": " List<PointQuadTree<T>> mChildren \n int MAX_ELEMENTS \n int MAX_DEPTH \n Bounds mBounds \n int mDepth \n List<T> mItems \n\n void add \n Point getPoint \n Collection<T> search \n void search \n void split \n void insert \n boolean remove \n boolean remove", "output": "void function ( ) { mChildren = null ; if ( mItems != null ) { mItems . clear ( ) ; } }"}, {"instruction": "Generate java code\nchecks if the device should be treated as tv . note that this should be invoked before #istablet context to get the correct resultsince they are not orthogonal . ", "input": " Boolean sIsTablet \n Boolean sIsTv \n int MINIMUM_TABLET_WIDTH_DP \n\n boolean isTablet \n void addDeviceSpecificUserAgentSwitch", "output": "boolean function ( Context arg0 ) { if ( sIsTv == null ) { PackageManager loc0 = arg0 . getPackageManager ( ) ; if ( loc0 != null ) { sIsTv = loc0 . hasSystemFeature ( PackageManager . FEATURE_TELEVISION ) ; return sIsTv ; } sIsTv = false ; } return sIsTv ; }"}, {"instruction": "Generate java code\nno spans will be added if the triangle does not overlap the heightfield grid . ", "input": " PlaceHolder placeHolder \n\n int[] dividePoly \n boolean overlapBounds \n void addSpan \n void rasterizeTriangles \n void rasterizeTriangles \n void rasterizeTri", "output": "void function ( Context arg0 , float [ ] arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Heightfield arg6 , int arg7 ) { arg0 . startTimer ( \"srini_string\" ) ; float loc0 = 1.0f / arg6 . cs ; float loc1 = 1.0f / arg6 . ch ; rasterizeTri ( arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , arg6 . bmin , arg6 . bmax , arg6 . cs , loc0 , loc1 , arg7 ) ; arg0 . stopTimer ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nasks current provider to ignore all data which dataprovider #getsortingkey sorting keys are less than the given value . ", "input": " DataProvider<? extends Comparable<?>,?>[] myProviders \n\n boolean next \n int compare \n boolean hasData \n void sort \n Pair<K,V> getData \n int getSortingKey", "output": "void function ( int arg0 ) { for ( int loc0 = 0 ; loc0 < myProviders . length ; loc0 ++ ) { DataProvider < ? extends Comparable < ? > , ? > loc1 = myProviders [ loc0 ] ; if ( loc1 == null ) { continue ; } loc1 . advance ( arg0 ) ; if ( loc1 . getData ( ) == null ) { myProviders [ loc0 ] = null ; } } sort ( ) ; }"}, {"instruction": "Generate java code\ncalculates all sun rise and sets at the specified coordinates . ", "input": " double J2 \n double C2 \n double E \n double JD_ONE_MINUTE_FRACTION \n double MINUTES_PER_DAY \n double J1 \n int CURVE_TIME_INTERVAL \n double H0 \n double J2000 \n double C3 \n double TH1 \n double H2 \n double C1 \n double H3 \n double M0 \n double H1 \n double M1 \n double RAD2DEG \n double P \n double SUN_ANGLE \n double DEG2RAD \n double J0 \n double SC \n double TH0 \n double SUN_DIAMETER \n\n void setPositionalInfo \n double getSiderealTime \n double getApproxSolarTransit \n double getSunriseJulianDate \n double getAzimuth \n double getSunsetJulianDate \n double getElevation \n boolean isSunUpAllDay \n double getEclipticLongitude \n double getSolarMeanAnomaly \n double getEquationOfCenter \n double getJulianCycle \n double getRightAscension \n Calendar addDays \n void setRadiationInfo \n double getSolarTransit \n double getSunDeclination \n double getHourAngle", "output": "Sun function ( Calendar arg0 , double arg1 , double arg2 , Integer arg3 ) { return getSunInfo ( arg0 , arg1 , arg2 , arg3 , false ) ; }"}, {"instruction": "Generate java code\ngets the value of the category property . ", "input": " Boolean _default \n String country \n String address3 \n String address2 \n String address1 \n String telephone \n String language \n String name \n String address6 \n String eMailAddr \n String address5 \n String postCode \n String address4 \n String category \n String fax \n\n void setName \n String getAddress4 \n String getAddress5 \n void setCountry \n String getAddress2 \n String getName \n String getAddress3 \n String getCountry \n String getAddress1 \n void setPostCode \n String getAddress6 \n void setAddress1 \n String getPostCode \n String getTelephone \n void setCategory \n void setFax \n String getLanguage \n void setAddress6 \n void setAddress4 \n void setDefault \n void setAddress5 \n void setTelephone \n void setAddress2 \n void setAddress3 \n String getFax \n Boolean isDefault \n String getEMailAddr \n void setEMailAddr \n void setLanguage", "output": "String function ( ) { return category ; }"}, {"instruction": "Generate java code\nrefresh the page ", "input": " Logger log \n\n boolean isAlert \n void closeBrowser \n void simpleWaitMillSec \n void simpleWait \n WebDriver createBrowser \n void verifyStartPage \n int getLatency \n T createPage \n T createPage \n void goToURL \n void windowSwitch \n void acceptAlert \n void windowClose \n void waitForPageLoaded", "output": "void function ( ) { WebDriver loc0 = DriverManager . getDriver ( ) ; loc0 . navigate ( ) . refresh ( ) ; log . trace ( \"srini_string\" ) ; waitForPageLoaded ( ) ; }"}, {"instruction": "Generate java code\nreturns the instruction of a view graph that starts at a given address . since addresses do not uniquely identify instructions it is possible that there is more than one instruction with the given address in the graph . in case of multiple instructions that start at the given address it is undefined exactly which of those instructions is returned . this function is guaranteed to work in o m + n where m is the number of nodes in the graph and n is the number of instructions in the graph . ", "input": " PlaceHolder placeHolder \n\n List<CodeNode> getCodeNodes \n List<FunctionNode> getFunctionNodes \n FunctionNode getFunctionNode \n InliningResult inlineFunctionCall \n CodeNode getCodeNode \n CodeNode getCodeNode", "output": "Instruction function ( final ViewGraph arg0 , final long arg1 ) { return getInstruction ( arg0 , new Address ( arg1 ) ) ; }"}, {"instruction": "Generate java code\ngets the value of the start property . ", "input": " BigInteger start \n BigInteger end \n String id \n String text \n\n void setStart \n String getText \n void setId \n String getId \n void setEnd \n BigInteger getEnd \n void setText", "output": "BigInteger function ( ) { return start ; }"}, {"instruction": "Generate java code\nget the value of an xml attribute stored in this mailetconfig . ", "input": " Pattern ATTRIBUTE_REGEX \n MailetContext mailetContext \n Configuration configuration \n String name \n\n String getInitParameter \n String getMailetName \n void setMailetName \n void setMailetContext \n MailetContext getMailetContext \n void setConfiguration \n Iterator<String> getInitParameterNames", "output": "String function ( String arg0 ) { return configuration . getString ( \"srini_string\" + arg0 + \"srini_string\" , null ) ; }"}, {"instruction": "Generate java code\nprints a child proc to standard out . ", "input": " long serialVersionUID \n Proc parent \n List<Proc> children \n int operationCount \n String name \n int id \n Map<Integer,LinkedList<Operation>> stacks \n List<Operation> operations \n List<String> nameHistory \n\n void setName \n boolean fromZygote \n Operation endOperation \n void didNotStart \n String toString \n void startOperation", "output": "void function ( String arg0 ) { System . out . println ( arg0 + \"srini_string\" + id + \"srini_string\" + name ) ; for ( Proc loc0 : children ) { loc0 . print ( arg0 + \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nreset the mockfilterchain allowing it to be invoked again . ", "input": " Servlet delegateServlet \n ServletRequest request \n Iterator<Filter> iterator \n ServletResponse response \n List<Filter> filters \n\n void init \n ServletRequest getRequest \n void doFilter \n void doFilter \n ServletResponse getResponse \n List<Filter> initFilterList \n void destroy \n String toString", "output": "void function ( ) { this . request = null ; this . response = null ; this . iterator = null ; }"}, {"instruction": "Generate java code\nstops ldap server and kdcserver and shuts down the directory service . ", "input": " int LDAP_PORT \n LdapServer ldapServer \n File KEYSTORE_FILE \n DirectoryService directoryService \n int LDAPS_PORT \n String KEYSTORE_FILENAME \n\n void startLdapServer \n void fixTransportAddress \n void setup \n void tearDown", "output": "void function ( ManagementClient arg0 , String arg1 ) { ldapServer . stop ( ) ; directoryService . shutdown ( ) ; KEYSTORE_FILE . delete ( ) ; FileUtils . deleteDirectory ( directoryService . getInstanceLayout ( ) . getInstanceDirectory ( ) ) ; }"}, {"instruction": "Generate java code\nthe json block of configuration information for each trigger . ", "input": " String configurationId \n java.util.List<RepositoryTrigger> triggers \n\n String getConfigurationId \n GetRepositoryTriggersResult withTriggers \n GetRepositoryTriggersResult withTriggers \n int hashCode \n void setTriggers \n boolean equals \n GetRepositoryTriggersResult clone \n String toString \n GetRepositoryTriggersResult withConfigurationId \n void setConfigurationId", "output": "java . util . List < RepositoryTrigger > function ( ) { return triggers ; }"}, {"instruction": "Generate java code\nvalidates that a key is not null . ", "input": " String NULL_KEY_IS_NOT_ALLOWED \n String NULL_VALUE_IS_NOT_ALLOWED \n int AWAIT_COMPLETION_TIMEOUT_SECONDS \n\n void validateConfiguredKeyType \n void validateConfiguredValueType \n void validateResults \n int getPartitionId \n void validateConfiguredTypes \n void validateConfiguredTypes \n void validateConfiguredTypes", "output": "void function ( K arg0 ) { checkNotNull ( arg0 , NULL_KEY_IS_NOT_ALLOWED ) ; }"}, {"instruction": "Generate java code\nreturns a string representation of this object ; useful for testing and debugging . ", "input": " com.amazonaws.internal.SdkInternalList<LifecycleHook> lifecycleHooks \n\n void setLifecycleHooks \n DescribeLifecycleHooksResult withLifecycleHooks \n DescribeLifecycleHooksResult withLifecycleHooks \n int hashCode \n boolean equals \n DescribeLifecycleHooksResult clone \n java.util.List<LifecycleHook> getLifecycleHooks", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( \"srini_string\" ) ; if ( getLifecycleHooks ( ) != null ) loc0 . append ( \"srini_string\" + getLifecycleHooks ( ) ) ; loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nloads the routes from the classpath ", "input": " PlaceHolder placeHolder \n\n RoutesDefinition loadRoutesFromXML \n RoutesDefinition loadRoutesFromFile \n RoutesDefinition loadRoutesFromFile \n RoutesDefinition loadRoutesFromURL \n RoutesDefinition loadRoutesFromURL", "output": "RoutesDefinition function ( ModelCamelContext arg0 , String arg1 ) { InputStream loc0 = ObjectHelper . loadResourceAsStream ( arg1 ) ; ObjectHelper . notNull ( loc0 , \"srini_string\" + arg1 + \"srini_string\" ) ; return ModelHelper . createModelFromXml ( arg0 , loc0 , RoutesDefinition . class ) ; }"}, {"instruction": "Generate java code\ntries to extract hazelcastinstance from sessionfactory . ", "input": " ILogger logger \n\n placeholderType placeHolder", "output": "HazelcastInstance function ( final SessionFactory arg0 ) { if ( ! ( arg0 instanceof SessionFactoryImplementor ) ) { logger . log ( Level . WARNING , \"srini_string\" ) ; return null ; } return getHazelcastInstance ( ( SessionFactoryImplementor ) arg0 ) ; }"}, {"instruction": "Generate java code\ncall the registered listeners in order , respecting and prioritising those that implement ordered . ", "input": " OrderedComposite<JobExecutionListener> listeners \n\n void setListeners \n void afterJob \n void register", "output": "void function ( JobExecution arg0 ) { for ( Iterator < JobExecutionListener > loc0 = listeners . loc0 ( ) ; loc0 . hasNext ( ) ; ) { JobExecutionListener loc1 = loc0 . next ( ) ; loc1 . beforeJob ( arg0 ) ; } }"}, {"instruction": "Generate java code\ngets the minimum corner of the box . that is the corner of smallest coordinates on each axis . note that the returned reference is not cloned for efficiency purposes so care must be taken not to change the coordinates of the point . ", "input": " Point3 maximum \n Point3 minimum \n\n void include \n void include \n void include \n Point3 getCenter \n boolean intersects \n boolean isEmpty \n Vector3 getExtents \n Point3 getMaximum \n float getVolume \n boolean contains \n boolean contains \n Point3 getCorner \n void enlargeUlps \n String toString \n float getBound \n float getArea", "output": "Point3 function ( ) { return minimum ; }"}, {"instruction": "Generate java code\nalternate way of calling isrepeatable ", "input": " String dcQualifier \n boolean required \n String visibility \n String valueListName \n String dcElement \n String dcSchema \n String hint \n String WORKFLOW_SCOPE \n String inputType \n boolean closedVocabulary \n List<String> typeBind \n String readOnly \n String SUBMISSION_SCOPE \n boolean repeatable \n String vocabulary \n String warning \n String label \n List<String> valueList \n\n boolean isRequired \n String getLabel \n String getInputType \n boolean isClosedVocabulary \n String getVocabulary \n boolean isVisible \n String getSchema \n boolean isRepeatable \n void setVocabulary \n boolean isReadOnly \n String getWarning \n boolean isAllowedFor \n String getElement \n List getPairs \n String getStoredString \n String getDisplayString \n String getHints \n String getPairsType \n String getQualifier", "output": "boolean function ( ) { return isRepeatable ( ) ; }"}, {"instruction": "Generate java code\ninjects the instance ", "input": " BeanManager manager \n InjectionTarget<T> it \n Object lock \n Map<BeanManager,ClassMetaCache<NonContextual<?>>> cache \n\n ClassMetaCache<NonContextual<?>> getCache \n NonContextual<T> of \n void preDestroy \n void postConstruct \n void undeploy", "output": "void function ( T arg0 ) { CreationalContext < T > loc0 = manager . createCreationalContext ( null ) ; it . inject ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\nupdate the annotation and ready state for save . ", "input": " DocumentViewController documentViewController \n Logger logger \n\n void removeAnnotation \n void pageAnnotationsInitialized \n void newAnnotation \n void processAnnotationAction", "output": "void function ( AnnotationComponent arg0 ) { Document loc0 = documentViewController . getDocument ( ) ; PageTree loc1 = loc0 . getPageTree ( ) ; Page loc2 = loc1 . getPage ( arg0 . getPageIndex ( ) ) ; loc2 . updateAnnotation ( arg0 . getAnnotation ( ) ) ; }"}, {"instruction": "Generate java code\ngets the value of the rval property . ", "input": " UpdateResult rval \n\n void setRval", "output": "UpdateResult function ( ) { return rval ; }"}, {"instruction": "Generate java code\ndoes this index belong to a primary key constraint ? ", "input": " boolean belongsToConstraint \n boolean unique \n boolean scan \n boolean persistent \n boolean spatial \n boolean hash \n boolean primaryKey \n\n String getSQL \n IndexType createScan \n boolean isSpatial \n IndexType createUnique \n boolean isPersistent \n IndexType createPrimaryKey \n boolean isUnique \n boolean getBelongsToConstraint \n void setBelongsToConstraint \n boolean isHash \n IndexType createNonUnique \n IndexType createNonUnique \n boolean isScan", "output": "boolean function ( ) { return primaryKey ; }"}, {"instruction": "Generate java code\nadds a data input item reference on this multi-instance . a data input item reference must be used when the instance is initialized using a collection : activitydefinitionbuilder #addmultiinstance boolean , string . it represents the collection element related to each instance . for instance , if the collection used to create the multi-instance is a list containing the elements a and b , in the first instance the data input item reference value will be a and in the second one , b. ", "input": " ProcessDefinitionBuilder builder \n ActivityDefinitionImpl activityDefinition \n MultiInstanceLoopCharacteristics entity \n\n MultiInstanceLoopCharacteristicsBuilder addLoopDataOutputRef \n MultiInstanceLoopCharacteristicsBuilder addDataOutputItemRef \n MultiInstanceLoopCharacteristicsBuilder addCompletionCondition", "output": "MultiInstanceLoopCharacteristicsBuilder function ( final String arg0 ) { entity . setDataInputItemRef ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nsets the label value for this customfieldtranslations . ", "input": " java.lang.String help \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n java.lang.String localeDescription \n java.lang.String label \n com.netsuite.webservices.platform.common_2014_2.types.Language locale \n org.apache.axis.description.TypeDesc typeDesc \n\n java.lang.String getLocaleDescription \n org.apache.axis.description.TypeDesc getTypeDesc \n java.lang.String getLabel \n void setLocaleDescription \n org.apache.axis.encoding.Deserializer getDeserializer \n org.apache.axis.encoding.Serializer getSerializer \n int hashCode \n java.lang.String getHelp \n boolean equals \n void setHelp \n com.netsuite.webservices.platform.common_2014_2.types.Language getLocale \n void setLocale", "output": "void function ( java . lang . String arg0 ) { this . label = arg0 ; }"}, {"instruction": "Generate java code\nfinds the length of the given 3d vector ", "input": " float x \n float z \n float y \n\n void setLength \n void logVector \n void normalize \n double dot \n void cross \n void cross \n void copy \n void copy \n void reverse \n double rotToRad \n void rotateX \n void rotateY \n void rotateZ", "output": "float function ( Point3D arg0 ) { return ( float ) Math . sqrt ( arg0 . x * arg0 . x + arg0 . y * arg0 . y + arg0 . z * arg0 . z ) ; }"}, {"instruction": "Generate java code\nremoves all the entries added into responsemodels . < p > returns a reference to this object so that method calls can be chained together . ", "input": " java.util.Map<String,Boolean> responseParameters \n java.util.Map<String,String> responseModels \n String statusCode \n\n void setStatusCode \n java.util.Map<String,Boolean> getResponseParameters \n MethodResponse addResponseParametersEntry \n void setResponseModels \n MethodResponse clearResponseParametersEntries \n MethodResponse withResponseModels \n MethodResponse withResponseParameters \n String getStatusCode \n java.util.Map<String,String> getResponseModels \n MethodResponse withStatusCode \n int hashCode \n boolean equals \n MethodResponse clone \n String toString \n void setResponseParameters \n MethodResponse addResponseModelsEntry", "output": "MethodResponse function ( ) { this . responseModels = null ; return this ; }"}, {"instruction": "Generate java code\ncreates a new database on the disk . ", "input": " int pinned \n boolean FAIL \n ArrayList<CountData> counts \n int reads \n String BUF_POLICY \n Random random \n boolean PASS \n String DB_PATH \n int DB_SIZE \n int allocs \n int BUF_SIZE \n int writes \n String desc \n\n void delete_minibase \n void load_minibase \n void saveCounts \n void printSummary \n void initCounts \n void initRandom \n void printCounters", "output": "void function ( ) { System . out . println ( \"srini_string\" + BUF_POLICY ) ; new Minibase ( DB_PATH , DB_SIZE , BUF_SIZE , BUF_POLICY , false ) ; }"}, {"instruction": "Generate java code\nthe default implementation returns null . ", "input": " Figure[] NO_FIGURES \n List<FigureChangeListener> listenerList \n String OPERATION_NOT_SUPPORTED \n boolean selectable \n FigureStyle normalStyle \n Handle[] NO_HANDLES \n boolean selected \n FigureStyle selectedStyle \n\n Figure[] getFigures \n Figure[] getFigures \n void rotate \n FigureStyle getHandleStyle \n void setSelected \n int getFigureIndex \n FigureStyle getNormalStyle \n void scale \n void setNormalStyle \n void setSelectedStyle \n void fireFigureChanged \n void fireFigureChanged \n double[] getSegment \n void addChangeListener \n void setSegment \n FigureStyle getEffectiveStyle \n boolean isSelected \n boolean removeFigure \n boolean addFigure \n boolean addFigure \n boolean isSelectable \n boolean removeFigureImpl \n Handle[] createHandles \n int getFigureCount \n Figure[] removeFiguresImpl \n Figure[] removeFiguresImpl \n Figure[] addFiguresImpl \n void move \n int getMaxSelectionStage \n FigureChangeListener[] getChangeListeners \n Figure[] addFigures \n void fireFiguresAdded \n Figure[] removeFigures \n FigureStyle getSelectedStyle \n void removeSegment \n Object createMemento \n FigureStyle getSelectedHandleStyle \n void setSelectable \n boolean contains \n void removeChangeListener \n void addSegment \n boolean addFigureImpl \n boolean addFigureImpl \n Object clone \n void setMemento \n Figure[] removeAllFigures \n void dispose \n Handle[] createScaleHandles \n void fireFiguresRemoved", "output": "Figure function ( Point2D arg0 , AffineTransform arg1 ) { return null ; }"}, {"instruction": "Generate java code\nreturns the folder with the primary key . ", "input": " FolderLocalService _service \n\n java.lang.String getOSGiServiceIdentifier \n com.liferay.mail.model.Folder deleteFolder \n com.liferay.mail.model.Folder deleteFolder \n com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery getActionableDynamicQuery \n int getPercentDownloaded \n int getLocalPageCount \n com.liferay.mail.model.Folder updateFolder \n com.liferay.mail.model.Folder updateFolder \n void deleteFolders \n com.liferay.portal.kernel.dao.orm.DynamicQuery dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n FolderLocalService getService \n void clearService \n com.liferay.mail.model.Folder fetchFolder \n long dynamicQueryCount \n long dynamicQueryCount \n com.liferay.portal.kernel.model.PersistedModel deletePersistedModel \n int getRemotePageCount \n com.liferay.portal.kernel.model.PersistedModel getPersistedModel \n com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery getIndexableActionableDynamicQuery \n int getFoldersCount \n com.liferay.mail.model.Folder addFolder \n com.liferay.mail.model.Folder addFolder \n com.liferay.mail.model.Folder createFolder \n java.lang.Object invokeMethod \n java.util.List<com.liferay.mail.model.Folder> getFolders \n java.util.List<com.liferay.mail.model.Folder> getFolders", "output": "com . liferay . mail . model . Folder function ( long arg0 ) { return getService ( ) . getFolder ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the result of interpreting the object as an instance of ` signature implementation ' . this implementation returns null ; returning a non-null result will terminate the switch . ", "input": " AnalyticsPackage modelPackage \n\n T caseDimensionDefinition \n T caseDimension \n T caseCellSet \n T caseGroupBy \n T caseInScope \n T caseNamedElement \n T caseDimensionExpression \n T caseFunctionSignatureImplementation \n T doSwitch \n T doSwitch \n T doSwitch \n T caseTypedElement \n T caseExpression \n T caseObjectBasedExpression \n T defaultCase", "output": "T function ( SignatureImplementation arg0 ) { return null ; }"}, {"instruction": "Generate java code\nreturns android 's implementation of saxparserfactory . unlike other java implementations , this method does not consult system properties , property files , or the services api . ", "input": " boolean validating \n boolean namespaceAware \n\n boolean isNamespaceAware \n void setFeature \n void setNamespaceAware \n void setValidating \n SAXParser newSAXParser \n void setXIncludeAware \n void setSchema \n boolean isXIncludeAware \n boolean isValidating \n boolean getFeature \n Schema getSchema", "output": "SAXParserFactory function ( ) { return new SAXParserFactoryImpl ( ) ; }"}, {"instruction": "Generate java code\nthreads that used to server request/response cycles in an application server are generally pulled from a pool . just before the thread is done completing the cycle , we should clear any local instance variables to ensure that they are not hanging on to any session references , otherwise the session and their resources are not released . ", "input": " Lifecycle lifecycle \n ClassLoader renderableClassLoader \n Log log \n ExecutorService executorService \n BridgeFacesContext facesContext \n Collection viewListeners \n InheritableThreadLocal localInstance \n long delay \n boolean synchronousMode \n\n void redirectTo \n void navigateTo \n void run \n void setCurrentInstance \n void execute \n ClassLoader getRenderableClassLoader \n FacesContext getFacesContext \n void warn \n void setFacesContext \n void addViewListener \n PersistentFacesState getInstance \n PersistentFacesState getInstance \n void render \n void renderLater \n void renderLater", "output": "void function ( ) { localInstance . set ( null ) ; }"}, {"instruction": "Generate java code\nreturns a string representation of this object ; useful for testing and debugging . ", "input": " Credentials credentials \n String identityId \n\n String getIdentityId \n GetCredentialsForIdentityResult withIdentityId \n GetCredentialsForIdentityResult withCredentials \n int hashCode \n boolean equals \n GetCredentialsForIdentityResult clone \n Credentials getCredentials \n void setCredentials \n void setIdentityId", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( \"srini_string\" ) ; if ( getIdentityId ( ) != null ) loc0 . append ( \"srini_string\" + getIdentityId ( ) + \"srini_string\" ) ; if ( getCredentials ( ) != null ) loc0 . append ( \"srini_string\" + getCredentials ( ) ) ; loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nreturns true if the collection contains an element for the key . ", "input": " int valueTable[] \n int elementSize \n Object keyTable[] \n int threshold \n\n int size \n int hashCode \n int get \n void clear \n void rehash \n String toString \n int put", "output": "boolean function ( Object arg0 ) { int loc0 = hashCode ( arg0 ) , loc1 = this . keyTable . loc1 ; while ( this . keyTable [ loc0 ] != null ) { if ( this . keyTable [ loc0 ] == arg0 ) return true ; if ( ++ loc0 == loc1 ) { loc0 = 0 ; } } return false ; }"}, {"instruction": "Generate java code\nreturns an immutable list containing elements . ", "input": " byte[] EMPTY_BYTE_ARRAY \n Pattern VERIFY_AS_IP_ADDRESS \n TimeZone UTC \n Charset UTF_8 \n String[] EMPTY_STRING_ARRAY \n\n void checkOffsetAndCount \n String hostHeader \n boolean discard \n ThreadFactory threadFactory \n ByteString sha256 \n T[] intersect \n List<T> intersect \n String md5Hex \n String format \n String domainToAscii \n String[] concat \n boolean containsInvalidHostnameAsciiCodes \n int delimiterOffset \n int delimiterOffset \n boolean equal \n ByteString sha1 \n int skipLeadingAsciiWhitespace \n String trimSubstring \n boolean isAndroidGetsocknameError \n String toHumanReadableAscii \n boolean verifyAsIpAddress \n String shaBase64 \n void closeQuietly \n void closeQuietly \n void closeQuietly \n boolean skipAll \n int indexOf \n int skipTrailingAsciiWhitespace", "output": "List < T > function ( T ... arg0 ) { return Collections . unmodifiableList ( Arrays . asList ( arg0 . clone ( ) ) ) ; }"}, {"instruction": "Generate java code\ncomputes the indices for a subline of the line . the subline must conform to the line ; that is , all vertices in the subline except possibly the first and last must be vertices of the line and occcur in the same order . ", "input": " Geometry linearGeom \n\n LinearLocation clampIndex \n LinearLocation getStartIndex \n LinearLocation getEndIndex \n Geometry extractLine \n LinearLocation project \n Coordinate extractPoint \n Coordinate extractPoint \n LinearLocation indexOf \n boolean isValidIndex \n void checkGeometryType \n LinearLocation indexOfAfter", "output": "LinearLocation [ ] function ( Geometry arg0 ) { return LocationIndexOfLine . indicesOf ( linearGeom , arg0 ) ; }"}, {"instruction": "Generate java code\nmethod to return whether chart is 3d or not ", "input": " List deleteList \n boolean is3D \n int deletInex \n List data \n List labels \n String label \n boolean pieNeedsRendering \n Color selectedColor \n float value \n List paints \n SelectItem[] availablePaints \n\n void deleteChart \n String getLabel \n void setPaints \n void setDeleteList \n boolean isDeleteAllowed \n SelectItem[] getAvailablePaints \n void deleteListValueChangeListener \n float getValue \n List getLabels \n boolean renderOnSubmit \n List getDeleteList \n List getPaints \n void setIs3D \n void paintChangeListener \n void setValue \n void setLabel \n void addToChart \n List getData", "output": "boolean function ( ) { return is3D ; }"}, {"instruction": "Generate java code\ngets object stored under given qualifier and given key ", "input": " Class<? extends Annotation> qualifier \n Map<QualifiedKey,Object> cache \n Class<?> key \n\n DroneContext add \n DroneContext add \n int hashCode \n boolean equals \n String toString \n DroneContext remove \n DroneContext remove", "output": "T function ( Class < T > arg0 , Class < ? extends Annotation > arg1 ) { return arg0 . cast ( cache . get ( new QualifiedKey ( arg0 , arg1 ) ) ) ; }"}, {"instruction": "Generate java code\nserialize an instance , restore it , and check for equality . ", "input": " PlaceHolder placeHolder \n\n void testSerialization2 \n void testEqualsPin \n void testCloning \n void testEqualsPointer \n void testHashCode \n void testEquals", "output": "void function ( ) { DialPointer loc0 = new DialPointer . Pin ( 1 ) ; DialPointer loc1 = ( DialPointer ) TestUtilities . serialised ( loc0 ) ; assertEquals ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nthis method sets the value for the ` modificationdate ' column ", "input": " String NAME \n Object[] iKeys \n String CREATIONDATE \n String iName \n String VALUE \n long iFk_projectid \n String FK_PROJECTID \n String iValue \n java.sql.Timestamp iCreationdate \n long iPropertyid \n boolean iUpdated \n String PROPERTYID \n String MODIFICATIONDATE \n java.sql.Timestamp iModificationdate \n\n void setPropertyid \n void setName \n java.sql.Timestamp getCreationdate \n String getName \n void setCreationdate \n Object[] getGeneratedKeys \n ArrayList<PropertyTableAccessor> retrieveAllEntries \n long getPropertyid \n String getBasicSelect \n int update \n long getFk_projectid \n int delete \n String getValue \n void setValue \n void setFk_projectid \n void retrieve \n int persist \n java.sql.Timestamp getModificationdate", "output": "void function ( java . sql . Timestamp arg0 ) { this . iModificationdate = arg0 ; this . iUpdated = true ; }"}, {"instruction": "Generate java code\ndraws the preview using the graphics canvas . ", "input": " boolean cloned \n int count \n mxGraphComponent graphComponent \n float opacity \n List<mxCellState> cellStates \n Map<mxCellState,mxPoint> deltas \n\n void restoreState \n void restore \n mxPoint moveState \n mxPoint moveState \n boolean isEmpty \n mxRectangle show \n void paint \n void setCloned \n Map<mxCellState,mxPoint> getDeltas \n void translateState \n mxRectangle revalidateState \n float getOpacity \n boolean isCloned \n void addEdges \n void paintPreview \n float getOpacityForCell \n int getCount \n List<mxCellState> snapshot \n void setOpacity", "output": "void function ( mxGraphics2DCanvas arg0 , mxCellState arg1 ) { graphComponent . getGraph ( ) . drawState ( arg0 , arg1 , arg1 . getCell ( ) != graphComponent . getCellEditor ( ) . getEditingCell ( ) ) ; }"}, {"instruction": "Generate java code\ntests the equals method . ", "input": " PlaceHolder placeHolder \n\n void testDateConstructor1 \n void testGetStart \n void test1Jan1900Next \n void testGetSerialIndex \n void testGetLastMillisecond \n void test1Jan1900Previous \n void testGetFirstMillisecondWithTimeZone \n void testNext \n void testGetLastMillisecondWithTimeZone \n void testGetFirstMillisecond \n void test31Dec9999Previous \n void testSerialization \n void testDateConstructor2 \n void testEqualsSelf \n void testGetLastMillisecondWithCalendar \n void test31Dec9999Next \n void testGetFirstMillisecondWithCalendar \n void testGetEnd \n void testParseDay \n void testHashcode \n void testNotCloneable", "output": "void function ( ) { Day loc0 = new Day ( 29 , MonthConstants . MARCH , 2002 ) ; Day loc1 = new Day ( 29 , MonthConstants . MARCH , 2002 ) ; assertTrue ( loc0 . equals ( loc1 ) ) ; }"}, {"instruction": "Generate java code\nturns a valid cypher query and returns it with keywords in uppercase , and new-lines in the appropriate places . ", "input": " org.neo4j.cypher.ExecutionEngine inner \n\n org.neo4j.cypher.ExecutionEngine createInnerEngine \n ExtendedExecutionResult profile \n ExtendedExecutionResult profile \n ExtendedExecutionResult execute \n ExtendedExecutionResult execute", "output": "String function ( String arg0 ) { return inner . prettify ( arg0 ) ; }"}, {"instruction": "Generate java code\nconverts wire type to protobuf type . ", "input": " PlaceHolder placeHolder \n\n TtlAction fromProtobuf", "output": "PTtlAction function ( TtlAction arg0 ) { if ( arg0 == null ) { return PTtlAction . DELETE ; } switch ( arg0 ) { case DELETE : return PTtlAction . DELETE ; case FREE : return PTtlAction . FREE ; default : throw new IllegalStateException ( \"srini_string\" + arg0 ) ; } }"}, {"instruction": "Generate java code\ngets the requestorid attribute . ", "input": " String routeRequestorReceipt \n String requestorId \n String requestorType \n String requestorsNote \n String openUrlString \n\n void setRequestorType \n String getRouteRequestorReceipt \n String getRequestorType \n void setRouteRequestorReceipt \n void setOpenUrlString \n String getOpenUrlString \n String getRequestorsNote \n void setRequestorsNote \n void setRequestorId", "output": "String function ( ) { return requestorId ; }"}, {"instruction": "Generate java code\nremoves all rights mappings for the database object identified by the dbobject argument from all grantee objects in the set . ", "input": " HashMappedList uUser \n GranteeManager granteeManager \n User sysUser \n\n HsqlArrayList listVisibleUsers \n void dropUser \n User getSysUser \n String[] getRightsArray \n HashMappedList getUsers \n User getUser \n User get \n boolean exists \n User createUser", "output": "void function ( Object arg0 ) { granteeManager . removeDbObject ( arg0 ) ; }"}, {"instruction": "Generate java code\npicks tasks from the queue to execute if present else no-op . ", "input": " BlockingQueue<T> blockingQueue \n Executor taskExecutor \n\n placeholderType placeHolder", "output": "void function ( ) { Runnable loc0 = blockingQueue . poll ( ) ; if ( loc0 != null ) { taskExecutor . execute ( loc0 ) ; } }"}, {"instruction": "Generate java code\nreturns a detailed string representation of this identity . ", "input": " Vector certificates \n IdentityScope scope \n String name \n long serialVersionUID \n PublicKey publicKey \n String info \n\n String getName \n void addCertificate \n String getInfo \n Certificate[] certificates \n int hashCode \n boolean equals \n PublicKey getPublicKey \n void setPublicKey \n void setInfo \n boolean identityEquals \n IdentityScope getScope \n void removeCertificate", "output": "String function ( boolean arg0 ) { SecurityManager loc0 = System . getSecurityManager ( ) ; if ( loc0 != null ) loc0 . checkSecurityAccess ( \"srini_string\" ) ; if ( arg0 ) { return ( name + \"srini_string\" + scope + \"srini_string\" + publicKey ) ; } else { return ( name + \"srini_string\" + scope + \"srini_string\" + publicKey ) ; } }"}, {"instruction": "Generate java code\nthis should read dynstruct from the cdr input stream , but following the jdk 1.5 api it does not . ", "input": " PlaceHolder placeHolder \n\n DynStruct extract \n DynStruct read \n void insert \n DynStruct narrow \n String id \n TypeCode type \n DynStruct unchecked_narrow", "output": "void function ( OutputStream arg0 , DynStruct arg1 ) { throw new MARSHAL ( DynAnyFactoryHelper . not_applicable ( id ( ) ) ) ; }"}, {"instruction": "Generate java code\nget the value associated to a metadata name . if many values are assiociated to the specified name , then the first one is returned . ", "input": " Map<String,String[]> metadata \n\n void add \n void set \n String[] getValues \n String[] _getValues \n boolean isMultiValued \n void clear \n void remove \n void readFields \n String[] names \n int size \n boolean equals \n String toString \n void setAll \n void write", "output": "String function ( final String arg0 ) { String [ ] loc0 = metadata . get ( arg0 ) ; if ( loc0 == null ) { return null ; } else { return loc0 [ 0 ] ; } }"}, {"instruction": "Generate java code\nreturns true if the tween or timeline has been started . ", "input": " boolean isPaused \n Object userData \n boolean isAutoStartEnabled \n boolean isInitialized \n BaseTween holder \n boolean isStarted \n boolean isFinished \n boolean isIterationStep \n float duration \n float currentTime \n float delay \n TweenCallback callback \n boolean isAutoRemoveEnabled \n int step \n boolean isKilled \n float repeatDelay \n boolean isYoyo \n Object lock \n int repeatCnt \n int callbackTriggers \n long id \n\n float getFullDuration \n float getDelay \n T repeatYoyo \n int getStep \n void killTarget \n void killTarget \n void callCallback \n T setCallback \n void update \n void forceToStart \n void testRelaunch \n void compute \n boolean containsTarget \n boolean containsTarget \n void forceEndValues \n void forceEndValues \n float getDuration \n void testInnerTransition \n T repeat \n void free \n void free \n void initializeOverride \n boolean isYoyo \n boolean isYoyo \n void forceToEnd \n void resume \n void testCompletion \n boolean isPaused \n void computeOverride \n void testLimitTransition \n boolean isValid \n T start \n T start \n void updateStep \n void kill \n boolean isFinished \n void pause \n T delay \n T build \n T setCallbackTriggers \n void reset \n float getRepeatDelay \n Object getUserData \n void initialize \n void forceStartValues \n void forceStartValues \n T setUserData \n int getRepeatCount", "output": "boolean function ( ) { return isStarted ; }"}, {"instruction": "Generate java code\nget a logger , based on a class name ", "input": " POILogger _nullLogger \n Map<String,POILogger> _loggers \n String _loggerClassName \n\n placeholderType placeHolder", "output": "POILogger function ( final Class < ? > arg0 ) { return getLogger ( arg0 . getName ( ) ) ; }"}, {"instruction": "Generate java code\nthe year class is immutable , so should not be cloneable . ", "input": " PlaceHolder placeHolder \n\n void test9999Previous \n void testDateConstructor1 \n void testGetStart \n void testGetLastMillisecond \n void testGetSerialIndex \n void test1900Next \n void testGetFirstMillisecondWithTimeZone \n void testNext \n void test9999Next \n void testGetLastMillisecondWithTimeZone \n void testGetFirstMillisecond \n void testSerialization \n void testDateConstructor2 \n void testEqualsSelf \n void testParseYear \n void testGetLastMillisecondWithCalendar \n void testGetFirstMillisecondWithCalendar \n void testGetEnd \n void testMinuss9999Previous \n void testHashcode \n void testEquals", "output": "void function ( ) { Year loc0 = new Year ( 1999 ) ; assertFalse ( loc0 instanceof Cloneable ) ; }"}, {"instruction": "Generate java code\nreinitialise . ", "input": " int bufpos \n boolean prevCharIsLF \n int bufsize \n int available \n java.io.Reader inputStream \n int line \n boolean staticFlag \n int bufcolumn[] \n int tabSize \n int bufline[] \n int maxNextCharInd \n char[] buffer \n boolean prevCharIsCR \n int tokenBegin \n int inBuf \n int column \n\n char[] GetSuffix \n void backup \n void Done \n int getEndLine \n int getLine \n void FillBuff \n char readChar \n char BeginToken \n int getBeginLine \n int getTabSize \n void adjustBeginLineColumn \n void setTabSize \n String GetImage \n void ExpandBuff \n int getBeginColumn \n int getColumn \n int getEndColumn \n void UpdateLineColumn", "output": "void function ( java . io . InputStream arg0 , int arg1 , int arg2 ) { ReInit ( arg0 , arg1 , arg2 , 4096 ) ; }"}, {"instruction": "Generate java code\nretrieve the timezone of the request log . ", "input": " ThreadLocal<StringBuilder> buffers \n Locale logLocale \n boolean logLatency \n String LOG_DATE_FORMAT \n String logTimeZone \n ThreadSafeSimpleDateFormat DATE_FORMATTER \n Logger LOG \n\n boolean getLogLatency \n void setLogLocale \n Locale getLogLocale \n void log \n boolean isEnabled \n void setLogTimeZone \n void setLogLatency \n StringBuilder initialValue \n void write", "output": "String function ( ) { return this . logTimeZone ; }"}, {"instruction": "Generate java code\nmethod removeiterationat . ", "input": " java.util.List<bzh.plealog.bioinfo.data.blast.loader.ncbi.Iteration> _iterationList \n long serialVersionUID \n\n void addIteration \n void addIteration \n int getIterationCount \n java.util.Enumeration<bzh.plealog.bioinfo.data.blast.loader.ncbi.Iteration> enumerateIteration \n bzh.plealog.bioinfo.data.blast.loader.ncbi.BlastOutput_iterations unmarshal \n bzh.plealog.bioinfo.data.blast.loader.ncbi.Iteration getIteration \n bzh.plealog.bioinfo.data.blast.loader.ncbi.Iteration[] getIteration \n boolean isValid \n void marshal \n void marshal \n boolean removeIteration \n java.util.Iterator<bzh.plealog.bioinfo.data.blast.loader.ncbi.Iteration> iterateIteration \n void setIteration \n void setIteration \n void removeAllIteration \n void validate", "output": "bzh . plealog . bioinfo . data . blast . loader . ncbi . Iteration function ( final int arg0 ) { java . lang . Object loc0 = this . _iterationList . remove ( arg0 ) ; return ( bzh . plealog . bioinfo . data . blast . loader . ncbi . Iteration ) loc0 ; }"}, {"instruction": "Generate java code\nset the jndi template to use for jndi lookups . you can also specify jndi environment settings via `` jndienvironment '' . ", "input": " JndiTemplate jndiTemplate \n Log logger \n\n JndiTemplate getJndiTemplate \n Properties getJndiEnvironment \n void setJndiEnvironment", "output": "void function ( JndiTemplate arg0 ) { this . jndiTemplate = ( arg0 != null ? arg0 : new JndiTemplate ( ) ) ; }"}, {"instruction": "Generate java code\nto use a custom xmlrpcrequestprocessor as server . ", "input": " boolean contentLengthOptional \n String basicUserName \n boolean enabledForExceptions \n String basicEncoding \n String basicPassword \n java.util.TimeZone timeZone \n String userAgent \n String encoding \n boolean gzipRequesting \n org.apache.xmlrpc.common.XmlRpcRequestProcessor xmlRpcServer \n boolean gzipCompressing \n boolean enabledForExtensions \n int replyTimeout \n int connectionTimeout \n\n void setGzipRequesting \n void setBasicPassword \n void setEncoding \n void setBasicEncoding \n TimeZone getTimeZone \n boolean isGzipCompressing \n void setEnabledForExceptions \n String getEncoding \n String getBasicUserName \n int getReplyTimeout \n XmlRpcRequestProcessor getXmlRpcServer \n void setTimeZone \n void setEnabledForExtensions \n boolean isContentLengthOptional \n int getConnectionTimeout \n boolean isEnabledForExtensions \n void setContentLengthOptional \n void setGzipCompressing \n void setConnectionTimeout \n void setUserAgent \n boolean isEnabledForExceptions \n String getBasicEncoding \n void setReplyTimeout \n void setBasicUserName \n String getUserAgent \n boolean isGzipRequesting \n String getBasicPassword", "output": "void function ( XmlRpcRequestProcessor arg0 ) { this . xmlRpcServer = arg0 ; }"}, {"instruction": "Generate java code\ngets the lagdays value for this projecttaskpredecessor . ", "input": " org.apache.axis.description.TypeDesc typeDesc \n com.netsuite.webservices.platform.core_2014_2.RecordRef task \n java.util.Calendar endDate \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n java.lang.Double lagDays \n com.netsuite.webservices.activities.scheduling_2014_2.types.ProjectTaskPredecessorPredecessorType type \n java.util.Calendar startDate \n\n java.util.Calendar getStartDate \n void setStartDate \n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Deserializer getDeserializer \n java.util.Calendar getEndDate \n void setType \n void setEndDate \n org.apache.axis.encoding.Serializer getSerializer \n com.netsuite.webservices.activities.scheduling_2014_2.types.ProjectTaskPredecessorPredecessorType getType \n void setLagDays \n int hashCode \n void setTask \n boolean equals \n com.netsuite.webservices.platform.core_2014_2.RecordRef getTask", "output": "java . lang . Double function ( ) { return lagDays ; }"}, {"instruction": "Generate java code\nthe query parsed . ", "input": " Map<String,Query> namedFilters \n Query query \n\n Map<String,Query> namedFilters \n ParsedQuery parsedMatchAllQuery", "output": "Query function ( ) { return this . query ; }"}, {"instruction": "Generate java code\nmain method ", "input": " boolean BATCH \n Properties pProperties \n String EKW \n boolean EOF \n int ln \n Statement sStatement \n Connection cConn \n\n void printHelp \n void trace \n String fileToString \n String toString \n void execute", "output": "void function ( String arg0 [ ] ) { for ( int loc0 = 0 ; loc0 < arg0 . length ; loc0 ++ ) { String loc1 = arg0 [ loc0 ] ; if ( loc1 . equals ( \"srini_string\" ) ) { printHelp ( ) ; System . exit ( 0 ) ; } } ScriptTool loc2 = new ScriptTool ( ) ; loc2 . execute ( arg0 ) ; System . exit ( 0 ) ; }"}, {"instruction": "Generate java code\ntest operatorutil #getcontractclass class ", "input": " PlaceHolder placeHolder \n\n void getContractClassShouldReturnSinkForOutputFormat \n void getContractClassShouldReturnSourceForInputFormat \n void getContractClassShouldReturnNullForStub \n void getContractClassShouldReturnCrossForCrossStub \n void getContractClassShouldReturnMatchForMatchStub \n void getContractClassShouldReturnCoGroupForCoGroupStub \n void getContractClassShouldReturnReduceForReduceStub", "output": "void function ( ) { final Class < ? > loc0 = OperatorUtil . getContractClass ( Mapper . class ) ; assertEquals ( CollectorMapOperatorBase . class , loc0 ) ; }"}, {"instruction": "Generate java code\nif a notification with an id and type exists . ", "input": " Context context \n\n Notification cancel \n void cancelAll \n List<Integer> getIdsByType \n List<Notification> getAll \n List<Notification> getByType \n NotificationManager getNotMgr \n List<JSONObject> getOptionsById \n SharedPreferences getPrefs \n Notification clear \n Notification update \n List<Integer> getIds \n List<JSONObject> getOptionsByType \n void clearAll \n Notification schedule \n Notification schedule \n List<Notification> getByIds \n List<JSONObject> getOptionsBy \n List<Notification> getBy \n Notification get \n Manager getInstance \n List<JSONObject> getOptions \n JSONObject mergeJSONObjects", "output": "boolean function ( int arg0 , Notification . Type arg1 ) { Notification loc0 = get ( arg0 ) ; return loc0 != null && loc0 . getType ( ) == arg1 ; }"}, {"instruction": "Generate java code\nreturns the file separator ' / ' or ' \\ \\ ' used by the client 's os . ", "input": " int remotePort \n String command \n String workingDirectory \n String[] args \n InetAddress remoteHost \n NGServer server \n PrintStream exitStream \n PrintStream out \n PrintStream err \n Properties remoteEnvironment \n InputStream in \n\n InetAddress getInetAddress \n String getWorkingDirectory \n void assertLoopbackClient \n String getCommand \n void setEnv \n void setNGServer \n void setPort \n void setCommand \n String[] getArgs \n NGServer getNGServer \n void setWorkingDirectory \n void setInetAddress \n void exit \n int getPort \n void setArgs \n void setExitStream \n void assertLocalClient \n String getPathSeparator \n Properties getEnv", "output": "String function ( ) { return ( remoteEnvironment . getProperty ( \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nget an untagged object from the bytebuffer ", "input": " byte _tag \n\n Object getObject \n Object getUntaggedObject \n void writeUntagged \n void writeTagged \n byte getTag \n void write", "output": "Object function ( ByteBuffer arg0 ) { Value loc0 = ValueFactory . createFromTagged ( arg0 ) ; return loc0 . getObject ( ) ; }"}, {"instruction": "Generate java code\ndownloads the iana root zone database , extracts the ascii tlds , then writes a jflex macro accepting any of them case-insensitively out to the specified output file . ", "input": " Pattern TLD_PATTERN_2 \n File outputFile \n String APACHE_LICENSE \n Pattern TLD_PATTERN_1 \n String NL \n URL tldFileURL \n long tldFileLastModified \n\n SortedSet<String> getIANARootZoneDatabase \n String getCaseInsensitiveRegex \n void writeOutput \n void main", "output": "void function ( ) { final SortedSet < String > loc0 = getIANARootZoneDatabase ( ) ; writeOutput ( loc0 ) ; System . err . println ( \"srini_string\" + loc0 . size ( ) + \"srini_string\" + outputFile + \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nswitch of the url puller to empty the internal queue . ", "input": " UrlPusher pusher \n AnthOnlineClassifier onlineLearner \n AnthBandit bandit \n Thread pullerThread \n BufferedWriter logFileWriter \n boolean run \n Thread banditThread \n UrlPuller puller \n Queue<AnthURL> outputList \n Queue<AnthURL> inputList \n boolean writeLog \n StatusPrinter statusViewer \n ConcurrentHashMap<String,AnthHost> knownDomains \n ArrayBlockingQueue<AnthHost> queuedDomains \n Thread statusThread \n boolean useStaticClassifier \n Thread pusherThread \n\n void switchOf \n void stop \n void writeLogFileHeader \n void addFeedback \n void addFeedback \n void start \n void run \n void getStatus \n void initiateClassifier", "output": "void function ( ) { puller . switchOf ( ) ; System . out . println ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncompare two result sets for equivalence . equivalance means : each row in rs1 matchs the same index row in rs2 . rows match if they have the same variables with the same values , bnodes must map to a consistent other bnodes . rdf term comparisons of nodes . destructive - rs1 and rs2 are both read , possibly to exhaustion . ", "input": " NodeIsomorphismMap mapping \n Transform<QuerySolution,Binding> qs2b \n EqualityTest literalTest \n\n boolean equal \n boolean equal \n boolean equalsByValue \n boolean equivalent \n boolean equalsByValueAndOrder \n boolean compareHeader \n boolean equalsByTerm \n boolean isomorphic \n boolean containedIn \n boolean equivalentByOrder \n List<Binding> convert \n Binding convert \n boolean equalsByTest", "output": "boolean function ( ResultSet arg0 , ResultSet arg1 ) { if ( ! compareHeader ( arg0 , arg1 ) ) return false ; return equivalentByOrder ( convert ( arg0 ) , convert ( arg1 ) , new BNodeIso ( NodeUtils . sameTerm ) ) ; }"}, {"instruction": "Generate java code\nthe locale of the ui related to the systemmessages request . ", "input": " VaadinRequest request \n VaadinService service \n Locale locale \n\n void setRequest \n void setService \n VaadinRequest getRequest \n void setLocale \n VaadinService getService", "output": "Locale function ( ) { return locale ; }"}, {"instruction": "Generate java code\nsimply removes an eobject from its container . ", "input": " Map nameFeatureMap \n Object NULL_TOKEN \n\n boolean shouldOverrideCopyOperation \n void setName \n boolean canContain \n XMLResource getResource \n String getName \n OverrideCopyOperation getOverrideCopyOperation \n boolean isCopyAlways \n boolean shouldSaveContainmentFeature \n PasteAction getPasteCollisionAction \n boolean hasPasteOption \n void performPostPasteProcessing \n boolean shouldOverrideChildPasteOperation \n OverridePasteChildOperation getOverrideChildPasteOperation \n void sendCreateNotification \n EAttribute getNameAttribute \n Collection getExcludedCopyObjects \n boolean isNameable", "output": "void function ( EObject arg0 ) { EcoreUtil . remove ( arg0 ) ; if ( arg0 . eResource ( ) != null ) { arg0 . eResource ( ) . getContents ( ) . remove ( arg0 ) ; } }"}, {"instruction": "Generate java code\nsets the max power . ", "input": " double constant \n double staticPower \n double maxPower \n\n double getMaxPower \n double getPower \n double getConstant \n double getStaticPower \n void setStaticPower \n void setConstant", "output": "void function ( double arg0 ) { this . maxPower = arg0 ; }"}, {"instruction": "Generate java code\nreturn the property 's type . this is the same as the type returned by the getter . ", "input": " ReflectedMethod getter \n String propertyName \n ReflectedMethod setter \n\n void set \n boolean isReadOnly \n String makeSetterName \n Object get \n String makeGetterName \n String makeBooleanGetterName \n String capitalize \n String getPropertyName", "output": "Class < ? > function ( ) { return getter . getType ( ) ; }"}, {"instruction": "Generate java code\ncommits preferences , disposes the window , and exits the program . ", "input": " PlaceHolder placeHolder \n\n void windowDeactivated \n void windowClosed \n void windowOpened \n void windowActivated \n void windowDeiconified \n void windowIconified", "output": "void function ( WindowEvent arg0 ) { PrefFactory . getPrefs ( ) . commit ( ) ; arg0 . getWindow ( ) . dispose ( ) ; System . exit ( 0 ) ; }"}, {"instruction": "Generate java code\ncreates a new testsetup the default plugin descriptor which is #default_plugin_descriptor ", "input": " PluginManager<TestPlugin> pluginManager \n Map<String,MycilaTesting> instances \n Logger LOGGER \n MycilaTesting customTestHandler \n String DEFAULT_PLUGIN_DESCRIPTOR \n\n PluginManager<TestPlugin> pluginManager \n void debug \n MycilaTesting newCustomSetup \n MycilaTesting staticDefaultSetup \n MycilaTesting newSetup \n MycilaTesting staticSetup \n MycilaTesting from \n MycilaTesting from \n MycilaTesting configure \n TestNotifier createNotifier \n MycilaTesting staticCustomSetup", "output": "MycilaTesting function ( ) { return newSetup ( DEFAULT_PLUGIN_DESCRIPTOR ) ; }"}, {"instruction": "Generate java code\nbuild base64 number a digit at a time , most significant digit first . ", "input": " int reps \n int id \n String content \n int current \n\n char next \n List<Integer> decodeLine \n List<Integer> decodeLine \n boolean hasNext \n LineEntry decodeLineEntry \n LineEntry decodeLineEntry \n int getIdFromRelativeId \n char peek", "output": "int function ( char arg0 , int arg1 ) { return ( arg1 * 64 ) + Base64 . fromBase64 ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the request id of this social request . ", "input": " SocialRequest _socialRequest \n\n long getClassNameId \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setGroupId \n boolean isEscapedModel \n boolean isCachedModel \n int compareTo \n SocialRequest getWrappedModel \n int getStatus \n long getGroupId \n void setModelAttributes \n Map<String,Object> getModelAttributes \n void setClassNameId \n long getClassPK \n com.liferay.portal.kernel.model.CacheModel<SocialRequest> toCacheModel \n long getCreateDate \n SocialRequest toUnescapedModel \n void setPrimaryKey \n long getReceiverUserId \n void setUserUuid \n boolean isEntityCacheEnabled \n void setReceiverUserId \n void resetOriginalValues \n java.lang.String getReceiverUserUuid \n Serializable getPrimaryKeyObj \n void setClassPK \n long getModifiedDate \n SocialRequest toEscapedModel \n long getPrimaryKey \n void setReceiverUserUuid \n int getType \n void setCreateDate \n java.lang.String getUuid \n void setExtraData \n void setCachedModel \n java.lang.String getClassName \n String getModelClassName \n void setCompanyId \n void setUserId \n boolean isFinderCacheEnabled \n ExpandoBridge getExpandoBridge \n void setClassName \n void setRequestId \n int hashCode \n void persist \n void setNew \n java.lang.String getUserUuid \n java.lang.String getExtraData \n boolean isNew \n void setType \n void setUuid \n Class<?> getModelClass \n void setStatus \n void setModifiedDate \n long getCompanyId \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n java.lang.String toString \n long getUserId", "output": "long function ( ) { return _socialRequest . getRequestId ( ) ; }"}, {"instruction": "Generate java code\nunmarshall message from xml to object ", "input": " LibCommMessage libCommMessage \n IProcessor processor \n Logger log \n\n void setProcessor \n IProcessor getProcessor \n void process \n JAXBContext initContext \n String marshalMessage", "output": "LibCommMessage function ( JAXBContext arg0 , InputStream arg1 ) { Unmarshaller loc0 = arg0 . createUnmarshaller ( ) ; libCommMessage = ( LibCommMessage ) loc0 . unmarshal ( arg1 ) ; return libCommMessage ; }"}, {"instruction": "Generate java code\nreturns the same date object . this object should be treated as read-only . ", "input": " SimpleDateFormat sdfd \n SimpleDateFormat sdfts \n String sdfdPattern \n String sdftsPattern \n SimpleDateFormat sdft \n Date today \n Date tempDate \n String sdftPattern \n\n Date dateValue \n String getDateString \n void resetToTime \n void resetToday \n void resetToDate \n Time getTime \n Timestamp getTimestamp \n Timestamp timestampValue \n Timestamp timestampValue \n java.sql.Date getDate \n String getTimestampString \n Time timeValue \n String getTimeString", "output": "Date function ( ) { long loc0 = System . currentTimeMillis ( ) ; if ( loc0 - today . getTime ( ) > 24 * 3600 * 1000 ) { resetToday ( ) ; } return today ; }"}, {"instruction": "Generate java code\ncreate the directory parent / children and all ancestorsalong the path . ", "input": " PlaceHolder placeHolder \n\n Map.Entry<INodesInPath,String> createAncestorDirectories \n PermissionStatus addImplicitUwx \n INodesInPath unprotectedMkdir \n HdfsFileStatus mkdirs \n void mkdirForEditLog \n INodesInPath createSingleDirectory", "output": "INodesInPath function ( FSDirectory arg0 , INodesInPath arg1 , List < String > arg2 , PermissionStatus arg3 ) { assert arg0 . hasWriteLock ( ) ; for ( String loc0 : arg2 ) { arg1 = createSingleDirectory ( arg0 , arg1 , loc0 , arg3 ) ; if ( arg1 == null ) { return null ; } } return arg1 ; }"}, {"instruction": "Generate java code\na list of strings of every word after the datatype of the column . example `` not '' , `` null '' ", "input": " ColDataType colDataType \n List<String> columnSpecStrings \n String columnName \n\n void setColumnName \n void setColDataType \n ColDataType getColDataType \n String getColumnName \n String toString \n void setColumnSpecStrings", "output": "List < String > function ( ) { return columnSpecStrings ; }"}, {"instruction": "Generate java code\nsignals that configuration is finished . ", "input": " Logger logger \n boolean notValidated \n\n void setNotValidated \n void init \n void endProcessUpdates \n boolean isNotValidated \n void endProcessValidators \n void startRenderResponse", "output": "void function ( boolean arg0 ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( \"srini_string\" + arg0 ) ; if ( arg0 ) { init ( ) ; } }"}, {"instruction": "Generate java code\nget path fragments . eg : '' / task/inbox/123 '' will return a list with three values : `` task '' , `` inbox '' and `` 123 '' in that order . ", "input": " String URL_PART_SEPARATOR \n String NAME_VALUE_SEPARATOR \n String PARAMETER_SEPARATOR \n String QUERY_STRING_SEPARATOR \n\n String extractUri \n String encode \n String extractQueryString \n Map<String,String> parseQueryParameters \n String getQueryString \n String getPath \n String decode", "output": "List < String > function ( String arg0 ) { if ( arg0 != null ) { List < String > loc0 = new ArrayList < String > ( ) ; String [ ] loc1 = arg0 . split ( URL_PART_SEPARATOR ) ; for ( String loc2 : loc1 ) { if ( loc2 . length ( ) > 0 ) { loc0 . add ( loc2 ) ; } } return loc0 ; } return null ; }"}, {"instruction": "Generate java code\nreturns the workbench project that this module is contained in , or null if the module is outside of the workspace . ", "input": " ModuleDelegate delegate \n ModuleFactory factory \n ModuleType moduleType \n String id2 \n String name \n IProject project \n String id \n Map<String,String> properties \n\n Object getAdapter \n IModule[] getChildModules \n String getName \n String getProperty \n boolean isExternal \n String getInternalId \n String getId \n ModuleDelegate getDelegate \n Object loadAdapter \n int hashCode \n boolean equals \n ModuleFactory getModuleFactory \n boolean exists \n String toString \n IModuleType getModuleType \n IStatus validate", "output": "IProject function ( ) { return project ; }"}, {"instruction": "Generate java code\ngets the value of the stepid property . ", "input": " int stepId \n\n void setStepId", "output": "int function ( ) { return stepId ; }"}, {"instruction": "Generate java code\nsets the max attempts of connect ", "input": " int port \n int connectAttemptsMax \n String clientId \n QoS willQos \n String userName \n boolean cleanSession \n short keepAliveInterval \n boolean willRetain \n String password \n String willTopic \n int connectionTimeout \n String host \n String willMessage \n\n void setPassword \n String getClientId \n void setKeepAliveInterval \n void setPort \n QoS getWillQos \n void setCleanSession \n void setWillRetain \n void setUserName \n void setWillTopic \n int getConnectAttemptsMax \n String getWillMessage \n String getUserName \n int getConnectionTimeout \n String getHost \n String getWillTopic \n void setHost \n short getKeepAliveInterval \n boolean isCleanSession \n void setConnectionTimeout \n String getPassword \n boolean isWillRetain \n int getPort \n void setWillQos \n void setWillMessage \n void setClientId", "output": "void function ( int arg0 ) { this . connectAttemptsMax = arg0 ; }"}, {"instruction": "Generate java code\nattempts to detect docstring format from given text and parses it into corresponding structured docstring . it 's recommended to use more reliable #parse string , psielement that fallbacks to format specified in settings . ", "input": " PlaceHolder placeHolder \n\n DocStringFormat getConfiguredDocStringFormat \n boolean isLikeNumpyDocstring \n boolean ensureNotPlainDocstringFormat \n StructuredDocString parseDocString \n StructuredDocString parseDocString \n StructuredDocString parseDocString \n StructuredDocString parseDocString \n StructuredDocString parseDocString \n String getAttributeDocComment \n String getDocStringValue \n PyStringLiteralExpression findDocStringExpression \n PyStringLiteralExpression getParentDefinitionDocString \n DocStringFormat guessDocStringFormat \n DocStringFormat guessDocStringFormat \n boolean isLikeSphinxDocString \n StructuredDocString parseDocStringContent \n boolean isLikeGoogleDocString \n boolean isDocStringExpression \n Substring stripPrefixAndQuotes \n boolean isLikeEpydocDocString \n StructuredDocString getStructuredDocString \n DocStringFormat getConfiguredDocStringFormatOrPlain \n boolean ensureNotPlainDocstringFormatForFile \n boolean isVariableDocString \n Module getModuleForElement", "output": "StructuredDocString function ( @ NotNull String arg0 ) { return parse ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nreads a #type type attribute . this method must return a new attribute object , of type #type type , corresponding to the len bytes starting at the given offset , in the given class reader . ", "input": " Attribute next \n String type \n byte[] value \n\n Label[] getLabels \n int getSize \n boolean isUnknown \n ByteVector write \n int getCount \n void put \n boolean isCodeAttribute", "output": "Attribute function ( ClassReader arg0 , int arg1 , int arg2 , char [ ] arg3 , int arg4 , Label [ ] arg5 ) { Attribute loc0 = new Attribute ( type ) ; loc0 . value = new byte [ arg2 ] ; System . arraycopy ( arg0 . b , arg1 , loc0 . value , 0 , arg2 ) ; return loc0 ; }"}, {"instruction": "Generate java code\nsets if we should generate svg fonts for texts . default value is false . ", "input": " boolean svgFont \n DecimalFormatSymbols dsf \n RenderingHints hints \n StyleHandler styleHandler \n Document domFactory \n Paint paint \n GraphicContextDefaults gcDefaults \n int precision \n DecimalFormat decimalFormat \n Stroke stroke \n ExtensionHandler extensionHandler \n SVGIDGenerator idGenerator \n String generatorComment \n Composite composite \n Color background \n ErrorHandler errorHandler \n ImageHandler imageHandler \n GenericImageHandler genericImageHandler \n DecimalFormat[] decimalFormats \n Shape clip \n Font font \n\n void setIDGenerator \n Stroke getStroke \n void setStyleHandler \n void setExtensionHandler \n ImageHandler getImageHandler \n void setPrecision \n RenderingHints getRenderingHints \n void setBackground \n SVGIDGenerator getIDGenerator \n ExtensionHandler getExtensionHandler \n ErrorHandler getErrorHandler \n void setGenericImageHandler \n void setComposite \n void setClip \n void setGraphicContextDefaults \n String getComment \n void setStroke \n void setFont \n Paint getPaint \n String doubleString \n void setImageHandler \n void setPaint \n SVGGeneratorContext createDefault \n StyleHandler getStyleHandler \n boolean isEmbeddedFontsOn \n int getPrecision \n Composite getComposite \n GraphicContextDefaults getGraphicContextDefaults \n Document getDOMFactory \n void setRenderingHints \n void setErrorHandler \n Shape getClip \n void setComment \n Font getFont \n void setDOMFactory \n Color getBackground", "output": "void function ( boolean arg0 ) { this . svgFont = arg0 ; }"}, {"instruction": "Generate java code\nretrieves a byte sequence representing the md5 digest of the specified character sequence , using the specified encoding to first convert the character sequence into a byte sequence . if the specified encoding is null , then iso-8859-1 is assumed . ", "input": " MessageDigest md5 \n\n String encode", "output": "byte [ ] function ( String arg0 , String arg1 ) { byte [ ] loc0 ; if ( arg1 == null ) { arg1 = \"srini_string\" ; } try { loc0 = arg0 . getBytes ( arg1 ) ; } catch ( UnsupportedEncodingException loc1 ) { throw new RuntimeException ( loc1 . toString ( ) ) ; } return digest ( loc0 ) ; }"}, {"instruction": "Generate java code\ncreate a string representing the argument signature of amethod . each element in the array is the fully qualified class name of the corresponding argument in the methods signature . ", "input": " Log logger \n String MBEAN_SUFFIX \n String IDENTITY_OBJECT_NAME_KEY \n\n Class<?> getMBeanInterface \n ObjectName appendIdentityToObjectName \n Class<?>[] parameterInfoToTypes \n Class<?>[] parameterInfoToTypes \n Class<?> getClassToExpose \n Class<?> getClassToExpose \n boolean isMXBeanSupportAvailable \n boolean isMBean \n String getAttributeName \n MBeanServer locateMBeanServer \n MBeanServer locateMBeanServer \n Class<?> getMXBeanInterface", "output": "String [ ] function ( Method arg0 ) { Class < ? > [ ] loc0 = arg0 . getParameterTypes ( ) ; String [ ] loc1 = new String [ loc0 . length ] ; for ( int loc2 = 0 ; loc2 < loc0 . length ; loc2 ++ ) { loc1 [ loc2 ] = loc0 [ loc2 ] . getName ( ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nreturns the osgi service identifier . ", "input": " DDMTemplateVersionService _ddmTemplateVersionService \n\n void setWrappedService \n int getTemplateVersionsCount \n com.liferay.dynamic.data.mapping.model.DDMTemplateVersion getLatestTemplateVersion \n java.util.List<com.liferay.dynamic.data.mapping.model.DDMTemplateVersion> getTemplateVersions \n DDMTemplateVersionService getWrappedService \n com.liferay.dynamic.data.mapping.model.DDMTemplateVersion getTemplateVersion", "output": "java . lang . String function ( ) { return _ddmTemplateVersionService . getOSGiServiceIdentifier ( ) ; }"}, {"instruction": "Generate java code\nactivity class implementation . ", "input": " String startFragment \n MainMenu mainMenu \n TabStrip tabStrip \n String color \n String backPublicKey \n Activities backActivity \n Activities type \n boolean fullScreen \n Map<String,Fragment> fragments \n String lastFragment \n TitleBar titleBar \n Header header \n SideMenu sideMenu \n StatusBar statusBar \n String activityType \n Map<WizardTypes,Wizard> wizards \n\n void addFragment \n void setTitleBar \n StatusBar getStatusBar \n SideMenu getSideMenu \n String getBackAppPublicKey \n void setFullScreen \n Map<String,Fragment> getFragments \n void setBackPublicKey \n void setHeader \n Activities getBackActivity \n FermatHeader getHeader \n void setBackActivity \n Map<WizardTypes,Wizard> getWizards \n String getActivityType \n void setSideMenu \n void setLastFragment \n TabStrip getTabStrip \n void setTabStrip \n void setStatusBar \n void changeBackActivity \n void addWizard \n String getColor \n void setType \n TitleBar getTitleBar \n void setMainMenu \n Activities getType \n Fragment getLastFragment \n MainMenu getMainMenu \n void setActivityType \n boolean isFullScreen \n Fragment getFragment \n void setStartFragment", "output": "void function ( String arg0 ) { this . color = arg0 ; }"}, {"instruction": "Generate java code\nfor all rings in the input list , determine whether the ring is a shell or a hole and add it to the appropriate list . due to the way the directededges were linked , a ring is a shell if it is oriented cw , a hole otherwise . ", "input": " CoordinateReferenceSystem crs \n List shellList \n int X \n int Y \n CGAlgorithms cga \n int Z \n\n void add \n void add \n void placePolygonHoles \n EdgeRing findEdgeRingContaining \n List buildMaximalEdgeRings \n EdgeRing findShell \n List buildMinimalEdgeRings \n List getPolygons \n List computeSurfaces \n boolean containsPoint \n void placeFreeHoles", "output": "void function ( List arg0 , List arg1 , List arg2 ) { for ( Iterator loc0 = arg0 . iterator ( ) ; loc0 . hasNext ( ) ; ) { EdgeRing loc1 = ( EdgeRing ) loc0 . next ( ) ; if ( loc1 . isHole ( ) ) { arg2 . add ( loc1 ) ; } else { arg1 . add ( loc1 ) ; } } }"}, {"instruction": "Generate java code\nreturn the extension part of a url . ", "input": " MimeType ANY \n MimeType HTML \n MimeType GIF \n MimeType MSEXCEL \n MimeType XML \n MimeType PLAINTEXT \n String mMimetype \n String mSubtype \n MimeType PDF \n MimeType BMP \n String mType \n MimeType JPG \n MimeType AP_NEWS \n MimeType MSWORD \n String[] mExtensions \n HashMap<String,MimeType> EXTENSION_MAP \n MimeType ZIP \n MimeType MSPPT \n String[] NO_EXTS \n\n void init \n String getMimeType \n int hashCode \n String getMediaSubtype \n boolean equals \n MimeType guessFromName \n MimeType guessFromName \n String getMediaType \n void main \n String toString \n String[] getExtensions \n HashMap getMap \n void register \n void register", "output": "String function ( String arg0 ) { int loc0 = arg0 . lastIndexOf ( '.' ) ; return ( loc0 != - 1 ) ? arg0 . substring ( loc0 + 1 ) . trim ( ) . toLowerCase ( ) : null ; }"}, {"instruction": "Generate java code\nset the location of the ocsp responder . ", "input": " Logger logger \n boolean enableOCSP \n KeyStore trustStore \n Collection<? extends CRL> crls \n String ocspResponderURL \n AtomicLong aliasCount \n boolean enableCRLDP \n int maxCertPathLength \n\n Collection<? extends CRL> getCrls \n void setEnableCRLDP \n int getMaxCertPathLength \n void setMaxCertPathLength \n String getOcspResponderURL \n boolean isEnableCRLDP \n void setEnableOCSP \n KeyStore getTrustStore \n boolean isEnableOCSP \n void validate \n String validate \n void validate \n void validate", "output": "void function ( String arg0 ) { arg0 = arg0 ; }"}, {"instruction": "Generate java code\nthe value gives a rough estimate of the largest cube-map texture that the gl can handle . the value must be at least 1024 . ", "input": " int mMaxTextureSize \n int mMaxTextureImageUnits \n int mMaxCombinedTextureImageUnits \n int mMaxAliasedPointSize \n int mMaxFragmentUniformVectors \n int mMaxCubeMapTextureSize \n int mMaxRenderbufferSize \n int mMaxVertexUniformVectors \n int mMinAliasedLineWidth \n int mMaxVertexTextureImageUnits \n int[] mParam \n int mMaxAliasedLineWidth \n Capabilities instance \n int mMaxViewportHeight \n int mMaxViewportWidth \n int mMinAliasedPointSize \n int mMaxVertexAttribs \n int mMaxVaryingVectors \n\n int getMaxCombinedTextureUnits \n int getMaxViewportWidth \n int getMaxTextureImageUnits \n int getMaxTextureSize \n int getMaxVertexAttribs \n int getMaxVertexTextureImageUnits \n int getMaxVertexUniformVectors \n int getMinAliasedPointSize \n int getInt \n int getInt \n int getMaxRenderbufferSize \n int getMaxAliasedLineWidth \n int getMaxVaryingVectors \n int getMinAliasedLineWidth \n int getMaxViewportHeight \n int getMaxAliasedPointSize \n int getMaxFragmentUniformVectors \n String toString \n Capabilities getInstance \n void initialize", "output": "int function ( ) { return mMaxCubeMapTextureSize ; }"}, {"instruction": "Generate java code\nthe message properties ", "input": " String originalCorrelationId \n AsyncCallback callback \n Exchange exchange \n String correlationId \n byte[] message \n long timeout \n AMQP.BasicProperties properties \n\n String getCorrelationId \n String getOriginalCorrelationId \n boolean isTimeout \n byte[] getMessage \n Exchange getExchange \n long getRequestTimeout \n AsyncCallback getCallback", "output": "AMQP . BasicProperties function ( ) { return properties ; }"}, {"instruction": "Generate java code\nsets int value ", "input": " int packet_len \n byte[] packet \n\n long getSscr \n void setSscr \n boolean hasPadding \n void setExtension \n int getSequenceNumber \n byte[] getPacket \n boolean hasMarker \n void setBit \n long getTimestamp \n void setPayload \n void setPayloadType \n void setTimestamp \n void setPayloadLength \n boolean getBit \n int getVersion \n int getPayloadType \n void setPadding \n void init \n void init \n void init \n void setMarker \n void setVersion \n long[] getCscrList \n int getPayloadLength \n long getLong \n byte[] getPayload \n int getInt \n int getInt \n void setCscrList \n void setLong \n void setSequenceNumber \n int getLength \n boolean hasExtension \n int getCscrCount \n int getHeaderLength", "output": "void function ( int arg0 , byte [ ] arg1 , int arg2 , int arg3 ) { setLong ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nwarning log message . ", "input": " int WARN \n int VERBOSE \n int ERROR \n int LOGLEVEL \n int DEBUG \n int INFO \n\n boolean isLoggable \n void d \n void d \n void d \n void setLogLevel \n void setLogLevel \n void e \n void e \n void e \n void v \n void v \n void v \n void i \n void i \n void i", "output": "void function ( String arg0 , String arg1 , Throwable arg2 ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nreturn true if the base direction is left-to-right . ", "input": " BidiBase bidiBase \n int DIRECTION_DEFAULT_LEFT_TO_RIGHT \n int DIRECTION_LEFT_TO_RIGHT \n int DIRECTION_DEFAULT_RIGHT_TO_LEFT \n int DIRECTION_RIGHT_TO_LEFT \n\n int getRunLevel \n int getRunCount \n int getRunLimit \n boolean isMixed \n int getBaseLevel \n boolean isRightToLeft \n boolean requiresBidi \n boolean isLeftToRight \n void reorderVisually \n Bidi createLineBidi \n int getLevelAt \n int getLength \n String toString \n int getRunStart", "output": "boolean function ( ) { return bidiBase . baseIsLeftToRight ( ) ; }"}, {"instruction": "Generate java code\nretrieve the url where the user should be redirected to start the openid authentication process ", "input": " PlaceHolder placeHolder \n\n CompletionStage<UserInfo> verifiedId \n OpenIdClient client", "output": "CompletionStage < String > function ( String arg0 , String arg1 , Map < String , String > arg2 ) { return client ( ) . redirectURL ( arg0 , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nrun a given command in a subprocess , including threads to copy its stdout and stderr to our stdout and stderr . ", "input": " Socket clientSocket \n OutputHandler<K2,V2> handler \n boolean WINDOWS \n Process process \n DownwardProtocol<K1,V1> downlink \n Log LOG \n ServerSocket serverSocket \n\n String createDigest \n void waitForAuthentication \n void abort \n void cleanup \n DownwardProtocol<K1,V1> getDownlink \n void writePasswordToLocalFile \n String getSecurityChallenge \n boolean waitForFinish", "output": "Process function ( List < String > arg0 , Map < String , String > arg1 ) { ProcessBuilder loc0 = new ProcessBuilder ( arg0 ) ; if ( arg1 != null ) { loc0 . environment ( ) . putAll ( arg1 ) ; } Process loc1 = loc0 . start ( ) ; return loc1 ; }"}, {"instruction": "Generate java code\nset whether this request is allowed to load icons from non http s urls e.g. the omni.ja . for example web content referencing internal urls should not lead to us loading icons from internal data structures like the omni.ja . ", "input": " IconRequest internal \n\n IconRequestBuilder privileged \n IconRequestBuilder skipNetwork \n void deferBuild \n IconRequestBuilder skipDisk \n IconRequestBuilder skipMemory \n IconRequestBuilder executeCallbackOnBackgroundThread \n IconRequest build \n IconRequestBuilder icon \n IconRequestBuilder forLauncherIcon \n IconRequestBuilder pageUrl \n IconRequestBuilder skipNetworkIf \n IconRequestBuilder prepareOnly", "output": "IconRequestBuilder function ( boolean arg0 ) { internal . arg0 = arg0 ; return this ; }"}, {"instruction": "Generate java code\nreturns a segment body corresponding to a header . if no cache is configured or there is an error while querying the cache , null is returned none the less . ", "input": " SegmentCache cache \n Logger LOGGER \n boolean supportsRichIndex \n Thread cacheMgrThread \n\n List<SegmentCache> initCache \n List<SegmentHeader> getSegmentHeaders \n boolean supportsRichIndex \n void checkThread \n SegmentCache instantiateCache \n void put \n boolean remove \n void shutdown", "output": "SegmentBody function ( SegmentHeader arg0 ) { checkThread ( ) ; try { return cache . get ( arg0 ) ; } catch ( Throwable loc0 ) { LOGGER . error ( MondrianResource . instance ( ) . SegmentCacheFailedToLoadSegment . baseMessage , loc0 ) ; throw MondrianResource . instance ( ) . SegmentCacheFailedToLoadSegment . ex ( loc0 ) ; } }"}, {"instruction": "Generate java code\ndeletes the user tracker path from the database . also notifies the appropriate model listeners . ", "input": " UserTrackerPathLocalService _service \n\n java.lang.String getOSGiServiceIdentifier \n com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery getActionableDynamicQuery \n com.liferay.portal.kernel.model.UserTrackerPath getUserTrackerPath \n com.liferay.portal.kernel.dao.orm.DynamicQuery dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n int getUserTrackerPathsCount \n UserTrackerPathLocalService getService \n com.liferay.portal.kernel.model.UserTrackerPath createUserTrackerPath \n com.liferay.portal.kernel.model.UserTrackerPath updateUserTrackerPath \n long dynamicQueryCount \n long dynamicQueryCount \n com.liferay.portal.kernel.model.PersistedModel deletePersistedModel \n com.liferay.portal.kernel.model.UserTrackerPath fetchUserTrackerPath \n com.liferay.portal.kernel.model.PersistedModel getPersistedModel \n com.liferay.portal.kernel.model.UserTrackerPath addUserTrackerPath \n com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery getIndexableActionableDynamicQuery \n java.util.List<com.liferay.portal.kernel.model.UserTrackerPath> getUserTrackerPaths \n java.util.List<com.liferay.portal.kernel.model.UserTrackerPath> getUserTrackerPaths", "output": "com . liferay . portal . kernel . model . UserTrackerPath function ( com . liferay . portal . kernel . model . UserTrackerPath arg0 ) { return getService ( ) . deleteUserTrackerPath ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the parent object in the object tree representing the unmarshalled xml document . ", "input": " Long queryTableFieldId \n Object parent \n String dataCellStyle \n CTXmlColumnPr xmlColumnPr \n CTExtensionList extLst \n String headerRowCellStyle \n Long totalsRowDxfId \n String uniqueName \n CTTableFormula calculatedColumnFormula \n String totalsRowCellStyle \n STTotalsRowFunction totalsRowFunction \n String name \n String totalsRowLabel \n long id \n CTTableFormula totalsRowFormula \n Long headerRowDxfId \n Long dataDxfId \n\n void setName \n Long getHeaderRowDxfId \n String getName \n void setCalculatedColumnFormula \n void afterUnmarshal \n Long getDataDxfId \n long getId \n void setUniqueName \n void setTotalsRowLabel \n String getTotalsRowCellStyle \n String getTotalsRowLabel \n void setExtLst \n void setId \n Long getTotalsRowDxfId \n void setParent \n void setDataDxfId \n void setTotalsRowDxfId \n void setTotalsRowCellStyle \n CTExtensionList getExtLst \n void setTotalsRowFormula \n STTotalsRowFunction getTotalsRowFunction \n CTXmlColumnPr getXmlColumnPr \n void setXmlColumnPr \n void setHeaderRowCellStyle \n String getDataCellStyle \n CTTableFormula getTotalsRowFormula \n void setHeaderRowDxfId \n void setQueryTableFieldId \n CTTableFormula getCalculatedColumnFormula \n String getHeaderRowCellStyle \n String getUniqueName \n Long getQueryTableFieldId \n void setDataCellStyle \n void setTotalsRowFunction", "output": "Object function ( ) { return this . parent ; }"}, {"instruction": "Generate java code\nsets the scale for a marker icon ", "input": " MarkerOptions mMarkerOptions \n float mMarkerColor \n int HSV_VALUES \n HashSet<String> mStylesSet \n String mStyleId \n HashMap<String,String> mBalloonOptions \n boolean mOutline \n boolean mIconRandomColorMode \n boolean mFill \n String mIconUrl \n int HUE_VALUE \n boolean mLineRandomColorMode \n int INITIAL_SCALE \n PolylineOptions mPolylineOptions \n boolean mPolyRandomColorMode \n double mScale \n PolygonOptions mPolygonOptions \n\n int computeRandomColor \n double getIconScale \n void setLineColorMode \n MarkerOptions getMarkerOptions \n PolygonOptions getPolygonOptions \n void setIconColorMode \n PolygonOptions createPolygonOptions \n void setOutline \n void setFill \n void setMarkerColor \n boolean isLineRandomColorMode \n void setStyleId \n boolean isPolyRandomColorMode \n void setInfoWindowText \n void setHotSpot \n boolean isIconRandomColorMode \n void setIconUrl \n String convertColor \n float getHueValue \n void setHeading \n PolylineOptions getPolylineOptions \n PolylineOptions createPolylineOptions \n void setWidth \n void setFillColor \n MarkerOptions createMarkerOptions \n String getStyleId \n HashMap<String,String> getBalloonOptions \n boolean isStyleSet \n boolean hasBalloonStyle \n void setOutlineColor \n boolean hasFill \n String getIconUrl \n String toString \n boolean hasOutline \n void setPolyColorMode", "output": "void function ( double arg0 ) { mScale = arg0 ; mStylesSet . add ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncheck if there 's at least one form parameter ", "input": " Boolean hasMore \n List<CodegenParameter> allParams \n String notes \n List<CodegenProperty> responseHeaders \n Set<String> imports \n Boolean isResponseBinary \n List<CodegenSecurity> authMethods \n Boolean hasConsumes \n String httpMethod \n Boolean hasProduces \n String path \n List<CodegenParameter> pathParams \n CodegenParameter bodyParam \n String nickname \n String operationIdLowerCase \n Boolean returnSimpleType \n String operationId \n Boolean hasParams \n Boolean returnTypeIsPrimitive \n String baseName \n List<Map<String,String>> consumes \n Boolean isListContainer \n String summary \n List<CodegenParameter> queryParams \n List<CodegenParameter> formParams \n Map<String,Object> vendorExtensions \n List<CodegenParameter> headerParams \n Boolean hasAuthMethods \n Boolean hasOptionalParams \n String defaultResponse \n String returnContainer \n String returnBaseType \n String discriminator \n List<String> tags \n Boolean isMapContainer \n List<Map<String,String>> examples \n Boolean subresourceOperation \n Boolean hasReference \n List<CodegenParameter> bodyParams \n List<Map<String,String>> produces \n List<CodegenResponse> responses \n Boolean isMultipart \n ExternalDocs externalDocs \n String returnType \n\n boolean getHasHeaderParams \n boolean getHasQueryParams \n boolean getHasPathParams \n boolean nonempty \n boolean getHasBodyParam", "output": "boolean function ( ) { return nonempty ( formParams ) ; }"}, {"instruction": "Generate java code\nadd a listener ", "input": " LinkedList<FilterListener<T>> listeners \n String name \n Listener listener \n ComplexAttribute attributes \n\n String getName \n AbstractAttribute getAttribute \n ComplexAttribute getAttributes \n void fireFilterChanged \n void attributeConstraintsChanged \n void addAttribute \n void removeFilterListener \n void attributeValueChanged \n String toExpressionString \n String getAttributeString \n boolean accept", "output": "void function ( FilterListener < T > arg0 ) { if ( ! listeners . contains ( arg0 ) ) listeners . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nremoves all the entries added into attributes . < p > returns a reference to this object so that method calls can be chained together . ", "input": " com.amazonaws.internal.SdkInternalMap<String,String> attributes \n\n GetEndpointAttributesResult withAttributes \n GetEndpointAttributesResult addAttributesEntry \n java.util.Map<String,String> getAttributes \n int hashCode \n boolean equals \n GetEndpointAttributesResult clone \n String toString \n void setAttributes", "output": "GetEndpointAttributesResult function ( ) { this . attributes = null ; return this ; }"}, {"instruction": "Generate java code\nwhether or not this step is visible within the progress bar . a step is only visible if it has been assigned a heading , otherwise it 's invisible ", "input": " String xmlBindingClassName \n String heading \n boolean workflowEditable \n String jspBindingClassName \n String processingClassName \n String COMPLETE_STEP \n String id \n String SELECT_COLLECTION_STEP \n int number \n\n String getProcessingClassName \n int getStepNumber \n void setStepNumber \n boolean isWorkflowEditable \n String getHeading \n String getJSPUIClassName \n String getId \n String getXMLUIClassName", "output": "boolean function ( ) { return ( ( heading != null ) && ( heading . length ( ) > 0 ) ) ; }"}, {"instruction": "Generate java code\nget a default java.util.concurrent.threadfactory . ", "input": " TimeUnit EXECUTOR_SERVICE_SHUTDOWN_TIMEOUT_TIMEUNIT \n ThreadFactory DEFAULT_THREAD_FACTORY \n long EXECUTOR_SERVICE_SHUTDOWN_TIMEOUT \n\n List<T> parallelize \n ThreadFactory newThreadFactory \n ThreadFactory newThreadFactory \n ThreadFactory newThreadFactory \n ThreadFactory newDaemonThreadFactory \n void shutdownExecutorService \n void shutdownExecutorService", "output": "ThreadFactory function ( ) { return DEFAULT_THREAD_FACTORY ; }"}, {"instruction": "Generate java code\nthis method is called when the database is closed . ", "input": " long last \n long start \n\n void exceptionThrown \n void init \n void test \n void setProgress \n void main \n void opened", "output": "void function ( ) { System . out . println ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nsets the value of the poradovecislo property . ", "input": " Integer poradoveCislo \n TUrceneCasoveObdobi urceneCasoveObdobi \n String nazevEvidenceDokumentu \n String evidencniCislo \n\n String getNazevEvidenceDokumentu \n void setEvidencniCislo \n TUrceneCasoveObdobi getUrceneCasoveObdobi \n void setUrceneCasoveObdobi \n void setNazevEvidenceDokumentu \n String getEvidencniCislo \n Integer getPoradoveCislo", "output": "void function ( Integer arg0 ) { this . poradoveCislo = arg0 ; }"}, {"instruction": "Generate java code\nhelper method - loads a testmodel from the given filename . ", "input": " String VALIDATION_TESTMODEL_DIR \n IModelSequencer sequencer \n\n ExecutionFlow loadExecutionFlowFromResource \n Statechart loadStatechartFromResource \n String getModelDirectory", "output": "Statechart function ( String arg0 ) { return AbstractTestModelsUtil . loadStatechart ( URI . createPlatformPluginURI ( arg0 , true ) ) ; }"}, {"instruction": "Generate java code\ndetects objects of different sizes in the input image . the detected objects are returned as a list of rectangles . the function is parallelized with the tbb library . note : python a face detection example using cascade classifiers can be found at opencv_source_code/samples/python2/facedetect.py ", "input": " long nativeObj \n\n boolean load_0 \n void detectMultiScale_3 \n boolean load \n long CascadeClassifier_1 \n long CascadeClassifier_0 \n boolean empty_0 \n void finalize \n void detectMultiScale_1 \n void delete \n void detectMultiScale_2 \n boolean empty \n void detectMultiScale_0", "output": "void function ( Mat arg0 , MatOfRect arg1 , MatOfInt arg2 , MatOfDouble arg3 ) { Mat loc0 = arg1 ; Mat loc1 = arg2 ; Mat loc2 = arg3 ; detectMultiScale_3 ( nativeObj , arg0 . nativeObj , loc0 . nativeObj , loc1 . nativeObj , loc2 . nativeObj ) ; return ; }"}, {"instruction": "Generate java code\nreturns a string representation of this object ; useful for testing and debugging . ", "input": " java.util.List<Suite> suites \n String nextToken \n\n void setNextToken \n void setSuites \n int hashCode \n java.util.List<Suite> getSuites \n boolean equals \n ListSuitesResult withSuites \n ListSuitesResult withSuites \n ListSuitesResult clone \n String getNextToken \n ListSuitesResult withNextToken", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( \"srini_string\" ) ; if ( getSuites ( ) != null ) loc0 . append ( \"srini_string\" + getSuites ( ) + \"srini_string\" ) ; if ( getNextToken ( ) != null ) loc0 . append ( \"srini_string\" + getNextToken ( ) ) ; loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\ngetting current trace interface for actor system ", "input": " float THREAD_MULTIPLIER \n int THREAD_MAX_COUNT \n ActorSystem mainSystem \n HashMap<String,ActorDispatcher> dispatchers \n TraceInterface traceInterface \n String DEFAULT_DISPATCHER \n\n ActorSystem system \n void addDispatcher \n void addDispatcher \n void setTraceInterface \n ActorRef actorOf \n ActorRef actorOf \n ActorRef actorOf \n ActorRef actorOf \n ActorRef actorOf \n ActorRef actorOf \n ActorRef actorOf \n ActorRef actorOf", "output": "TraceInterface function ( ) { return traceInterface ; }"}, {"instruction": "Generate java code\nadd one new element to the set . ", "input": " AtomicReference<Provider<T>> ref \n Provider<T> item \n CopyOnWriteArrayList<AtomicReference<Provider<T>>> items \n Key<T> key \n\n Key<T> getKey \n DynamicSet<T> emptySet \n Iterator<T> iterator \n boolean contains \n LinkedBindingBuilder<T> bind \n LinkedBindingBuilder<T> bind \n LinkedBindingBuilder<T> bind \n LinkedBindingBuilder<T> bind \n ReloadableHandle replace \n void setOf \n void setOf \n void remove", "output": "RegistrationHandle function ( final T arg0 ) { return add ( Providers . of ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nindicates whether a score computation is needed for the given advocates . ", "input": " long serialVersionUID \n HashSet<Integer> defaultScores \n Integer minDecoysInBin \n HashMap<Integer,HashSet<Integer>> spectrumMatchingScores \n\n void clearScores \n void setDefaultScores \n void setDecoysInFirstBin \n Integer getDecoysInFirstBin \n void clearAllScores \n String getShortDescription \n HashSet<Integer> getDefaultScores \n void addScore \n boolean equals \n Set<Integer> getAdvocates \n HashSet<Integer> getScoreForAlgorithm \n boolean isTargetDecoyNeededForPsmScoring", "output": "boolean function ( ArrayList < Integer > arg0 ) { if ( spectrumMatchingScores != null && ! spectrumMatchingScores . isEmpty ( ) ) { for ( Integer loc0 : arg0 ) { if ( PsmScoringPreferences . this . isScoringNeeded ( loc0 ) ) { return true ; } } } return false ; }"}, {"instruction": "Generate java code\nassert a changed file has staged changes and no unstaged changes . ", "input": " IPath fPath \n GitRepository fRepo \n\n void assertRefresh \n void assertRefresh \n void assertDeletedUnstagedFile \n void assertCurrentBranch \n void assertDeletedStagedFile \n void assertNewUnstagedFile \n void assertNewStagedFile \n void assertUnstaged \n void assertModifiedStagedFile \n GitRepository getRepo \n void assertStatus \n void delete \n void tearDown \n void assertStageFiles \n void assertUnstageFiles \n GitRepository createRepo \n GitRepository createRepo \n void assertModifiedUnstagedFile \n void assertSwitchBranch \n IGitRepositoryManager getGitRepositoryManager \n void assertCommit \n void assertCreateBranch \n IPath repoToGenerate", "output": "void function ( ChangedFile arg0 ) { assertTrue ( \"srini_string\" , arg0 . hasStagedChanges ( ) ) ; assertFalse ( \"srini_string\" , arg0 . hasUnstagedChanges ( ) ) ; }"}, {"instruction": "Generate java code\nreturns the asa of the residue in the complexed state ", "input": " Group g \n HashMap<Character,Double> tripeptAsa \n List<Double> atomAsaUs \n double asaC \n List<Double> atomAsaCs \n long serialVersionUID \n double asaU \n\n void setAsaU \n double getAsaU \n void addAtomAsaU \n double getBsaToAsaRatio \n double getRelativeAsaC \n List<Double> getAtomAsaUs \n int getGroupNoHSize \n void setAtomAsaUs \n double getBsa \n HashMap<Character,Double> initTriPeptAsas \n Group getGroup \n Object clone \n List<Double> getAtomAsaCs \n void setAtomAsaCs \n double getRelativeAsaU \n void addAtomAsaC \n void setAsaC", "output": "double function ( ) { return asaC ; }"}, {"instruction": "Generate java code\ncreates an instance of tostringhelper in the same manner as #tostringhelper object , but using the simple name of clazz instead of using aninstance 's object #getclass . note that in gwt , class names are often obfuscated . ", "input": " ValueHolder next \n ValueHolder holderTail \n String name \n String className \n boolean omitNullValues \n ValueHolder holderHead \n Object value \n\n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper add \n ToStringHelper omitNullValues \n ValueHolder addHolder \n ToStringHelper addHolder \n ToStringHelper addHolder \n T firstNonNull \n String toString \n ToStringHelper addValue \n ToStringHelper addValue \n ToStringHelper addValue \n ToStringHelper addValue \n ToStringHelper addValue \n ToStringHelper addValue \n ToStringHelper addValue", "output": "ToStringHelper function ( Class < ? > arg0 ) { return new ToStringHelper ( arg0 . getSimpleName ( ) ) ; }"}, {"instruction": "Generate java code\nchanges price of cat to a price given by parameter ", "input": " int quantity \n String color \n boolean trained \n String species \n double price \n int nextCatID \n String name \n double weight \n int id \n int age \n\n void haveLitter \n int getAge \n String getName \n int getQuantity \n double getWeight \n String getColor \n void increaseAge \n int getID \n void gainWeight \n String makeSound \n double getPrice \n String getSpecies \n void changeName \n void loseWeight \n int getNextID \n String toString", "output": "void function ( double arg0 ) { price = arg0 ; }"}, {"instruction": "Generate java code\nreturn a file pointing to the storage location for map tiles . ", "input": " String PREF_MYLOCATION_ENABLED \n int MAX_DISK_CACHE_BYTES \n String TILE_PATH \n String[] mapTileAssets \n String TAG \n\n DiskLruCache openDiskCache \n MarkerOptions createPartnerMarker \n void removeUnusedTiles \n void setMyLocationEnabled \n boolean hasTile \n boolean getMyLocationEnabled \n MarkerOptions createMosconeMarker \n boolean copyTileAsset \n MarkerOptions createSessionMarker \n MarkerOptions createLabelMarker \n boolean hasTileAsset \n void clearDiskCache", "output": "File function ( Context arg0 , String arg1 ) { File loc0 = new File ( arg0 . getFilesDir ( ) , TILE_PATH ) ; if ( ! loc0 . exists ( ) ) { loc0 . mkdirs ( ) ; } return new File ( loc0 , arg1 ) ; }"}, {"instruction": "Generate java code\nthis method is used to to set the unique identifier associated with this table . ", "input": " boolean m_resourceFlag \n String m_name \n ArrayList<Column> m_columns \n int m_id \n\n void setName \n void setResourceFlag \n void addColumn \n String getName \n boolean getResourceFlag \n int getID \n String toString \n List<Column> getColumns", "output": "void function ( int arg0 ) { m_id = arg0 ; }"}, {"instruction": "Generate java code\nget the name of broker to use for sending/receiving mqtt messages . ", "input": " String itemName \n MessageType messageType \n Logger logger \n String topic \n String TEMP_COLON_REPLACEMENT \n TransformationService transformationService \n String broker \n String transformationRule \n\n MessageType getMessageType \n String getTopic \n void setMessageType \n void setTopic \n void initTransformService \n String getItemName \n TransformationService getTransformationService \n void setTransformationRule \n String[] splitConfigurationString \n String getTransformationServiceParam \n void setBroker \n String getTransformationServiceName \n String getTransformationRule \n void setItemName \n void setTransformationService", "output": "String function ( ) { return broker ; }"}, {"instruction": "Generate java code\ntest of getmacnameresolvers method , of class adminservice . ", "input": " WaarIsWifiEJB waarIsWifiEJB \n EndpointMapping endpointMapping \n AdminService systemUnderTest \n\n void init \n void testPutMacNameResolversDelete \n void testProcessGet \n void testProcessGetRoot \n EndpointEntity newEndpointEntity \n void testProcessPost \n void testPutMacNameResolversUpdate", "output": "void function ( ) { when ( waarIsWifiEJB . getAllMacNameResolvers ( ) ) . thenReturn ( new ArrayList < MacNameResolverEntity > ( ) ) ; assertNotNull ( systemUnderTest . getMacNameResolvers ( ) ) ; }"}, {"instruction": "Generate java code\ngets the value of the chargebasislevel property . ", "input": " RateLevelBasisType rateLevelBasis \n ChargeBasisLevelType chargeBasisLevel \n CodAddTransportationChargeBasisType chargeBasis \n RateTypeBasisType rateTypeBasis \n\n RateLevelBasisType getRateLevelBasis \n void setRateLevelBasis \n RateTypeBasisType getRateTypeBasis \n CodAddTransportationChargeBasisType getChargeBasis \n void setChargeBasisLevel \n void setChargeBasis \n void setRateTypeBasis", "output": "ChargeBasisLevelType function ( ) { return chargeBasisLevel ; }"}, {"instruction": "Generate java code\ngets total number of completed executions of query . this value is actual only for local node . ", "input": " LongAdder8 sumTime \n LongAdder8 completed \n GridAtomicLong minTime \n double avgTime \n LongAdder8 fails \n long serialVersionUID \n GridAtomicLong maxTime \n LongAdder8 execs \n\n void writeExternal \n long minimumTime \n int executions \n long maximumTime \n double averageTime \n void readExternal \n void update \n String toString \n GridCacheQueryMetricsAdapter copy \n int fails", "output": "int function ( ) { return completed . intValue ( ) ; }"}, {"instruction": "Generate java code\nthis method sets item barcode . ", "input": " String itemBarcode \n String customerCode \n\n void setCustomerCode \n String getCustomerCode \n String getItemBarcode \n int hashCode \n boolean equals", "output": "void function ( String arg0 ) { this . itemBarcode = arg0 ; }"}, {"instruction": "Generate java code\ntransforms a resource uri into a shared access signature uri , by appending a shared access token . ", "input": " PlaceHolder placeHolder \n\n String getAccountName \n StorageCredentials tryParseCredentials \n StorageCredentials tryParseCredentials \n String toString", "output": "StorageUri function ( StorageUri arg0 ) { return this . transformUri ( arg0 , null ) ; }"}, {"instruction": "Generate java code\ngets the value of the type property . ", "input": " String type \n String value \n\n String getValue \n void setValue \n void setType", "output": "String function ( ) { return type ; }"}, {"instruction": "Generate java code\nutility method that resets the auction item list . this used for demo purposes as the auction items may need to be reset if the bids become too large or have expired . ", "input": " ArrayList<AuctionItem> auctionItems \n\n void initializeData \n boolean bidOnAuctionItem \n List<AuctionItem> getAllAuctionItems", "output": "void function ( ) { initializeData ( ) ; }"}, {"instruction": "Generate java code\nenqueue a task to be run later . ", "input": " Looper realObject \n Scheduler scheduler \n SoftThreadLocal<Looper> looperForThread \n boolean quit \n Thread myThread \n Thread MAIN_THREAD \n\n boolean hasQuit \n void pauseMainLooper \n void removeSyncBarrier \n void runToEndOfTasks \n void pauseLooper \n void idleConstantly \n void unPauseMainLooper \n void unPauseLooper \n boolean setPaused \n void runToNextTask \n void resetThreadLoopers \n void __constructor__ \n void loop \n Scheduler getScheduler \n Looper getMainLooper \n void unPause \n SoftThreadLocal<Looper> makeThreadLocalLoopers \n boolean isPaused \n int postSyncBarrier \n void idle \n void idle \n void doLoop \n void idleMainLooperConstantly \n void pause \n Looper myLooper \n boolean postAtFrontOfQueue \n void runOneTask \n Thread getThread \n void runPaused \n void reset \n void quit \n Looper createLooper \n void idleMainLooper", "output": "boolean function ( Runnable arg0 , long arg1 ) { if ( ! quit ) { scheduler . postDelayed ( arg0 , arg1 ) ; return true ; } else { return false ; } }"}, {"instruction": "Generate java code\ncreates a query for the given data set ", "input": " PlaceHolder placeHolder \n\n List getColumnList \n List getColumnList \n IBaseDataSetDesign getDataSetDesign \n QueryDefinition getQueryDefinition \n QueryDefinition getQueryDefinition \n QueryDefinition getQueryDefinition \n List generateComputedColumns \n void defineSourceDataSets", "output": "IPreparedQuery function ( DataEngine arg0 , DataSetHandle arg1 ) { return getPreparedQuery ( arg0 , arg1 , true ) ; }"}, {"instruction": "Generate java code\nreturn the lookuptable for this op . ", "input": " RenderingHints hints \n LookupTable lut \n\n BufferedImage filter \n WritableRaster filter \n Point2D getPoint2D \n Rectangle2D getBounds2D \n Rectangle2D getBounds2D \n RenderingHints getRenderingHints \n BufferedImage createCompatibleDestImage \n WritableRaster createCompatibleDestRaster", "output": "LookupTable function ( ) { return lut ; }"}, {"instruction": "Generate java code\nexecutes a single command via the bundled busybox executable ", "input": " HandlerThread mCallbackThread \n List<String> mLastOutput \n boolean mCommandRunning \n int mLastExitCode \n OnCommandResultListener commandResultListener \n Shell.Interactive mShell \n\n boolean startShell \n void waitForCommandFinished \n void dispose \n void finalize \n int execute \n void onCommandResult", "output": "int function ( String arg0 , List < String > arg1 ) { AssetUtil . extractBusybox ( ) ; return execute ( AssetUtil . BUSYBOX_FILE . getAbsolutePath ( ) + \"srini_string\" + arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nadds to the time taken to process a response at the scaling layer . ", "input": " ScalingMetricsTracker scalingMetricsTracker \n String DEFAULT_REQUEST_TYPE \n long roundTripTimeInMs \n long requestReceivedTime \n RestRequestMetrics defaultMetrics \n boolean failed \n AtomicLong requestProcessingTimeInMs \n AtomicLong responseProcessingWaitTimeInMs \n AtomicLong responseProcessingTimeInMs \n AtomicLong requestProcessingWaitTimeInMs \n NioMetricsTracker nioMetricsTracker \n AtomicBoolean metricsRecorded \n RestRequestMetrics metrics \n\n void markFailure \n void markRequestCompleted \n void markRequestCompleted \n long addToRequestProcessingTime \n long addToRequestProcessingTime \n long addToResponseProcessingWaitTime \n void recordMetrics \n long addToRequestProcessingWaitTime \n void injectMetrics \n void markRequestReceived \n void markRequestReceived \n void setDefaults", "output": "long function ( long arg0 ) { return responseProcessingTimeInMs . addAndGet ( arg0 ) ; }"}, {"instruction": "Generate java code\nan array of structures that represent the workspaces that could not be created . note : this method appends the values to the existing list if any . use #setfailedrequests java.util.collection or #withfailedrequests java.util.collection if you want to overridethe existing values . ", "input": " com.amazonaws.internal.SdkInternalList<Workspace> pendingRequests \n com.amazonaws.internal.SdkInternalList<FailedCreateWorkspaceRequest> failedRequests \n\n CreateWorkspacesResult withPendingRequests \n CreateWorkspacesResult withPendingRequests \n java.util.List<FailedCreateWorkspaceRequest> getFailedRequests \n java.util.List<Workspace> getPendingRequests \n int hashCode \n boolean equals \n CreateWorkspacesResult clone \n void setFailedRequests \n String toString \n void setPendingRequests", "output": "CreateWorkspacesResult function ( FailedCreateWorkspaceRequest ... arg0 ) { if ( this . failedRequests == null ) { setFailedRequests ( new com . amazonaws . internal . SdkInternalList < FailedCreateWorkspaceRequest > ( arg0 . length ) ) ; } for ( FailedCreateWorkspaceRequest loc0 : arg0 ) { this . failedRequests . add ( loc0 ) ; } return this ; }"}, {"instruction": "Generate java code\nretrieve the tag object associated with this actionmode . like the tag available to views , this allows applications to associate arbitrary data with an actionmode for later reference . ", "input": " Object mTag \n\n boolean onCreateActionMode \n void setCustomView \n CharSequence getSubtitle \n void onDestroyActionMode \n void setTitle \n void setTitle \n void invalidate \n boolean isUiFocusable \n CharSequence getTitle \n View getCustomView \n Menu getMenu \n MenuInflater getMenuInflater \n void setTag \n void finish \n void setSubtitle \n void setSubtitle \n boolean onActionItemClicked \n boolean onPrepareActionMode", "output": "Object function ( ) { return mTag ; }"}, {"instruction": "Generate java code\nconvenient call for abstractdao #deleteall . ", "input": " Map<Class<?>,AbstractDao<?,?>> entityToDao \n SQLiteDatabase db \n\n V callInTxNoException \n long insert \n void refresh \n void update \n void runInTx \n List<T> loadAll \n Collection<AbstractDao<?,?>> getAllDaos \n long insertOrReplace \n void delete \n SQLiteDatabase getDatabase \n T load \n AbstractDao<?,?> getDao \n List<T> queryRaw \n void registerDao \n V callInTx \n AsyncSession startAsyncSession \n QueryBuilder<T> queryBuilder", "output": "void function ( Class < T > arg0 ) { @ SuppressWarnings ( \"srini_string\" ) AbstractDao < T , ? > loc0 = ( AbstractDao < T , ? > ) getDao ( arg0 ) ; loc0 . deleteAll ( ) ; }"}, {"instruction": "Generate java code\nread a short value from the specified byte array , starting at start . this version of the method reads the highest byte first . ", "input": " PlaceHolder placeHolder \n\n byte[] longToByte \n byte[] longToByte \n int byteToIntH \n long byteToLong \n byte[] shortToByte \n byte[] shortToByteH \n byte[] intToByteH \n short byteToShort \n byte[] intToByte \n void main \n int byteToInt", "output": "short function ( final byte [ ] arg0 , final int arg1 ) { return ( short ) ( ( ( arg0 [ arg1 ] & 0xff ) << 8 ) | ( arg0 [ arg1 + 1 ] & 0xff ) ) ; }"}, {"instruction": "Generate java code\nget the identity portion of this uid . ", "input": " MuLong COUNTER \n long time \n long id \n\n long getTime \n int hashCode \n boolean equals \n Object clone \n String toString \n String asString", "output": "long function ( ) { return id ; }"}, {"instruction": "Generate java code\nsample_has_redundancy takes one of the following four values : 0 : it is unknown whether there is redundant coding in this sample ; 1 : there is redundant coding in this sample ; 2 : there is no redundant coding in this sample ; 3 : reserved ", "input": " int sampleDegradationPriority \n int samplePaddingValue \n int reserved \n int sampleIsDependedOn \n int sampleHasRedundancy \n int sampleDependsOn \n boolean sampleIsDifferenceSample \n\n int getSampleDependsOn \n int getSampleDegradationPriority \n int getSampleHasRedundancy \n void setSampleDependsOn \n void getContent \n int getReserved \n void setSampleDegradationPriority \n int getSamplePaddingValue \n void setSampleIsDifferenceSample \n void setSampleIsDependedOn \n int hashCode \n int getSampleIsDependedOn \n boolean equals \n void setReserved \n void setSamplePaddingValue \n String toString \n boolean isSampleIsDifferenceSample", "output": "void function ( int arg0 ) { this . sampleHasRedundancy = arg0 ; }"}, {"instruction": "Generate java code\nsets the minimal number of unique peptides required for a protein , ignored if negative . ", "input": " double ratioResolution \n boolean ignoreNullIntensities \n MatchValidationLevel peptideValidation \n MatchValidationLevel psmValidation \n boolean ignoreMissedCleavages \n double percentile \n int minUnique \n HashSet<String> excludingPTM \n MatchValidationLevel proteinValidation \n\n void addExcludingPtm \n void setProteinValidationLevel \n void setPeptideValidationLevel \n boolean isIgnoreMissedCleavages \n int getMinUnique \n void emptyPTMList \n MatchValidationLevel getPeptideValidationLevel \n boolean isIgnoreNullIntensities \n void setPercentile \n void setIgnoreMissedCleavages \n void setIgnoreNullIntensities \n void setPsmValidationLevel \n boolean isSameAs \n RatioEstimationSettings clone \n double getRatioResolution \n MatchValidationLevel getProteinValidationLevel \n void setRatioResolution \n MatchValidationLevel getPsmValidationLevel \n double getPercentile \n HashSet<String> getExcludingPtms", "output": "void function ( int arg0 ) { this . minUnique = arg0 ; }"}, {"instruction": "Generate java code\nconfigures eclipse wtp information for examples see docs for eclipsewtp ", "input": " EclipseWtp wtp \n EclipseClasspath classpath \n EclipseProject project \n EclipseJdt jdt \n\n EclipseClasspath getClasspath \n void setClasspath \n void wtp \n void setWtp \n void pathVariables \n void classpath \n void project \n void setProject \n void setJdt \n void jdt \n EclipseJdt getJdt \n EclipseProject getProject", "output": "EclipseWtp function ( ) { return wtp ; }"}, {"instruction": "Generate java code\nthe default implementation does nothing . ", "input": " PlaceHolder placeHolder \n\n void visitErrorNode \n void enterProgram \n void visitTerminal \n void exitSends_to_tl \n void enterEveryRule \n void enterSends_to_tl \n void exitProgram", "output": "void function ( @ NotNull ParserRuleContext arg0 ) { }"}, {"instruction": "Generate java code\nget a database connection instance from the identity persistence manager ", "input": " Log log \n boolean isKeyCacheInistialized \n\n Cache getKeyManagerCache \n void removeFromKeyManagerCache \n String getTenantDomainFromTenantId \n API getAPI \n Map<String,String> constructParameterMap \n APIKeyValidationInfoDTO getFromKeyManagerCache \n void writeToKeyManagerCache", "output": "Connection function ( ) { return IdentityDatabaseUtil . getDBConnection ( ) ; }"}, {"instruction": "Generate java code\nset the current error message for this download . ", "input": " String mUrl \n String mErrorMessage \n String mFileName \n DownloadRunnable mRunnable \n Notification mNotification \n int mProgress \n boolean mIsAborted \n boolean mIsFinished \n NotificationManager mNotificationManager \n int mNotificationId \n Context mContext \n\n void onProgress \n void onFinished \n void startDownload \n void abortDownload \n void updateNotificationOnEnd \n boolean isFinished \n int getProgress \n String getUrl \n void createNotification \n void updateFileName \n void onStart \n String getFilePath \n String getFileName \n void checkFileName \n String getErrorMessage \n boolean isAborted", "output": "void function ( String arg0 ) { mErrorMessage = arg0 ; }"}, {"instruction": "Generate java code\nsets the mvcc version of this user group group role . ", "input": " UserGroupGroupRole _userGroupGroupRole \n\n boolean isFinderCacheEnabled \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setGroupId \n boolean isEscapedModel \n boolean isCachedModel \n ExpandoBridge getExpandoBridge \n long getRoleId \n int compareTo \n UserGroupGroupRole getWrappedModel \n long getGroupId \n void setModelAttributes \n long getMvccVersion \n void setRoleId \n Map<String,Object> getModelAttributes \n CacheModel<UserGroupGroupRole> toCacheModel \n int hashCode \n void setUserGroupId \n UserGroupGroupRole toUnescapedModel \n void setPrimaryKey \n void persist \n boolean isEntityCacheEnabled \n void setNew \n void resetOriginalValues \n Role getRole \n UserGroup getUserGroup \n boolean isNew \n long getUserGroupId \n Serializable getPrimaryKeyObj \n Class<?> getModelClass \n UserGroupGroupRole toEscapedModel \n com.liferay.portal.kernel.service.persistence.UserGroupGroupRolePK getPrimaryKey \n long getCompanyId \n Group getGroup \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n void setCachedModel \n java.lang.String toString \n String getModelClassName \n void setCompanyId", "output": "void function ( long arg0 ) { _userGroupGroupRole . setMvccVersion ( arg0 ) ; }"}, {"instruction": "Generate java code\ngetstatus - getter ", "input": " String image \n ParseUser friendUser \n boolean isOnline \n double lastLongitude \n String MODEL \n String name \n String objectId \n double lastLatitude \n String email \n int status \n boolean tracking \n\n String getName \n void enableTracking \n String getId \n boolean isOnline \n void disableTracking \n int compareTo \n boolean isTrackingEnabled \n void setStatus \n ParseUser getUserByEmail \n void setIsOnline \n void setCoordinates \n String getEmail \n String toString \n double[] getCoordinateArray", "output": "int function ( ) { return this . status ; }"}, {"instruction": "Generate java code\ncreate an instance of organismtype.lineage ", "input": " QName _Copyright_QNAME \n\n ProteinType.AlternativeName createProteinTypeAlternativeName \n SourceType createSourceType \n CommentType.TemperatureDependence createCommentTypeTemperatureDependence \n EvidencedStringType createEvidencedStringType \n PersonType createPersonType \n ProteinType.RecommendedName createProteinTypeRecommendedName \n ProteinType createProteinType \n ImportedFromType createImportedFromType \n FeatureType createFeatureType \n ProteinType.SubmittedName createProteinTypeSubmittedName \n ReferenceType createReferenceType \n ConsortiumType createConsortiumType \n InteractantType createInteractantType \n CommentType.Conflict createCommentTypeConflict \n CommentType createCommentType \n KeywordType createKeywordType \n CommentType.Disease createCommentTypeDisease \n IsoformType.Name createIsoformTypeName \n CommentType.Link createCommentTypeLink \n ProteinType.Domain createProteinTypeDomain \n CommentType.PhDependence createCommentTypePhDependence \n CommentType.Absorption createCommentTypeAbsorption \n MoleculeType createMoleculeType \n NameListType createNameListType \n CofactorType createCofactorType \n OrganismNameType createOrganismNameType \n GeneNameType createGeneNameType \n SubcellularLocationType createSubcellularLocationType \n SourceDataType.Tissue createSourceDataTypeTissue \n IsoformType.Sequence createIsoformTypeSequence \n SourceDataType.Transposon createSourceDataTypeTransposon \n CommentType.RedoxPotential createCommentTypeRedoxPotential \n EvidenceType createEvidenceType \n ProteinExistenceType createProteinExistenceType \n GeneLocationType createGeneLocationType \n GeneType createGeneType \n DbReferenceType createDbReferenceType \n EventType createEventType \n SourceDataType.Plasmid createSourceDataTypePlasmid \n IsoformType createIsoformType \n ProteinType.Component createProteinTypeComponent \n SequenceType createSequenceType \n CommentType.Kinetics createCommentTypeKinetics \n CitationType createCitationType \n JAXBElement<String> createCopyright \n PositionType createPositionType \n OrganismType createOrganismType \n LocationType createLocationType \n Uniprot createUniprot \n CommentType.Conflict.Sequence createCommentTypeConflictSequence \n SourceDataType createSourceDataType \n Entry createEntry \n SourceDataType.Strain createSourceDataTypeStrain \n StatusType createStatusType \n PropertyType createPropertyType", "output": "OrganismType . Lineage function ( ) { return new OrganismType . Lineage ( ) ; }"}, {"instruction": "Generate java code\nthis is a static access kill-switch . all of the static shortcut methods in this class will not work if this property is set to false . by default it is set to true . ", "input": " String SYSTEM_PROPERTIES_SETTING \n String AUTO_DOWNLOAD_SETTING \n String DISABLE_CHECKSUMS_SETTING \n GrapeEngine instance \n boolean enableAutoDownload \n boolean enableGrapes \n boolean disableChecksums \n\n void setEnableGrapes \n void addResolver \n URI[] resolve \n URI[] resolve \n Map<String,Map<String,List<String>>> enumerateGrapes \n boolean getEnableAutoDownload \n void setDisableChecksums \n GrapeEngine getInstance \n void grab \n void grab \n void grab \n Map[] listDependencies \n void setEnableAutoDownload \n boolean getDisableChecksums", "output": "boolean function ( ) { return enableGrapes ; }"}, {"instruction": "Generate java code\ncalculates a rank for a given modifier key . ", "input": " int UNKNOWN_KEY \n\n int compare \n int rankGNOME \n int rankMacOSX \n int rankWindows", "output": "int function ( ModifierKey arg0 ) { if ( Util . isWindows ( ) ) { return rankWindows ( arg0 ) ; } if ( Util . isGtk ( ) ) { return rankGNOME ( arg0 ) ; } if ( Util . isMac ( ) ) { return rankMacOSX ( arg0 ) ; } if ( Util . isMotif ( ) ) { return rankGNOME ( arg0 ) ; } return UNKNOWN_KEY ; }"}, {"instruction": "Generate java code\nget the reference instance . ", "input": " Reference reference \n long serialVersionUID \n Long first \n ResourceAdapter ra \n Boolean second \n\n void setSecond \n void setResourceAdapter \n void setFirst \n void setReference \n Long getFirst \n int hashCode \n boolean equals \n Boolean getSecond \n ResourceAdapter getResourceAdapter", "output": "Reference function ( ) { return reference ; }"}, {"instruction": "Generate java code\nreturns the left member of the pair ", "input": " S left \n T right \n long serialVersionUID \n\n T getRight \n int hashCode \n boolean equals \n boolean safeEquals \n String toString \n int compareTo", "output": "S function ( ) { return left ; }"}, {"instruction": "Generate java code\nretrieve a partial view of the ndarray . this method uses tensor along dimension internally note this will call dup ", "input": " AtomicReference<INDArray> arr \n AtomicInteger totalUpdates \n\n INDArray get \n int totalUpdates \n void setArray", "output": "INDArray function ( int arg0 , int ... arg1 ) { return arr . get ( ) . tensorAlongDimension ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nnotifies observers about data changing ", "input": " List<DataSetObserver> datasetObservers \n\n void unregisterDataSetObserver \n void registerDataSetObserver \n View getEmptyItem \n void notifyDataInvalidatedEvent", "output": "void function ( ) { if ( datasetObservers != null ) { for ( DataSetObserver loc0 : datasetObservers ) { loc0 . onChanged ( ) ; } } }"}, {"instruction": "Generate java code\nalways returns 1 - any field can live within 1 row . ", "input": " PlaceHolder placeHolder \n\n boolean isActionBlock \n void removeUnviewableBlocks \n void setEditableBlocks \n boolean isEmpty \n AccountingLineTableCell createTableCell \n void joinRow \n void performFieldTransformations \n void joinTable \n void removeAllActionBlocks \n boolean isHidden \n void readOnlyizeReadOnlyBlocks", "output": "int function ( ) { return 1 ; }"}, {"instruction": "Generate java code\nsets the value of the includeconfirmationstatement property . ", "input": " Boolean includeConfirmationStatement \n XMLGregorianCalendar monthlyPaymentEffectiveDate \n BigDecimal creditBalanceAfterReturn \n BigDecimal lastAmountOfPayment \n long serialVersionUID \n BigDecimal originalPlanCreditBalance \n XMLGregorianCalendar lastPaymentDueDate \n BigDecimal monthlyPaymentAfterReturn \n\n XMLGregorianCalendar getLastPaymentDueDate \n void setLastPaymentDueDate \n XMLGregorianCalendar getMonthlyPaymentEffectiveDate \n BigDecimal getCreditBalanceAfterReturn \n BigDecimal getLastAmountOfPayment \n void setOriginalPlanCreditBalance \n Boolean isIncludeConfirmationStatement \n void setCreditBalanceAfterReturn \n BigDecimal getOriginalPlanCreditBalance \n BigDecimal getMonthlyPaymentAfterReturn \n void setMonthlyPaymentAfterReturn \n void setMonthlyPaymentEffectiveDate \n void setLastAmountOfPayment", "output": "void function ( Boolean arg0 ) { this . includeConfirmationStatement = arg0 ; }"}, {"instruction": "Generate java code\nread a list of integers from a bufferedreader . ", "input": " PlaceHolder placeHolder \n\n List<Integer> readIntegers \n List<Integer> readIntegers \n List<Long> readLongs \n List<Long> readLongs", "output": "List < String > function ( BufferedReader arg0 ) { List < String > loc0 = new ArrayList < String > ( ) ; String loc1 = \"srini_string\" ; try { while ( ( loc1 = arg0 . readLine ( ) ) != null ) loc0 . add ( loc1 . trim ( ) ) ; } catch ( IOException loc2 ) { throw new IOException ( \"srini_string\" + loc1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nresponds @value #error_message to the ok 200 response . ", "input": " String PATH_EXCEPTION \n Logger LOGGER \n String ERROR_MESSAGE \n\n Response testExceptionMapper", "output": "Response function ( Exception arg0 ) { LOGGER . info ( \"srini_string\" , arg0 ) ; return Response . ok ( ) . entity ( ERROR_MESSAGE ) . build ( ) ; }"}, {"instruction": "Generate java code\ngets the value of the filename property . ", "input": " String macroName \n String fileName \n Long fileSize \n Long assetId \n byte[] assetByteArray \n\n void setFileName \n Long getFileSize \n byte[] getAssetByteArray \n String getMacroName \n void setAssetId \n void setFileSize \n void setAssetByteArray \n void setMacroName \n Long getAssetId", "output": "String function ( ) { return fileName ; }"}, {"instruction": "Generate java code\nremoves the ve sinh cong trinh with the primary key from the database . also notifies the appropriate model listeners . ", "input": " VeSinhCongTrinhPersistence _persistence \n\n int countAll \n void cacheResult \n void cacheResult \n List<VeSinhCongTrinh> findWithDynamicQuery \n List<VeSinhCongTrinh> findWithDynamicQuery \n List<VeSinhCongTrinh> findWithDynamicQuery \n VeSinhCongTrinh update \n VeSinhCongTrinh update \n void clearCache \n void clearCache \n long countWithDynamicQuery \n java.util.List<vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh> findAll \n java.util.List<vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh> findAll \n java.util.List<vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh> findAll \n vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh fetchByPrimaryKey \n void removeAll \n VeSinhCongTrinhPersistence getPersistence \n vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh create \n vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh findByPrimaryKey \n void setPersistence \n vn.dtt.sol.ns.vesinhmoitruong.dao.model.VeSinhCongTrinh updateImpl", "output": "vn . dtt . sol . ns . vesinhmoitruong . dao . model . VeSinhCongTrinh function ( int arg0 ) { return getPersistence ( ) . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the datasetid value for this sdkdocument . ", "input": " java.lang.Integer dataSourceId \n java.lang.Integer dataSetId \n org.apache.axis.description.TypeDesc typeDesc \n java.lang.Object __equalsCalc \n java.lang.String name \n java.lang.String description \n boolean __hashCodeCalc \n java.lang.Integer id \n java.lang.String label \n java.lang.String state \n java.lang.String type \n java.lang.Integer engineId \n\n void setName \n org.apache.axis.description.TypeDesc getTypeDesc \n java.lang.String getLabel \n java.lang.String getName \n org.apache.axis.encoding.Deserializer getDeserializer \n void setEngineId \n java.lang.Integer getId \n void setDescription \n void setDataSourceId \n void setType \n java.lang.String getDescription \n java.lang.Integer getEngineId \n java.lang.Integer getDataSourceId \n java.lang.String getState \n org.apache.axis.encoding.Serializer getSerializer \n java.lang.String getType \n int hashCode \n boolean equals \n void setDataSetId \n void setId \n void setLabel \n void setState", "output": "java . lang . Integer function ( ) { return dataSetId ; }"}, {"instruction": "Generate java code\nreturns the class names of modules involved in creating this element . the first element index 0 is the class name of module that defined the element , and the last element is the class name of root module . ", "input": " ElementSource originalElementSource \n ModuleSource moduleSource \n Object declaringSource \n InMemoryStackTraceElement[] partialCallStack \n\n StackTraceElement[] getStackTrace \n Object getDeclaringSource \n String toString \n List<Integer> getModuleConfigurePositionsInStackTrace \n ElementSource getOriginalElementSource", "output": "List < String > function ( ) { return moduleSource . getModuleClassNames ( ) ; }"}, {"instruction": "Generate java code\nclears all internal data structures . ", "input": " Map<String,String> keyLocalizedLabels \n List<String> ordinalKeys \n Map<String,String> localizedLabelKeys \n Map<String,String> keyValues \n\n void add \n int getOrdinal \n String getValue \n String getKey \n int size \n String[] getElements \n String getLocalizedLabel \n Object getItem \n Object getItemObject", "output": "void function ( ) { this . ordinalKeys . clear ( ) ; this . keyValues . clear ( ) ; this . keyLocalizedLabels . clear ( ) ; this . localizedLabelKeys . clear ( ) ; }"}, {"instruction": "Generate java code\nchecking if in the row or in the column are all o and if are than prints message that player o is winner . ", "input": " PlaceHolder placeHolder \n\n boolean isRowX \n boolean getRowForO \n boolean isAllOColumn \n void printTicTacToeMatrix \n boolean checkDiagonalsO \n boolean isSideDiagonalO \n boolean checkRowsAndColumnsX \n boolean checkX \n String[][] playerXPlays \n boolean isMainDiagonalX \n boolean checkOutColumnForO \n boolean isAllXColumn \n void printMatrix \n String[][] playerOPlays \n boolean isRowO \n boolean getRowForX \n boolean checkOutColumnForX \n boolean isMainDiagonalO \n boolean isSideDiagonalX \n boolean checkDiagonalsX \n boolean checkO", "output": "boolean function ( String [ ] [ ] arg0 ) { boolean loc0 = isRowO ( arg0 ) ; if ( loc0 == true ) { System . out . println ( \"srini_string\" ) ; return true ; } boolean loc1 = isAllOColumn ( arg0 ) ; if ( loc1 == true ) { System . out . println ( \"srini_string\" ) ; return true ; } return false ; }"}, {"instruction": "Generate java code\nreturns the length of the word resulting from the stemming process . ", "input": " int i_end \n char[] b \n int INC \n int i \n int j \n int k \n\n void add \n void add \n void step6 \n void step4 \n void step5 \n boolean doublec \n boolean vowelinstem \n char[] getResultBuffer \n void step2 \n int m \n void step3 \n void step1 \n boolean cvc \n void r \n boolean ends \n void setto \n String toString \n boolean cons \n void stem", "output": "int function ( ) { return i_end ; }"}, {"instruction": "Generate java code\ncheck tc failed . ", "input": " String[] recoveryMethodNames \n int TIMEOUT \n SeleniumTestBase caller \n RecoveryThreadTask recovery \n long thresholdTimeout \n Timer timer \n String[] onerrorMethodNames \n\n void initRecoveryThreadClick \n void initRecoveryThreadClickAt \n void initRecoveryThreadDoubleClick \n void advice \n void initRecoveryThreadOpen \n void cancelRecoveryThread \n void initRecoveryThreadType \n void initRecoveryThreadDoubleClickAt \n void initiateRecoveryThread \n void getRecoveryMethodNames", "output": "void function ( final boolean arg0 ) { if ( arg0 ) { RecoveryThreadTask loc0 = new RecoveryThreadTask ( caller , recoveryMethodNames ) ; loc0 . run ( ) ; loc0 . cancel ( ) ; } }"}, {"instruction": "Generate java code\nwrite binay data to a file ", "input": " PlaceHolder placeHolder \n\n String readContentAsString \n String readContentAsString \n String readContentAsString \n String readContentAsString \n void copyDirectory \n byte[] readContent \n byte[] readContent \n List<String> readLines \n List<String> readLines \n List<String> readLines \n void writeContent \n void writeContent \n void writeContent \n void writeContent \n void copy \n Properties readUtf8Properties", "output": "void function ( byte [ ] arg0 , File arg1 ) { OutputStream loc0 = null ; try { loc0 = new FileOutputStream ( arg1 ) ; loc0 . write ( arg0 ) ; loc0 . flush ( ) ; } catch ( IOException loc1 ) { throw new UnexpectedException ( loc1 ) ; } finally { try { if ( loc0 != null ) loc0 . close ( ) ; } catch ( Exception loc1 ) { } } }"}, {"instruction": "Generate java code\nset the where slot of this event . ", "input": " String address \n String NAME \n String proto \n ContainerID where \n\n String getName \n void setAddress \n String getAddress \n ContainerID getWhere \n void setProto \n String getProto", "output": "void function ( ContainerID arg0 ) { where = arg0 ; }"}, {"instruction": "Generate java code\nset the view names or name patterns that can be handled by this view resolver . view names can contain simple wildcards such that ` my ' , ` report ' and ` repo ' will all match the view name ` myreport ' . ", "input": " UrlBasedViewResolver viewResolver \n\n UrlBasedViewResolverRegistration prefix \n UrlBasedViewResolverRegistration viewNames \n UrlBasedViewResolverRegistration suffix \n UrlBasedViewResolverRegistration viewClass \n UrlBasedViewResolver getViewResolver", "output": "UrlBasedViewResolverRegistration function ( String ... arg0 ) { this . viewResolver . setViewNames ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nfind the requested number of available udp ports , each randomly selected from the range @value #port_range_min , @value #port_range_max . ", "input": " int PORT_RANGE_MAX \n Random random \n int PORT_RANGE_MIN \n\n int findAvailableTcpPort \n int findAvailableTcpPort \n int findAvailableTcpPort \n SortedSet<Integer> findAvailableTcpPorts \n SortedSet<Integer> findAvailableTcpPorts \n boolean isPortAvailable \n boolean isPortAvailable \n boolean isPortAvailable \n int findRandomPort \n SortedSet<Integer> findAvailablePorts \n int findAvailablePort \n int findAvailableUdpPort \n int findAvailableUdpPort \n int findAvailableUdpPort", "output": "SortedSet < Integer > function ( int arg0 ) { return findAvailableUdpPorts ( arg0 , PORT_RANGE_MIN , PORT_RANGE_MAX ) ; }"}, {"instruction": "Generate java code\nallows subclasses to modify the login form url that should be applicable for a given request . ", "input": " String loginFormUrl \n boolean forceHttps \n boolean useForward \n Log logger \n RedirectStrategy redirectStrategy \n PortMapper portMapper \n PortResolver portResolver \n\n void commence \n RedirectStrategy getRedirectStrategy \n boolean isUseForward \n boolean isForceHttps \n void setUseForward \n void setLoginFormUrl \n String buildRedirectUrlToLoginPage \n void setForceHttps \n String buildHttpsRedirectUrlForRequest \n PortMapper getPortMapper \n PortResolver getPortResolver \n void setRedirectStrategy \n void afterPropertiesSet \n void setPortMapper \n String getLoginFormUrl \n void setPortResolver", "output": "String function ( HttpServletRequest arg0 , HttpServletResponse arg1 , AuthenticationException arg2 ) { return getLoginFormUrl ( ) ; }"}, {"instruction": "Generate java code\nreturns a string representation of this object ; useful for testing and debugging . ", "input": " String code \n String message \n\n CancelSpotFleetRequestsError withCode \n CancelSpotFleetRequestsError withCode \n int hashCode \n void setCode \n void setCode \n boolean equals \n CancelSpotFleetRequestsError clone \n String getMessage \n void setMessage \n String getCode \n CancelSpotFleetRequestsError withMessage", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( \"srini_string\" ) ; if ( getCode ( ) != null ) loc0 . append ( \"srini_string\" + getCode ( ) + \"srini_string\" ) ; if ( getMessage ( ) != null ) loc0 . append ( \"srini_string\" + getMessage ( ) ) ; loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nserialize an instance , restore it , and check for equality . ", "input": " PlaceHolder placeHolder \n\n void testCloning \n void testEquals", "output": "void function ( ) { TickLabelEntity loc0 = new TickLabelEntity ( new Rectangle2D . Double ( 1.0 , 2.0 , 3.0 , 4.0 ) , \"srini_string\" , \"srini_string\" ) ; TickLabelEntity loc1 = ( TickLabelEntity ) TestUtilities . serialised ( loc0 ) ; assertEquals ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\ngets the value of the expirefuturepriceplansind property . ", "input": " JAXBElement<String> sequenceNumber \n JAXBElement<String> dealerCode \n JAXBElement<BigInteger> monthsToExtend \n JAXBElement<Boolean> isRemoveAllConflictServices \n long serialVersionUID \n JAXBElement<String> deviceID \n JAXBElement<Boolean> validateIndicator \n JAXBElement<String> ban \n JAXBElement<String> planCode \n Boolean expireFuturePricePlansInd \n JAXBElement<Boolean> extendContract \n JAXBElement<Boolean> doProductCatalogCheck \n JAXBElement<String> imei \n JAXBElement<XMLGregorianCalendar> planEffectiveDate \n JAXBElement<Boolean> allAutoResolveIndicator \n\n void setImei \n void setExtendContract \n JAXBElement<String> getSequenceNumber \n JAXBElement<Boolean> getValidateIndicator \n void setDoProductCatalogCheck \n void setBan \n JAXBElement<String> getDeviceID \n JAXBElement<String> getBan \n JAXBElement<Boolean> getDoProductCatalogCheck \n JAXBElement<Boolean> getIsRemoveAllConflictServices \n void setPlanCode \n JAXBElement<Boolean> getExtendContract \n JAXBElement<Boolean> getAllAutoResolveIndicator \n void setMonthsToExtend \n JAXBElement<BigInteger> getMonthsToExtend \n void setDeviceID \n void setExpireFuturePricePlansInd \n JAXBElement<String> getPlanCode \n void setDealerCode \n void setValidateIndicator \n void setAllAutoResolveIndicator \n void setPlanEffectiveDate \n void setSequenceNumber \n void setIsRemoveAllConflictServices \n JAXBElement<String> getImei \n JAXBElement<String> getDealerCode \n JAXBElement<XMLGregorianCalendar> getPlanEffectiveDate", "output": "Boolean function ( ) { return expireFuturePricePlansInd ; }"}, {"instruction": "Generate java code\nused to communicate a progress update between a plugin tool and the main whitebox user interface . ", "input": " String[] args \n boolean cancelOp \n WhiteboxPluginHost myHost \n String previousProgressLabel \n int previousProgress \n boolean amIActive \n\n String getName \n void setPluginHost \n String[] getToolbox \n String getDescriptiveName \n void setCancelOp \n void returnData \n String getToolDescription \n void setArgs \n void run \n void cancelOperation \n boolean isActive \n void showFeedback", "output": "void function ( int arg0 ) { if ( myHost != null && arg0 != previousProgress ) { myHost . updateProgress ( arg0 ) ; } previousProgress = arg0 ; }"}, {"instruction": "Generate java code\nget the job id ", "input": " JobPriorityChange datum \n\n EventType getEventType \n Object getDatum \n void setDatum \n JobPriority getPriority", "output": "JobID function ( ) { return JobID . forName ( datum . getJobid ( ) . toString ( ) ) ; }"}, {"instruction": "Generate java code\ncreates an empty sortedset instance . ", "input": " PlaceHolder placeHolder \n\n HashSet<K> newHashSet \n HashSet<E> newHashSet", "output": "SortedSet < E > function ( ) { return new TreeSet < E > ( ) ; }"}, {"instruction": "Generate java code\nreturns the content of this vdoc logger . ", "input": " vdocLogger _vdocLogger \n\n void setExpandoBridgeAttributes \n void setContent \n void setGroupId \n boolean isEscapedModel \n vdocLogger getWrappedvdocLogger \n boolean isCachedModel \n com.liferay.portlet.expando.model.ExpandoBridge getExpandoBridge \n java.lang.String getLoggerId \n int compareTo \n vdocLogger getWrappedModel \n void setCreatedByUser \n void setLoggerId \n long getGroupId \n com.liferay.portal.model.CacheModel<com.vportal.portlet.vdoc.model.vdocLogger> toCacheModel \n int hashCode \n void setPrimaryKey \n void setUserUuid \n java.util.Date getCreatedDate \n void setNew \n java.lang.String getUserUuid \n void resetOriginalValues \n boolean isNew \n java.io.Serializable getPrimaryKeyObj \n Class<?> getModelClass \n java.lang.String getPrimaryKey \n com.vportal.portlet.vdoc.model.vdocLogger toEscapedModel \n void setCreatedDate \n long getCompanyId \n java.lang.String toXmlString \n void setPrimaryKeyObj \n java.lang.Object clone \n void setCachedModel \n long getCreatedByUser \n java.lang.String toString \n String getModelClassName \n void setCompanyId \n long getUserId \n void setUserId", "output": "java . lang . String function ( ) { return _vdocLogger . getContent ( ) ; }"}, {"instruction": "Generate java code\nif the service has completed return true ", "input": " int SERVICE_FINISHED \n Throwable t \n int SERVICE_FAILED \n int status \n int SERVICE_RUNNING \n boolean completed \n Map<String,Object> result \n String module \n\n Map<String,Object> getResult \n void receiveThrowable \n void receiveResult \n Throwable getThrowable \n int status \n Map<String,Object> waitForResult \n Map<String,Object> waitForResult", "output": "boolean function ( ) { return completed ; }"}, {"instruction": "Generate java code\ngets the value of the insttyp property . ", "input": " String instSrc \n List<SettlPartiesBlockT> pty \n DlvyInstTypeEnumT instTyp \n\n void setInstSrc \n String getInstSrc \n List<SettlPartiesBlockT> getPty \n void setInstTyp", "output": "DlvyInstTypeEnumT function ( ) { return instTyp ; }"}, {"instruction": "Generate java code\nserializes the message and writes it to output . ", "input": " int cachedSize \n\n int computeSerializedSize \n MessageNano mergeFrom \n T mergeFrom \n T mergeFrom \n boolean messageNanoEquals \n int getSerializedSize \n byte[] toByteArray \n void toByteArray \n MessageNano clone \n int getCachedSize \n String toString", "output": "void function ( CodedOutputByteBufferNano arg0 ) { }"}, {"instruction": "Generate java code\nprepends a task to the front of the queue and makes sure a worker thread is running , unless the queue has been suspended . ", "input": " boolean isWorkerRunning \n Deque<Runnable> queue \n Executor executor \n Object internalLock \n int suspensions \n Logger log \n\n void suspend \n void resume \n void startQueueWorker \n void run \n void workOnQueue \n void execute", "output": "void function ( Runnable arg0 ) { synchronized ( internalLock ) { queue . addFirst ( arg0 ) ; } startQueueWorker ( ) ; }"}, {"instruction": "Generate java code\nadd an attribute to this node , replacing any existing attribute with the same name . ", "input": " String name \n HashMap attributes \n TreeNode parent \n String body \n ArrayList children \n\n TreeNode findChild \n String findAttribute \n String getName \n String getBody \n Iterator findAttributes \n String toString \n void toString \n Iterator findChildren \n Iterator findChildren \n void removeAttribute \n void setBody \n void addChild \n void removeNode", "output": "void function ( String arg0 , String arg1 ) { if ( attributes == null ) attributes = new HashMap ( ) ; attributes . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the value of the integervalue property . ", "input": " String stringValue \n List<String> stringValues \n List<Double> doubleValues \n List<Boolean> booleanValues \n Long integerValue \n Boolean booleanValue \n Double doubleValue \n Long feedAttributeId \n List<Long> integerValues \n\n Boolean isBooleanValue \n String getStringValue \n void setBooleanValue \n Double getDoubleValue \n List<Boolean> getBooleanValues \n List<Double> getDoubleValues \n void setStringValue \n Long getIntegerValue \n Long getFeedAttributeId \n List<Long> getIntegerValues \n void setDoubleValue \n void setFeedAttributeId \n List<String> getStringValues", "output": "void function ( Long arg0 ) { this . integerValue = arg0 ; }"}, {"instruction": "Generate java code\nextracts the first word from a timezone displayname . ", "input": " DateFormat selectedFormat \n int[] pacificXCoords \n int[] nfldXCoords \n int[] easternYCoords \n int[] alaskaYCoords \n int[] pacificYCoords \n ArrayList allTimeZoneList \n int[] mountainXCoords \n TimeZone serverTimeZone \n int icefacesYOffset \n int[] hawaiiXCoords \n DateFormat serverFormat \n int[] easternXCoords \n int[] alaskaXCoords \n int[] nfldYCoords \n TimeZone selectedTimeZone \n int[] centralXCoords \n int[] centralYCoords \n int icefacesXOffset \n int[] hawaiiYCoords \n int[] mountainYCoords \n\n void init \n String getSelectedTime \n String getServerTimeZoneName \n DateFormat buildDateFormatForTimeZone \n String formatCurrentTime \n String getSelectedTimeZoneName \n TimeZoneWrapper getTimeZoneWrapperByComponentId \n String getServerTime \n void listen", "output": "String function ( String arg0 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } else { int loc0 = arg0 . indexOf ( ' ' ) ; if ( loc0 != - 1 ) { arg0 = arg0 . substring ( 0 , loc0 ) ; } } return arg0 ; }"}, {"instruction": "Generate java code\nreturns true if parameter type is a function and false otherwise . ", "input": " String name \n String type \n boolean required \n\n boolean isRequired \n String getName \n FunctionInfo getInfo \n String getType", "output": "boolean function ( ) { return TernTypeHelper . isFunction ( type ) ; }"}, {"instruction": "Generate java code\nset the name of the algorithm ", "input": " String BIN \n String DEC \n String OCT \n Format timestampFormatter \n char groupChar \n long length \n String encoding \n String separator \n String HEX_UPPERCASE \n String filename \n String BASE16 \n String BASE32 \n String BASE64 \n String name \n String timestampFormat \n String HEX \n String BUBBLEBABBLE \n long value \n int BUFFERSIZE \n int group \n long timestamp \n\n String getTimestampFormat \n String getName \n void setGrouping \n void update \n void update \n void update \n void update \n boolean isTimestampWanted \n void setFilename \n String getEncoding \n int hashCode \n long getTimestamp \n String getSeparator \n void setHex \n void setTimestamp \n void setGroupChar \n void setTimestampFormat \n void setSeparator \n long getValue \n void setGroup \n String getTimestampFormatted \n String getFilename \n void setUpperCase \n long readFile \n long readFile \n boolean equals \n int getGroup \n byte[] getByteArray \n boolean isGroupWanted \n void reset \n long getLength \n char getGroupChar", "output": "void function ( String arg0 ) { this . name = arg0 ; }"}, {"instruction": "Generate java code\ndefine el valor de la propiedad x509serialnumber . ", "input": " BigInteger x509SerialNumber \n String x509IssuerName \n\n void setX509IssuerName \n BigInteger getX509SerialNumber \n String getX509IssuerName", "output": "void function ( BigInteger arg0 ) { this . x509SerialNumber = arg0 ; }"}, {"instruction": "Generate java code\nis this fixture a sensor non-solid ? ", "input": " Object userData \n short[] tmp \n Shape shape \n Filter filter \n Body body \n long addr \n\n float getRestitution \n float jniGetRestitution \n Shape getShape \n boolean testPoint \n boolean testPoint \n boolean jniTestPoint \n void jniSetRestitution \n void setFilterData \n void jniSetFilterData \n void refilter \n boolean jniIsSensor \n void jniSetFriction \n void setFriction \n float jniGetFriction \n float getFriction \n Filter getFilterData \n void jniRefilter \n int jniGetType \n Body getBody \n void jniSetSensor \n void jniSetDensity \n float getDensity \n void setDensity \n void setSensor \n void setRestitution \n Type getType \n void jniGetFilterData \n void reset \n float jniGetDensity \n Object getUserData \n void setUserData \n long jniGetShape", "output": "boolean function ( ) { return jniIsSensor ( addr ) ; }"}, {"instruction": "Generate java code\nset the value for requestid . ", "input": " String rateLevel \n Integer requestId \n String confirmNote \n\n void setConfirmNote \n void setRateLevel \n String getConfirmNote \n String getRateLevel \n Integer getRequestId", "output": "void function ( Integer arg0 ) { this . requestId = arg0 ; }"}, {"instruction": "Generate java code\ndeletes the document library file rank from the database . also notifies the appropriate model listeners . ", "input": " DLFileRankLocalService _service \n\n com.liferay.portlet.documentlibrary.model.DLFileRank addDLFileRank \n com.liferay.portlet.documentlibrary.model.DLFileRank getDLFileRank \n com.liferay.portlet.documentlibrary.model.DLFileRank updateDLFileRank \n com.liferay.portlet.documentlibrary.model.DLFileRank updateDLFileRank \n java.util.List dynamicQuery \n java.util.List dynamicQuery \n java.util.List dynamicQuery \n java.util.List<com.liferay.portlet.documentlibrary.model.DLFileRank> getFileRanks \n void setBeanIdentifier \n DLFileRankLocalService getService \n java.lang.String getBeanIdentifier \n void setService \n long dynamicQueryCount \n com.liferay.portlet.documentlibrary.model.DLFileRank updateFileRank \n int getDLFileRanksCount \n void checkFileRanks \n com.liferay.portlet.documentlibrary.model.DLFileRank fetchDLFileRank \n com.liferay.portal.model.PersistedModel getPersistedModel \n void deleteFileRanksByUserId \n java.util.List<com.liferay.portlet.documentlibrary.model.DLFileRank> getDLFileRanks \n void deleteFileRank \n void deleteFileRank \n com.liferay.portlet.documentlibrary.model.DLFileRank addFileRank \n void deleteFileRanksByFileEntryId \n com.liferay.portlet.documentlibrary.model.DLFileRank createDLFileRank", "output": "com . liferay . portlet . documentlibrary . model . DLFileRank function ( com . liferay . portlet . documentlibrary . model . DLFileRank arg0 ) { return getService ( ) . deleteDLFileRank ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the class resolver used by this class . ", "input": " BarcodeUtil instance \n BarcodeClassResolver classResolver \n\n BarcodeGenerator createBarcodeGenerator \n BarcodeGenerator createBarcodeGenerator \n BarcodeUtil getInstance", "output": "BarcodeClassResolver function ( ) { return this . classResolver ; }"}, {"instruction": "Generate java code\nall bindings for #bindingkey that were resolved in #owningcomponent . ", "input": " Function<ResolvedBindings,Set<ContributionBinding>> CONTRIBUTION_BINDINGS \n\n ImmutableSet<? extends Binding> bindings \n Class<?> frameworkClass \n Binding binding \n boolean isMultibindingContribution \n ResolvedBindings forContributionBindings \n Optional<String> bindingPackage \n ImmutableMap<ComponentDescriptor,MembersInjectionBinding> allMembersInjectionBindings \n ImmutableSet<ContributionBinding> ownedContributionBindings \n BindingKey bindingKey \n Optional<Scope> scope \n ImmutableSet<MultibindingDeclaration> multibindingDeclarations \n ResolvedBindings forMembersInjectionBinding \n Key key \n BindingType bindingType \n Set<ContributionBinding> apply \n ContributionBinding contributionBinding \n Optional<MembersInjectionBinding> membersInjectionBinding \n boolean isEmpty \n Optional<MembersInjectionBinding> ownedMembersInjectionBinding \n ResolvedBindings asInheritedIn \n ResolvedBindings noBindings \n ContributionType contributionType \n ImmutableSetMultimap<ComponentDescriptor,ContributionBinding> allContributionBindings \n ImmutableSet<ContributionBinding> contributionBindings \n ComponentDescriptor owningComponent \n ComponentDescriptor owningComponent \n ImmutableList<Map.Entry<ComponentDescriptor,? extends Binding>> bindingsByComponent", "output": "ImmutableSet < ? extends Binding > function ( ) { switch ( bindingKey ( ) . kind ( ) ) { case CONTRIBUTION : return ownedContributionBindings ( ) ; case MEMBERS_INJECTION : return ImmutableSet . copyOf ( ownedMembersInjectionBinding ( ) . asSet ( ) ) ; default : throw new AssertionError ( bindingKey ( ) ) ; } }"}, {"instruction": "Generate java code\nsets the value of the actor property . ", "input": " String actor \n Boolean mustUnderstand \n String value \n\n String getValue \n Boolean isMustUnderstand \n void setValue \n void setMustUnderstand \n String getActor", "output": "void function ( String arg0 ) { this . actor = arg0 ; }"}, {"instruction": "Generate java code\ndefines the module class name . ", "input": " String moduleClass \n String patchLevel \n String majorVersion \n String minorVersion \n\n void setPatchLevel \n String getMajorVersion \n String getModuleClass \n int hashCode \n boolean equals \n String getMinorVersion \n String getPatchLevel \n String toString \n void setMajorVersion \n void setMinorVersion", "output": "void function ( final String arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } this . moduleClass = arg0 ; }"}, {"instruction": "Generate java code\nreturns a string representation of this object ; useful for testing and debugging . ", "input": " String nextToken \n java.util.List<Offering> offerings \n\n void setNextToken \n int hashCode \n boolean equals \n ListOfferingsResult clone \n java.util.List<Offering> getOfferings \n void setOfferings \n ListOfferingsResult withOfferings \n ListOfferingsResult withOfferings \n String getNextToken \n ListOfferingsResult withNextToken", "output": "String function ( ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0 . append ( \"srini_string\" ) ; if ( getOfferings ( ) != null ) loc0 . append ( \"srini_string\" + getOfferings ( ) + \"srini_string\" ) ; if ( getNextToken ( ) != null ) loc0 . append ( \"srini_string\" + getNextToken ( ) ) ; loc0 . append ( \"srini_string\" ) ; return loc0 . toString ( ) ; }"}, {"instruction": "Generate java code\nworks exactly like resourcebundle.getbundle string , locale . this is needed because the java method depends on a particular stack configuration that is not guaranteed in groovy when calling the java method . ", "input": " PlaceHolder placeHolder \n\n void sleep \n void sleep \n Thread createThread \n Matcher getLastMatcher \n Date parseToStringDate \n long currentTimeSeconds \n Thread start \n Thread start \n File createTempDir \n File createTempDir \n Date parse \n Date parse \n Thread startDaemon \n Thread startDaemon \n void sleepImpl", "output": "ResourceBundle function ( ResourceBundle arg0 , String arg1 , Locale arg2 ) { Class loc0 = ReflectionUtils . getCallingClass ( ) ; ClassLoader loc1 = loc0 != null ? loc0 . getClassLoader ( ) : null ; if ( loc1 == null ) loc1 = ClassLoader . getSystemClassLoader ( ) ; return ResourceBundle . getBundle ( arg1 , arg2 , loc1 ) ; }"}, {"instruction": "Generate java code\nmethod to return the total using a nested for-each loop ", "input": " int[][] matrix \n\n void print \n void setMatrix \n int getTotal \n void fillPattern1 \n void fillCount", "output": "int function ( ) { int loc0 = 0 ; for ( int [ ] loc1 : matrix ) { for ( int loc2 : loc1 ) { loc0 = loc0 + loc2 ; } } return loc0 ; }"}, {"instruction": "Generate java code\nobtain a story instance from a given story class . story instances are used for recording and reporting test results . ", "input": " String storyName \n String path \n ApplicationFeature feature \n String narrative \n String id \n String type \n String storyClassName \n\n String getName \n Story called \n TestTag asTag \n ApplicationFeature findFeatureFrom \n String getReportName \n String getReportName \n String getId \n Story withType \n Story withId \n Story withId \n Story withNarrative \n Story asFeature \n int hashCode \n String getPath \n Story withIdAndPathAndFeature \n Story withIdAndPath \n Class<?> testedInTestCase \n Story withPath \n TestTag asQualifiedTag \n String getStoryClassName \n Class<?> getFeatureClass \n ApplicationFeature getFeature \n String getDisplayName \n String getType \n String pathOf \n boolean equals \n String getStoryName \n boolean isAFeature \n String getNarrative", "output": "Story function ( final Class < ? > arg0 ) { return new Story ( arg0 ) ; }"}, {"instruction": "Generate java code\nload the app for use in non jetty containers . ", "input": " AzkabanWebServer app \n String AZKABAN_SERVLET_CONTEXT_KEY \n\n void contextDestroyed", "output": "void function ( ServletContextEvent arg0 ) { try { this . app = new AzkabanWebServer ( ) ; } catch ( Exception loc0 ) { loc0 . printStackTrace ( ) ; } arg0 . getServletContext ( ) . setAttribute ( AZKABAN_SERVLET_CONTEXT_KEY , this . app ) ; }"}, {"instruction": "Generate java code\nreturns the quate . ", "input": " String quate \n String SEPARATOR_COMMA \n String SEPARATOR_TAB \n String record \n boolean beforeStart \n String SEPARATOR_SPACE \n String separator \n int currentIndex \n String DOUBLE_QUATE \n String SINGLE_QUATE \n\n int countTokens \n boolean hasMoreTokens \n String nextToken \n String nextToken \n boolean hasMoreElements \n void setQuate \n String[] toArray \n Object nextElement", "output": "String function ( ) { return this . quate ; }"}, {"instruction": "Generate java code\nsets the value of the height property . ", "input": " String mapping \n List<Address> address \n String flavour \n String src \n BigDecimal refresh \n Label label \n String suffix \n String type \n Layout layout \n String width \n String sendValue \n Boolean bindClickToWidget \n String height \n\n void setSrc \n String getMapping \n Boolean isBindClickToWidget \n Label getLabel \n String getSrc \n void setMapping \n void setRefresh \n void setLayout \n String getWidth \n void setType \n void setWidth \n String getSendValue \n Layout getLayout \n String getHeight \n String getSuffix \n String getType \n void setBindClickToWidget \n void setSendValue \n String getFlavour \n void setLabel \n void setSuffix \n List<Address> getAddress \n BigDecimal getRefresh \n void setFlavour", "output": "void function ( String arg0 ) { this . height = arg0 ; }"}, {"instruction": "Generate java code\nreturns the clazz . ", "input": " Circular other \n String id \n Object anyEntity \n Class clazz \n\n void setOther \n void setClazz \n Object getAnyEntity \n void setAnyEntity \n void setId \n String getId \n Circular getOther", "output": "Class function ( ) { return clazz ; }"}, {"instruction": "Generate java code\nsets the user name ", "input": " int port \n int connectAttemptsMax \n String clientId \n QoS willQos \n String userName \n boolean cleanSession \n short keepAliveInterval \n boolean willRetain \n String password \n String willTopic \n int connectionTimeout \n String host \n String willMessage \n\n void setPassword \n String getClientId \n void setKeepAliveInterval \n void setPort \n QoS getWillQos \n void setCleanSession \n void setWillRetain \n void setWillTopic \n int getConnectAttemptsMax \n String getWillMessage \n String getUserName \n int getConnectionTimeout \n String getHost \n String getWillTopic \n void setConnectAttemptsMax \n void setHost \n short getKeepAliveInterval \n boolean isCleanSession \n void setConnectionTimeout \n String getPassword \n boolean isWillRetain \n int getPort \n void setWillQos \n void setWillMessage \n void setClientId", "output": "void function ( String arg0 ) { this . userName = arg0 ; }"}, {"instruction": "Generate java code\nreturn type metadata object ", "input": " java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n org.apache.axis.description.TypeDesc typeDesc \n org.talend.mdm.webservice.WSTransformerV2PK wsTransformerV2PK \n\n org.talend.mdm.webservice.WSTransformerV2PK getWsTransformerV2PK \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n int hashCode \n void setWsTransformerV2PK \n boolean equals", "output": "org . apache . axis . description . TypeDesc function ( ) { return typeDesc ; }"}, {"instruction": "Generate java code\nreturns the destination inetaddress of this udpmasterconnection . ", "input": " InetAddress m_Address \n UDPMasterTerminal m_Terminal \n int m_Timeout \n int m_Port \n boolean m_Connected \n\n void setTimeout \n UDPTerminal getTerminal \n int getPort \n void setAddress \n ModbusTransport getModbusTransport \n int getTimeout \n boolean isConnected \n void close \n void setPort \n void connect", "output": "InetAddress function ( ) { return m_Address ; }"}, {"instruction": "Generate java code\nsignals start of the nearest neighbour search . initializes the stats object . ", "input": " double m_MaxP \n double m_PointCount \n double m_CoordCount \n double m_SumP \n double m_SumC \n double m_SumSqC \n long serialVersionUID \n double m_SumSqP \n double m_MinC \n double m_MaxC \n int m_NumQueries \n double m_MinP \n\n void updatePointCount \n double getMeanPointsVisited \n String getStats \n double getStdDevCoordsPerPoint \n double getMeanCoordsPerPoint \n double getTotalPointsVisited \n void incrCoordCount \n int getNumQueries \n double getMinPointsVisited \n double getTotalCoordsPerPoint \n double getMaxPointsVisited \n double getMinCoordsPerPoint \n double getMeasure \n void reset \n double getMaxCoordsPerPoint \n void searchFinish \n Enumeration enumerateMeasures \n double getStdDevPointsVisited \n void incrPointCount \n String getRevision", "output": "void function ( ) { m_PointCount = 0 ; m_CoordCount = 0 ; }"}, {"instruction": "Generate java code\nadd an entity to the existing related entity map ", "input": " HashMap<String,Set<Object>> primaryFilters \n HashMap<String,Object> otherInfo \n HashMap<String,Set<String>> relatedEntities \n String entityType \n String entityId \n Long startTime \n List<TimelineEvent> events \n String domainId \n\n Map<String,Set<String>> getRelatedEntities \n Map<String,Object> getOtherInfo \n void addPrimaryFilter \n int compareTo \n void setEvents \n List<TimelineEvent> getEvents \n void addEvent \n int hashCode \n HashMap<String,Set<String>> getRelatedEntitiesJAXB \n String getEntityId \n Long getStartTime \n void setStartTime \n void setOtherInfo \n String getDomainId \n HashMap<String,Set<Object>> getPrimaryFiltersJAXB \n void setRelatedEntities \n void addEvents \n void setDomainId \n void setEntityId \n String getEntityType \n void setPrimaryFilters \n void addPrimaryFilters \n HashMap<String,Object> getOtherInfoJAXB \n void addRelatedEntities \n Map<String,Set<Object>> getPrimaryFilters \n boolean equals \n void addOtherInfo \n void addOtherInfo \n void setEntityType", "output": "void function ( String arg0 , String arg1 ) { Set < String > loc0 = relatedEntities . get ( arg0 ) ; if ( loc0 == null ) { loc0 = new HashSet < String > ( ) ; relatedEntities . put ( arg0 , loc0 ) ; } loc0 . add ( arg1 ) ; }"}, {"instruction": "Generate java code\nresolves the ready files handler ", "input": " Logger log \n ApplicationContext applicationContext \n SourceSnapshot sourceSnapshot \n boolean fileLevelReporting \n\n void waitUntilReady \n Message<FileMessage> handle \n boolean isReleaseTrigger", "output": "ReadyMessageHandler < FileMessage > function ( ReadyFilesStrategy arg0 ) { if ( arg0 == ReadyFilesStrategy . LINUX_COMPLETED_FILES_ONLY ) { return applicationContext . getBean ( LinuxLsofBasedReadyFilesHandler . class ) ; } return applicationContext . getBean ( DefaultReadyFilesHandler . class ) ; }"}, {"instruction": "Generate java code\nreturns the flag that indicates whether or not a change event has been received . ", "input": " boolean notified \n\n void setNotified \n void rendererChanged", "output": "boolean function ( ) { return this . notified ; }"}, {"instruction": "Generate java code\nindicates whether the given color value describes the `` none '' color . ", "input": " PlaceHolder placeHolder \n\n String[] clearSizeStyle \n String getHexString \n void restoreSizeStyle \n int getPreferredWidth \n Color getColor \n void setWidgetFontTypeface \n int[] getPreferredSizeOfDetachedWidget \n void setWidgetBackgroundColor \n void setWidgetFontItalic \n void setEnabled \n void setWidgetBackgroundImage \n void setWidgetTextColor \n void setWidgetFontSize \n void setWidgetTextAlign \n int getPreferredHeight \n void setWidgetFontBold \n boolean isDefaultColor", "output": "boolean function ( String arg0 ) { return getHexString ( arg0 , 8 ) . equals ( MockVisibleComponent . COLOR_NONE ) ; }"}, {"instruction": "Generate java code\nadss an available options to the question that the user has in order to answer the question . ", "input": " boolean required \n String FORM_TYPE \n List<String> values \n String ELEMENT \n String variable \n List<Option> options \n ValidateElement validateElement \n String description \n String label \n String ELEMENT \n Type type \n String value \n\n ValidateElement getValidateElement \n boolean isRequired \n void setRequired \n void setValidateElement \n String getLabel \n String getLabel \n List<String> getValues \n XmlStringBuilder toXML \n XmlStringBuilder toXML \n void setDescription \n void setType \n String getDescription \n String getVariable \n String getElementName \n String getElementName \n String getValue \n void resetValues \n Type getType \n int hashCode \n int hashCode \n boolean equals \n boolean equals \n void setLabel \n String toString \n String toString \n Type fromString \n List<Option> getOptions \n void addValues \n void addValue", "output": "void function ( Option arg0 ) { synchronized ( options ) { options . add ( arg0 ) ; } }"}, {"instruction": "Generate java code\nget token end column number . ", "input": " int bufpos \n boolean prevCharIsLF \n int bufsize \n int available \n int tabSize \n java.io.Reader inputStream \n int line \n int bufcolumn[] \n int bufline[] \n int maxNextCharInd \n char[] buffer \n boolean prevCharIsCR \n int tokenBegin \n int inBuf \n boolean trackLineColumn \n boolean staticFlag \n int column \n\n char[] GetSuffix \n void backup \n void Done \n void setTrackLineColumn \n int getEndLine \n boolean getTrackLineColumn \n int getLine \n void FillBuff \n char readChar \n char BeginToken \n int getBeginLine \n int getTabSize \n void adjustBeginLineColumn \n void setTabSize \n String GetImage \n void ExpandBuff \n int getBeginColumn \n int getColumn \n void UpdateLineColumn \n void ReInit \n void ReInit \n void ReInit \n void ReInit \n void ReInit \n void ReInit \n void ReInit \n void ReInit \n void ReInit", "output": "int function ( ) { return bufcolumn [ bufpos ] ; }"}, {"instruction": "Generate java code\na fast method to retrieve one row of data from the matrix as a bitarray . ", "input": " int width \n int[] bits \n int height \n int rowSize \n\n void setRegion \n int getHeight \n void set \n int[] getTopLeftOnBit \n int hashCode \n boolean get \n boolean equals \n void clear \n String toString \n int getWidth \n void flip \n int[] getBottomRightOnBit", "output": "BitArray function ( int arg0 , BitArray arg1 ) { if ( arg1 == null || arg1 . getSize ( ) < width ) { arg1 = new BitArray ( width ) ; } int loc0 = arg0 * rowSize ; for ( int loc1 = 0 ; loc1 < rowSize ; loc1 ++ ) { arg1 . setBulk ( loc1 << 5 , bits [ loc0 + loc1 ] ) ; } return arg1 ; }"}, {"instruction": "Generate java code\nsets the nmtoken for node address only in the singleton obtained from #getsingleton . if you are using your own nmtokencache that is different from the singleton , use #settoken string , token ", "input": " ConcurrentHashMap<String,Token> nmTokens \n NMTokenCache NM_TOKEN_CACHE \n\n void setToken \n void removeToken \n Token getNMToken \n Token getToken \n void clearCache \n boolean containsToken \n int numberOfTokensInCache \n NMTokenCache getSingleton", "output": "void function ( String arg0 , Token arg1 ) { NM_TOKEN_CACHE . setToken ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nget the handler for rewriting the xml . ", "input": " boolean success \n boolean complete \n\n boolean isSuccessful \n void success \n void waitForCompletion \n boolean isComplete", "output": "ContentHandler function ( final ContentHandler arg0 ) { return null ; }"}, {"instruction": "Generate java code\nwhen deserializing , initialize the seed because otherwise we could get duplicate evolution results when doing distributed computing ! ", "input": " Random m_rn \n double m_scale \n double m_location \n String CVS_REVISION \n\n float nextFloat \n double nextCauchy \n double getCauchyStandardDeviation \n int nextInt \n int nextInt \n boolean nextBoolean \n long nextLong \n double nextDouble", "output": "void function ( ObjectInputStream arg0 ) { arg0 . defaultReadObject ( ) ; m_rn . setSeed ( System . currentTimeMillis ( ) ) ; }"}, {"instruction": "Generate java code\nstarts the race . note that the race only starts when all racers are ready , i.e. all waiting at the start barrier , and for that to happen there is a 30 seconds timeout . ", "input": " AtomicInteger abortedPosition \n AtomicInteger donePosition \n RaceBroadcaster broadcaster \n CountDownLatch endCountDownLatch \n RaceResult result \n int number \n Map<String,String> environment \n CyclicBarrier startBarrier \n Racer racer \n Racer racer2 \n RaceResults results \n Racer racer1 \n Racer racer4 \n Racer racer3 \n\n void broadcast \n void aborted \n void processResult \n void run \n Map<String,String> getEnvironment \n void startEngines \n void done \n int getNumber \n void ready \n void reset \n void registerRacers \n Racer getRacer \n void awaitEnd", "output": "void function ( ) { broadcaster . readySetGo ( ) ; startBarrier . await ( 30 , TimeUnit . SECONDS ) ; }"}, {"instruction": "Generate java code\ngroupisavailable ", "input": " WmiManager m_manager \n WmiAgentConfig m_agentConfig \n String m_address \n IWmiClient m_wmiClient \n HashMap<String,WmiGroupState> m_groupStates \n\n WmiManager getManager \n void setGroupIsAvailable \n String getAddress \n void didCheckGroupAvailability \n IWmiClient getWmiClient \n void setWmiClient \n void connect \n boolean shouldCheckAvailability", "output": "boolean function ( final String arg0 ) { final WmiGroupState loc0 = m_groupStates . get ( arg0 ) ; if ( loc0 == null ) { return false ; } return loc0 . isAvailable ( ) ; }"}, {"instruction": "Generate java code\nget the partition count of s3filemerger operator ", "input": " String secretAccessKey \n int mergerCount \n String endPoint \n String bucketName \n String outputDirectoryPath \n int timeOutWindowCount \n ProxyInputPort<AbstractBlockReader.ReaderRecord<Slice>> blockData \n String accessKey \n ProxyInputPort<BlockMetadata.FileBlockMetadata> blocksMetadataInput \n ProxyInputPort<AbstractFileSplitter.FileMetadata> filesMetadataInput \n\n void setEndPoint \n String getOutputDirectoryPath \n String getSecretAccessKey \n int getTimeOutWindowCount \n void setTimeOutWindowCount \n S3InitiateFileUploadOperator createS3InitiateUpload \n S3FileMerger createS3FileMerger \n void setBucketName \n String getEndPoint \n void setAccessKey \n S3BlockUploadOperator createS3BlockUpload \n void setOutputDirectoryPath \n void populateDAG \n String getAccessKey \n void setMergerCount \n void setSecretAccessKey \n String getBucketName", "output": "int function ( ) { return mergerCount ; }"}, {"instruction": "Generate java code\nsets the operator type for the filter ", "input": " String column \n DatabaseFilterType type \n String value \n\n String getValue \n void setColumn \n DatabaseFilterType getType \n void setValue \n String getColumn", "output": "void function ( DatabaseFilterType arg0 ) { this . type = arg0 ; }"}, {"instruction": "Generate java code\nexpert : registers and associates a termstate with an leaf ordinal . theleaf ordinal should be derived from a indexreadercontext 's leaf ord . on the contrary to #register termstate , int , int , long this methoddoes not update term statistics . ", "input": " long totalTermFreq \n IndexReaderContext topReaderContext \n int docFreq \n TermState[] states \n\n void accumulateStatistics \n long totalTermFreq \n TermContext build \n boolean hasOnlyRealTerms \n TermState get \n void clear \n String toString \n int docFreq", "output": "void function ( TermState arg0 , final int arg1 ) { assert arg0 != null : \"srini_string\" ; assert arg1 >= 0 && arg1 < states . length ; assert states [ arg1 ] == null : \"srini_string\" + arg1 + \"srini_string\" ; states [ arg1 ] = arg0 ; }"}, {"instruction": "Generate java code\nget color ", "input": " String className \n String color \n\n String toIndentedString \n void setColor \n Animal color \n int hashCode \n boolean equals \n Animal className \n String toString \n String getClassName \n void setClassName", "output": "String function ( ) { return color ; }"}, {"instruction": "Generate java code\nreturns the index of the eigenvalue which has the largest magnitude . ", "input": " DenseMatrix64F mat \n EigenDecomposition<DenseMatrix64F> eig \n\n Complex64F getEigenvalue \n T getEigenVector \n EigenDecomposition getEVD \n int getNumberOfEigenvalues \n int getIndexMin \n double quality", "output": "int function ( ) { int loc0 = 0 ; double loc1 = getEigenvalue ( 0 ) . getMagnitude2 ( ) ; final int loc2 = getNumberOfEigenvalues ( ) ; for ( int loc3 = 1 ; loc3 < loc2 ; loc3 ++ ) { double loc4 = getEigenvalue ( loc3 ) . getMagnitude2 ( ) ; if ( loc4 > loc1 ) { loc1 = loc4 ; loc0 = loc3 ; } } return loc0 ; }"}, {"instruction": "Generate java code\nadds command line arguments for the application . ", "input": " String EXECUTOR_EXTRA_LIBRARY_PATH \n String DRIVER_EXTRA_LIBRARY_PATH \n String EXECUTOR_CORES \n String EXECUTOR_EXTRA_CLASSPATH \n String EXECUTOR_EXTRA_JAVA_OPTIONS \n SparkSubmitCommandBuilder builder \n String DRIVER_EXTRA_CLASSPATH \n String DRIVER_EXTRA_JAVA_OPTIONS \n String SPARK_MASTER \n String DRIVER_MEMORY \n String EXECUTOR_MEMORY \n\n SparkLauncher setMainClass \n SparkLauncher setAppName \n SparkLauncher setJavaHome \n SparkLauncher addPyFile \n Process launch \n SparkLauncher setPropertiesFile \n SparkLauncher setVerbose \n SparkLauncher setConf \n SparkLauncher addJar \n SparkLauncher setAppResource \n SparkLauncher setSparkHome \n SparkLauncher setMaster \n SparkLauncher setDeployMode \n SparkLauncher addFile", "output": "SparkLauncher function ( String ... arg0 ) { for ( String loc0 : arg0 ) { checkNotNull ( loc0 , \"srini_string\" ) ; builder . appArgs . add ( loc0 ) ; } return this ; }"}, {"instruction": "Generate java code\nproduces a packet to poll this thermostat ", "input": " double dcbFrostTemperature \n byte dcbHeatState \n byte dcbWaterState \n byte address \n double dcbSetTemperature \n int dcbHoldTime \n Models dcbModel \n byte dcbState \n double dcbFloorTemperature \n double dcbRoomTemperature \n byte function \n int dcbHolidayTime \n int frameLength \n Logger logger \n byte data[] \n int dcbStart \n\n State getFrostTemperature \n State getHolidaySet \n State getHeatState \n State getFloorTemperature \n double getTemp \n byte[] setRunMode \n byte[] setFrostTemperature \n State getOnOffState \n State getHolidayTime \n int getAddress \n boolean setTime \n byte[] setTime \n State getHoldMode \n Models getModel \n void setAddress \n boolean setData \n State getSetTemperature \n State getWaterState \n int getInt \n State getHolidayMode \n State getState \n byte[] setOnOff \n int checkCRC \n byte[] setRoomTemperature \n byte[] formatCommand \n byte[] makePacket \n State getTemperature \n State getHoldTime \n byte[] setHolidayTime", "output": "byte [ ] function ( ) { return makePacket ( false , 0 , 0xffff , null ) ; }"}, {"instruction": "Generate java code\ngenerates a tool tip text item for a particular item within a series . ", "input": " long serialVersionUID \n List toolTipSeries \n\n int getListCount \n void addToolTipSeries \n int getToolTipCount \n boolean equals \n Object clone \n String getToolTipText", "output": "String function ( XYDataset arg0 , int arg1 , int arg2 ) { return getToolTipText ( arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nreturns all jobs tagged with the given tag that have been started after the given timestamp . returned jobids are mapreduce jobids . ", "input": " JobClient jc \n Logger LOG \n Configuration conf \n\n JobStatus getJobStatus \n void killJob \n void killJobs \n JobStatus[] getAllJobs \n JobProfile getJobProfile \n void close \n Set<ApplicationId> getYarnChildJobs \n void addCacheFile \n RunningJob getJob", "output": "Set < String > function ( String arg0 , long arg1 ) { Set < ApplicationId > loc0 = getYarnChildJobs ( arg0 , arg1 ) ; Set < String > loc1 = new HashSet < String > ( ) ; for ( ApplicationId loc2 : loc0 ) { String loc3 = TypeConverter . fromYarn ( loc2 ) . toString ( ) ; loc1 . add ( loc3 ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nsets the value of the objmodels property . ", "input": " String objItemIndexViewURL \n ObjectProfile.ObjModels objModels \n String objLastModDate \n String pid \n List<String> model \n String objCreateDate \n String objDissIndexViewURL \n String objLabel \n\n void setObjDissIndexViewURL \n String getObjCreateDate \n List<String> getModel \n void setObjItemIndexViewURL \n void setObjLabel \n void setPid \n String getObjLabel \n String getObjItemIndexViewURL \n String getObjDissIndexViewURL \n ObjectProfile.ObjModels getObjModels \n String getObjLastModDate \n String getPid \n void setObjCreateDate \n void setObjLastModDate", "output": "void function ( ObjectProfile . ObjModels arg0 ) { this . objModels = arg0 ; }"}, {"instruction": "Generate java code\nretrieves the factory implementation that this factory is using to produce threads . ", "input": " ThreadFactory factory \n\n Thread newThread \n ThreadFactory setImpl", "output": "ThreadFactory function ( ) { return factory ; }"}, {"instruction": "Generate java code\nsend a byte array to a dedicated remoteaddress . ", "input": " Thread _myThread \n int _myDatagramSize \n boolean isSocket \n boolean isRunning \n int _myPort \n DatagramSocket _myDatagramSocket \n InetAddress _myInetAddress \n String _myAddress \n UdpPacketListener _myListener \n\n void start \n void run \n void dispose \n DatagramSocket socket", "output": "void function ( byte [ ] arg0 , String arg1 , int arg2 ) { try { InetAddress loc0 = InetAddress . getByName ( arg1 ) ; send ( arg0 , loc0 , arg2 ) ; } catch ( UnknownHostException loc0 ) { Logger . printError ( \"srini_string\" , \"srini_string\" + arg1 + \"srini_string\" + loc0 ) ; } }"}, {"instruction": "Generate java code\nget the current transform ", "input": " float tw \n Point2D.Float prevEnd \n AffineTransform cur \n float fsize \n AffineTransform line \n float tr \n boolean inuse \n int tm \n float tc \n StringBuffer word \n float tk \n Point2D.Float wordStart \n float tl \n float th \n PDFFont font \n\n float getHorizontalScale \n float getFontSize \n void setRise \n void setMode \n void setTextFormatMode \n void carriageReturn \n void carriageReturn \n void setCharSpacing \n void setWordSpacing \n void setHorizontalScale \n float getCharSpacing \n void doText \n void doText \n void flush \n float getWordSpacing \n Object clone \n void reset \n void end \n void setLeading \n PDFFont getFont \n void setMatrix \n void setFont \n int getMode \n float getRise \n float getLeading", "output": "AffineTransform function ( ) { return this . cur ; }"}, {"instruction": "Generate java code\nbuilds a csv list from the specified int , separator string and quote string . all arguments are assumed to be non-null . separates each list element with the value of the separator argument . prepends and appends each element with the value of the quote argument . ", "input": " PlaceHolder placeHolder \n\n String arrayToString \n int rTrimSize \n String[] split \n String toLowerSubset \n boolean isEmpty \n int skipSpaces \n void appendPair", "output": "String function ( int [ ] arg0 , String arg1 , String arg2 ) { int loc0 = arg0 . length ; StringBuffer loc1 = new StringBuffer ( loc0 * 8 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 . append ( arg2 ) ; loc1 . append ( arg0 [ loc2 ] ) ; loc1 . append ( arg2 ) ; if ( loc2 + 1 < loc0 ) { loc1 . append ( arg1 ) ; } } return loc1 . toString ( ) ; }"}, {"instruction": "Generate java code\nget the default language for the platform ", "input": " Locale defaultLocale \n String[] installedLocaleIds \n Locale currentEditLocale \n String defaultLocaleId \n Logger log \n Locale currentLocale \n Locale[] availableLocales \n\n LocaleManager lookup \n void init \n String[] localeToString \n Object localize \n Locale currentLocale \n String getDefaultLocaleId \n String[] getInstalledLocaleIds \n void setDefaultLocaleId \n String[] getPlatformAvailableLangs \n Locale getCurrentLocale \n void setCurrentLang \n Locale getDefaultLocale \n Locale getLocaleById \n String[] getLangs \n Locale[] getPlatformAvailableLocales \n String currentLang \n Locale[] getAllLocales \n Locale[] geLocales \n String getCurrentLang \n void setInstalledLocaleIds \n String[] getAllLanguages \n void setCurrentLocale", "output": "String function ( ) { return getDefaultLocale ( ) . toString ( ) ; }"}, {"instruction": "Generate java code\ngets the value of the datumod property . ", "input": " XMLGregorianCalendar rokDo \n XMLGregorianCalendar datumDo \n XMLGregorianCalendar mesicDo \n XMLGregorianCalendar rokOd \n XMLGregorianCalendar datumOd \n XMLGregorianCalendar mesicOd \n XMLGregorianCalendar rok \n\n XMLGregorianCalendar getMesicOd \n void setRokOd \n void setMesicOd \n void setRok \n void setDatumOd \n XMLGregorianCalendar getRok \n void setRokDo \n void setDatumDo \n XMLGregorianCalendar getRokOd \n XMLGregorianCalendar getMesicDo \n void setMesicDo \n XMLGregorianCalendar getRokDo \n XMLGregorianCalendar getDatumDo", "output": "XMLGregorianCalendar function ( ) { return datumOd ; }"}, {"instruction": "Generate java code\ngetdatestamp ", "input": " XMLGregorianCalendar m_dateStamp \n List<PluginConfig> m_policies \n String m_name \n boolean m_default \n Duration m_scanInterval \n List<PluginConfig> m_detectors \n long serialVersionUID \n\n void setName \n void deletePolicies \n void setDetectors \n List<PluginConfig> getDetectors \n String getName \n void deleteDetectors \n PluginConfig getDetector \n int compareTo \n void setScanInterval \n PluginConfig getPolicy \n void setDefault \n void addDetector \n void updateDateStamp \n void setDateStamp \n boolean isDefault \n Date getDateStampAsDate \n List<PluginConfig> getPolicies \n void addPolicy \n int hashCode \n boolean equals \n void setPolicies \n String toString \n Duration getScanInterval \n List<String> getDetectorNames", "output": "XMLGregorianCalendar function ( ) { return m_dateStamp ; }"}, {"instruction": "Generate java code\nthe ca cert data ", "input": " int poolSize \n String caCertData \n String oauthToken \n String clientKeyAlgo \n String clientCertFile \n String password \n String apiVersion \n String clientKeyData \n String masterUrl \n String clientCertData \n String caCertFile \n String clientKeyFile \n String category \n String operation \n String clientKeyPassphrase \n DefaultKubernetesClient kubernetesClient \n String namespaceName \n String username \n Boolean trustCerts \n\n void setPassword \n int getPoolSize \n void setCaCertFile \n void setClientCertData \n void setNamespaceName \n void setClientKeyPassphrase \n String getUsername \n void setClientKeyFile \n void setApiVersion \n String getCaCertFile \n void setPoolSize \n String getClientCertData \n void setTrustCerts \n void setCategory \n String getOauthToken \n void setOauthToken \n String getClientKeyAlgo \n String getApiVersion \n void setClientKeyAlgo \n String getClientKeyData \n void setUsername \n Boolean getTrustCerts \n void setCaCertData \n String getNamespaceName \n String getCategory \n DefaultKubernetesClient getKubernetesClient \n String getClientKeyFile \n String getMasterUrl \n void setMasterUrl \n String getPassword \n void setKubernetesClient \n String getOperation \n void setOperation \n String toString \n String getClientKeyPassphrase \n void setClientKeyData \n String getClientCertFile \n void setClientCertFile", "output": "String function ( ) { return caCertData ; }"}, {"instruction": "Generate java code\nmatches a vector3d close to another one . ", "input": " PlaceHolder placeHolder \n\n Matcher<Double> numberCloseTo \n Matcher<Double> closeTo \n Matcher<GeodeticPoint> geodeticPointCloseTo \n Matcher<GeodeticPoint> geodeticPointCloseTo \n Matcher<Vector3D> vector \n Matcher<GeodeticPoint> geodeticPoint \n Matcher<GeodeticPoint> geodeticPoint \n Matcher<Double> relativelyCloseTo", "output": "Matcher < Vector3D > function ( Vector3D arg0 , int arg1 ) { return arg0 ( relativelyCloseTo ( arg0 . getX ( ) , arg1 ) , relativelyCloseTo ( arg0 . getY ( ) , arg1 ) , relativelyCloseTo ( arg0 . getZ ( ) , arg1 ) ) ; }"}, {"instruction": "Generate java code\nresolves a reference starting with a query string . ", "input": " PlaceHolder placeHolder \n\n URI removeDotSegments \n URI resolve \n URI resolve \n URI rewriteURI \n URI rewriteURI \n HttpHost extractHost \n URI createURI \n String normalizePath", "output": "URI function ( final URI arg0 , final URI arg1 ) { String loc0 = arg0 . toString ( ) ; loc0 = loc0 . indexOf ( '?' ) > - 1 ? loc0 . substring ( 0 , loc0 . indexOf ( '?' ) ) : loc0 ; return URI . create ( loc0 + arg1 . toString ( ) ) ; }"}, {"instruction": "Generate java code\nsets whether this kaleo node is terminal . ", "input": " KaleoNode _kaleoNode \n\n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n boolean getTerminal \n java.lang.String getName \n void setGroupId \n boolean isEscapedModel \n boolean isCachedModel \n long getKaleoNodeId \n boolean isTerminal \n KaleoTransition getKaleoTransition \n int compareTo \n KaleoNode getWrappedModel \n long getGroupId \n long getKaleoDefinitionId \n void setKaleoNodeId \n void setModelAttributes \n Map<String,Object> getModelAttributes \n com.liferay.portal.kernel.model.CacheModel<KaleoNode> toCacheModel \n Date getCreateDate \n KaleoNode toUnescapedModel \n void setPrimaryKey \n java.lang.String getUserName \n void setUserUuid \n boolean isEntityCacheEnabled \n java.lang.String getMetadata \n void resetOriginalValues \n KaleoTransition getDefaultKaleoTransition \n boolean isInitial \n Serializable getPrimaryKeyObj \n Date getModifiedDate \n KaleoNode toEscapedModel \n long getPrimaryKey \n java.lang.String getType \n void setCreateDate \n void setCachedModel \n String getModelClassName \n void setCompanyId \n void setUserId \n void setName \n boolean isFinderCacheEnabled \n ExpandoBridge getExpandoBridge \n void setDescription \n java.util.List<KaleoTransition> getKaleoTransitions \n java.lang.String getDescription \n void setUserName \n int hashCode \n void persist \n void setNew \n void setInitial \n boolean getInitial \n void setKaleoDefinitionId \n java.lang.String getUserUuid \n boolean isNew \n void setType \n Class<?> getModelClass \n void setMetadata \n void setModifiedDate \n long getCompanyId \n boolean hasKaleoTransition \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n java.lang.String toString \n long getUserId", "output": "void function ( boolean arg0 ) { _kaleoNode . setTerminal ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis method is used to determine if the named interface is included in the passed package 's url includes . if the interface is found in any of the url files , then a value of true is returned , else a false value is returned . the file url is read and each entry in this file checked . each line in the url file can be one of - < ip > < space > # < comments > or < ip > or # < comments > lines starting with a ' # ' are ignored and so are characters after a ' < space > # ' in a line . ", "input": " String m_urlName \n List<String> m_ipList \n\n void setIpList \n void createIpList \n String getName \n List<String> getIpList", "output": "boolean function ( String arg0 ) { boolean loc0 = false ; List < String > loc1 = getIpList ( ) ; if ( loc1 != null && loc1 . size ( ) > 0 ) { loc0 = loc1 . contains ( arg0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nget a hook for a specific event . ", "input": " String PRE_EXEC \n String POST_EXEC_DEV \n String POST_EXEC \n Map<String,Map<String,Map<String,String>>> registry \n String interpreterId \n String PRE_EXEC_DEV \n String GLOBAL_KEY \n\n String getInterpreterId \n void addNote \n void unregister \n void addRepl \n void register", "output": "String function ( String arg0 , String arg1 , String arg2 ) { synchronized ( registry ) { if ( arg0 == null ) { arg0 = GLOBAL_KEY ; } addRepl ( arg0 , arg1 ) ; return registry . get ( arg0 ) . get ( arg1 ) . get ( arg2 ) ; } }"}, {"instruction": "Generate java code\nthis method is to retrieve numerical information when it is not known how that number will be provided beforehand . ", "input": " String GEOMETRY_KEY \n String GEOMETRIES_KEY \n String COORDINATES_KEY \n String PROPERTIES_KEY \n GeometryFactory geometryFactory \n String TYPE_KEY \n\n Coordinate getCoordinate \n String toWkt \n Map toJsonMap \n List<Position> toGeoRssPositions \n Geometry getGeometry \n Coordinate[] getCoordinates \n CompositeGeometry getCompositeGeometry \n CompositeGeometry getCompositeGeometry", "output": "double function ( Object arg0 ) { if ( arg0 instanceof Double ) { return ( Double ) arg0 ; } else { if ( arg0 != null ) { return Double . valueOf ( arg0 . toString ( ) ) ; } else { return 0.0 ; } } }"}, {"instruction": "Generate java code\ndeerializes elements from a string obtained from the system clipboard and pastes them into the specified target element . ", "input": " String IGNORE_RECYCLE_HINT_ID \n String PASTE_SELECTION_FROM_STRING \n String PASTE_TO_TARGET_PARENT \n String MERGE_HINT_STRONG \n String RECYCLE_HINT_ID \n String MERGE_HINT_WEAK \n String HARVESTED_ELEMENT \n String COPY_SELECTION_TO_STRING \n\n void handleException \n String copyElementsToString \n IClipboardSupport createClipboardSupport \n IClipboardSupport createClipboardSupport \n Collection pasteElementsFromStringDelagate", "output": "Collection function ( String arg0 , Resource arg1 , final Map arg2 , IProgressMonitor arg3 ) { return pasteElementsFromStringDelagate ( arg0 , new PasteTarget ( arg1 ) , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nenables the internal caching of typevariables . ", "input": " Map<Class<?>,Reference<Map<TypeVariable<?>,Type>>> typeVariableCache \n boolean cacheEnabled \n\n Type resolveGenericType \n Map<TypeVariable<?>,Type> getTypeVariableMap \n Class<?>[] resolveArguments \n Class<?>[] resolveArguments \n void disableCache \n Class<?> resolveClass \n void buildTypeVariableMap \n void buildTypeVariableMap \n Type resolveBound \n Class<?> resolveArgument \n Class<?> resolveArgument", "output": "void function ( ) { cacheEnabled = true ; }"}, {"instruction": "Generate java code\ngetblurredimage . ", "input": " PlaceHolder placeHolder \n\n BufferedImage getImage \n BufferedImage getImage", "output": "BufferedImage function ( BufferedImage arg0 , int arg1 , float arg2 ) { float loc0 = arg2 / ( arg1 * arg1 ) ; float [ ] loc1 = new float [ arg1 * arg1 ] ; for ( int loc2 = 0 , loc3 = arg1 * arg1 ; loc2 < loc3 ; loc2 ++ ) loc1 [ loc2 ] = loc0 ; ConvolveOp loc4 = new ConvolveOp ( new Kernel ( arg1 , arg1 , loc1 ) ) ; return loc4 . filter ( arg0 , null ) ; }"}, {"instruction": "Generate java code\ngets the data value for this ctconohchy30rs . ", "input": " pe.com.grupobbva.ohc.hy30.CtBodyRs data \n java.lang.Object __equalsCalc \n pe.com.grupobbva.xsd.ps9.CtHeaderRs header \n boolean __hashCodeCalc \n org.apache.axis.description.TypeDesc typeDesc \n\n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n void setData \n int hashCode \n boolean equals \n void setHeader \n pe.com.grupobbva.xsd.ps9.CtHeaderRs getHeader", "output": "pe . com . grupobbva . ohc . hy30 . CtBodyRs function ( ) { return data ; }"}, {"instruction": "Generate java code\nchecks whether this memory segment factory has been initialized with a type to produce . ", "input": " Factory factory \n\n MemorySegment wrapPooledHeapMemory \n MemorySegment wrapPooledHeapMemory \n void ensureInitialized \n MemorySegment allocateUnpooledSegment \n MemorySegment allocateUnpooledSegment \n MemorySegment allocateUnpooledSegment \n MemorySegment wrapPooledOffHeapMemory \n MemorySegment wrapPooledOffHeapMemory \n void initializeFactory \n Factory getFactory \n MemorySegment wrap \n MemorySegment wrap", "output": "boolean function ( ) { return factory != null ; }"}, {"instruction": "Generate java code\ndefines the limit for the strokelinejoin.miter line join style . ", "input": " BorderStrokeStyle NONE \n StrokeLineJoin lineJoin \n double miterLimit \n StrokeType type \n double dashOffset \n BorderStrokeStyle DASHED \n BorderStrokeStyle DOTTED \n List<Double> DASHED_LIST \n StrokeLineCap lineCap \n List<Double> DOTTED_LIST \n BorderStrokeStyle SOLID \n List<Double> dashArray \n int hash \n\n StrokeLineCap getLineCap \n double getDashOffset \n StrokeType getType \n int hashCode \n boolean equals \n List<Double> getDashArray \n String toString \n StrokeLineJoin getLineJoin \n List<Double> asList", "output": "double function ( ) { return miterLimit ; }"}, {"instruction": "Generate java code\nreturn if continue after a failed check . ", "input": " boolean verbose \n int cachesz \n String dbFile \n String dbName \n boolean continueAfterFail \n LogSequenceNumber endLsn \n Date endTime \n Date startTime \n LogSequenceNumber startLsn \n String envHome \n\n void setEnvHome \n int getCacheSize \n void setCacheSize \n void setStartLsn \n void setDbFile \n void setEndLsn \n void setVerbose \n LogSequenceNumber getStartLsn \n String getEnvHome \n void setContinueAfterFail \n LogSequenceNumber getEndLsn \n void setDbName \n String getDbFile \n Date getEndTime \n boolean getVerbose \n void setEndTime \n String getDbName \n Date getStartTime \n void setStartTime", "output": "boolean function ( ) { return continueAfterFail ; }"}, {"instruction": "Generate java code\nupdates the begin time for this interval . ", "input": " LinkedList beginDependents \n InstanceTime endInstanceTime \n LinkedList endDependents \n InstanceTime beginInstanceTime \n float end \n float begin \n\n float getBegin \n InstanceTime getBeginInstanceTime \n void addDependent \n void removeDependent \n InstanceTime getEndInstanceTime \n String toString \n float setEnd \n float getEnd", "output": "float function ( float arg0 ) { float loc0 = Float . POSITIVE_INFINITY ; this . begin = arg0 ; Iterator loc1 = beginDependents . iterator ( ) ; while ( loc1 . hasNext ( ) ) { InstanceTime loc2 = ( InstanceTime ) loc1 . next ( ) ; float loc3 = loc2 . dependentUpdate ( arg0 ) ; if ( loc3 < loc0 ) { loc0 = loc3 ; } } return loc0 ; }"}, {"instruction": "Generate java code\nset the wss4j validator instance to use to validate the token . ", "input": " String X509_PKI_PATH \n org.slf4j.Logger LOGGER \n String signaturePropertiesPath \n Merlin merlin \n String BASE64_ENCODING \n Validator validator \n CertConstraintsParser certConstraints \n\n boolean canHandleToken \n boolean canHandleToken \n void init \n void setSubjectConstraints \n String getSignaturePropertiesPath \n void setSignaturePropertiesPath \n TokenValidatorResponse validateToken", "output": "void function ( Validator arg0 ) { this . validator = arg0 ; }"}, {"instruction": "Generate java code\nincrements the reference count and returns whether it was successful . if the method returns false , the counter has already been disposed . otherwise it returns true . ", "input": " int disposeOnReferenceCount \n int referenceCount \n boolean isDisposed \n Object lock \n\n boolean disposeIfNotUsed \n boolean decrement \n int get \n boolean isDisposed", "output": "boolean function ( ) { synchronized ( lock ) { if ( isDisposed ) { return false ; } referenceCount ++ ; return true ; } }"}, {"instruction": "Generate java code\nconstructs an instance of errorgroupserviceclient with default settings . ", "input": " ErrorGroupServiceSettings settings \n UnaryCallable<GetGroupRequest,ErrorGroup> getGroupCallable \n ScheduledExecutorService executor \n ManagedChannel channel \n List<AutoCloseable> closeables \n UnaryCallable<UpdateGroupRequest,ErrorGroup> updateGroupCallable \n\n UnaryCallable<GetGroupRequest,ErrorGroup> getGroupCallable \n ErrorGroupServiceSettings getSettings \n ErrorGroup getGroup \n ErrorGroup getGroup \n ErrorGroup updateGroup \n ErrorGroup updateGroup \n void close \n UnaryCallable<UpdateGroupRequest,ErrorGroup> updateGroupCallable", "output": "ErrorGroupServiceClient function ( ) { return create ( ErrorGroupServiceSettings . defaultBuilder ( ) . build ( ) ) ; }"}, {"instruction": "Generate java code\nreads a languageprofile from an inputstream in utf-8 . ", "input": " String PROFILES_DIR \n LangProfileReader internalReader \n\n String makePathForClassLoader \n List<LanguageProfile> readAllBuiltIn \n boolean looksLikeLanguageProfileFile \n boolean looksLikeLanguageProfileName \n String makeProfileFileName \n LanguageProfile readBuiltIn \n List<LanguageProfile> readBuiltIn \n List<LanguageProfile> readAll \n List<LanguageProfile> readAll", "output": "LanguageProfile function ( InputStream arg0 ) { return OldLangProfileConverter . convert ( internalReader . read ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nsets the user id of this user thread . ", "input": " UserThread _userThread \n\n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n boolean isEscapedModel \n boolean getRead \n boolean isCachedModel \n int compareTo \n UserThread getWrappedModel \n void setModelAttributes \n void setTopMBMessageId \n Map<String,Object> getModelAttributes \n com.liferay.portal.kernel.model.CacheModel<com.liferay.privatemessaging.model.UserThread> toCacheModel \n Date getCreateDate \n long getMbThreadId \n void setPrimaryKey \n com.liferay.privatemessaging.model.UserThread toUnescapedModel \n java.lang.String getUserName \n void setUserUuid \n long getTopMBMessageId \n boolean isEntityCacheEnabled \n long getUserThreadId \n void resetOriginalValues \n Serializable getPrimaryKeyObj \n Date getModifiedDate \n long getPrimaryKey \n com.liferay.privatemessaging.model.UserThread toEscapedModel \n void setCreateDate \n void setCachedModel \n String getModelClassName \n void setCompanyId \n boolean isFinderCacheEnabled \n boolean isRead \n ExpandoBridge getExpandoBridge \n boolean getDeleted \n boolean isDeleted \n void setUserName \n int hashCode \n void setRead \n void persist \n void setNew \n java.lang.String getUserUuid \n boolean isNew \n Class<?> getModelClass \n void setMbThreadId \n void setModifiedDate \n long getCompanyId \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n void setUserThreadId \n java.lang.String toString \n long getUserId \n void setDeleted", "output": "void function ( long arg0 ) { _userThread . setUserId ( arg0 ) ; }"}, {"instruction": "Generate java code\ngets the number of available color maps . ", "input": " Color color \n HashMap<String,ColorMap> colorMaps \n String name \n List<ColorMapEntry> colorList \n int ele \n\n void setName \n int getEle \n String getName \n void registerColorMap \n Color getColor \n Color getColor \n Color interpolate \n ColorMap create \n String[] getNames \n int compareTo \n void unregisterColorMap \n ColorMap getMap", "output": "int function ( ) { return colorMaps != null ? colorMaps . size ( ) : 0 ; }"}, {"instruction": "Generate java code\ntest will timeout if secure random implementation always returns a constant value . ", "input": " PlaceHolder placeHolder \n\n void testRandomLong \n void testRandomFloat \n void testRandomInt \n void testRandomBytes \n void testRandomDouble", "output": "void function ( OpensslSecureRandom arg0 , int arg1 ) { byte [ ] loc0 = new byte [ arg1 ] ; byte [ ] loc1 = new byte [ arg1 ] ; arg0 . nextBytes ( loc0 ) ; arg0 . nextBytes ( loc1 ) ; while ( Arrays . equals ( loc0 , loc1 ) ) { arg0 . nextBytes ( loc1 ) ; } }"}, {"instruction": "Generate java code\nfind all principals . ", "input": " Provider<EntityManager> entityManagerProvider \n DaoUtils daoUtils \n\n PrincipalEntity findById \n PrincipalEntity merge \n void create \n void create \n List<PrincipalEntity> findByPermissionId", "output": "List < PrincipalEntity > function ( ) { TypedQuery < PrincipalEntity > loc0 = entityManagerProvider . get ( ) . createQuery ( \"srini_string\" , PrincipalEntity . class ) ; return daoUtils . selectList ( loc0 ) ; }"}, {"instruction": "Generate java code\nget a collection containing all the edges leading from this vertex to other vertices . there is probably some overhead to creating the wrapper arraylist objects , but this allows filtering and combining edge lists using stock collection-based methods . ", "input": " long serialVersionUID \n I18NString name \n double x \n Edge[] incoming \n Logger LOG \n int index \n double y \n String label \n int maxIndex \n Edge[] outgoing \n\n String getName \n String getName \n String getLabel \n int getDegreeOut \n int getIndex \n Edge[] removeEdge \n void addIncoming \n double azimuthTo \n double azimuthTo \n int hashCode \n List<Edge> getOutgoingStreetEdges \n int getDegreeIn \n double getLon \n double getLat \n void writeObject \n void readObject \n int getMaxIndex \n double getX \n Coordinate getCoordinate \n boolean removeOutgoing \n double getY \n boolean removeIncoming \n void setIndex \n void addOutgoing \n String toString \n Edge[] addEdge \n Collection<Edge> getIncoming", "output": "Collection < Edge > function ( ) { return Arrays . asList ( outgoing ) ; }"}, {"instruction": "Generate java code\nreturn the next digitalrepositories . ", "input": " java.util.Vector vector \n int i \n\n boolean hasNext", "output": "osid . dr . DigitalRepository function ( ) { if ( i >= vector . size ( ) ) { throw new osid . dr . DigitalRepositoryException ( osid . dr . DigitalRepositoryException . NO_MORE_ITERATOR_ELEMENTS ) ; } return ( osid . dr . DigitalRepository ) vector . elementAt ( i ++ ) ; }"}, {"instruction": "Generate java code\nmethod to set the opcode . ", "input": " int payloadOffset \n short HW_MAX_LEN \n byte[] targetHWAddr \n jND_BYTE2 protAddrTypeNo \n byte[] srcProtAddr \n byte[] pload \n int ARP_REPLY \n int headerOffset \n short PROT_MAX_LEN \n jND_BYTE2 hwAddrTypeNo \n jND_BYTE1 hwLenNo \n int RARP_REQUEST \n int HEADER_LEN \n jND_BYTE1 protLenNo \n byte[] srcHWAddr \n int RARP_REPLY \n jND_BYTE2 opcodeNo \n byte[] targetProtAddr \n int ARP_REQUEST \n\n byte[] sourceHWAddress \n void sourceHWAddress \n jND_BYTE1 protocolAddressLength \n void protocolAddressLength \n byte[] targetProtocolAddress \n void targetProtocolAddress \n byte[] sourceProtocolAddress \n void sourceProtocolAddress \n byte[] payload \n void payload \n byte[] build \n jND_BYTE2 protocolAddressType \n void protocolAddressType \n byte[] targetHWAddress \n void targetHWAddress \n void parse \n void parse \n jND_BYTE2 opcode \n void opcode \n jND_BYTE1 hwAddressLength \n void hwAddressLength \n jND_BYTE2 hwAddressType \n void hwAddressType", "output": "void function ( jND_BYTE2 arg0 ) { opcodeNo = arg0 ; }"}, {"instruction": "Generate java code\ngets the results value for this reconciliationreportpage . ", "input": " java.lang.Integer startIndex \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n org.apache.axis.description.TypeDesc typeDesc \n java.lang.Integer totalResultSetSize \n com.google.api.ads.dfp.axis.v201408.ReconciliationReport[] results \n\n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n void setTotalResultSetSize \n java.lang.Integer getStartIndex \n void setStartIndex \n int hashCode \n boolean equals \n void setResults \n void setResults \n java.lang.Integer getTotalResultSetSize", "output": "com . google . api . ads . dfp . axis . v201408 . ReconciliationReport [ ] function ( ) { return results ; }"}, {"instruction": "Generate java code\ngets the timer label . ", "input": " boolean SINGLE_THREAD \n TimerListener listener \n boolean active \n long time \n String label \n\n void init \n void halt \n long getTime \n void start \n void onInnerTimeout", "output": "String function ( ) { return label ; }"}, {"instruction": "Generate java code\nsubmits the given runnable to the given executor catching and logging all @linkplain runtimeexception runtime exceptions thrown by the executor . ", "input": " RunnableExecutorPair next \n Runnable runnable \n Executor executor \n Logger log \n boolean executed \n RunnableExecutorPair runnables \n\n void add \n void execute", "output": "void function ( Runnable arg0 , Executor arg1 ) { try { arg1 . execute ( arg0 ) ; } catch ( RuntimeException loc0 ) { log . log ( Level . SEVERE , \"srini_string\" + arg0 + \"srini_string\" + arg1 , loc0 ) ; } }"}, {"instruction": "Generate java code\nreturns true if the given state is currently active otherwise false . ", "input": " ITimer timer \n boolean[] timeEvents \n int nextStateIndex \n State[] stateVector \n\n void init \n void exitAction \n void reactMain_region_End \n void runCycle \n void timeElapsed \n void exit \n void clearEvents \n void reactMain_region_Start \n void enter \n void setTimer \n ITimer getTimer \n void clearOutEvents \n void entryAction", "output": "boolean function ( State arg0 ) { switch ( arg0 ) { case main_region_Start : return stateVector [ 0 ] == State . main_region_Start ; case main_region_End : return stateVector [ 0 ] == State . main_region_End ; default : return false ; } }"}, {"instruction": "Generate java code\ncreate an instance of jaxbelement ", "input": " QName _UpdateLineDesignationRequest_QNAME \n QName _UpdateLineDesignationResponse_QNAME \n\n UpdateLineDesignationResponseType createUpdateLineDesignationResponseType \n UpdateLineDesignationRequestType createUpdateLineDesignationRequestType \n JAXBElement<UpdateLineDesignationRequestType> createUpdateLineDesignationRequest \n LineDesignationInfoType createLineDesignationInfoType", "output": "JAXBElement < UpdateLineDesignationResponseType > function ( UpdateLineDesignationResponseType arg0 ) { return new JAXBElement < UpdateLineDesignationResponseType > ( _UpdateLineDesignationResponse_QNAME , UpdateLineDesignationResponseType . class , null , arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the list of warnings , or null if there were none . ", "input": " List<String> warnings \n List<String> errors \n\n void warning \n String formatDetailedMessage \n void error \n List<String> errors", "output": "List < String > function ( ) { return warnings ; }"}, {"instruction": "Generate java code\nreturns whether the lines match between this instance and the one given . ", "input": " int address \n int line \n SourcePosition NO_INFO \n CstString sourceFile \n\n boolean sameLineAndFile \n int hashCode \n CstString getSourceFile \n boolean equals \n int getLine \n String toString \n int getAddress", "output": "boolean function ( SourcePosition arg0 ) { return ( line == arg0 . line ) ; }"}, {"instruction": "Generate java code\nauto generated getter method ", "input": " javax.xml.namespace.QName MY_QNAME \n com.amazon.ec2.AssociateRouteTableResponseType localAssociateRouteTableResponse \n\n java.lang.String generatePrefix \n void serialize \n void serialize \n void writeQName \n void writeQNames \n javax.xml.stream.XMLStreamReader getPullParser \n void writeQNameAttribute \n boolean isReaderMTOMAware \n java.lang.String registerPrefix \n org.apache.axiom.om.OMElement getOMElement \n AssociateRouteTableResponse parse \n void setAssociateRouteTableResponse \n void writeAttribute \n void writeAttribute", "output": "com . amazon . ec2 . AssociateRouteTableResponseType function ( ) { return localAssociateRouteTableResponse ; }"}, {"instruction": "Generate java code\nrestituisce il bottonefase spostamento ", "input": " Rectangle dimensioni \n BottoneRisicammara giocatoreButton \n BottoneRisicammara carteButton \n MenuGiocatore menuGiocatore \n Point posizioneCarte \n BarraFasi barraFasi \n MenuCarte menuCarte \n Point posizioneGiocatore \n Dimension dimensioniPannello \n\n void disegna \n BottoneRisicammara getGiocatoreButton \n BarraFasi getBarraFasi \n MenuGiocatore getMenuGiocatore \n BottoneRisicammara getCarteButton \n BottoneFaseAttaccoAvanzato getBottoneFaseAttacco \n MenuCarte getMenuCarte", "output": "BottoneFaseAvanzato function ( ) { return barraFasi . getBottoneFaseSpostamento ( ) ; }"}, {"instruction": "Generate java code\nobtains the @linkplain swordworldplayer player for this @linkplain clientsession session 's user , and puts the player into the one true room for this swordworld . ", "input": " Logger logger \n long serialVersionUID \n ManagedReference<SwordWorldRoom> roomRef \n\n void setRoom \n SwordWorldRoom getRoom \n void initialize", "output": "ClientSessionListener function ( ClientSession arg0 ) { logger . log ( Level . INFO , \"srini_string\" , arg0 . getName ( ) ) ; SwordWorldPlayer loc0 = SwordWorldPlayer . loggedIn ( arg0 ) ; loc0 . enter ( getRoom ( ) ) ; return loc0 ; }"}, {"instruction": "Generate java code\naccess the list of tools by group ", "input": " String CURRENT_PORTAL_PATH \n java.lang.String SERVICE_NAME \n org.sakaiproject.component.api.ServerConfigurationService m_instance \n String CURRENT_SERVER_URL \n\n java.util.List getDefaultTools \n java.lang.String getLoggedOutUrl \n java.util.List getCategoryGroups \n List<String> getToolCategories \n java.lang.String getServerName \n java.lang.String getServerIdInstance \n java.lang.String getToolUrl \n boolean getBoolean \n java.lang.String getServerUrl \n java.util.List getToolGroup \n java.util.List getToolOrder \n Map<String,String> getToolToCategoryMap \n java.lang.String getGatewaySiteId \n java.lang.String getAccessUrl \n java.lang.String getString \n java.lang.String getString \n java.lang.String getHelpUrl \n boolean toolGroupIsSelected \n Map<String,List<String>> getToolCategoriesAsMap \n java.lang.String getPortalUrl \n java.lang.String[] getStrings \n int getInt \n java.lang.String getAccessPath \n java.lang.String getUserHomeUrl \n java.lang.String getSakaiHomePath \n java.lang.String getServerId \n org.sakaiproject.component.api.ServerConfigurationService getInstance \n java.lang.String getServerInstance \n boolean toolGroupIsRequired", "output": "java . util . List function ( java . lang . String arg0 ) { org . sakaiproject . component . api . ServerConfigurationService loc0 = getInstance ( ) ; if ( loc0 == null ) return null ; return loc0 . getToolsRequired ( arg0 ) ; }"}, {"instruction": "Generate java code\nget a string representation of this database . ", "input": " List<PseudoSequence> pseudoSequences \n Cluster cluster \n\n void setCluster \n int size \n Set<Integer> getSequenceIDs \n void printDatabase \n List<PseudoSequence> getPseudoSequences \n Cluster getCluster \n void addSequence", "output": "String function ( ) { }"}, {"instruction": "Generate java code\nreturns the default state , or this state if it corresponds to the defaults for a given action subclass . ", "input": " int depth \n State defaults \n Element topElement \n int curStateIndex \n List<Element> elements \n\n void pop \n Element getElement \n void setElement \n void push \n StateIndex registerElementType", "output": "State function ( ) { if ( defaults != null ) return defaults ; return this ; }"}, {"instruction": "Generate java code\ncreate an instance of chargeinfotype.frequency ", "input": " PlaceHolder placeHolder \n\n OrderInfoType createOrderInfoType \n CouponInfoType createCouponInfoType \n ChargeInfoType createChargeInfoType \n PeriodicChargeInfoType createPeriodicChargeInfoType \n SharedCounterType createSharedCounterType \n ConfirmationInfoType createConfirmationInfoType \n OrderIdentifier createOrderIdentifier \n BalanceInfoType createBalanceInfoType \n CouponType createCouponType \n BucketBalanceType createBucketBalanceType \n DataBalanceType createDataBalanceType", "output": "ChargeInfoType . Frequency function ( ) { return new ChargeInfoType . Frequency ( ) ; }"}, {"instruction": "Generate java code\nif we did save away the value , then just access it , but if we did n't save it away , then we 'll want the most up-to-date value ", "input": " Object savedValue \n Object submittedValue \n Log log \n String name \n boolean haveSavedValue \n boolean setSubmittedInLocalValue \n boolean setLocalValueInValueBinding \n Object value \n\n void restoreState \n void clearSubmittedValue \n Object[] saveState \n void saveValue \n Object getSubmittedValue \n void discontinueSettingLocalValueInValueBinding \n void clearValue \n Object getValue \n void updateModel \n void setValue \n boolean equals \n void setSubmittedValue \n boolean isComponentValid \n String getDesc \n void setInvalid \n void validate", "output": "Object function ( FacesContext arg0 , UIComponent arg1 ) { if ( haveSavedValue ) return savedValue ; else return getValue ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngzip start ", "input": " Integer defaultPagesize \n Logger logger \n String x_app \n String x_device \n int MENU_BANLANCE \n String JSON_TYPE \n int MENU_PERSONAL \n int MENU_COLLECT \n String x_channel \n int MENU_COUSE \n String HEADUSERKEY \n int MENU_ORDER \n Integer startPage \n String USER_AGENT \n String x_userId \n ObjectMapper objectMapper \n int MENU_SAFE \n String MENU \n\n User getUserFromSession \n String getIpAddr \n void writeJ \n boolean validPicCode \n boolean cmpRandomKey \n String getRequestBodyByReader \n UserDeviceType parseDeviceType \n String genRandomKey \n void writeJSON \n int obtainClientPageSizeParameter \n String getHeaderForKey \n void writeZIP \n void writerZip \n UserDeviceType getDeviceType \n Long getUserIdFromSession \n Map<String,Object> getBaseHeader \n void writeJSONP \n void writer \n void writer \n void writer \n ModelAndView exp \n int obtainClientPageNoParameter", "output": "void function ( Object arg0 , String arg1 , HttpServletResponse arg2 ) { writerZip ( arg1 + \"srini_string\" + objectMapper . writeValueAsString ( arg0 ) + \"srini_string\" , arg2 , JSON_TYPE ) ; }"}, {"instruction": "Generate java code\nhandles errors . ", "input": " Logger LOGGER \n\n void fatalError \n void warning", "output": "void function ( SAXParseException arg0 ) { throw new SAXException ( XmlUtils . getPrettyParseExceptionInfo ( arg0 ) ) ; }"}, {"instruction": "Generate java code\ncreate a new builder instance with a specific status code . ", "input": " Map<String,Object> details \n Status status \n\n Builder withDetail \n Builder withException \n Health build \n int hashCode \n Builder outOfService \n Builder outOfService \n boolean equals \n Map<String,Object> getDetails \n String toString \n Builder up \n Builder up \n Status getStatus \n Builder down \n Builder down \n Builder down \n Builder down \n Builder unknown \n Builder unknown", "output": "Builder function ( String arg0 ) { return status ( new Status ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nrotate an array , see std : : rotate ", "input": " PlaceHolder placeHolder \n\n T[] reallocateBuffer \n int[] reallocateBuffer \n float[] reallocateBuffer \n T[] reallocateBuffer \n int[] reallocateBuffer \n float[] reallocateBuffer", "output": "void function ( int [ ] arg0 , int arg1 , int arg2 , int arg3 ) { int loc0 = arg2 ; while ( loc0 != arg1 ) { int loc1 = arg0 [ arg1 ] ; arg0 [ arg1 ] = arg0 [ loc0 ] ; arg0 [ loc0 ] = loc1 ; arg1 ++ ; loc0 ++ ; if ( loc0 == arg3 ) { loc0 = arg2 ; } else if ( arg1 == arg2 ) { arg2 = loc0 ; } } }"}, {"instruction": "Generate java code\nrecord an event . ", "input": " com.codahale.metrics.Meter meter \n boolean isEnabled \n\n void setEnabled \n double getFifteenMinuteRate \n double getMeanRate \n boolean isEnabled \n double getFiveMinuteRate \n long getCount \n double getOneMinuteRate", "output": "void function ( ) { if ( isEnabled ( ) ) { meter . mark ( ) ; } }"}, {"instruction": "Generate java code\nreturn the configured decoder . ", "input": " StringDecoder stringDecoder \n DataBufferFactory bufferFactory \n IntPredicate NEWLINE_DELIMITER \n Decoder<?> decoder \n\n List<MediaType> getReadableMediaTypes \n Flux<DataBuffer> splitOnNewline \n Flux<Object> read \n ServerSentEvent<Object> buildEvent \n Object decodeData \n boolean canRead \n Mono<Object> readMono", "output": "Decoder < ? > function ( ) { return this . decoder ; }"}, {"instruction": "Generate java code\nsets the save type used by the last save . ", "input": " String saveType \n String CONTENT_PARAM \n String SAVE_VALUE \n String OVERWRITE_VALUE \n String CANCEL_VALUE \n String STORED_CARET_POSITION \n String EMBED_ATTACHMENT_VALUE \n String previousVersion \n String SUBMITTED_CONTENT_PARAM \n String VERSION_PARAM \n String previousContent \n String LINK_ATTACHMENT_VALUE \n int previousRevision \n String PREVIEW_VALUE \n\n void setPreviousVersion \n void setPreviousRevision \n int getPreviousRevision \n void setPreviousContent \n String getPreviousVersion \n String getPreviousContent \n String getSaveType", "output": "void function ( String arg0 ) { this . saveType = arg0 ; }"}, {"instruction": "Generate java code\nassigns me my `` build '' button . ", "input": " WorkspaceSnapshot workspace \n Button buildButton \n IWorkingSetProxy.ISnapshot currentWorkingSet \n TreeViewer tree \n Button removeButton \n IWorkingSetProxy.ISnapshot initialWorkingSet \n Button addButton \n Button activateButton \n IWorkingSetConfiguration.ISnapshot currentConfig \n ProjectConfigsController projectsController \n Button renameButton \n\n void updateButtons \n void widgetSelected \n void setAddButton \n void renameConfig \n void removeConfig \n void widgetDefaultSelected \n void buildConfig \n void setRemoveButton \n void setProjectConfigsController \n void addConfig \n void projectSelectionsChanged \n void selectionChanged \n void setRenameButton \n Button updateButton \n void updateForActivation \n void setTreeViewer \n void setActivateButton \n void activateConfig", "output": "void function ( Button arg0 ) { this . buildButton = updateButton ( this . buildButton , arg0 ) ; }"}, {"instruction": "Generate java code\nsets is this effect should fire partial submit when finished . transitory also needs to be set to true . default is false ", "input": " boolean fired \n boolean submit \n boolean queued \n float fps \n boolean sync \n int sequenceId \n float duration \n String sequence \n float delay \n boolean transitory \n float from \n float to \n String id \n EffectsArguments ea \n boolean queueEnd \n String queue \n\n void setDuration \n void setSequence \n int getSequenceId \n float getDelay \n String getId \n boolean isSync \n void setSync \n boolean isFired \n float getDuration \n void setQueue \n void setFired \n int hashCode \n String getQueue \n void setId \n void setOptions \n boolean isQueueEnd \n boolean isQueued \n void setDelay \n float getFrom \n String getFunctionName \n void setTransitory \n void setQueueEnd \n void setFps \n void setFrom \n int getIntfromString \n void setSequenceId \n float getTo \n boolean isTransitory \n boolean isSubmit \n void setQueued \n boolean equals \n void setTo \n String toString \n String toString \n float getFps \n String getSequence", "output": "void function ( boolean arg0 ) { this . submit = arg0 ; ea . add ( \"srini_string\" , arg0 ) ; }"}, {"instruction": "Generate java code\nreturn the values for the correlation set ", "input": " String _keyValues[] \n int _csetId \n long serialVersionUID \n\n List<String> toCanonicalList \n void escapeTilde \n String toCanonicalString \n int hashCode \n boolean equals \n int getCSetId \n String toString \n boolean isMatch", "output": "String [ ] function ( ) { return _keyValues ; }"}, {"instruction": "Generate java code\ntests the com.acme.spring.javaconfig.repository.impl.defaultstockrepository #getall method . ", "input": " StockRepository stockRepository \n\n List<Stock> createStocks \n Stock createStock \n void testGet \n Archive createTestArchive \n void assertStock \n void testSave \n void testGetBySymbol \n void testUpdate \n void saveStocks", "output": "void function ( ) { List < Stock > loc0 = createStocks ( ) ; saveStocks ( loc0 ) ; List < Stock > loc1 = stockRepository . getAll ( ) ; assertNotNull ( \"srini_string\" , loc1 ) ; assertEquals ( \"srini_string\" , 2 , loc1 . size ( ) ) ; }"}, {"instruction": "Generate java code\ndisable trust management and hostname verification . note this is a security hole , so only set this option if you can not or do not want to verify the identity of the host you are communicating with . ", "input": " TimeUnit socketTimeoutUnits \n TimeUnit establishConnectionTimeoutUnits \n SSLContext sslContext \n int connectionPoolSize \n long socketTimeout \n TimeUnit connectionTTLUnit \n long establishConnectionTimeout \n KeyStore clientKeyStore \n boolean disableTrustManager \n int maxPooledPerRoute \n HostnameVerifier verifier \n HostnameVerifier verifier \n HostnameVerificationPolicy policy \n KeyStore truststore \n long connectionTTL \n String clientPrivateKeyPassword \n\n void checkServerTrusted \n HttpClientBuilder connectionTTL \n HttpClientBuilder connectionPoolSize \n HttpClientBuilder sslContext \n HttpClientBuilder hostnameVerification \n void checkClientTrusted \n HttpClientBuilder establishConnectionTimeout \n HttpClientBuilder maxPooledPerRoute \n HttpClient build \n HttpClient build \n HttpClientBuilder keyStore \n HttpClientBuilder keyStore \n HttpClientBuilder socketTimeout \n HttpClientBuilder trustStore \n void verify \n void verify \n void verify \n boolean verify \n X509Certificate[] getAcceptedIssuers", "output": "HttpClientBuilder function ( ) { this . disableTrustManager = true ; return this ; }"}, {"instruction": "Generate java code\nreturns the primary key of this vcms attached message . ", "input": " VcmsAttachedMessage _vcmsAttachedMessage \n\n void setExpandoBridgeAttributes \n void setContent \n void setGroupId \n boolean isEscapedModel \n java.lang.String getContent \n boolean isCachedModel \n com.liferay.portlet.expando.model.ExpandoBridge getExpandoBridge \n boolean isReadMessage \n int compareTo \n VcmsAttachedMessage getWrappedModel \n void setCreatedByUser \n long getGroupId \n java.lang.String getMessageId \n com.liferay.portal.model.CacheModel<com.vportal.portlet.vcms.model.VcmsAttachedMessage> toCacheModel \n int hashCode \n void setPrimaryKey \n java.util.Date getCreatedDate \n void setReadMessage \n void persist \n void setNew \n void resetOriginalValues \n boolean isNew \n void setMessageId \n java.io.Serializable getPrimaryKeyObj \n Class<?> getModelClass \n com.vportal.portlet.vcms.model.VcmsAttachedMessage toEscapedModel \n void setCreatedDate \n long getCompanyId \n void setArticleId \n boolean getReadMessage \n VcmsAttachedMessage getWrappedVcmsAttachedMessage \n java.lang.String toXmlString \n void setPrimaryKeyObj \n java.lang.Object clone \n void setCachedModel \n java.lang.String getCreatedByUser \n java.lang.String toString \n String getModelClassName \n void setCompanyId \n java.lang.String getArticleId", "output": "java . lang . String function ( ) { return _vcmsAttachedMessage . getPrimaryKey ( ) ; }"}, {"instruction": "Generate java code\nchecks if text is empty characters < = space ", "input": " PlaceHolder placeHolder \n\n String arrayToString \n int rightTrimSize \n String toZeroPaddedString \n String[] split \n String getList \n String getList \n String getList \n String toLowerSubset \n String toPaddedString \n String toPaddedString \n int skipSpaces \n void appendPair", "output": "boolean function ( String arg0 ) { int loc0 = arg0 == null ? 0 : arg0 . length ( ) ; while ( loc0 > 0 ) { if ( arg0 . charAt ( -- loc0 ) > ' ' ) { return false ; } } return true ; }"}, {"instruction": "Generate java code\npeek . ", "input": " List<E> mElements \n int mSize \n\n E pop \n E set \n int size \n E get \n boolean isEmpty \n void clear \n void push \n E remove", "output": "E function ( ) { if ( mSize == 0 ) throw new EmptyStackException ( ) ; return mElements . get ( mSize - 1 ) ; }"}, {"instruction": "Generate java code\nattribute specifying whether to ignore the difference between / and \\ the two common directory characters . ", "input": " int prefixLength \n int postfixLength \n boolean fromContainsStar \n String fromPrefix \n boolean handleDirSep \n boolean caseSensitive \n String fromPostfix \n String toPrefix \n boolean toContainsStar \n String toPostfix \n\n void setCaseSensitive \n String modifyName \n boolean getHandleDirSep \n void setFrom \n String[] mapFileName \n void setTo \n String extractVariablePart", "output": "void function ( boolean arg0 ) { this . handleDirSep = arg0 ; }"}, {"instruction": "Generate java code\nthe 24 hour time slices are fix - 00:00 to 24:00 . this method determines the 24 hour time slice based on #currenthour and returns the start of the time slice . ", "input": " Supplier<DateTime> now \n\n DateTime currentMinute \n DateTime currentHour \n TemporalAdjuster startOfNextOddHour \n DateTime get24HourTimeSlice \n long getTimeSlice \n DateTime getTimeSlice", "output": "DateTime function ( ) { return get24HourTimeSlice ( currentHour ( ) ) ; }"}, {"instruction": "Generate java code\nget the margin value . ", "input": " int margin \n boolean INVALID \n boolean VALID \n HashMap<String,String> attributes \n boolean state \n\n void setAttributs \n String printAttributes \n HashMap<String,String> getAttributes \n String getLaneAttribute \n boolean isValid \n void setMargin \n void setState \n void setLaneAttribute \n String toString \n void main", "output": "int function ( ) { return margin ; }"}, {"instruction": "Generate java code\nchecks if data size for node is represented by quotableparent path should be updated asynchronously . if so that path is putting into respective collection . ", "input": " ThreadLocal<ChangesItem> pendingChanges \n Log LOG \n RPCService rpcService \n RemoteCommand applyPersistedChangesTask \n String wsName \n ExceededQuotaBehavior exceededQuotaBehavior \n WorkspaceQuotaManager wqm \n String uniqueName \n ChangesLog changesLog \n String rName \n ExecutorService executor \n QuotaPersister quotaPersister \n LocationFactory lFactory \n\n void validatePendingRepositoryChanges \n void onCommit \n void validatePendingWorkspaceChanges \n void pushChangesToCoordinator \n void validatePendingNodesChanges \n void onSaveItems \n void addPathsWithUnknownChangedSize \n void destroy \n void validatePendingGlobalChanges \n boolean isTXAware \n void behaveWhenQuotaExceeded \n void validatePendingChanges \n String getPath \n void onRollback \n void pushAllChangesToCoordinator \n void initApplyPersistedChangesTask", "output": "void function ( ChangesItem arg0 , String arg1 ) { boolean loc0 ; try { loc0 = quotaPersister . isNodeQuotaOrGroupOfNodesQuotaAsync ( rName , wsName , arg1 ) ; } catch ( UnknownQuotaLimitException loc1 ) { loc0 = true ; } if ( loc0 ) { arg0 . addPathWithAsyncUpdate ( arg1 ) ; } }"}, {"instruction": "Generate java code\nit returns the attribute setters ", "input": " Set<Method> setters \n String name \n long serialVersionUID \n Field attribute \n Set<Method> getters \n\n void setAttribute \n String getName \n Field getAttribute \n Set<Method> getGetters \n Set<Method> getRawSetters \n int hashCode \n boolean equals \n String toString \n Set<Method> getRawGetters", "output": "Set < Method > function ( ) { return new HashSet < Method > ( setters ) ; }"}, {"instruction": "Generate java code\nrequests , in a jdk 1.1 compliant way , that the file or directory denoted by the given abstract pathname be deleted when the virtual machine terminates . deletion will be attempted only for jdk 1.2 and greater runtime environments and only upon normal termination of the virtual machine , as defined by the java language specification . once deletion has been sucessfully requested , it is not possible to cancel the request . this method should therefore be used with care . ", "input": " boolean fsNormalizesPosixSeparator \n FileUtil fileUtil \n FileDescriptor outDescriptor \n Random random \n boolean fsIsIgnoreCase \n\n void renameElement \n java.io.InputStream openInputStreamElement \n IOException toIOException \n boolean isStreamElement \n boolean delete \n File canonicalFile \n File canonicalFile \n void sync \n FileAccess.FileSync getFileSync \n FileUtil getDefaultInstance \n boolean renameOverwrite \n String canonicalPath \n String canonicalPath \n boolean exists \n boolean exists \n String absolutePath \n void removeElement \n void makeParentDirectories \n java.io.OutputStream openOutputStreamElement \n void createParentDirs \n String canonicalOrAbsolutePath", "output": "void function ( File arg0 ) { JavaSystem . deleteOnExit ( arg0 ) ; }"}, {"instruction": "Generate java code\nsince 4.1 ", "input": " Log log \n ClientConnectionOperator connOperator \n ConnPoolByRoute pool \n AbstractConnPool connectionPool \n SchemeRegistry schemeRegistry \n ConnPerRouteBean connPerRoute \n\n ClientConnectionOperator createConnectionOperator \n int getDefaultMaxPerRoute \n void releaseConnection \n void setDefaultMaxPerRoute \n void setMaxTotal \n int getMaxForRoute \n void setMaxForRoute \n void closeExpiredConnections \n void closeIdleConnections \n AbstractConnPool createConnectionPool \n ConnPoolByRoute createConnectionPool \n ClientConnectionRequest requestConnection \n void finalize \n int getConnectionsInPool \n int getConnectionsInPool \n SchemeRegistry getSchemeRegistry \n void shutdown", "output": "int function ( ) { return pool . getMaxTotalConnections ( ) ; }"}, {"instruction": "Generate java code\nsets the value of the contrast property . ", "input": " Integer contrast \n Integer bright \n\n void setBright \n int getContrast \n int getBright", "output": "void function ( Integer arg0 ) { this . contrast = arg0 ; }"}, {"instruction": "Generate java code\nmethod to set the destination path . ", "input": " String associationType \n String destinationPath \n String sourcePath \n\n void setSourcePath \n String getSourcePath \n String getAssociationType \n String getDestinationPath \n void setAssociationType", "output": "void function ( String arg0 ) { this . destinationPath = arg0 ; }"}, {"instruction": "Generate java code\nconvert object to json ", "input": " Gson GSON \n Gson GSON_NO_NULLS \n\n Gson createGson \n Gson createGson \n V fromJson \n V fromJson \n V fromJson \n V fromJson \n V fromJson \n V fromJson \n Gson getGson \n Gson getGson", "output": "String function ( final Object arg0 ) { return toJson ( arg0 , true ) ; }"}, {"instruction": "Generate java code\nadd information message to a specific client . ", "input": " PlaceHolder placeHolder \n\n String getRequestParameter \n Application getApplication \n ValueBinding getValueBinding \n Object getElValue \n Object getManagedBean \n void addErrorMessage \n void addErrorMessage \n String getJsfEl \n void resetManagedBean \n void setManagedBeanInSession \n HttpServletRequest getServletRequest", "output": "void function ( String arg0 , String arg1 ) { FacesContext . getCurrentInstance ( ) . addMessage ( arg0 , new FacesMessage ( FacesMessage . SEVERITY_INFO , arg1 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nreturns the value of the security property named by the argument . ", "input": " Class<?> unused \n Properties secprops \n\n List<String> getAliases \n int addProvider \n Provider[] getProviders \n Provider[] getProviders \n Provider[] getProviders \n int insertProviderAt \n String getAlgorithmProperty \n void renumProviders \n void renumProviders \n void filterProviders \n Provider.Service getService \n void removeProvider \n void setProperty \n Provider getProvider \n void registerDefaultProviders \n Set<String> getAlgorithms", "output": "String function ( String arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = secprops . getProperty ( arg0 ) ; if ( loc0 != null ) { loc0 = loc0 . trim ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns a bean expression value builder ", "input": " PlaceHolder placeHolder \n\n ValueBuilder faultBodyAs \n ValueBuilder constant \n ValueBuilder sendTo \n ValueBuilder systemProperty \n ValueBuilder systemProperty \n ValueBuilder language \n ValueBuilder simple \n ValueBuilder simple \n ValueBuilder body \n ValueBuilder outBody \n ValueBuilder outBodyAs \n ValueBuilder bodyAs \n ValueBuilder exchangeProperty \n ValueBuilder property \n ValueBuilder header \n ValueBuilder faultBody \n ValueBuilder exceptionStackTrace \n ValueBuilder exceptionMessage \n ValueBuilder regexReplaceAll \n ValueBuilder regexReplaceAll", "output": "ValueBuilder function ( Class < ? > arg0 , String arg1 ) { Expression loc0 = new MethodCallExpression ( arg0 , arg1 ) ; return new ValueBuilder ( loc0 ) ; }"}, {"instruction": "Generate java code\nthis method always returns 0 to indicate equality for any argument . this is only meaningful when comparing against other principal objects or names of principals . ", "input": " AnybodyPrincipal ANYBODY_PRINCIPAL \n String ANYBODY \n\n String getName \n int hashCode \n String toString \n int compareTo", "output": "boolean function ( Object arg0 ) { return true ; }"}, {"instruction": "Generate java code\nset the target name . ", "input": " String targetName \n Log logger \n boolean exceptionIfInvalid \n Validator validator \n boolean resolvePlaceholders \n MessageSource messageSource \n boolean ignoreNestedProperties \n T target \n char[] TARGET_NAME_DELIMITERS \n char[] EXACT_DELIMITERS \n boolean ignoreInvalidFields \n boolean hasBeenBound \n ConversionService conversionService \n PropertySources propertySources \n boolean ignoreUnknownFields \n\n void setMessageSource \n T getObject \n PropertyNamePatternsMatcher getPropertyNamePatternsMatcher \n void setIgnoreInvalidFields \n void setIgnoreUnknownFields \n boolean isSingleton \n void bindPropertiesToTarget \n void setValidator \n void setResolvePlaceholders \n Set<String> getNames \n boolean isMapTarget \n void setConversionService \n void setIgnoreNestedProperties \n PropertyValues getPropertySourcesPropertyValues \n void setPropertySources \n void afterPropertiesSet \n Class<?> getObjectType \n void doBindPropertiesToTarget \n Iterable<String> getRelaxedTargetNames \n void setExceptionIfInvalid \n void validate \n void customizeBinder", "output": "void function ( String arg0 ) { this . targetName = arg0 ; }"}, {"instruction": "Generate java code\ngets the activitydatetime value for this activityrecord . ", "input": " java.lang.String foreignSysOrgId \n java.lang.String orgName \n java.lang.String mktgAssetName \n boolean __hashCodeCalc \n java.util.Calendar activityDateTime \n java.lang.String personName \n org.apache.axis.description.TypeDesc typeDesc \n java.lang.String foreignSysId \n java.lang.Object __equalsCalc \n com.marketo.www.mktows.Attribute[] activityAttributes \n java.lang.String campaign \n long id \n java.lang.String activityType \n java.lang.String mktPersonId \n\n java.lang.String getCampaign \n com.marketo.www.mktows.Attribute[] getActivityAttributes \n java.lang.String getPersonName \n long getId \n void setMktgAssetName \n void setForeignSysId \n void setMktPersonId \n org.apache.axis.encoding.Serializer getSerializer \n int hashCode \n java.lang.String getActivityType \n void setPersonName \n java.lang.String getForeignSysOrgId \n void setId \n void setForeignSysOrgId \n java.lang.String getForeignSysId \n java.lang.String getOrgName \n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Deserializer getDeserializer \n void setOrgName \n void setCampaign \n void setActivityAttributes \n boolean equals \n java.lang.String getMktgAssetName \n void setActivityDateTime \n void setActivityType \n java.lang.String getMktPersonId", "output": "java . util . Calendar function ( ) { return activityDateTime ; }"}, {"instruction": "Generate java code\nencodes a string into base64 format . no blanks or line breaks are inserted . ", "input": " char[] map1 \n byte[] map2 \n\n char[] encode \n char[] encode \n String decodeString \n String removeNewLine \n byte[] decode \n byte[] decode", "output": "String function ( String arg0 ) { return new String ( encode ( arg0 . getBytes ( ) ) ) ; }"}, {"instruction": "Generate java code\nremove the given authorized roles from an action . note that this is only relevant if a role was previously authorized for that action . if no roles where previously authorized the effect of the unauthorize call is that no roles at all will be authorized for that action . ", "input": " Map<Action,EnumSet<Role>> authorizedRolesForAction \n\n EnumSet<Role> rolesFor \n void authorize \n void authorize \n void authorizeAll", "output": "void function ( final Action arg0 , final EnumSet < Role > arg1 ) { this . unauthorize ( arg0 , arg1 . toArray ( new Role [ arg1 . size ( ) ] ) ) ; }"}, {"instruction": "Generate java code\nadds the new settings name if it does not nexist , or overwrites the old one . ", "input": " String homedir \n String fileName \n String emptySettingName \n String[][] sJDBCTypes \n String[][] connTypes \n File recentSettings \n\n void setHomeDir \n void storeRecentConnectionSettings \n Hashtable loadRecentConnectionSettings \n String[][] getTypes \n void deleteRecentConnectionSettings", "output": "void function ( Hashtable arg0 , ConnectionSetting arg1 ) { arg0 . put ( arg1 . getName ( ) , arg1 ) ; ConnectionDialogCommon . storeRecentConnectionSettings ( arg0 ) ; }"}, {"instruction": "Generate java code\nthis event is ignored not required . ", "input": " SortButtonRenderer renderer \n SortableTableModel model \n int sortColumnIndex \n\n void mouseReleased \n void setTableModel \n void mouseDragged \n void mouseExited \n void mouseClicked \n void mouseMoved \n void mousePressed", "output": "void function ( final MouseEvent arg0 ) { }"}, {"instruction": "Generate java code\ncreate a random vector in -0.5 , 0.5 and scale it according the domain of the problem . ", "input": " ControlParameter alpha \n DistanceMeasure distanceMeasure \n ControlParameter betaMin \n ControlParameter gamma \n\n void setGamma \n Vector updatePosition \n StandardFireflyPositionUpdateStrategy getClone \n Vector moveToward \n ControlParameter getBetaMin \n DistanceMeasure getDistanceMeasure \n ControlParameter getGamma \n void setAlpha \n void setBetaMin \n void setDistanceMeasure \n ControlParameter getAlpha", "output": "Vector function ( Firefly arg0 ) { double loc0 = arg0 . getPosition ( ) . boundsOf ( 0 ) . getRange ( ) ; return Vector . newBuilder ( ) . repeat ( arg0 . getDimension ( ) , Real . valueOf ( 0.0 , new Bounds ( - 0.5 , 0.5 ) ) ) . buildRandom ( ) . multiply ( loc0 ) ; }"}, {"instruction": "Generate java code\nprocess a method with the dead-code remver ", "input": " BitSet worklist \n BitSet noSideEffectRegs \n SsaMethod ssaMeth \n int regCount \n ArrayList<SsaInsn>[] useList \n\n void visitNonMoveInsn \n boolean isCircularNoSideEffect \n void pruneDeadInstructions \n void visitMoveInsn \n void run \n void visitPhiInsn \n boolean hasSideEffect", "output": "void function ( SsaMethod arg0 ) { DeadCodeRemover loc0 = new DeadCodeRemover ( arg0 ) ; loc0 . run ( ) ; }"}, {"instruction": "Generate java code\ntest of getfechainicio method , of class lineareserva . ", "input": " Promocion promocion \n Date fecha \n Servicio servicio \n LineaReserva instance \n\n void setUpClass \n void testGetCantidad \n void testGetPromocion \n void tearDownClass \n void tearDown \n void testSetCantidad \n void testSetPromocion \n void testCrearDTLineaReserva \n void setUp \n void testSetFechaInicio \n void testSetFechaFin \n void testGetServicio \n void testGetPrecio \n void testGetFechaFin \n void testSetServicio", "output": "void function ( ) { System . out . println ( \"srini_string\" ) ; Date loc0 = fecha ; Date loc1 = instance . getFechaInicio ( ) ; assertEquals ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\nvalidates the signature on a simple notification service message . no amazon-specific dependencies , just plain java crypto and jackson for parsing ", "input": " String MESSAGE_ID \n String SIGNATURE_VERSION \n String SIGNATURE \n String TYPE \n String SUBSCRIBE_TYPE \n String TOPIC \n Set<String> INTERESTING_FIELDS \n String MESSAGE \n String TIMESTAMP \n String TOKEN \n String SUBSCRIBE_URL \n String NOTIFICATION_TYPE \n String UNSUBSCRIBE_TYPE \n Signature sigChecker \n String SUBJECT \n\n boolean verifySignature \n boolean verifySignature \n Map<String,String> parseJSON \n TreeMap<String,String> subscribeMessageValues \n TreeMap<String,String> publishMessageValues \n String stringToSign", "output": "boolean function ( String arg0 , PublicKey arg1 ) { Map < String , String > loc0 = parseJSON ( arg0 ) ; return verifySignature ( loc0 , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the value of the frameborder property . ", "input": " Layout layout \n String scrolling \n String flavour \n String src \n String background \n String width \n BigDecimal refresh \n String frameborder \n String ga \n Label label \n String height \n\n void setSrc \n Label getLabel \n String getSrc \n void setRefresh \n void setLayout \n String getWidth \n String getScrolling \n String getGa \n void setWidth \n void setHeight \n void setBackground \n Layout getLayout \n String getHeight \n void setGa \n void setLabel \n String getFlavour \n String getFrameborder \n BigDecimal getRefresh \n void setScrolling \n void setFlavour \n String getBackground", "output": "void function ( String arg0 ) { this . frameborder = arg0 ; }"}, {"instruction": "Generate java code\nreturns a hashcode for the specified value . ", "input": " PlaceHolder placeHolder \n\n int fastCeil", "output": "int function ( long arg0 ) { return ( ( int ) ( arg0 ^ ( arg0 >>> 32 ) ) ) * 31 ; }"}, {"instruction": "Generate java code\nadd text to the word currently being built . ", "input": " boolean isFirstParagraph \n boolean _justify \n String _currentWord \n boolean _fill \n int _textWidth \n int _indentation \n Line _currentLine \n PageAssembler _pages \n int _textHeight \n int _parIndent \n int REGULAR_SPACE_CONSTANT \n List<String> _words \n int _parSkip \n Queue<Line> _lines \n\n void addWord \n void addWord \n void newLine \n void setPageTextHeight \n void setTextWidth \n String getWord \n boolean isEmpty \n void setJustify \n int getNumWords \n LineAssembler createEndnoteAssembler \n void setFill \n void flushLine \n void setIndentation \n void setParSkip \n void outputConstantLine \n void outputJustifiedLine \n int getWordsLength \n void setParIndentation \n void emitLine \n void finishWord \n String indentStr \n void emitFormattedLines \n LineAssembler createLineAssembler \n void endParagraph \n void setTextHeight", "output": "void function ( String arg0 ) { _currentWord += arg0 ; }"}, {"instruction": "Generate java code\nretrieve the setter name from the field name . implementation is based on the code of java.beans.introspector . ", "input": " boolean reportNoSetterFound \n Field field \n String SET_PREFIX \n Object target \n\n void reportNoSetterFound \n boolean set", "output": "String function ( String arg0 ) { return new StringBuilder ( SET_PREFIX ) . append ( arg0 . substring ( 0 , 1 ) . toUpperCase ( Locale . ENGLISH ) ) . append ( arg0 . substring ( 1 ) ) . toString ( ) ; }"}, {"instruction": "Generate java code\nallow quit all marked error of the textcomponent . you must call it when you do n't want the errors marks . you must first call markerrors or a illegalargumentexception will be throw . ", "input": " String DESTROY_PROPERTY \n RealTimeSpellChecker realTimeSpellChecker \n Map<JTextComponent,ErrorMarkerListener> errorMarkers \n SpellChecker spellChecker \n String DOCUMENT_PROPERTY \n PropertyChangeListener automaticStopListener \n EventMulticaster<TextComponentSpellCheckerListener> eventMulticaster \n DocumentWordFinder defaultDocumentWordFinder \n ErrorToolTips errorToolTips \n PropertyChangeListener docChangeListener \n UIErrorMarkerListener uiErrorListener \n ActionManager actionManager \n ErrorPopUpMenu errorPopUpMenu \n\n RealTimeSpellCheckAction getRealTimeSpellCheckAction \n void ignoreWord \n AddWordAction getAddWordAction \n ActionManager getActionManager \n void markInManagers \n void stopRealtimeMarkErrors \n DocumentWordFinder stopRealtimeMarkErrors \n void stopRealtimeMarkErrors \n void replaceBadWord \n ReplaceWordAction getReplaceWordAction \n ReplaceWordAction getReplaceWordAction \n ErrorMarkerListener getErrorMarkerListener \n void replaceAllBadWords \n boolean spellCheck \n boolean spellCheck \n IgnoreWordAction getIgnoreWordAction \n void propertyChange \n void propertyChange \n void unMarkInManagers \n void deleteBadWord \n ErrorPopUpMenu getErrorPopUpMenu \n void addListener \n void setErrorPopUpMenu \n void recheckAll \n void addWordToDictionary \n ReplaceAllWordsAction getReplaceAllWordsAction \n SpellCheckAction getSpellCheckAction \n DeleteWordAction getDeleteWordAction \n void removeListener \n void setActionManager \n void startRealtimeMarkErrors \n void startRealtimeMarkErrors \n void setErrorToolTips \n ErrorToolTips getErrorToolTips \n ErrorMarker getErrorMarker \n void markErrors \n void markErrors \n boolean isRealtimeMarkErrors \n boolean isRealtimeMarkErrors \n SpellChecker getSpellChecker \n void recheckErrors", "output": "void function ( JTextComponent arg0 ) { ErrorMarkerListener loc0 = getErrorMarkerListener ( arg0 ) ; if ( null != loc0 ) { loc0 . setTextComponent ( null ) ; errorMarkers . remove ( arg0 ) ; unMarkInManagers ( loc0 . getErrorMarker ( ) ) ; } else throw new IllegalArgumentException ( ) ; }"}, {"instruction": "Generate java code\nreturn name of the village , amount of houses and inhabitants . ", "input": " Villager mayor \n Villager[] villager \n int MAX_NUM_VILLAGER \n String name \n int amountHouses \n int population \n\n int getPopulation \n void addInhabitant \n void addInhabitant \n Villager[] getVillager \n String getName \n int getAmountHouses \n Villager getMayor \n boolean isNewPopulationOK \n Villager electMayor \n void buildHouse \n void setVillager \n Villager setMayor", "output": "String function ( ) { return \"srini_string\" + name + \"srini_string\" + amountHouses + \"srini_string\" + mayor . getName ( ) ; }"}, {"instruction": "Generate java code\ntest getting an specific airport ", "input": " AirportDao airportDao \n\n void testgetAirports \n void testdeleteAirport \n void testcreateAirport", "output": "void function ( ) { Airport loc0 ; try { loc0 = airportDao . getAirport ( ( long ) 1 ) ; Assert . assertEquals ( loc0 . getId ( ) , 1 ) ; loc0 = airportDao . getAirport ( ( long ) 1000 ) ; Assert . assertEquals ( loc0 , null ) ; } catch ( DatabaseException loc1 ) { loc1 . printStackTrace ( ) ; } }"}, {"instruction": "Generate java code\nsetnodeid ", "input": " List<Integer> m_reporters \n Type m_type \n String m_svcName \n String m_ipAddr \n Long m_nodeid \n\n void setReporters \n int getReporterCount \n List<Integer> getReporters \n String getIpAddr \n Long getNodeid \n Type getType \n void setSvcName \n void removeReporter \n void setIpAddr \n String getSvcName \n void addReporter \n void setType", "output": "void function ( final Long arg0 ) { m_nodeid = arg0 ; }"}, {"instruction": "Generate java code\nstart a named task . the results are undefined if #stop or timing methods are called without invoking this method . ", "input": " boolean running \n int taskCount \n long startTimeMillis \n String currentTaskName \n TaskInfo lastTaskInfo \n long totalTimeMillis \n List<TaskInfo> taskList \n String taskName \n String id \n boolean keepTaskList \n TimeValue timeValue \n\n StopWatch keepTaskList \n String prettyPrint \n String getTaskName \n String shortSummary \n TimeValue totalTime \n TimeValue getTime \n TimeValue lastTaskTime \n int taskCount \n StopWatch stop \n boolean isRunning \n String lastTaskName \n String toString \n TaskInfo[] taskInfo", "output": "StopWatch function ( String arg0 ) { if ( this . running ) { throw new IllegalStateException ( \"srini_string\" ) ; } this . startTimeMillis = System . currentTimeMillis ( ) ; this . running = true ; this . currentTaskName = arg0 ; return this ; }"}, {"instruction": "Generate java code\nsets the licenses declared . ", "input": " boolean licenseDeclaredCorrect \n String fileName \n String licenseConcluded \n List<LicensePairCompatibilityError> errors \n boolean licenseConcludedCorrect \n boolean isAdjustFeasible \n String licenseDeclared \n String[] infoLicenses \n List<String> proposedApplicableLicenses \n boolean violationDetected \n\n void setViolationDetected \n void setLicenseDeclaredCorrect \n void setInfoLicenses \n String getLicenseDeclared \n void setProposedApplicableLicenses \n void setLicenseConcluded \n boolean isLicenseDeclaredCorrect \n String[] getInfoLicenses \n void setErrors \n List<LicensePairCompatibilityError> getErrors \n boolean isLicenseConcludedCorrect \n void removeProposedApplicableLicense \n void setFileName \n void setLicenseConcludedCorrect \n boolean isViolationDetected \n boolean isAdjustFeasible \n void setAdjustFeasible \n String toString \n void addProposedApplicableLicense \n List<String> getProposedApplicableLicenses \n String getFileName \n String getLicenseConcluded", "output": "void function ( String arg0 ) { this . licenseDeclared = arg0 ; }"}, {"instruction": "Generate java code\nremembers this mouse location as last . ", "input": " Control m_control \n int m_stateMask \n int m_lastDragX \n int m_lastDragY \n int m_dragButton \n\n void endDrag \n void postModifiers \n void keyUp \n void keyUp \n void sendText \n void mouseEnter \n void sendCharacter \n void sendCharacter \n void postKeyEvent \n void dragTo \n void updateStateMask \n Event createEvent \n void mouseHover \n void mouseHover \n void postMouseDown \n void postMouseUp \n void setVerticalBarSelection \n void ctrlUp \n void postMouseDownUp \n void postMouseMove \n void postMouseMove \n void postMouseMove \n void click \n void click \n void click \n void click \n void ctrlDown \n void setStateMask \n void doubleClick \n void waitEventLoop \n void sendKey \n void sendKey \n void postMouseMoveAbs \n void postMouseMoveAbs \n void startDrag \n Event createKeyEvent \n void keyDown \n void keyDown \n EventSender moveTo", "output": "void function ( int arg0 , int arg1 ) { m_lastDragX = arg0 ; m_lastDragY = arg1 ; }"}, {"instruction": "Generate java code\nnarrow the given object to the dynany . for the objects that are always local , this operation does not differ from the ordinary #narrow classcastexception will be thrown if narrowing somethingdifferent . ", "input": " PlaceHolder placeHolder \n\n DynAny extract \n DynAny read \n void insert \n DynAny narrow \n String id \n TypeCode type \n void write", "output": "DynAny function ( org . omg . CORBA . Object arg0 ) { return narrow ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the page number , falls back to default value of 1 if not specified . ", "input": " Set<OrganisationUnit> organisationUnits \n TrackedEntity trackedEntity \n int DEFAULT_PAGE_SIZE \n Integer pageSize \n Program program \n TrackedEntityInstance trackedEntityInstance \n Date lastUpdated \n Boolean followUp \n boolean skipPaging \n Date programEndDate \n boolean totalPages \n Integer page \n Date programStartDate \n OrganisationUnitSelectionMode organisationUnitMode \n int DEFAULT_PAGE \n ProgramStatus programStatus \n\n boolean hasLastUpdated \n boolean hasProgramStartDate \n boolean isPaging \n boolean hasTrackedEntityInstance \n Integer getPage \n int getOffset \n void setProgramStartDate \n void setTrackedEntity \n void setOrganisationUnits \n Date getProgramStartDate \n boolean hasProgramStatus \n boolean hasProgramEndDate \n void setProgram \n Date getProgramEndDate \n Program getProgram \n void setLastUpdated \n TrackedEntityInstance getTrackedEntityInstance \n boolean isSkipPaging \n void addOrganisationUnit \n Set<OrganisationUnit> getOrganisationUnits \n void setOrganisationUnitMode \n boolean isOrganisationUnitMode \n void setPage \n void setTotalPages \n boolean hasTrackedEntity \n void setFollowUp \n Date getLastUpdated \n void setProgramEndDate \n ProgramStatus getProgramStatus \n boolean isTotalPages \n void setTrackedEntityInstance \n void setSkipPaging \n boolean hasOrganisationUnits \n Integer getPageSize \n void setProgramStatus \n Boolean getFollowUp \n boolean hasFollowUp \n boolean hasProgram \n void setDefaultPaging \n int getPageSizeWithDefault \n TrackedEntity getTrackedEntity \n OrganisationUnitSelectionMode getOrganisationUnitMode \n void setPageSize", "output": "int function ( ) { return page != null && page > 0 ? page : DEFAULT_PAGE ; }"}, {"instruction": "Generate java code\nget data ", "input": " List<MsgVpnRestDeliveryPointQueueBindingLinks> links \n SempMeta meta \n List<MsgVpnRestDeliveryPointQueueBinding> data \n\n String toIndentedString \n List<MsgVpnRestDeliveryPointQueueBindingLinks> getLinks \n MsgVpnRestDeliveryPointQueueBindingsResponse data \n void setData \n void setMeta \n MsgVpnRestDeliveryPointQueueBindingsResponse addDataItem \n MsgVpnRestDeliveryPointQueueBindingsResponse addLinksItem \n MsgVpnRestDeliveryPointQueueBindingsResponse meta \n int hashCode \n boolean equals \n void setLinks \n SempMeta getMeta \n MsgVpnRestDeliveryPointQueueBindingsResponse links \n String toString", "output": "List < MsgVpnRestDeliveryPointQueueBinding > function ( ) { return data ; }"}, {"instruction": "Generate java code\nsets the instancename value for this wsrolespecificationinstance . ", "input": " org.apache.axis.description.TypeDesc typeDesc \n java.lang.String instanceName \n java.lang.String[] parameter \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n boolean writable \n\n java.lang.String getInstanceName \n org.apache.axis.description.TypeDesc getTypeDesc \n void setWritable \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n int hashCode \n boolean equals \n void setParameter \n void setParameter \n boolean isWritable \n java.lang.String[] getParameter \n java.lang.String getParameter", "output": "void function ( java . lang . String arg0 ) { this . instanceName = arg0 ; }"}, {"instruction": "Generate java code\nget ith child inputsplit . ", "input": " InputSplit[] splits \n long totsize \n int fill \n\n void add \n void readFields \n String[] getLocation \n long getLength \n long getLength \n String[] getLocations \n void write", "output": "InputSplit function ( int arg0 ) { return splits [ arg0 ] ; }"}, {"instruction": "Generate java code\nsets the value of the currencycode property . ", "input": " String companyName \n Boolean testAccount \n String name \n Long customerId \n String dateTimeZone \n String currencyCode \n List<AccountLabel> accountLabels \n Boolean canManageClients \n\n void setName \n String getCurrencyCode \n String getName \n List<AccountLabel> getAccountLabels \n Boolean isCanManageClients \n String getDateTimeZone \n void setCompanyName \n Long getCustomerId \n Boolean isTestAccount \n void setTestAccount \n void setDateTimeZone \n String getCompanyName \n void setCanManageClients \n void setCustomerId", "output": "void function ( String arg0 ) { this . currencyCode = arg0 ; }"}, {"instruction": "Generate java code\ngets the response . ", "input": " UUID RESP_ID \n byte RESP_REQ_FLAG \n String cacheName \n int CMD_POS \n ByteBuffer response \n int AUX_OFFSET \n int KEY_POS \n long serialVersionUID \n List<String> msgParts \n\n UUID clientId \n void clientId \n String aux \n List<String> aux \n void setResponse \n List<String> getMsgParts \n List<String> auxMKeys \n UUID destinationId \n void destinationId \n GridRedisCommand command \n String cacheName \n void cacheName \n long requestId \n void requestId \n byte[] sessionToken \n void sessionToken \n String toString \n int messageSize \n void append \n String key", "output": "ByteBuffer function ( ) { return response ; }"}, {"instruction": "Generate java code\ncheck is this is a valid url ", "input": " PlaceHolder placeHolder \n\n boolean checkNumeric \n boolean isValidString \n boolean checkDecimal \n boolean checkPhoneNumber \n void paint \n int constrainedSize \n String getDisplayString \n String getDisplayString \n boolean checkEmail", "output": "boolean function ( char [ ] arg0 ) { return true ; }"}, {"instruction": "Generate java code\nverify if the given fetch orientation is part of the supported orientation types . ", "input": " HiveSession parentSession \n EnumSet<FetchOrientation> DEFAULT_FETCH_ORIENTATION_SET \n long lastAccessTime \n HiveConf configuration \n boolean hasResultSet \n long operationTimeout \n OperationHandle opHandle \n Log LOG \n boolean isOperationLogEnabled \n boolean runAsync \n OperationState state \n FetchOrientation DEFAULT_FETCH_ORIENTATION \n OperationLog operationLog \n long DEFAULT_FETCH_MAX_ROWS \n HiveSQLException operationException \n Future<?> backgroundHandle \n\n void cancel \n long getLastAccessTime \n void runInternal \n boolean isCanceled \n boolean isFailed \n boolean hasResultSet \n void cleanupOperationLog \n OperationHandle getHandle \n void setHasResultSet \n OperationLog getOperationLog \n void validateDefaultFetchOrientation \n void run \n void afterRun \n OperationStatus getStatus \n boolean isTimedOut \n Future<?> getBackgroundHandle \n void assertState \n HiveConf getConfiguration \n boolean isRunning \n TableSchema getResultSetSchema \n HiveSession getParentSession \n void setConfiguration \n void createOperationLog \n void close \n RowSet getNextRowSet \n RowSet getNextRowSet \n long getOperationTimeout \n void setBackgroundHandle \n void beforeRun \n boolean isFinished \n void setOperationTimeout \n HiveSQLException toSQLException \n TProtocolVersion getProtocolVersion \n void setOperationException \n OperationType getType \n OperationState setState \n void unregisterOperationLog \n boolean shouldRunAsync", "output": "void function ( FetchOrientation arg0 , EnumSet < FetchOrientation > arg1 ) { if ( ! arg1 . contains ( arg0 ) ) { throw new HiveSQLException ( \"srini_string\" + arg0 . toString ( ) + \"srini_string\" , \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\ngets requestor first name . ", "input": " Object notes \n Object deliveryMethod \n String itemBarcode \n Object requestorLastName \n String destination \n String customerCode \n Object errorCode \n Object requestorEmail \n Object priority \n String requestor \n Object requestorOther \n Object requestTime \n Object requestorFirstName \n Object requestDate \n Object errorNote \n Object requestorMiddleName \n\n void setRequestorEmail \n String getDestination \n void setRequestorFirstName \n void setDeliveryMethod \n void setDestination \n void setErrorCode \n void setNotes \n void setRequestorMiddleName \n Object getNotes \n Object getErrorCode \n String getItemBarcode \n Object getRequestorEmail \n void setRequestDate \n Object getRequestorOther \n void setRequestorOther \n Object getRequestorMiddleName \n Object getRequestTime \n Object getErrorNote \n Object getDeliveryMethod \n void setItemBarcode \n void setRequestor \n void setRequestorLastName \n void setRequestTime \n void setCustomerCode \n String getCustomerCode \n Object getRequestorLastName \n String getRequestor \n Object getPriority \n void setErrorNote \n Object getRequestDate \n void setPriority", "output": "Object function ( ) { return requestorFirstName ; }"}, {"instruction": "Generate java code\nthe state the channel entered . ", "input": " Date date \n long serialVersionUID \n ChannelState state \n\n Date getDate \n String toString", "output": "ChannelState function ( ) { return state ; }"}, {"instruction": "Generate java code\nadds 1 to the counter . progress condition : wait-free population oblivious o 1 above is only true on architectures that support fetch-and-add natively , and only with this fix : intrinsify getandincrement consistency model : sequentially consistent with decrement and sum ", "input": " int kNumCounters \n int CACHE_LINE \n AtomicLongArray counters \n\n void decrement \n void reset \n long sum \n int tid2hash", "output": "void function ( ) { counters . getAndIncrement ( tid2hash ( ) ) ; }"}, {"instruction": "Generate java code\nread the configuration file configfilename if it exists . moreover , a thread will be created that will periodically check if configfilename has been created or modified . the period is determined by the delay argument . if a change or file creation is detected , then configfilename is read to configure log4j . ", "input": " PlaceHolder placeHolder \n\n void doConfigure \n void doConfigure \n void doConfigure \n void doConfigure \n void configure \n void configure \n void configure \n void configure", "output": "void function ( final String arg0 , final long arg1 ) { }"}, {"instruction": "Generate java code\nsets the reporter jira user id of this j i r a issue . ", "input": " JIRAIssue _jiraIssue \n\n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setIssueNumber \n boolean isEscapedModel \n boolean isCachedModel \n int compareTo \n JIRAIssue getWrappedModel \n java.lang.String getStatus \n void setModelAttributes \n Map<String,Object> getModelAttributes \n com.liferay.portal.kernel.model.CacheModel<com.liferay.socialcoding.model.JIRAIssue> toCacheModel \n Date getCreateDate \n java.lang.String getAssigneeJiraUserId \n long getIssueNumber \n com.liferay.socialcoding.model.JIRAIssue toUnescapedModel \n void setPrimaryKey \n boolean isEntityCacheEnabled \n void setAssigneeJiraUserId \n java.lang.String getKey \n void resetOriginalValues \n void setResolution \n Serializable getPrimaryKeyObj \n Date getModifiedDate \n com.liferay.socialcoding.model.JIRAIssue toEscapedModel \n long getPrimaryKey \n void setCreateDate \n void setCachedModel \n void setProjectId \n String getModelClassName \n java.lang.String getResolution \n boolean isFinderCacheEnabled \n ExpandoBridge getExpandoBridge \n long getProjectId \n void setDescription \n void setJiraIssueId \n java.lang.String getDescription \n int hashCode \n void persist \n void setNew \n void setSummary \n java.lang.String getSummary \n boolean isNew \n Class<?> getModelClass \n void setStatus \n java.lang.String getReporterJiraUserId \n long getJiraIssueId \n void setModifiedDate \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n java.lang.String toString", "output": "void function ( java . lang . String arg0 ) { _jiraIssue . setReporterJiraUserId ( arg0 ) ; }"}, {"instruction": "Generate java code\noptional hook to supply additional attributes for any category including urn : oasis : names : tc : xacml :3.0 : attribute-category : environment ", "input": " Log log \n\n String findAction \n String getUserName \n String findServiceName \n String findOperationName", "output": "Attribute [ ] function ( MessageContext arg0 ) { return null ; }"}, {"instruction": "Generate java code\nset the most similar position in terms of frame number ", "input": " float score \n int mostSimilarFramePosition \n float similarity \n FingerprintProperties fingerprintProperties \n\n int getMostSimilarFramePosition \n float getsetMostSimilarTimePosition \n float getScore \n void setScore \n float getSimilarity \n void setSimilarity", "output": "void function ( int arg0 ) { this . mostSimilarFramePosition = arg0 ; }"}, {"instruction": "Generate java code\nlookup the specified name in the jndi context . ", "input": " String INITIAL_CONTEXT_FACTORY \n String QUEUE_JNDI_NAME \n InitialContext _ctx \n String CONNECTION_JNDI_NAME \n String QUEUE_NAME \n String BROKER \n String CONNECTION_NAME \n CountDownLatch _shutdownHook \n\n void onMessage \n void closeJNDI \n void main \n void setupJNDI", "output": "Object function ( String arg0 ) { try { return _ctx . lookup ( arg0 ) ; } catch ( NamingException loc0 ) { System . err . println ( \"srini_string\" + arg0 + \"srini_string\" + loc0 ) ; } return null ; }"}, {"instruction": "Generate java code\ngets the value of the start property . ", "input": " String total \n String unit \n String start \n String end \n String list \n\n void setTotal \n void setStart \n String getList \n void setUnit \n String getTotal \n void setEnd \n void setList \n String getUnit \n String getEnd", "output": "String function ( ) { return start ; }"}, {"instruction": "Generate java code\ntkgzip can return uncompressed content . ", "input": " PlaceHolder placeHolder \n\n void compressesOnDemandOnly", "output": "void function ( ) { MatcherAssert . assertThat ( new RsPrint ( new TkGzip ( new TkClasspath ( ) ) . act ( new RqFake ( Arrays . asList ( \"srini_string\" , \"srini_string\" ) , \"srini_string\" ) ) ) . print ( ) , Matchers . startsWith ( \"srini_string\" ) ) ; }"}, {"instruction": "Generate java code\nsetter method for the customer segment classification ", "input": " String percentCancelled \n String percentUR \n String percentClosed \n String subSubType \n String type \n String totalSR \n String retailerSegment \n String customerSegment \n String closed \n String closedLoopTask \n String cancelled \n String subType \n String percentClosedLoopTask \n String customerCategory \n String circle \n String retailerCategory \n String UR \n\n String getPercentUR \n void setCustomerCategory \n String getCircle \n void setSubType \n String getPercentClosedLoopTask \n void setSubSubType \n String getSubType \n void setClosed \n String getCancelled \n String getPercentClosed \n String getClosed \n String getClosedLoopTask \n String getRetailerSegment \n void setPercentUR \n String getSubSubType \n void setPercentClosed \n String getPercentCancelled \n void setCancelled \n void setPercentClosedLoopTask \n String getUR \n void setRetailerSegment \n void setTotalSR \n void setCircle \n void setPercentCancelled \n void setType \n void setClosedLoopTask \n String getRetailerCategory \n String getCustomerCategory \n String getType \n void setRetailerCategory \n String getTotalSR \n String getCustomerSegment \n void setUR", "output": "void function ( String arg0 ) { this . customerSegment = arg0 ; }"}, {"instruction": "Generate java code\nupdates the virtual host in the database or adds it if it does not yet exist . also notifies the appropriate model listeners . ", "input": " VirtualHostLocalService _service \n\n java.lang.String getOSGiServiceIdentifier \n java.util.List<com.liferay.portal.kernel.model.VirtualHost> getVirtualHosts \n com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery getActionableDynamicQuery \n com.liferay.portal.kernel.model.VirtualHost getVirtualHost \n com.liferay.portal.kernel.model.VirtualHost getVirtualHost \n com.liferay.portal.kernel.model.VirtualHost getVirtualHost \n com.liferay.portal.kernel.model.VirtualHost createVirtualHost \n com.liferay.portal.kernel.dao.orm.DynamicQuery dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n VirtualHostLocalService getService \n long dynamicQueryCount \n long dynamicQueryCount \n com.liferay.portal.kernel.model.PersistedModel deletePersistedModel \n com.liferay.portal.kernel.model.PersistedModel getPersistedModel \n com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery getIndexableActionableDynamicQuery \n com.liferay.portal.kernel.model.VirtualHost addVirtualHost \n com.liferay.portal.kernel.model.VirtualHost fetchVirtualHost \n com.liferay.portal.kernel.model.VirtualHost fetchVirtualHost \n com.liferay.portal.kernel.model.VirtualHost fetchVirtualHost \n com.liferay.portal.kernel.model.VirtualHost deleteVirtualHost \n com.liferay.portal.kernel.model.VirtualHost deleteVirtualHost \n int getVirtualHostsCount", "output": "com . liferay . portal . kernel . model . VirtualHost function ( com . liferay . portal . kernel . model . VirtualHost arg0 ) { return getService ( ) . updateVirtualHost ( arg0 ) ; }"}, {"instruction": "Generate java code\nget the first unbound binding in the list ", "input": " int COUNT \n List removedBindings \n Set<IBindingListViewer> changeListeners \n List<Binding> bindings \n\n Binding getNextTypeConflict \n void insert \n void remove \n void addChangeListener \n void removeAll \n Binding get \n Binding getRemovedBindingMatch \n boolean hasRemovedBindingMatch \n void moveTop \n void bindingChanged \n int indexOf \n void moveUp \n void moveBottom \n void add \n List getAll \n List getRemovedList \n void swap \n void refresh \n void moveDown \n Binding getNextUnbound \n boolean hasTypeConflict \n void removeChangeListener \n int size \n Binding getFirstBound \n void addAll \n Binding getNextBound \n Binding getFirstTypeConflict", "output": "Binding function ( ) { Binding loc0 = null ; Iterator loc1 = bindings . iterator ( ) ; while ( loc1 . hasNext ( ) ) { Binding loc2 = ( Binding ) loc1 . next ( ) ; if ( ! loc2 . isBound ( ) ) { loc0 = loc2 ; break ; } } return loc0 ; }"}, {"instruction": "Generate java code\nreturns a byte array with the buffer 's contents , trying to avoid copying the data if possible . ", "input": " long DEFAULT_DRIVER_MEM_MB \n Logger logger \n ImmutableMap<String,ByteUnit> byteSuffixes \n ImmutableMap<String,TimeUnit> timeSuffixes \n\n long timeStringAsSec \n void deleteRecursivelyUsingJavaIO \n long byteStringAsBytes \n File[] listFilesSafely \n int nonNegativeHash \n long byteStringAsGb \n long byteStringAs \n long byteStringAsMb \n long byteStringAsKb \n long timeStringAsMs \n long timeStringAs \n void closeQuietly \n void deleteRecursivelyUsingUnixNative \n ByteBuffer stringToBytes \n boolean isSymlink \n String bytesToString \n void deleteRecursively", "output": "byte [ ] function ( ByteBuffer arg0 ) { if ( arg0 . hasArray ( ) && arg0 . arrayOffset ( ) == 0 && arg0 . array ( ) . length == arg0 . remaining ( ) ) { return arg0 . array ( ) ; } else { byte [ ] loc0 = new byte [ arg0 . remaining ( ) ] ; arg0 . get ( loc0 ) ; return loc0 ; } }"}, {"instruction": "Generate java code\nmoves the current position relative ` rows ' from the current position . ", "input": " ResultSet owner \n ServerPreparedStatement prepStmt \n boolean wasEmpty \n boolean lastRowFetched \n List fetchedRows \n int BEFORE_START_OF_ROWS \n long statementIdOnServer \n int SERVER_STATUS_LAST_ROW_SENT \n int currentPositionInEntireResult \n int currentPositionInFetchedRows \n MysqlIO mysql \n Field[] fields \n boolean firstFetchCompleted \n\n Object[] next \n boolean wasEmpty \n boolean isDynamic \n void fetchMoreRows \n boolean isLast \n boolean isEmpty \n void beforeFirst \n boolean isBeforeFirst \n boolean hasNext \n void addRow \n ResultSet getOwner \n void setOwner \n void afterLast \n boolean isFirst \n void beforeLast \n void notSupported \n boolean isAfterLast \n Object[] getAt \n int size \n int getCurrentRowNumber \n void removeRow \n void close \n void nextRecord \n void setCurrentRow", "output": "void function ( int arg0 ) { notSupported ( ) ; }"}, {"instruction": "Generate java code\nmytag setter . ", "input": " List children \n Attributes attributes \n Tag tag \n\n List getChildren \n Attributes getAttributes \n void setAttributes \n Tag getTag \n void addChild \n void replaceTagWireWithChildren", "output": "void function ( Tag arg0 ) { this . tag = arg0 ; }"}, {"instruction": "Generate java code\nutility to create a containerstatus during exceptionalcircumstances . ", "input": " String LOST_CONTAINER \n String COMPLETED_APPLICATION \n String RELEASED_CONTAINER \n String UNRESERVED_CONTAINER \n RecordFactory recordFactory \n String EXPIRED_CONTAINER \n String PREEMPTED_CONTAINER \n\n void normalizeRequest \n void normalizeRequest \n void validateResourceRequest \n ContainerStatus createPreemptedContainerStatus \n void normalizeRequests \n void normalizeRequests", "output": "ContainerStatus function ( ContainerId arg0 , String arg1 ) { return createAbnormalContainerStatus ( arg0 , ContainerExitStatus . ABORTED , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the main operator name . ", "input": " String mainComNodeName \n Map<String,DataType> dataTypes \n int numberOfTopExecutions \n long averageDataSize \n String mainOperatorName \n Set<String> specialVertexOperatorIds \n\n int getNumberOfTopExecutions \n void setNumberOfTopExecutions \n int getDataTypeSizeOrDefault \n DataType getDataType \n void addSpecialVertexOperatorId \n void setMainComNodeName \n long getAverageDataSize \n void putDataType \n void removeSpecialVertexOperatorId \n void removeDataType \n void setAverageDataSize \n Map<String,DataType> getDataTypes \n boolean hasSpecialVertexOperatorId \n String getMainComNodeName \n String getMainOperatorName \n Set<String> getSpecialVertexOperatorIds", "output": "void function ( final String arg0 ) { this . mainOperatorName = arg0 ; }"}, {"instruction": "Generate java code\nsetter for value ", "input": " String preferredPrefix \n String unit \n String nameSpace \n Double value \n\n String toXMLString \n Double getValue \n boolean isWhitespaceNode \n void setUnit \n String getAttributeAsXml \n String getUnit", "output": "void function ( Double arg0 ) { this . value = arg0 ; }"}, {"instruction": "Generate java code\nthis method calls object #tostring on the given object , unless theobject is an array . in that case , it will use the #arraytostring object method to create a string representation of the array that includes all contained elements . ", "input": " PlaceHolder placeHolder \n\n String arrayToString \n String showControlCharacters \n String escapeHtml \n String readNullableString \n void writeNullableString \n String stringifyException \n String getRandomString \n String getRandomString \n byte[] hexStringToByte \n String byteToHexString \n String byteToHexString", "output": "String function ( Object arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } if ( arg0 . getClass ( ) . isArray ( ) ) { return arrayToString ( arg0 ) ; } return arg0 . toString ( ) ; }"}, {"instruction": "Generate java code\ninsert the idl type into the given any . ", "input": " PlaceHolder placeHolder \n\n IDLType extract \n IDLType read \n IDLType narrow \n String id \n TypeCode type \n void write", "output": "void function ( Any arg0 , IDLType arg1 ) { OutputStream loc0 = arg0 . create_output_stream ( ) ; arg0 . type ( type ( ) ) ; write ( loc0 , arg1 ) ; arg0 . read_value ( loc0 . create_input_stream ( ) , type ( ) ) ; }"}, {"instruction": "Generate java code\nfinds all nodes at the specified depth whose expected_policy_set contains the specified expected oid if matchany is false or the special oid `` any value '' if matchany is true . ", "input": " PolicyNodeImpl mParent \n boolean mCriticalityIndicator \n HashSet<String> mExpectedPolicySet \n HashSet<PolicyNodeImpl> mChildren \n String ANY_POLICY \n boolean isImmutable \n String mValidPolicy \n int mDepth \n HashSet<PolicyQualifierInfo> mQualifierSet \n boolean mOriginalExpectedPolicySet \n\n PolicyNode getParent \n int getDepth \n void deleteChild \n PolicyNodeImpl copyTree \n PolicyNodeImpl copyTree \n String getValidPolicy \n Set<PolicyQualifierInfo> getPolicyQualifiers \n Set<String> getExpectedPolicies \n Set<PolicyNodeImpl> getPolicyNodes \n void getPolicyNodes \n Iterator<PolicyNodeImpl> getChildren \n void setImmutable \n boolean isImmutable \n void prune \n Set<PolicyNodeImpl> getPolicyNodesValid \n String policyToString \n boolean isCritical \n String toString \n Set<PolicyNodeImpl> getPolicyNodesExpectedHelper \n String asString \n void addChild \n void addExpectedPolicy", "output": "Set < PolicyNodeImpl > function ( int arg0 , String arg1 , boolean arg2 ) { if ( arg1 . equals ( ANY_POLICY ) ) { return getPolicyNodes ( arg0 ) ; } else { return getPolicyNodesExpectedHelper ( arg0 , arg1 , arg2 ) ; } }"}, {"instruction": "Generate java code\nthis method returns the sequence quality . ", "input": " int occurrences \n double score \n String sequence \n String strand \n String cigar \n String chromosome \n int map_quality \n int start \n int end \n String firstData \n String quality \n\n void setCigar \n void setSequence \n int getStart \n void setStrand \n int getEnd \n String getChromosome \n String getStrand \n void setQuality \n int getOccurrences \n void setStart \n String getFirstData \n void increaseOccurrence \n void setMap_quality \n String toString \n void setEnd \n double getScore \n int getMap_quality \n String getSequence \n String getCigar \n void setChromosome \n void setScore \n void setOccurrences \n void setFirstData", "output": "String function ( ) { return quality ; }"}, {"instruction": "Generate java code\nreturns true iff the ref ends with the given suffix . otherwise false . ", "input": " BigInteger nextId \n int ID_LENGTH \n Object idLock \n BigInteger mask128 \n int GOOD_FAST_HASH_SEED \n\n boolean sliceEquals \n byte[] randomId \n BytesRef intsRefToBytesRef \n int bytesDifference \n boolean equals \n int murmurhash3_x86_32 \n int murmurhash3_x86_32 \n String idToString \n int sortKeyLength \n boolean startsWith \n boolean startsWith", "output": "boolean function ( BytesRef arg0 , BytesRef arg1 ) { return sliceEquals ( arg0 , arg1 , arg0 . length - arg1 . length ) ; }"}, {"instruction": "Generate java code\nmethod setvalue ", "input": " String myClassName \n String relationshipType \n int revisionID \n Log log \n int REVISION_2 \n long serialVersionUID \n ArrayList extensibilityAttributes \n String value \n\n String getValue \n void setExtensibilityAttributes \n void writeExternal \n ArrayList getExtensibilityAttributes \n String getRelationshipType \n void readExternal \n String toString \n void setRelationshipType", "output": "void function ( String arg0 ) { this . value = arg0 ; }"}, {"instruction": "Generate java code\ncreate a mutable integer counter ", "input": " Map<String,MutableMetric> metricsMap \n Map<String,MetricsTag> tagsMap \n MetricsInfo metricsInfo \n\n void add \n void add \n MutableGaugeInt newGauge \n MutableGaugeInt newGauge \n MutableGaugeLong newGauge \n MutableGaugeLong newGauge \n MetricsTag getTag \n MutableStat newStat \n MutableStat newStat \n Collection<MetricsTag> tags \n void checkTagName \n MutableMetric get \n MetricsRegistry setContext \n MutableRate newRate \n MutableRate newRate \n MutableRate newRate \n MutableRate newRate \n void checkMetricName \n String toString \n MetricsRegistry tag \n MetricsRegistry tag \n MetricsRegistry tag \n MetricsRegistry tag \n Collection<MutableMetric> metrics \n MutableQuantiles newQuantiles \n void snapshot \n MetricsInfo info", "output": "MutableCounterInt function ( String arg0 , String arg1 , int arg2 ) { return newCounter ( Interns . info ( arg0 , arg1 ) , arg2 ) ; }"}, {"instruction": "Generate java code\ngenerate a list of of typeinfos from an avro schema . this method is currently public due to some weirdness in deserializing unions , but will be made private once that is resolved . ", "input": " Map<Schema.Type,TypeInfo> primitiveTypeToTypeInfo \n InstanceCache<Schema,TypeInfo> typeInfoCache \n\n TypeInfo generateTypeInfo \n TypeInfo generateTypeInfoWorker \n TypeInfo generateMapTypeInfo \n TypeInfo generateArrayTypeInfo \n Map<Schema.Type,TypeInfo> initTypeMap \n TypeInfo generateRecordTypeInfo \n TypeInfo generateUnionTypeInfo \n TypeInfo generateEnumTypeInfo \n TypeInfo makeInstance", "output": "List < TypeInfo > function ( Schema arg0 ) { return generateColumnTypes ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nset the locale for error reporting . this is not supported in sax2 , and will always throw an exception . ", "input": " AttributesAdapter qAtts \n XMLReader xmlReader \n DocumentHandler documentHandler \n Attributes attributes \n\n void setupXMLReader \n void setEntityResolver \n String getName \n void endPrefixMapping \n void setDTDHandler \n void startElement \n void parse \n void parse \n void setAttributes \n void startDocument \n void endDocument \n void setDocumentHandler \n void characters \n String getValue \n String getValue \n void startPrefixMapping \n void endElement \n String getType \n String getType \n void setErrorHandler \n void skippedEntity \n void setup \n int getLength \n void setDocumentLocator \n void ignorableWhitespace \n void processingInstruction", "output": "void function ( Locale arg0 ) { throw new SAXNotSupportedException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nadds new filter queries ", "input": " List<String> fieldPresentQueries \n int facetOffset \n String query \n int facetLimit \n List<DiscoverFacetField> facetFields \n List<String> facetQueries \n List<String> filterQueries \n boolean spellCheck \n int DSpaceObjectFilter \n Map<String,DiscoverHitHighlightingField> hitHighlighting \n SORT_ORDER sortOrder \n String sortField \n int facetMinCount \n int maxResults \n List<String> searchFields \n int start \n Map<String,List<String>> properties \n\n void setFacetOffset \n int getStart \n void addHitHighlightingField \n List<DiscoverHitHighlightingField> getHitHighlightingFields \n int getMaxResults \n SORT_ORDER getSortOrder \n void addFacetField \n List<DiscoverFacetField> getFacetFields \n DiscoverHitHighlightingField getHitHighlightingField \n void setStart \n String getSortField \n void addFieldPresentQueries \n List<String> getFieldPresentQueries \n void setFacetMinCount \n void setQuery \n int getDSpaceObjectFilter \n String getQuery \n void setSortField \n void setDSpaceObjectFilter \n List<String> getFilterQueries \n Map<String,List<String>> getProperties \n int getFacetMinCount \n void addSearchField \n void addProperty \n List<String> getFacetQueries \n int getFacetOffset \n void setSpellCheck \n boolean isSpellCheck \n void addFacetQuery \n List<String> getSearchFields \n void setMaxResults", "output": "void function ( String ... arg0 ) { this . filterQueries . addAll ( Arrays . asList ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nregister a session factory with the given name . ", "input": " UnitOfWork unitOfWork \n Map<Method,UnitOfWork> methodMap \n Map<Method,UnitOfWork> methodMap \n Map<String,SessionFactory> sessionFactories \n Session session \n SessionFactory sessionFactory \n Map<String,SessionFactory> sessionFactories \n\n void beginTransaction \n RequestEventListener onRequest \n void commitTransaction \n void onEvent \n void onEvent \n void configureSession \n void rollbackTransaction \n void registerUnitOfWorkAnnotations", "output": "void function ( String arg0 , SessionFactory arg1 ) { sessionFactories . put ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ngets the value of the sbbvendor property . ", "input": " List<ResourceAdaptorTypeBinding> resourceAdaptorTypeBinding \n List<EnvEntry> envEntry \n Description description \n List<EjbRef> ejbRef \n SbbVendor sbbVendor \n List<ActivityContextAttributeAlias> activityContextAttributeAlias \n SbbClasses sbbClasses \n SbbName sbbName \n List<SbbRef> sbbRef \n List<ProfileSpecRef> profileSpecRef \n List<LibraryRef> libraryRef \n SbbVersion sbbVersion \n SbbAlias sbbAlias \n String id \n AddressProfileSpecAliasRef addressProfileSpecAliasRef \n List<Event> event \n\n List<Event> getEvent \n void setSbbVendor \n void setSbbAlias \n List<EnvEntry> getEnvEntry \n List<LibraryRef> getLibraryRef \n List<ActivityContextAttributeAlias> getActivityContextAttributeAlias \n List<ResourceAdaptorTypeBinding> getResourceAdaptorTypeBinding \n String getId \n SbbVersion getSbbVersion \n void setDescription \n void setSbbName \n Description getDescription \n void setAddressProfileSpecAliasRef \n List<ProfileSpecRef> getProfileSpecRef \n void setSbbVersion \n List<SbbRef> getSbbRef \n AddressProfileSpecAliasRef getAddressProfileSpecAliasRef \n SbbName getSbbName \n SbbAlias getSbbAlias \n SbbClasses getSbbClasses \n void setSbbClasses \n List<EjbRef> getEjbRef \n void setId", "output": "SbbVendor function ( ) { return sbbVendor ; }"}, {"instruction": "Generate java code\ncreate an identifier ", "input": " boolean trace \n CloneableBootstrapContext defaultBootstrapContext \n CoreLogger log \n ConcurrentMap<String,CloneableBootstrapContext> bootstrapContexts \n Map<String,CloneableBootstrapContext> activeBootstrapContexts \n Map<String,Integer> refCountBootstrapContexts \n WorkManagerCoordinator workManagerCoordinator \n\n void registerBootstrapContext \n void unregisterBootstrapContext \n void setDefaultBootstrapContext \n void removeBootstrapContext \n CloneableBootstrapContext getDefaultBootstrapContext \n CloneableBootstrapContext createBootstrapContext \n CloneableBootstrapContext createBootstrapContext \n void setWorkManagerCoordinator", "output": "String function ( String arg0 , Collection < ConfigProperty > arg1 ) { return createIdentifier ( arg0 , arg1 , null ) ; }"}, {"instruction": "Generate java code\ncall this from your startactivityforresult overload . this is required to catch the case where plugins use activity.startactivityforresult + cordovainterface.setactivityresultcallback rather than cordovainterface.startactivityforresult . ", "input": " String TAG \n PluginManager pluginManager \n Activity activity \n CordovaPlugin activityResultCallback \n String initCallbackService \n ActivityResultHolder savedResult \n int resultCode \n int requestCode \n ExecutorService threadPool \n int activityResultRequestCode \n Intent intent \n\n ExecutorService getThreadPool \n void restoreInstanceState \n void startActivityForResult \n void onCordovaInit \n Activity getActivity \n void setActivityResultCallback \n Object onMessage \n void onSaveInstanceState \n boolean onActivityResult", "output": "void function ( int arg0 ) { activityResultRequestCode = arg0 ; }"}, {"instruction": "Generate java code\nwhich connection dropped or was restarted ? ", "input": " MessageFilter _or \n boolean logMINOR \n boolean _setTimeout \n AsyncMessageFilterCallback _callback \n MessageType _type \n String VERSION \n boolean _matched \n List<String> _fieldList \n boolean _timeoutFromWait \n PeerContext _droppedConnection \n ByteCounter _ctr \n Message _message \n HashMap<String,Object> _fields \n PeerContext _source \n long _timeout \n long _oldBootID \n long _initialTimeout \n\n MessageFilter setSource \n boolean reallyTimedOut \n void clearOr \n void onMatched \n void onStartWaiting \n MessageFilter setField \n MessageFilter setField \n MessageFilter setField \n MessageFilter setField \n MessageFilter setField \n MessageFilter setField \n MessageFilter setAsyncCallback \n boolean matchesDroppedConnection \n boolean anyConnectionsDropped \n boolean matchesRestartedConnection \n long getTimeout \n void onTimedOut \n MessageFilter create \n void onRestartedConnection \n MessageFilter or \n boolean timedOut \n void clearMatched \n MATCHED match \n MATCHED match \n Message getMessage \n MessageFilter setType \n void setMessage \n MessageFilter setNoTimeout \n boolean hasCallback \n MessageFilter setTimeout \n PeerContext getSource \n MessageFilter setTimeoutRelativeToCreation \n boolean matched \n String toString \n void onDroppedConnection \n long getInitialTimeout", "output": "PeerContext function ( ) { return _droppedConnection ; }"}, {"instruction": "Generate java code\nensures two rectangles are overlaps when the top left corner of one rectangle overlaps the right corner of another . ", "input": " double EPSILON \n Rectangle rectangle \n\n void overlapsWhenLeftSideOverlapsMiddleOfOther \n void constructorShouldAllowNegativeValuesForY \n void constructorShouldAllowNegativeValuesForX \n void testHeight \n void overlapsWhenBottomRightOverlapsTopLeftOfOther \n void overlapsWhenRightSideOverlapsLeftSideOfOther \n void overlapsWhenRightSideOverlapsMiddleOfOther \n void overlapsWhenLeftSideOverlapsRightSideOfOther \n void overlapsWhenBottomLeftOverlapsRightOfOther \n void overlapsWhenBottomRightInsideOther \n void testX \n void testY \n void overlapsWhenTopRightInsideOther \n void overlapsWhenBottomRightOverlapsLeftOfOther \n void setUp \n void testoverlapsNullArgument \n void overlapsWhenTopRightOverlapsBottomOfOther \n void overlapsWhenTopLeftInsideOther \n void constructorShouldAllowZeroForWidth \n void overlapsWhenBottomLeftOverlapsTopRightOfOther \n void overlapsWhenTopSideOverlapsMiddleOfOther \n void overlapsWhenBottomLeftInsideOther \n void overlapsWhenBottomSideOverlapsMiddleOfOther \n void constructorShouldThrowAnExceptionForNegativeWidth \n void overlapsWhenOtherRectangleIsInsideCaller \n void overlapsWhenRightSideInsideOther \n void constructorShouldAllowZeroForHeight \n void overlapsWhenBottomSideOverlapsTopSideOfOther \n void constructorShouldAllowZeroForX \n void constructorShouldAllowZeroForY \n void overlapsWhenTopRightOverlapsBottomLeftOfOther \n void overlapsWhenMiddlesOverlap \n void doesntOverlapWhenYOverlapsButXDoesNot \n void overlapsWhenLeftSideInsideOther \n void constructorShouldThrowAnExceptionForNegativeHeight \n void overlapsWhenTopSideInsideOther \n void overlapsWhenTopSideOverlapsBottomSideOfOther \n void overlapsWhenTopRightOverlapsLeftOfOther \n void sanityCheck \n void overlapsWhenCallerIsInsideTheOtherRectangle \n void doesntOverlapWhenDoesntOverlap \n void colldingWhenEqual \n void testWidth \n void overlapsWhenBottomRightOverlapsTopOfOther \n void overlapsWhenTopLeftOverlapsBottomOfOther \n void overlapsWhenBottomLeftOverlapsTopOfOther \n void overlapsWhenTopLeftOverlapsBottomRightOfOther \n void overlapsWhenBottomSideInsideOther \n void doesntOverlapWhenXOverlapsButYDoesNot", "output": "void function ( ) { assertTrue ( rectangle . overlaps ( new Rectangle ( 2 , - 1 , 2 , 2 ) ) ) ; }"}, {"instruction": "Generate java code\na convenience method to set the global property fo adding a blinding operation when executing the rsa decryption primitive . ", "input": " String TRUE \n String PROPERTIES_FILE \n String DO_RSA_BLINDING \n HashMap props \n String CHECK_WEAK_KEYS \n Properties singleton \n String NAME \n PrintWriter err \n boolean checkForWeakKeys \n boolean DEBUG \n boolean reproducible \n boolean doRSABlinding \n String REPRODUCIBLE_PRNG \n String FALSE \n\n void init \n void debug \n String getProperty \n Properties instance \n void setReproducible \n boolean checkForWeakKeys \n void setProperty \n boolean isReproducible \n boolean doRSABlinding \n void setCheckForWeakKeys \n void handleBooleanProperty", "output": "void function ( final boolean arg0 ) { SecurityManager loc0 = System . getSecurityManager ( ) ; if ( loc0 != null ) { loc0 . checkPermission ( new PropertyPermission ( DO_RSA_BLINDING , \"srini_string\" ) ) ; } instance ( ) . doRSABlinding = arg0 ; props . put ( DO_RSA_BLINDING , String . valueOf ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nwrite string . ", "input": " int BUFFER_SIZE \n\n String read \n void writeLines \n void writeLines \n void appendLines \n String[] readLines \n String[] readLines", "output": "long function ( Writer arg0 , String arg1 ) { Reader loc0 = new StringReader ( arg1 ) ; try { return write ( loc0 , arg0 ) ; } finally { loc0 . close ( ) ; } }"}, {"instruction": "Generate java code\nmarshal method for the port class , encodes the port object to the output stream . ", "input": " com.ericsson.otp.ic.TypeCode _tc \n\n Port extract \n Port unmarshal \n String name \n void insert \n String id \n com.ericsson.otp.ic.TypeCode type", "output": "void function ( com . ericsson . otp . erlang . OtpOutputStream arg0 , Port arg1 ) { arg0 . write_port ( arg1 . node ( ) , arg1 . id ( ) , arg1 . creation ( ) ) ; }"}, {"instruction": "Generate java code\ngets selected time zone display name . ", "input": " DateFormat selectedFormat \n int[] pacificXCoords \n int[] nfldXCoords \n int[] easternYCoords \n int[] alaskaYCoords \n int[] pacificYCoords \n ArrayList allTimeZoneList \n int[] mountainXCoords \n TimeZone serverTimeZone \n int icefacesYOffset \n int[] hawaiiXCoords \n DateFormat serverFormat \n int[] easternXCoords \n int[] alaskaXCoords \n int[] nfldYCoords \n TimeZone selectedTimeZone \n int[] centralXCoords \n int[] centralYCoords \n int icefacesXOffset \n int[] hawaiiYCoords \n int[] mountainYCoords \n\n void init \n String getSelectedTime \n String getServerTimeZoneName \n DateFormat buildDateFormatForTimeZone \n String formatCurrentTime \n TimeZoneWrapper getTimeZoneWrapperByComponentId \n String getServerTime \n String displayNameTokenizer \n void listen", "output": "String function ( ) { return displayNameTokenizer ( selectedTimeZone . getDisplayName ( ) ) ; }"}, {"instruction": "Generate java code\nupdate cancelstatus ", "input": " PlaceHolder placeHolder \n\n Cancelstatus getCancelstatusById \n boolean deleteCancelstatus \n List<Cancelstatus> lstCancelstatus \n boolean insertCancelstatus", "output": "boolean function ( Cancelstatus arg0 , String arg1 ) { return CancelstatusDAO . updateCancelstatus ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\ndemangles a term . ", "input": " ArrayList<Primitive> demangling \n String pre \n String post \n CalculatorRewriting calc \n int symId \n HashMap<Primitive,Term> mangling \n\n void setFormat \n Term mangle", "output": "Primitive function ( Term arg0 ) { final String loc0 = arg0 . getValue ( ) ; final String loc1 = loc0 . substring ( this . pre . length ( ) , loc0 . length ( ) - this . post . length ( ) ) ; final int loc2 ; try { loc2 = Integer . parseInt ( loc1 ) ; } catch ( NumberFormatException loc3 ) { return null ; } return this . demangling . get ( loc2 ) ; }"}, {"instruction": "Generate java code\nerror log message . ", "input": " int WARN \n int VERBOSE \n int ERROR \n int LOGLEVEL \n int DEBUG \n int INFO \n\n boolean isLoggable \n void d \n void d \n void d \n void setLogLevel \n void setLogLevel \n void v \n void v \n void v \n void w \n void w \n void w \n void i \n void i \n void i", "output": "void function ( String arg0 , String arg1 ) { if ( LOG . ERROR >= LOGLEVEL ) Log . e ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nreturns whether the point is in the frustum . ", "input": " Vector3[] clipSpacePlanePoints \n Plane[] planes \n float[] clipSpacePlanePointsArray \n float[] planePointsArray \n Vector3[] planePoints \n\n boolean sphereInFrustum \n boolean boundsInFrustum \n boolean sphereInFrustumWithoutNearFar \n void update", "output": "boolean function ( Vector3 arg0 ) { for ( int loc0 = 0 ; loc0 < planes . length ; loc0 ++ ) { PlaneSide loc1 = planes [ loc0 ] . testPoint ( arg0 ) ; if ( loc1 == PlaneSide . Back ) return false ; } return true ; }"}, {"instruction": "Generate java code\ngets the list of items . ", "input": " String nextPageLink \n List<T> items \n\n String nextPageLink \n PageImpl<T> setNextPageLink \n PageImpl<T> setItems", "output": "List < T > function ( ) { return items ; }"}, {"instruction": "Generate java code\nget custom deserializer ", "input": " org.apache.axis.description.TypeDesc typeDesc \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n\n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Serializer getSerializer \n int hashCode \n boolean equals", "output": "org . apache . axis . encoding . Deserializer function ( java . lang . String arg0 , java . lang . Class arg1 , javax . xml . namespace . QName arg2 ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( arg1 , arg2 , typeDesc ) ; }"}, {"instruction": "Generate java code\naccess to the soql query api . ", "input": " String recentItemsUrl \n String chatterUsersUrl \n String partnerUrl \n String chatterFeedsUrl \n String sobjectUrl \n String chatterFeedItemsUrl \n String userProfileUrl \n String chatterGroupsUrl \n String restUrl \n String queryUrl \n String metadataUrl \n String searchUrl \n String enterpriseUrl \n\n void setQueryUrl \n String getMetadataUrl \n void setChatterUsersUrl \n void setChatterFeedItemsUrl \n void setSobjectUrl \n void setEnterpriseUrl \n String getChatterFeedsUrl \n void setPartnerUrl \n void setMetadataUrl \n void setRestUrl \n void setRecentItemsUrl \n String getSearchUrl \n void setSearchUrl \n void setUserUrl \n void setChatterFeedsUrl \n String getPartnerUrl \n String getRecentItemsUrl \n String getUserUrl \n void setChatterGroupsUrl \n String getSobjectUrl \n String getEnterpriseUrl \n String getChatterFeedItemsUrl \n String getChatterUsersUrl \n String getRestUrl \n String toString \n String getChatterGroupsUrl", "output": "String function ( ) { return this . queryUrl ; }"}, {"instruction": "Generate java code\nadds a sub-model to this model . if the model is already in the list then it does nothing . ", "input": " boolean isValidState \n ArrayList<Variable> variables \n Model.ListenerHelper listenerHelper \n ArrayList<Statistic> statistics \n ArrayList<Model> models \n String name \n String id \n\n void removeModelListener \n void acceptModelState \n void addModelRestoreListener \n void restoreState \n void removeModel \n Statistic getStatistic \n Statistic getStatistic \n void sendState \n void modelChangedEvent \n String getId \n String getModelName \n void addModelListener \n void addVariable \n void addStatistic \n void modelRestored \n void setId \n void removeVariable \n void handleVariableChangedEvent \n void restoreModelState \n void sendStateNoParameters \n Model getModel \n void removeStatistic \n int getStatisticCount \n void receiveStateNoParameters \n Element createElement \n void variableChangedEvent \n Variable getVariable \n boolean isUsed \n boolean hasVariable \n int getModelCount \n boolean isValidState \n int getVariableCount \n void receiveState \n void handleModelChangedEvent \n void acceptState \n void storeState \n String toString \n void fireModelChanged \n void fireModelChanged \n void fireModelChanged \n void storeModelState", "output": "void function ( Model arg0 ) { Model . CONNECTED_MODEL_SET . add ( arg0 ) ; if ( ! models . contains ( arg0 ) ) { models . add ( arg0 ) ; arg0 . addModelListener ( this ) ; } }"}, {"instruction": "Generate java code\nprint ", "input": " List<LetterComposite> children \n\n void add \n int count \n void printThisBefore \n void printThisAfter", "output": "void function ( ) { printThisBefore ( ) ; for ( LetterComposite loc0 : children ) { loc0 . print ( ) ; } printThisAfter ( ) ; }"}, {"instruction": "Generate java code\nreturns the bundle context of this bundle ", "input": " BundleContext context \n Logger logger \n String TRANSFORM_FOLDER_NAME \n\n void stop \n void start", "output": "BundleContext function ( ) { return context ; }"}, {"instruction": "Generate java code\nget the tprotocol being used as the input read protocol . ", "input": " TProtocol oprot_ \n TProtocol iprot_ \n int seqid_ \n\n void receiveBase \n TProtocol getOutputProtocol \n void sendBase", "output": "TProtocol function ( ) { return this . iprot_ ; }"}, {"instruction": "Generate java code\ngets the item value for this assemblycomponent . ", "input": " java.lang.String componentNumbers \n com.netsuite.webservices.platform.core_2014_2.RecordRef item \n java.lang.Double quantity \n org.apache.axis.description.TypeDesc typeDesc \n com.netsuite.webservices.platform.common_2014_2.InventoryDetail componentInventoryDetail \n java.lang.Double quantityOnHand \n java.lang.Object __equalsCalc \n java.lang.String binNumbers \n boolean __hashCodeCalc \n\n org.apache.axis.description.TypeDesc getTypeDesc \n java.lang.Double getQuantity \n com.netsuite.webservices.platform.common_2014_2.InventoryDetail getComponentInventoryDetail \n org.apache.axis.encoding.Deserializer getDeserializer \n void setQuantityOnHand \n java.lang.Double getQuantityOnHand \n java.lang.String getBinNumbers \n org.apache.axis.encoding.Serializer getSerializer \n java.lang.String getComponentNumbers \n void setBinNumbers \n void setQuantity \n int hashCode \n boolean equals \n void setComponentInventoryDetail \n void setComponentNumbers \n void setItem", "output": "com . netsuite . webservices . platform . core_2014_2 . RecordRef function ( ) { return item ; }"}, {"instruction": "Generate java code\nset value of command_status . ", "input": " int sequenceNumber \n int commandStatus \n int commandLength \n int commandId \n long serialVersionUID \n\n void setCommandLength \n String getCommandStatusAsHex \n int getSequenceNumber \n int getCommandLength \n void setSequenceNumber \n int hashCode \n boolean equals \n int getCommandId \n void setCommandId \n String toString \n String getCommandIdAsHex \n int getCommandStatus", "output": "void function ( int arg0 ) { this . commandStatus = arg0 ; }"}, {"instruction": "Generate java code\nsets the value of the project property . ", "input": " String password \n String firstname \n WSDate createdDate \n String phone \n WSDate loginDate \n String project \n String email \n String username \n String lastname \n WSUserGroup group \n\n String getPhone \n void setPassword \n void setLastname \n String getFirstname \n void setFirstname \n void setUsername \n WSDate getLoginDate \n void setLoginDate \n void setPhone \n String getUsername \n void setGroup \n String getPassword \n void setCreatedDate \n void setEmail \n WSUserGroup getGroup \n String getEmail \n WSDate getCreatedDate \n String getLastname \n String getProject", "output": "void function ( String arg0 ) { this . project = arg0 ; }"}, {"instruction": "Generate java code\nincrements the specified matrix element by 1 . ", "input": " PlaceHolder placeHolder \n\n double rowAverage \n double maxDouble \n void rowInitNormal \n List<Double> rowDifference \n void columnInitNormal \n int maxInteger \n double rowScalarProduct \n Double rowScalarProduct \n void initNormal \n float maxFloat \n double rowScalarProductWithRowDifference \n void multiply \n double frobeniusNorm \n double columnAverage", "output": "void function ( Matrix < Integer > arg0 , int arg1 , int arg2 ) { arg0 . data [ arg1 * arg0 . dim2 + arg2 ] = ( Integer ) arg0 . data [ arg1 * arg0 . dim2 + arg2 ] + 1 ; }"}, {"instruction": "Generate java code\nset the yaml . ", "input": " boolean exceptionIfInvalid \n Log logger \n Resource resource \n T configuration \n Validator validator \n MessageSource messageSource \n Class<?> type \n Map<Class<?>,Map<String,String>> propertyAliases \n String yaml \n\n void setMessageSource \n T getObject \n void afterPropertiesSet \n Class<?> getObjectType \n boolean isSingleton \n void setValidator \n void setExceptionIfInvalid \n void setResource \n void setPropertyAliases \n void validate", "output": "void function ( String arg0 ) { this . yaml = arg0 ; }"}, {"instruction": "Generate java code\ngets an `` inline '' string portion for tohuman , if available . this is the portion that appears after the rop opcode ", "input": " RegisterSpec result \n RegisterSpecList sources \n SourcePosition position \n Rop opcode \n\n String toHumanWithInline \n Insn withRegisterOffset \n boolean equalsHandleNulls \n void visitPlainInsn \n void visitPlainInsn \n void visitThrowingCstInsn \n void visitThrowingCstInsn \n RegisterSpecList getSources \n void visitPlainCstInsn \n void visitPlainCstInsn \n int hashCode \n String toHuman \n Insn copy \n Insn withSourceLiteral \n Rop getOpcode \n TypeList getCatches \n boolean canThrow \n void visitFillArrayDataInsn \n void visitFillArrayDataInsn \n boolean contentEquals \n Insn withAddedCatch \n void accept \n void visitSwitchInsn \n void visitSwitchInsn \n SourcePosition getPosition \n RegisterSpec getLocalAssignment \n Insn withNewRegisters \n String toStringWithInline \n boolean equals \n RegisterSpec getResult \n String toString \n void visitThrowingInsn \n void visitThrowingInsn", "output": "String function ( ) { return null ; }"}, {"instruction": "Generate java code\nreturns the value of the metric . ", "input": " String name \n T value \n Date timestamp \n\n String getName \n Metric<S> set \n Date getTimestamp \n int hashCode \n boolean equals \n Metric<Long> increment \n String toString", "output": "T function ( ) { return this . value ; }"}, {"instruction": "Generate java code\nsets the targetwindow value for this siterichmediasettings . ", "input": " java.lang.String frameAndLayerFooter \n java.lang.String alternateText \n java.lang.Object __equalsCalc \n java.lang.String iframeFooter \n java.lang.String frameAndLayerHeader \n boolean __hashCodeCalc \n java.lang.String iframeHeader \n org.apache.axis.description.TypeDesc typeDesc \n java.lang.String targetWindow \n\n java.lang.String getAlternateText \n java.lang.String getFrameAndLayerHeader \n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Deserializer getDeserializer \n java.lang.String getIframeHeader \n java.lang.String getTargetWindow \n java.lang.String getFrameAndLayerFooter \n void setFrameAndLayerFooter \n void setAlternateText \n void setIframeFooter \n void setFrameAndLayerHeader \n org.apache.axis.encoding.Serializer getSerializer \n int hashCode \n boolean equals \n void setIframeHeader \n java.lang.String getIframeFooter", "output": "void function ( java . lang . String arg0 ) { this . targetWindow = arg0 ; }"}, {"instruction": "Generate java code\nthe fixed price for the term . ", "input": " Double price \n Long term \n String currencyCode \n\n PriceScheduleSpecification withPrice \n PriceScheduleSpecification withCurrencyCode \n PriceScheduleSpecification withCurrencyCode \n String getCurrencyCode \n int hashCode \n Long getTerm \n boolean equals \n PriceScheduleSpecification clone \n String toString \n void setPrice \n void setTerm \n PriceScheduleSpecification withTerm \n void setCurrencyCode \n void setCurrencyCode", "output": "Double function ( ) { return price ; }"}, {"instruction": "Generate java code\nset logging level for http calls , @see java.util.logging.level ", "input": " BraintreeApiName apiName \n Integer httpReadTimeout \n String ENVIRONMENT \n String methodName \n String publicKey \n String PRIVATE_KEY \n String proxyHost \n String httpLogName \n String MERCHANT_ID \n String privateKey \n Integer proxyPort \n String environment \n String merchantId \n Level httpLogLevel \n String PUBLIC_KEY \n\n void setHttpLogName \n String getMethodName \n void setMethodName \n void setApiName \n String getProxyHost \n void setProxyHost \n String getEnvironment \n String getPublicKey \n void setPublicKey \n void setPrivateKey \n void setEnvironment \n void setProxyPort \n String getMerchantId \n String getHttpLogName \n Integer getHttpReadTimeout \n Environment getBraintreeEnvironment \n Integer getProxyPort \n BraintreeGateway newBraintreeGateway \n void setHttpReadTimeout \n BraintreeApiName getApiName \n Level getHttpLogLevel \n String getPrivateKey \n void setMerchantId", "output": "void function ( Level arg0 ) { this . httpLogLevel = arg0 ; }"}, {"instruction": "Generate java code\nsets the value . ", "input": " long serialVersionUID \n T value \n\n T getValue \n int hashCode \n boolean equals \n String toString", "output": "void function ( final T arg0 ) { this . value = arg0 ; }"}, {"instruction": "Generate java code\nthe name of the recorder . by default , aws config automatically assigns the name `` default '' when creating the configuration recorder . you can not change the assigned name . ", "input": " RecordingGroup recordingGroup \n String roleARN \n String name \n\n void setName \n ConfigurationRecorder withRoleARN \n int hashCode \n RecordingGroup getRecordingGroup \n boolean equals \n ConfigurationRecorder clone \n void setRecordingGroup \n void setRoleARN \n String toString \n ConfigurationRecorder withName \n ConfigurationRecorder withRecordingGroup \n String getRoleARN", "output": "String function ( ) { return this . name ; }"}, {"instruction": "Generate java code\noutputs a loglevel #warn level message . ", "input": " int mPriorityLevel \n boolean LOGV \n char[] mHexDigit \n char mPriorityLetter \n boolean LOGD \n ILogOutput sLogOutput \n String mStringValue \n char[] mSpaceLine \n LogLevel mLevel \n\n LogLevel getByLetterString \n String getStringValue \n void d \n void e \n void e \n LogLevel getByLetter \n LogLevel getByString \n void i \n void printAndPromptLog \n void printLog \n void printLog \n void setLevel \n void hexDump \n void hexDump \n void println \n char getPriorityLetter \n void v \n int getPriority \n void setLogOutput \n void logAndDisplay", "output": "void function ( String arg0 , String arg1 ) { println ( LogLevel . WARN , arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\na description of the import snapshot task . ", "input": " String importTaskId \n String description \n SnapshotTaskDetail snapshotTaskDetail \n\n void setSnapshotTaskDetail \n SnapshotTaskDetail getSnapshotTaskDetail \n String getImportTaskId \n ImportSnapshotResult withImportTaskId \n void setImportTaskId \n int hashCode \n boolean equals \n ImportSnapshotResult clone \n ImportSnapshotResult withDescription \n String toString \n ImportSnapshotResult withSnapshotTaskDetail \n String getDescription", "output": "void function ( String arg0 ) { this . description = arg0 ; }"}, {"instruction": "Generate java code\ngive an invalid value wrong type for the field ", "input": " ExecHandler handler \n ObjectName oName \n\n void compositeWithSetField \n MBeanServerConnection getMBeanServer \n void arrayOfComposites \n void invalidField \n void unregisterMBean \n void registerMBean \n void listOfComposites \n void overloaded \n void nested \n void compositeWithArrayField \n void missingField \n void compositeWithListField \n void setOfComposites \n void mapOfComposites \n void invalidTypeCompositeWithListField \n void compositeWithMapField \n void createHandler", "output": "void function ( ) { JmxExecRequest loc0 = new JmxRequestBuilder ( EXEC , oName ) . operation ( \"srini_string\" ) . arguments ( \"srini_string\" ) . build ( ) ; handler . handleRequest ( getMBeanServer ( ) , loc0 ) ; }"}, {"instruction": "Generate java code\nthis method returns the column for this location ", "input": " int col \n int row \n\n String toString \n int getRow", "output": "int function ( ) { return col ; }"}, {"instruction": "Generate java code\ncopy input byte source to outfile . if outfile exists , it is attempted to be deleted . ", "input": " long size \n Predicate<Throwable> IS_EXCEPTION \n Collection<File> files \n\n void addSizedFiles \n long size \n boolean apply \n void addFiles \n Collection<File> getFiles \n void addFile", "output": "FileCopyResult function ( final ByteSource arg0 , final File arg1 , final Predicate < Throwable > arg2 , final int arg3 ) { try { StreamUtils . retryCopy ( arg0 , Files . asByteSink ( arg1 ) , arg2 , arg3 ) ; return new FileCopyResult ( arg1 ) ; } catch ( Exception loc0 ) { throw Throwables . propagate ( loc0 ) ; } }"}, {"instruction": "Generate java code\nonly when plan is not null and at least one of #validcascadingplan long , evictionplan , blockmetadatamanager , #validnoncascadingplan long , evictionplan , blockmetadatamanager is true , the assertionwill be passed , used in unit test . ", "input": " PlaceHolder placeHolder \n\n boolean requestSpaceSatisfied \n boolean validCascadingPlan \n boolean validNonCascadingPlan \n boolean blocksInTheSameDir", "output": "void function ( long arg0 , EvictionPlan arg1 , BlockMetadataManager arg2 ) { Assert . assertNotNull ( arg1 ) ; Assert . assertTrue ( validNonCascadingPlan ( arg0 , arg1 , arg2 ) || validCascadingPlan ( arg0 , arg1 , arg2 ) ) ; }"}, {"instruction": "Generate java code\nreturn session factory session factory will be rebuilded in the next call ", "input": " Configuration configuration \n String configFile \n ThreadLocal<Session> threadLocal \n String CONFIG_FILE_LOCATION \n org.hibernate.SessionFactory sessionFactory \n\n List<?> executeQueryByPage \n Configuration getConfiguration \n void rebuildSessionFactory \n Session openSession \n void closeSession \n Session getSession \n org.hibernate.SessionFactory getSessionFactory \n List<?> executeQuery \n void executeSave \n void executeUpdate", "output": "void function ( String arg0 ) { HibernateSessionFactory . arg0 = arg0 ; sessionFactory = null ; }"}, {"instruction": "Generate java code\nget custom serializer ", "input": " org.apache.axis.description.TypeDesc typeDesc \n java.lang.String firstname \n java.lang.String logintime \n java.lang.String returnmsg \n java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n java.lang.String emailid \n java.lang.String lastname \n\n java.lang.String getLogintime \n void setLogintime \n void setLastname \n org.apache.axis.description.TypeDesc getTypeDesc \n java.lang.String getFirstname \n void setFirstname \n org.apache.axis.encoding.Deserializer getDeserializer \n void setEmailid \n java.lang.String getEmailid \n java.lang.String getReturnmsg \n void setReturnmsg \n int hashCode \n boolean equals \n java.lang.String getLastname", "output": "org . apache . axis . encoding . Serializer function ( java . lang . String arg0 , java . lang . Class arg1 , javax . xml . namespace . QName arg2 ) { return new org . apache . axis . encoding . ser . BeanSerializer ( arg1 , arg2 , typeDesc ) ; }"}, {"instruction": "Generate java code\noverride to handle mouse clicks on a link . ", "input": " PlaceHolder placeHolder \n\n String getDescription", "output": "boolean function ( @ NotNull String arg0 , @ NotNull Editor arg1 ) { return false ; }"}, {"instruction": "Generate java code\ngets the value of the url property . ", "input": " String password \n String executionEnvRef \n List<AnyArgType> anyArg \n String uuid \n String url \n String username \n\n void setPassword \n String getPassword \n List<AnyArgType> getAnyArg \n String getUUID \n void setUsername \n String getExecutionEnvRef \n void addAnyArg \n void setExecutionEnvRef \n void setUUID \n void setURL \n String getUsername", "output": "String function ( ) { return url ; }"}, {"instruction": "Generate java code\nretrieve rmi interface from the transactional server ", "input": " String source_bank_id \n String target_account_nmr \n String target_bank_id \n String source_account_nmr \n int ammount \n\n void sendCommitMessage \n void beginTransaction \n boolean depositMoney \n TXid sendBeginMessage \n void makeOperations \n BankIf getBankObject \n boolean withdrawMoney \n void abortTransaction", "output": "TransactionControlIf function ( ) { Registry loc0 = LocateRegistry . getRegistry ( 3333 ) ; return ( TransactionControlIf ) loc0 . lookup ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncreate a server which will attempt to bind to a specific host and port . ", "input": " boolean closeIdleConnections \n Logger logger \n RpcHandler rpcHandler \n TransportConf conf \n MessageDecoder decoder \n MessageEncoder encoder \n\n TransportConf getConf \n TransportChannelHandler createChannelHandler \n TransportClientFactory createClientFactory \n TransportClientFactory createClientFactory \n TransportChannelHandler initializePipeline \n TransportChannelHandler initializePipeline", "output": "TransportServer function ( String arg0 , int arg1 , List < TransportServerBootstrap > arg2 ) { return new TransportServer ( this , arg0 , arg1 , rpcHandler , arg2 ) ; }"}, {"instruction": "Generate java code\nreturn the server name . ", "input": " int LDAP_PORT \n int port \n String serverName \n\n int getPort \n Object clone \n String toString", "output": "String function ( ) { return serverName ; }"}, {"instruction": "Generate java code\nreturns the `` continuation without first '' indent instance , indicating that the block will be indented by the number of spaces indicated in the `` project code style | general | continuation indent '' setting relative to its parent block , unless this block is the first of the children of its parent having the same indent type . this is used for things like parameter lists , where the first parameter does not have any indent and the remaining parameters are indented by the continuation indent . note : returned indent is not set to be ` relative ' to it 's direct parent block ", "input": " Type NONE \n Type CONTINUATION \n Type SPACES \n String myName \n Type NORMAL \n IndentFactory myFactory \n Type CONTINUATION_WITHOUT_FIRST \n Type LABEL \n\n void setFactory \n Indent getContinuationIndent \n Indent getContinuationIndent \n Indent getSmartIndent \n Indent getNormalIndent \n Indent getNormalIndent \n Indent getAbsoluteNoneIndent \n Indent getIndent \n Indent getIndent \n Indent getLabelIndent \n Type getType \n Indent getSpaceIndent \n Indent getSpaceIndent \n Indent getAbsoluteLabelIndent \n Indent getNoneIndent \n String toString", "output": "Indent function ( ) { return myFactory . getContinuationWithoutFirstIndent ( false ) ; }"}, {"instruction": "Generate java code\ncalled whenever the osgi framework stops our bundle ", "input": " BundleContext context \n Logger logger \n\n void start \n BundleContext getContext", "output": "void function ( BundleContext arg0 ) { context = null ; logger . debug ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets an individual change from the change collection . ", "input": " boolean moreChangesAvailable \n List<TChange> changes \n String syncState \n\n void add \n Iterator<TChange> iterator \n void setMoreChangesAvailable \n void setSyncState \n boolean getMoreChangesAvailable \n int getCount \n String getSyncState", "output": "TChange function ( int arg0 ) { if ( arg0 < 0 || arg0 >= this . getCount ( ) ) { throw new IndexOutOfBoundsException ( String . format ( \"srini_string\" , arg0 , this . getCount ( ) ) ) ; } return this . changes . get ( arg0 ) ; }"}, {"instruction": "Generate java code\nreinitializes the insets parameter with this border 's current insets . ", "input": " PlaceHolder placeHolder \n\n boolean isLeftToRight \n int getBaseline \n void paintBorder \n Component.BaselineResizeBehavior getBaselineResizeBehavior \n boolean isBorderOpaque \n Rectangle getInteriorRectangle \n Rectangle getInteriorRectangle", "output": "Insets function ( Component arg0 , Insets arg1 ) { arg1 . left = arg1 . top = arg1 . right = arg1 . bottom = 0 ; return arg1 ; }"}, {"instruction": "Generate java code\nsets the named character represented by this instance . ", "input": " NamedCharacter character \n double widthY \n RectangularShape bBox \n double widthX \n int charCode \n\n boolean hasCharCode \n String getUnicodeSequence \n RectangularShape getBBox \n void setWidthY \n void setWidthX \n void setBBox \n double getWidthX \n double getWidthY \n int getCharCode \n NamedCharacter getCharacter \n String toString \n void setCharCode \n String getCharName", "output": "void function ( NamedCharacter arg0 ) { this . character = arg0 ; }"}, {"instruction": "Generate java code\nreturns a buffer to the pool , throwing away old buffers if the pool would exceed its allotted size . ", "input": " List<byte[]> mBuffersByLastUse \n Comparator<byte[]> BUF_COMPARATOR \n List<byte[]> mBuffersBySize \n int mCurrentSize \n int mSizeLimit \n\n int compare \n void trim \n byte[] getBuf", "output": "void function ( byte [ ] arg0 ) { if ( arg0 == null || arg0 . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( arg0 ) ; int loc0 = Collections . binarySearch ( mBuffersBySize , arg0 , BUF_COMPARATOR ) ; if ( loc0 < 0 ) { loc0 = - loc0 - 1 ; } mBuffersBySize . add ( loc0 , arg0 ) ; mCurrentSize += arg0 . length ; trim ( ) ; }"}, {"instruction": "Generate java code\nimplements pathhandler #closepath . ", "input": " ExtendedGeneralPath path \n float currentX \n float yCenter \n int windingRule \n float currentY \n float xCenter \n\n Shape createShape \n void curvetoCubicRel \n void curvetoQuadraticAbs \n void setWindingRule \n Shape getShape \n void linetoHorizontalAbs \n void curvetoCubicAbs \n void curvetoQuadraticRel \n void linetoVerticalAbs \n void endPath \n void linetoHorizontalRel \n void movetoAbs \n void curvetoQuadraticSmoothRel \n void linetoAbs \n void curvetoCubicSmoothRel \n void startPath \n void linetoVerticalRel \n int getWindingRule \n void curvetoQuadraticSmoothAbs \n void movetoRel \n void arcAbs \n void curvetoCubicSmoothAbs \n void arcRel \n void linetoRel", "output": "void function ( ) { path . closePath ( ) ; Point2D loc0 = path . getCurrentPoint ( ) ; currentX = ( float ) loc0 . getX ( ) ; currentY = ( float ) loc0 . getY ( ) ; }"}, {"instruction": "Generate java code\ngets the parent object in the object tree representing the unmarshalled xml document . ", "input": " String val \n Object parent \n\n String getVal \n void afterUnmarshal \n void setParent \n void setVal", "output": "Object function ( ) { return this . parent ; }"}, {"instruction": "Generate java code\ninterface abc : operation paramop param1 : integer , param2 : boolean : string operation stringop in event voidevent in event intevent : integer var intvar : integer var boolvar : boolean ", "input": " ILinker linker \n StextResourceFactory factory \n IParser parser \n\n StextResource getResource \n Scope internalScope \n Scope createInternalScope \n Scope createInterfaceScope \n EObject parseExpression \n EObject parseExpression \n EObject parseExpression", "output": "Scope function ( ) { return createInterfaceScope ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturns the response as a character stream decoded with the charset of the content-type header . if that header is either absent or lacks a charset , this will attempt to decode the response body as utf-8 . ", "input": " Request request \n RawHeaders headers \n int code \n Reader reader \n RawHeaders headers \n Response redirectedBy \n Body body \n\n Request request \n List<String> headers \n Charset charset \n Builder addHeader \n int code \n String headerName \n String string \n InputStream byteStream \n Set<String> headerNames \n Response redirectedBy \n Builder redirectedBy \n String headerValue \n void onFailure \n int headerCount \n Body body \n Builder body \n RawHeaders rawHeaders \n Builder rawHeaders \n boolean onResponse \n Response build \n boolean ready \n byte[] bytes \n String header \n String header \n Builder header \n long contentLength \n MediaType contentType", "output": "Reader function ( ) { if ( reader == null ) { reader = new InputStreamReader ( byteStream ( ) , charset ( ) ) ; } return reader ; }"}, {"instruction": "Generate java code\ninitialize the stream without reading from it . ", "input": " Schema schema \n List<String> metaKeyList \n long blockCount \n boolean availableBlock \n byte[] data \n DatumReader<D> reader \n long blockRemaining \n Map<String,byte[]> meta \n int blockSize \n ByteBuffer blockBuffer \n byte[] syncBuffer \n byte[] sync \n Codec codec \n boolean flushOnWrite \n BinaryDecoder datumIn \n int offset \n Header header \n BinaryDecoder vin \n DataBlock block \n long numEntries \n\n D next \n D next \n boolean isFlushOnWrite \n void remove \n Header getHeader \n Codec resolveCodec \n Iterator<D> iterator \n void compressUsing \n boolean hasNextBlock \n ByteBuffer getAsByteBuffer \n long getBlockSize \n int getBlockSize \n void setFlushOnWrite \n DataBlock nextRawBlock \n long getBlockCount \n void writeBlockTo \n void close \n byte[] getData \n void decompressUsing \n void blockFinished \n String getMetaString \n long getMetaLong \n boolean hasNext \n ByteBuffer nextBlock \n Schema getSchema \n long getNumEntries \n List<String> getMetaKeys \n byte[] getMeta", "output": "void function ( InputStream arg0 , Header arg1 ) { this . header = arg1 ; this . codec = resolveCodec ( ) ; reader . setSchema ( arg1 . schema ) ; }"}, {"instruction": "Generate java code\nchecks if some of the edge of source polygon is inside target polygon area . warning : some use case are not covered . for example to know if to polygons instersects we check only if one or more edges of the two polygon are inside the other polygon shape . this works for our uses cases check if a door is inside a room but if we have two polygons like this a `` plus sign '' shape it will return false even if they `` intersects '' each other because no edges are contained ", "input": " AffineTransform transform \n Logger LOG \n\n Color convertColorToAWT \n FreedomPolygon rotate \n boolean contains \n FreedomPoint getRectangleCenter \n Shape convertToAWT \n Shape convertToAWT \n Point convertToAWT \n Ellipse2D convertToAWT \n Polygon convertToAWT \n FreedomPolygon getBoundingBox \n FreedomPolygon translate \n FreedomPolygon translate \n FreedomPoint rotatePoint", "output": "boolean function ( FreedomPolygon arg0 , FreedomPolygon arg1 ) { for ( FreedomPoint loc0 : arg0 . getPoints ( ) ) { if ( contains ( arg1 , loc0 ) ) { return true ; } } for ( FreedomPoint loc0 : arg1 . getPoints ( ) ) { if ( contains ( arg0 , loc0 ) ) { return true ; } } return false ; }"}, {"instruction": "Generate java code\ngets the value of the ascontext property . ", "input": " AsContext asContext \n SasContext sasContext \n TransportConfig transportConfig \n\n void setTransportConfig \n SasContext getSasContext \n TransportConfig getTransportConfig \n void setSasContext \n void setAsContext", "output": "AsContext function ( ) { return asContext ; }"}, {"instruction": "Generate java code\nsearches an entity by id . ", "input": " Logger LOG \n\n void removeOffer \n Offer insertOffer \n List<Offer> listOffers \n Offer updateOffer \n Offer getOffer", "output": "Offer function ( final Long arg0 ) { return ofy ( ) . load ( ) . type ( Offer . class ) . arg0 ( arg0 ) . now ( ) ; }"}, {"instruction": "Generate java code\ngets the minimum of two float values . nan is only returned if all numbers are nan as per ieee-754r . ", "input": " PlaceHolder placeHolder \n\n double max \n float max \n double max \n double max \n float max \n float max", "output": "float function ( final float arg0 , final float arg1 ) { if ( Float . isNaN ( arg0 ) ) { return arg1 ; } else if ( Float . isNaN ( arg1 ) ) { return arg0 ; } else { return Math . min ( arg0 , arg1 ) ; } }"}, {"instruction": "Generate java code\nmethod that can be overridden to do any additional processing ", "input": " PlaceHolder placeHolder \n\n List<ClassAnnotationInformationFactory> annotationInformationFactories \n void deploy \n void undeploy", "output": "void function ( final DeploymentPhaseContext arg0 , final DeploymentUnit arg1 ) { }"}, {"instruction": "Generate java code\nsets the limit . ", "input": " BidiMap xPathToTreeItem \n TreeViewer availableXmlTree \n String filePath \n int limit \n\n TreeItem getTreeItem \n boolean isValidFile \n int getLimit \n boolean populateTree \n boolean populateTree \n boolean populateTree \n boolean populateTree \n boolean populateTree \n String getFilePath \n void setFilePath \n String getAbsoluteXPath \n int getMaximumRowsToPreview", "output": "void function ( int arg0 ) { limit = arg0 ; }"}, {"instruction": "Generate java code\nit adds an item to the itemset . the item is inserted in the specified position . ", "input": " List<Item> items \n int beginning \n long timestamp \n\n int getBeginning \n void removeItem \n Item removeItem \n void setBeginning \n Itemset cloneItemSetMinusItems \n Itemset cloneItemSet \n List<Item> getItems \n int size \n long getTimestamp \n int hashCode \n Item get \n boolean equals \n String toString \n void setTimestamp", "output": "void function ( int arg0 , Item arg1 ) { items . set ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\na map containing column name - > column pairs of the author table . ", "input": " Result<BookRecord> books \n Result<AuthorRecord> authorsAlphanumeric \n Record edit \n Map<Table<?>,SortField<?>> sort \n BookRecord newBook \n long serialVersionUID \n LibraryEJB ejb \n AuthorRecord newAuthor \n Result<AuthorRecord> authors \n\n Result<AuthorRecord> getAuthorsAlphanumeric \n Result<BookRecord> getBooks \n void edit \n Map<Integer,AuthorRecord> getAuthorById \n void save \n void sort \n void delete \n Map<String,Field<?>> getAuthorColumns \n Map<String,Field<?>> getColumns \n Map<String,SortField<?>> getSort \n BookRecord getNewBook \n Result<AuthorRecord> getAuthors \n AuthorRecord getNewAuthor \n void reset \n Record getEdit", "output": "Map < String , Field < ? >> function ( ) { return getColumns ( BOOK ) ; }"}, {"instruction": "Generate java code\nreturns the environments a rule supports by default , i.e. if it has no explicit references to environments in this group . ", "input": " Package containingPackage \n Set<Label> defaults \n Set<Label> environments \n Location location \n Label label \n Map<Label,NestedSet<Label>> fulfillersMap \n\n Set<Label> getEnvironments \n List<Event> processMemberEnvironments \n Package getPackage \n Location getLocation \n Label getLabel \n String getName \n boolean apply \n String getTargetKind \n boolean isValidEnvironment \n Iterable<Label> getFulfillers \n Rule getAssociatedRule \n boolean isDefault \n NestedSet<Label> setTransitiveFulfillers \n License getLicense \n boolean equals \n List<Event> validateMembership \n Set<License.DistributionType> getDistributions \n String targetKind \n String toString \n RuleVisibility getVisibility", "output": "Set < Label > function ( ) { return defaults ; }"}, {"instruction": "Generate java code\napply the sizes to chart panel , use setwidth/setheight before ", "input": " boolean showLegend \n PlotOptions options \n SimplePlot plot \n int DEFAULT_WIDTH \n int DEFAULT_HEIGHT \n int width \n PlotModel model \n int height \n List<SeriesData<X,Y>> data \n\n PlotModel getModel \n void setData \n void setShowLegend \n int getWidth \n void setWidth \n void setHeight \n void redraw \n int getHeight \n SimplePlot getPlot \n boolean isShowLegend \n void applyOptions \n PlotOptions getOptions \n Widget asWidget \n List<SeriesData<X,Y>> getData", "output": "void function ( ) { if ( plot != null ) { plot . setWidth ( getWidth ( ) ) ; plot . setHeight ( getHeight ( ) ) ; } }"}, {"instruction": "Generate java code\nthe array name . ", "input": " List<ParameterNameValue> attributes \n String mediaFileName \n String arrayBarcode \n AffymetrixGuidType mediaFileGUID \n String arrayName \n CreateStepType createdStep \n ArrayMediaType media \n AffymetrixGuidType masterFileId \n String comment \n String masterFile \n PATAssignmentMethodType patAssignment \n String libraryPackageName \n int mediaCol \n String createdBy \n int mediaRow \n AffymetrixGuidType id \n String customerBarcode \n String creationDateTime \n\n void setLibraryPackageName \n void setIdentifier \n void setCreationDateTime \n AffymetrixGuidType getMediaFileGUID \n void setArrayName \n String getCreationDateTime \n PATAssignmentMethodType getPATAssignment \n void setMediaFileName \n void setMasterFile \n void setCustomerBarcode \n AffymetrixGuidType getIdentifier \n String getMediaFileName \n String getComment \n void setCreatedStep \n int getMediaCol \n String getMasterFile \n String getArrayBarcode \n void setMediaCol \n void setArrayBarcode \n String getLibraryPackageName \n void setPATAssignment \n ArrayMediaType getMedia \n List<ParameterNameValue> getAttributes \n int getMediaRow \n AffymetrixGuidType getMasterFileId \n void clear \n void setMasterFileId \n void setMediaFileGUID \n String getCustomerBarcode \n void setCreatedBy \n void setMedia \n void setMediaRow \n void setComment \n CreateStepType getCreatedStep \n String getCreatedBy", "output": "String function ( ) { return arrayName ; }"}, {"instruction": "Generate java code\nencrypt a password . a master password must have been provided in the constructor . ", "input": " long CACHE_EXPIRATION_MIN \n long CACHE_SIZE \n Optional<TextEncryptor> encryptor \n Logger LOG \n LoadingCache<Map.Entry<Optional<String>,Boolean>,PasswordManager> CACHED_INSTANCES \n Pattern PASSWORD_PATTERN \n\n Optional<String> getMasterPassword \n Optional<String> getMasterPassword \n Optional<String> getMasterPassword \n PasswordManager load \n String decryptPassword \n String readPassword \n PasswordManager getInstance \n PasswordManager getInstance \n PasswordManager getInstance \n PasswordManager getInstance \n boolean shouldUseStrongEncryptor", "output": "String function ( String arg0 ) { Preconditions . checkArgument ( this . encryptor . isPresent ( ) , \"srini_string\" ) ; try { return this . encryptor . get ( ) . encrypt ( arg0 ) ; } catch ( Exception loc0 ) { throw new RuntimeException ( \"srini_string\" , loc0 ) ; } }"}, {"instruction": "Generate java code\nthis is to implement memory allocation in the array . like malloc . ", "input": " long serialVersionUID \n byte[] array \n int DEFAULT_BLOCK_SIZE \n int blockSize \n int n \n\n void trimToSize \n byte get \n int length \n byte[] getArray \n void put \n int capacity", "output": "int function ( int arg0 ) { int loc0 = n ; int loc1 = array . length ; if ( n + arg0 >= loc1 ) { byte [ ] loc2 = new byte [ loc1 + blockSize ] ; System . arraycopy ( array , 0 , loc2 , 0 , loc1 ) ; array = loc2 ; } n += arg0 ; return loc0 ; }"}, {"instruction": "Generate java code\nsets the g function that is used in the fda1 problem without specifying the problem . ", "input": " long serialVersionUID \n ContinuousFunction fda1_g \n FunctionOptimisationProblem fda1_h_problem \n ContinuousFunction fda1_h \n FunctionOptimisationProblem fda1_g_problem \n\n FunctionOptimisationProblem getFDA1_h_problem \n Double apply \n Double apply \n FunctionOptimisationProblem getFDA1_g_problem \n ContinuousFunction getFDA1_g \n void setFDA1_h \n void setFDA1_h \n ContinuousFunction getFDA1_h", "output": "void function ( ContinuousFunction arg0 ) { this . fda1_g = arg0 ; }"}, {"instruction": "Generate java code\ndefine output directory based on network type ", "input": " Logger log \n\n Updater loadUpdators \n void saveNetworkAndParameters \n void saveLayerParameters \n Map<String,String> getStringParamPaths \n MultiLayerNetwork loadNetworkAndParameters \n Layer loadLayerParameters \n void saveParameters \n void saveParameters \n Map<Integer,String> getIdParamPaths \n void saveUpdators \n MultiLayerNetwork loadParameters \n MultiLayerNetwork loadParameters", "output": "String function ( String arg0 ) { String loc0 = System . getProperty ( \"srini_string\" ) ; String loc1 = File . separator + arg0 + File . separator + \"srini_string\" ; File loc2 = new File ( loc0 , loc1 ) ; if ( ! loc2 . getParentFile ( ) . exists ( ) ) loc2 . mkdirs ( ) ; return loc2 . toString ( ) ; }"}, {"instruction": "Generate java code\nremove a session attribute from the map . ", "input": " WebServer server \n HashMap<String,Object> map \n Connection conn \n ArrayList<String> commandHistory \n boolean shutdownServerOnDisconnect \n long lastAccess \n Locale locale \n ResultSet result \n int MAX_HISTORY \n Statement executingStatement \n DatabaseMetaData meta \n DbContents contents \n Bnf bnf \n\n void loadBnf \n HashMap<String,Object> getInfo \n String getCommand \n void addCommand \n void setConnection \n Bnf getBnf \n void put \n ArrayList<String> getCommands \n boolean getShutdownServerOnDisconnect \n Connection getConnection \n void setShutdownServerOnDisconnect \n Object get \n DbContents getContents \n DatabaseMetaData getMetaData \n void close", "output": "void function ( String arg0 ) { map . remove ( arg0 ) ; }"}, {"instruction": "Generate java code\nbuilds select expr1 , expr2 from table . ", "input": " PlaceHolder placeHolder \n\n void addExpression \n Select buildSelectFromTable \n Select buildSelectFromTableAndSelectItems \n Join addJoin \n void addGroupBy", "output": "Select function ( Table arg0 , Expression ... arg1 ) { SelectItem [ ] loc0 = new SelectItem [ arg1 . length ] ; for ( int loc1 = 0 ; loc1 < arg1 . length ; loc1 ++ ) { loc0 [ loc1 ] = new SelectExpressionItem ( arg1 [ loc1 ] ) ; } return buildSelectFromTableAndSelectItems ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\nset a field with the specified value . if the field is not found , it is added . if the field is found , the existing values are replaced . ", "input": " int responseCode \n String statusLine \n int httpMinorVersion \n String requestLine \n List<String> namesAndValues \n String responseMessage \n Comparator<String> FIELD_NAME_COMPARATOR \n\n int compare \n int getHttpMinorVersion \n void readHeaders \n String getResponseMessage \n void removeAll \n RawHeaders fromNameValueBlock \n String get \n Map<String,List<String>> toMultimap \n void addSpdyRequestHeaders \n RawHeaders fromBytes \n void add \n RawHeaders fromMultimap \n void setStatusLine \n void addLenient \n RawHeaders getAll \n void setRequestLine \n byte[] toBytes \n int length \n List<String> toNameValueBlock \n String getValue \n void addLine \n void addAll \n int getResponseCode \n String getStatusLine \n String getFieldName \n void computeResponseStatusLineFromSpdyHeaders", "output": "void function ( String arg0 , String arg1 ) { removeAll ( arg0 ) ; add ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nthe file after it has been compressed ", "input": " String gpsDateStamp \n String gpsLatitudeRef \n String gpsLongitude \n String gpsLatitude \n String whiteBalance \n String orientation \n String model \n String focalLength \n String make \n String datetime \n String gpsLongitudeRef \n String gpsAltitude \n String aperture \n String flash \n String gpsAltitudeRef \n ExifInterface inFile \n ExifInterface outFile \n String gpsProcessingMethod \n String exposureTime \n String gpsTimestamp \n String iso \n\n int getOrientation \n void resetOrientation \n void writeExifData \n void createInFile \n void readExifData", "output": "void function ( String arg0 ) { this . outFile = new ExifInterface ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the size of the entry for key and value inuser-defined units . the default implementation returns 1 so that size is the number of entries and max size is the maximum number of entries . an entry 's size must not change while it is in the cache . ", "input": " int size \n int maxSize \n LinkedHashMap<String,BitmapDrawable> map \n LinkedHashMap<String,ArrayList<String>> mapFilters \n\n boolean contains \n void trimToSize \n void evictAll \n int size \n BitmapDrawable get \n ArrayList<String> getFilterKeys \n void entryRemoved \n int maxSize \n BitmapDrawable put \n BitmapDrawable remove \n int safeSizeOf", "output": "int function ( String arg0 , BitmapDrawable arg1 ) { return 1 ; }"}, {"instruction": "Generate java code\nreturn the current transformer 's name . ", "input": " ObjectManager objectManager \n char DIVIDER \n Log logger \n String componentName \n\n ObjectManager getObjectManager \n void setLogger \n String generateID \n String generateID \n Log getLogger \n void dispose \n String generateName \n void setComponentName \n String combine \n void setObjectManager \n void checkValidity", "output": "String function ( ) { return this . componentName ; }"}, {"instruction": "Generate java code\nget the hash code . ", "input": " String[] NO_ARGS \n MarshalledObject data \n long serialVersionUID \n long serialVersionUID \n String[] options \n String className \n String location \n ActivationGroupDesc.CommandEnvironment env \n String command \n long hash \n Properties props \n\n String getCommandPath \n String getLocation \n Properties getPropertyOverrides \n ActivationGroupDesc.CommandEnvironment getCommandEnvironment \n boolean equals \n boolean equals \n String[] getCommandOptions \n String getClassName \n boolean eq \n MarshalledObject getData", "output": "int function ( ) { int loc0 = command == null ? 0 : command . hashCode ( ) ; for ( int loc1 = 0 ; loc1 < options . length ; loc1 ++ ) loc0 ^= options [ loc1 ] . hashCode ( ) ; return loc0 ; }"}, {"instruction": "Generate java code\nset the value of the action property . ", "input": " String branchContractedIcon \n boolean expanded \n String tooltip \n String branchExpandedIcon \n String icon \n String action \n DefaultMutableTreeNode wrapper \n int rowIndex \n String text \n TreeNode treeNode \n boolean leaf \n String leafIcon \n\n TreeNode getTreeNode \n void setExpanded \n String getBranchContractedIcon \n void setWrapper \n void setTooltip \n boolean isLeaf \n String getTooltip \n void setLeafIcon \n void setBranchContractedIcon \n String action \n String getLeafIcon \n boolean isExpanded \n String getText \n String getAction \n void setLeaf \n void setTreeNode \n void setRowIndex \n String getIcon \n int getRowIndex \n String getBranchExpandedIcon \n void setBranchExpandedIcon \n String getFamily \n String toString \n DefaultMutableTreeNode getWrapper \n void setText", "output": "void function ( String arg0 ) { this . action = arg0 ; }"}, {"instruction": "Generate java code\nchars . ", "input": " int SEED \n int fODD_PRIME_NUMBER \n\n int firstTerm \n boolean isArray", "output": "int function ( int arg0 , char arg1 ) { return firstTerm ( arg0 ) + arg1 ; }"}, {"instruction": "Generate java code\nthe changetoken that you used to submit the deleterule request . you can also use this value to query the status of the request . for more information , see getchangetokenstatus . ", "input": " String changeToken \n\n void setChangeToken \n int hashCode \n boolean equals \n DeleteRuleResult clone \n String toString \n DeleteRuleResult withChangeToken", "output": "String function ( ) { return this . changeToken ; }"}, {"instruction": "Generate java code\nreturns true if the given . java file contains a valid @author javadoc tag ", "input": " PrintStream systemOut \n boolean setUpDone \n InputStream systemIn \n ByteArrayOutputStream out \n\n String getCapturedOutput \n int checkCompleteOutput \n void setInputCaptureOutput \n void setUp \n void resetInputOutput \n boolean checkOutputContains \n String getTestName", "output": "boolean function ( String arg0 ) { return checkAuthorship ( arg0 , null ) ; }"}, {"instruction": "Generate java code\nget custom serializer ", "input": " java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n org.apache.axis.description.TypeDesc typeDesc \n java.lang.String targetType \n\n java.lang.String getTargetType \n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Deserializer getDeserializer \n int hashCode \n boolean equals \n void setTargetType", "output": "org . apache . axis . encoding . Serializer function ( java . lang . String arg0 , java . lang . Class arg1 , javax . xml . namespace . QName arg2 ) { return new org . apache . axis . encoding . ser . BeanSerializer ( arg1 , arg2 , typeDesc ) ; }"}, {"instruction": "Generate java code\nthe aws user id of an account . returns a reference to this object so that method calls can be chained together . ", "input": " String groupName \n String groupId \n String userId \n\n String getGroupName \n void setGroupName \n UserIdGroupPair withGroupName \n void setGroupId \n UserIdGroupPair withGroupId \n int hashCode \n boolean equals \n String toString \n String getUserId \n String getGroupId \n void setUserId", "output": "UserIdGroupPair function ( String arg0 ) { this . userId = arg0 ; return this ; }"}, {"instruction": "Generate java code\ntests for replaycallable s that runtimeexception s are correctly propagated . ", "input": " String TEST_ERROR_MESSAGE \n long mCount \n Exception mException \n Long TEST_MAX_SIZE \n ReplayCache<Long> mCache \n Long TEST_TIMEOUT_MS \n\n Long call \n Long call \n Long call \n Long call \n void testTimeEviction \n void testSizeEviction \n void before \n void testAlluxioExceptionRethrow2 \n void testAlluxioExceptionRethrow1 \n void testCaching2 \n void testRuntimeExceptionPropagated2 \n void testCaching1 \n void testIOExceptionRethrow", "output": "void function ( ) { RuntimeException loc0 = new RuntimeException ( TEST_ERROR_MESSAGE ) ; try { mCache . run ( \"srini_string\" , new ThrowingCallable ( loc0 ) ) ; Assert . fail ( \"srini_string\" ) ; } catch ( RuntimeException loc1 ) { Assert . assertSame ( loc0 , loc1 ) ; } }"}, {"instruction": "Generate java code\nsimlar to readfully , but does n't throw exception when eof is reached . ", "input": " byte STRICT_SYNC \n boolean singleChMode \n PushbackInputStream source \n byte[] rawID3v2 \n byte INITIAL_SYNC \n byte[] frameBytes \n int bitIndex \n int syncWord \n boolean firstFrame \n Header header \n int[] frameBuffer \n int frameSize \n int[] BITMASK \n byte[] syncBuffer \n int BUFFER_INT_SIZE \n int wordPointer \n\n Header readNextFrame \n int getBits \n boolean isSyncCurrentPosition \n void loadID3v2 \n void closeFrame \n void unreadFrame \n int readFrameData \n boolean isSyncMark \n void parseFrame \n int syncHeader \n int readFully \n Header readFrame \n void setSyncWord \n int readID3v2Header", "output": "int function ( byte [ ] arg0 , int arg1 , int arg2 ) { int loc0 = 0 ; while ( arg2 > 0 ) { int loc1 = source . read ( arg0 , arg1 , arg2 ) ; if ( loc1 == - 1 ) { break ; } loc0 += loc1 ; arg1 += loc1 ; arg2 -= loc1 ; } return loc0 ; }"}, {"instruction": "Generate java code\nthe table name is auto-generated using #extracttablename class . ", "input": " Class<? extends ContentItem> mDataItem \n String DOUBLE_ESCAPE \n String mTable \n\n void appendFKColumnDef \n void appendColumnDef \n List<String> getTableCreation \n String getDbColumnName \n String extractTableName \n Class<? extends DBColumnType<?>> getFieldType \n Class<? extends DBColumnType<?>> getFieldType", "output": "String function ( ) { return mTable ; }"}, {"instruction": "Generate java code\nverifies that the given array contains the given subsequence of values possibly with other values between them . ", "input": " Arrays arrays \n Failures failures \n BooleanArrays INSTANCE \n\n void assertEndsWith \n void assertStartsWith \n BooleanArrays instance \n void assertNullOrEmpty \n void assertNotEmpty \n void assertContainsOnly \n void assertContainsExactly \n void assertContainsSequence \n void assertDoesNotHaveDuplicates \n void assertHasSameSizeAs \n void assertHasSameSizeAs \n void assertContains \n void assertContains \n void assertIsSortedAccordingToComparator \n void assertContainsOnlyOnce \n void assertEmpty \n void assertIsSorted \n void assertHasSize \n void assertDoesNotContain \n void assertDoesNotContain", "output": "void function ( AssertionInfo arg0 , boolean [ ] arg1 , boolean [ ] arg2 ) { arrays . assertContainsSubsequence ( arg0 , failures , arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\nsets an element in a particular data bank . the offset specified in the constructor is added to i before updating the underlying data array . ", "input": " int banks \n int TYPE_BYTE \n int TYPE_FLOAT \n int offset \n int size \n int TYPE_INT \n int[] offsets \n int dataType \n int TYPE_DOUBLE \n int TYPE_UNDEFINED \n int TYPE_USHORT \n int TYPE_SHORT \n\n int getSize \n int getNumBanks \n int getDataTypeSize \n double getElemDouble \n double getElemDouble \n void setElemDouble \n void setElemDouble \n int getDataType \n int getOffset \n int[] getOffsets \n void setElem \n void setElem \n float getElemFloat \n float getElemFloat \n int getElem \n int getElem", "output": "void function ( int arg0 , int arg1 , float arg2 ) { setElem ( arg0 , arg1 , ( int ) arg2 ) ; }"}, {"instruction": "Generate java code\nby default , there are no collisions in pasting . ", "input": " Map nameFeatureMap \n Object NULL_TOKEN \n\n boolean shouldOverrideCopyOperation \n void setName \n boolean canContain \n XMLResource getResource \n String getName \n OverrideCopyOperation getOverrideCopyOperation \n boolean isCopyAlways \n boolean shouldSaveContainmentFeature \n void destroy \n boolean hasPasteOption \n void performPostPasteProcessing \n boolean shouldOverrideChildPasteOperation \n OverridePasteChildOperation getOverrideChildPasteOperation \n void sendCreateNotification \n EAttribute getNameAttribute \n Collection getExcludedCopyObjects \n boolean isNameable", "output": "PasteAction function ( EClass arg0 ) { return PasteAction . ADD ; }"}, {"instruction": "Generate java code\nadds the error code and the key to the list of errors . this list is populated during construction or addition of elements and is used outside this class to act upon the errors . ", "input": " Method savePropsMethod \n String fileName \n boolean resource \n String[] errorKeys \n Properties stringProps \n int[] errorCodes \n int NO_VALUE_FOR_KEY \n\n String getProperty \n String getProperty \n HsqlProperties argArrayToProps \n Properties getProperties \n void save \n boolean isEmpty \n void main \n void addProperties \n void addProperties \n void setFileName \n boolean checkFileExists \n boolean checkFileExists \n boolean load \n String setPropertyIfNotExists \n Enumeration propertyNames \n String setProperty \n String setProperty \n String setProperty \n boolean isPropertyTrue \n boolean isPropertyTrue \n int getIntegerProperty \n int getIntegerProperty \n void removeProperty \n HsqlProperties delimitedArgPairsToProps", "output": "void function ( int arg0 , String arg1 ) { errorCodes = ( int [ ] ) ArrayUtil . resizeArray ( errorCodes , errorCodes . length + 1 ) ; errorKeys = ( String [ ] ) ArrayUtil . resizeArray ( errorKeys , errorKeys . length + 1 ) ; errorCodes [ errorCodes . length - 1 ] = arg0 ; errorKeys [ errorKeys . length - 1 ] = arg1 ; }"}, {"instruction": "Generate java code\nreturns the tmp directory . ", "input": " MoaTestCase m_Owner \n String m_DataDirectory \n\n boolean copyResourceToTmp \n boolean copyResourceToTmp \n boolean deleteFileFromTmp \n I load \n String getDataDirectory \n boolean save \n boolean renameTmpFile \n String getTmpLocationFromResource", "output": "String function ( ) { return System . getProperty ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ngets the description of of the treasure ", "input": " String imageName \n String roomNameWest \n Gold gold \n boolean flagKilledCreature \n String roomNameNorth \n String roomNameSouth \n String description \n String NONE \n String roomNameEast \n String ENTRY \n String DEFAULT_IMAGE \n Creature creature \n String name \n Weapon weapon \n\n boolean isCreatureKilled \n String getCreatureName \n String getImageName \n String getCreatureSpecies \n String getName \n boolean isEntry \n void attackCreature \n int takeGold \n String getDescription \n String getRoomNameInDirection \n void selectImageName \n void resetFlags \n Weapon takeWeapon \n void giveWeaponToPlayer \n String getTreasureName \n boolean hasGold \n int normalizeDirection \n boolean hasRoomInDirection \n void storeWeapon \n boolean hasWeapon \n String getCreatureDescription \n String getWeaponDescription \n String getCreatureWeaponName \n boolean hasCreature \n String getWeaponName \n String getItemName \n void storeGold \n void giveGoldToPlayer \n void spawnCreature", "output": "String function ( ) { return gold . getDescription ( ) ; }"}, {"instruction": "Generate java code\ngets the value of the calendartype property . ", "input": " List<CTFilter> filter \n Object parent \n Boolean blank \n STCalendarType calendarType \n List<CTDateGroupItem> dateGroupItem \n\n List<CTFilter> getFilter \n void setBlank \n Object getParent \n void afterUnmarshal \n boolean isBlank \n void setParent \n void setCalendarType \n List<CTDateGroupItem> getDateGroupItem", "output": "STCalendarType function ( ) { if ( calendarType == null ) { return STCalendarType . NONE ; } else { return calendarType ; } }"}, {"instruction": "Generate java code\napply css changes to the rendered componenent ", "input": " String CSS_UPDATE_FIELD \n String cssString \n Logger log \n String DISPLAY_ON \n String DISPLAY_OFF \n String lastCssString \n\n boolean equals \n String getLastCssString \n void setLastCssString \n String getCssString \n Map decode \n void decode", "output": "void function ( FacesContext arg0 , UIComponent arg1 ) { apply ( arg0 , arg1 , null , null , null ) ; }"}, {"instruction": "Generate java code\nget threaddata by its id ", "input": " int diskAccessNum \n List<ThreadData> threadList \n\n void updateDiskEnergy \n Map<Long,Long> calculateCPUTimeByID \n void calculateDiskAccessNum \n void updateCPUEnergy", "output": "ThreadData function ( Long arg0 ) { for ( ThreadData loc0 : this . threadList ) { if ( loc0 . arg0 . equals ( arg0 ) ) return loc0 ; } return null ; }"}, {"instruction": "Generate java code\nget length of extent . ", "input": " long offset \n int[] osds \n long length \n\n long getOffset \n int[] getOSDs \n String toString", "output": "long function ( ) { return length ; }"}, {"instruction": "Generate java code\nresets scene to default settings . removes and clears any attached object3ds . resets light list . ", "input": " FogType _fogType \n ISceneController _sceneController \n float _fogFar \n float _fogNear \n ArrayList<Object3d> _children \n boolean _lightingEnabled \n Color4 _fogColor \n boolean _fogEnabled \n CameraVo _camera \n ManagedLightList _lights \n Color4Managed _backgroundColor \n\n boolean lightingEnabled \n void lightingEnabled \n FogType fogType \n void fogType \n void init \n Object3d getChildByName \n Color4Managed backgroundColor \n float fogFar \n void fogFar \n void clearChildren \n boolean removeChild \n void update \n void onDirty \n int getChildIndexOf \n ISceneController sceneController \n void sceneController \n Object3d getChildAt \n float fogNear \n void fogNear \n boolean fogEnabled \n void fogEnabled \n ArrayList<Object3d> children \n void addChildAt \n Object3d removeChildAt \n Color4 fogColor \n void fogColor \n int numChildren \n CameraVo camera \n void camera \n void addChild \n ManagedLightList lights", "output": "void function ( ) { clearChildren ( this ) ; _children = new ArrayList < Object3d > ( ) ; _camera = new CameraVo ( ) ; _backgroundColor = new Color4Managed ( 0 , 0 , 0 , 255 , this ) ; _lights = new ManagedLightList ( ) ; lightingEnabled ( true ) ; }"}, {"instruction": "Generate java code\ncalls the iselectable . setselected selected method with the given argument for all iselectable s in the set . ", "input": " List<ISelectable> set \n ESelectionType selectionType \n\n void add \n Iterator<ISelectable> iterator \n boolean contains \n int getSize \n ESelectionType getSelectionType \n void addAll \n ISelectable get \n void clear \n boolean isEmpty \n String toString \n int getMovableCount", "output": "void function ( boolean arg0 ) { for ( ISelectable loc0 : set ) { loc0 . setSelected ( arg0 ) ; } }"}, {"instruction": "Generate java code\ngetter method for circleid for the circle ", "input": " Integer templetId \n String agentId \n Integer customerType \n String sendTo \n Date endDate \n String templetType \n long serialVersionUID \n String circleID \n String circle \n Date startDate \n Integer parentId \n Integer status \n\n Date getStartDate \n void setStartDate \n void setTempletId \n Integer getTempletId \n String getCircle \n String getAgentId \n void setSendTo \n Date getEndDate \n void setCircle \n Integer getStatus \n void setEndDate \n void setCircleID \n String getSendTo \n void setStatus \n Integer getCustomerType \n String getTempletType \n void setParentId \n String toString \n void setTempletType \n Integer getParentId \n void setCustomerType \n void setAgentId", "output": "String function ( ) { return circleID ; }"}, {"instruction": "Generate java code\nthis method was generated by mybatis generator . this method sets the value of the database column portal_space . space_id ", "input": " String spaceName \n String organizationId \n String spaceId \n String spaceChname \n String cfSpaceGuid \n String spaceDescription \n String cfOrgGuid \n long serialVersionUID \n\n void setSpaceChname \n String getCfOrgGuid \n void setCfSpaceGuid \n String getSpaceDescription \n void setSpaceName \n String getCfSpaceGuid \n String getSpaceChname \n String getOrganizationId \n String getSpaceName \n String getSpaceId \n void setCfOrgGuid \n void setOrganizationId \n void setSpaceDescription", "output": "void function ( String arg0 ) { this . spaceId = arg0 == null ? null : arg0 . trim ( ) ; }"}, {"instruction": "Generate java code\nsets the entry id1 of this asset link . ", "input": " AssetLink _assetLink \n\n boolean isFinderCacheEnabled \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n boolean isEscapedModel \n int getWeight \n boolean isCachedModel \n com.liferay.portlet.expando.model.ExpandoBridge getExpandoBridge \n int compareTo \n AssetLink getWrappedModel \n void setModelAttributes \n Map<String,Object> getModelAttributes \n long getEntryId2 \n com.liferay.portal.model.CacheModel<com.liferay.portlet.asset.model.AssetLink> toCacheModel \n Date getCreateDate \n long getEntryId1 \n void setUserName \n int hashCode \n void setPrimaryKey \n com.liferay.portlet.asset.model.AssetLink toUnescapedModel \n java.lang.String getUserName \n void setUserUuid \n boolean isEntityCacheEnabled \n void persist \n void setNew \n void setEntryId2 \n java.lang.String getUserUuid \n void setLinkId \n void resetOriginalValues \n void setWeight \n boolean isNew \n void setType \n java.io.Serializable getPrimaryKeyObj \n Class<?> getModelClass \n long getPrimaryKey \n com.liferay.portlet.asset.model.AssetLink toEscapedModel \n int getType \n long getCompanyId \n void setCreateDate \n long getLinkId \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n void setCachedModel \n java.lang.String toString \n String getModelClassName \n void setCompanyId \n long getUserId \n void setUserId", "output": "void function ( long arg0 ) { _assetLink . setEntryId1 ( arg0 ) ; }"}, {"instruction": "Generate java code\ntests the read byte , int , int method . ", "input": " UnderFileSystemFileInStream mTestStream \n int FILE_SIZE \n ConfigurationRule mConfigurationRule \n NettyUnderFileSystemFileReader mMockReader \n byte[] mData \n long FILE_ID \n\n void readByteArray \n void before \n void readByteBuffered \n void readByte \n void readBulkBuffered \n void readToEOF", "output": "void function ( ) { byte [ ] loc0 = new byte [ FILE_SIZE ] ; Assert . assertEquals ( FILE_SIZE / 2 , mTestStream . read ( loc0 , FILE_SIZE / 2 , FILE_SIZE / 2 ) ) ; for ( int loc1 = 0 ; loc1 < FILE_SIZE ; loc1 ++ ) { Assert . assertEquals ( ( byte ) Math . max ( 0 , loc1 - FILE_SIZE / 2 ) , loc0 [ loc1 ] ) ; } }"}, {"instruction": "Generate java code\nreturns int array ` bit ' of size 8 with bit i = bit at index ` i ' in byte b ", "input": " PlaceHolder placeHolder \n\n int getValue \n boolean lieBetween \n byte bitToByte \n int getNibble \n byte[] parse \n int getBit", "output": "int [ ] function ( byte arg0 ) { int [ ] loc0 = new int [ 8 ] ; for ( int loc1 = 0 ; loc1 < 8 ; loc1 ++ ) { loc0 [ loc1 ] = getBit ( arg0 , loc1 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nsets the value of the contentmetadatakeyhierarchyaction property . ", "input": " Statement filterStatement \n ContentMetadataKeyHierarchyAction contentMetadataKeyHierarchyAction \n\n Statement getFilterStatement \n ContentMetadataKeyHierarchyAction getContentMetadataKeyHierarchyAction \n void setFilterStatement", "output": "void function ( ContentMetadataKeyHierarchyAction arg0 ) { this . contentMetadataKeyHierarchyAction = arg0 ; }"}, {"instruction": "Generate java code\nreturns a double representing the number of hours of the specified time . ", "input": " long serialVersionUID \n double MILLISECONDS_TO_HOURS_MULTIPLIER \n Time DISABLED_TIME \n double MILLISECONDS_TO_MINUTES_MULTIPLIER \n\n void setMonth \n Integer getMinutesFromTime \n Date addBusinessDays \n Date addBusinessDays \n String nowTimeHour \n void setMinutes \n Time getTimeSeconds \n void main \n void assertEquals \n void setYear \n Time getTimeFromHours \n Time getTimeFromMinutes \n Time getTimeMilliSeconds \n void setHours \n Integer getMinutesFromTimeString \n void setSeconds \n Timestamp now \n void setDate \n T setDateToMidnight \n String formatHoursElapsedString \n Time parseTime \n Time parseTime \n double getHoursElapsed \n double getHoursElapsed \n void setTime \n Timestamp nowMidnight", "output": "double function ( Time arg0 ) { return getHoursElapsed ( Time . valueOf ( \"srini_string\" ) , arg0 ) ; }"}, {"instruction": "Generate java code\nreturn type metadata object ", "input": " org.apache.axis.description.TypeDesc typeDesc \n java.lang.String displayName \n java.lang.Object __equalsCalc \n java.lang.String name \n boolean __hashCodeCalc \n\n void setName \n java.lang.String getName \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n java.lang.String getDisplayName \n int hashCode \n boolean equals \n void setDisplayName", "output": "org . apache . axis . description . TypeDesc function ( ) { return typeDesc ; }"}, {"instruction": "Generate java code\nload referrer of cmkishtesuryolist by the set-upper of referrer . cm_kish_tesuryo by cm_kaisha_id , named ` cmkishtesuryolist ' . cmkaishabhv.load cmkaishalist , kaishaloader - > kaishaloader.loadcmkishtesuryo tesuryocb - > tesuryocb.setupselect ... tesuryocb.query . set ... tesuryocb.query . addorderby ... ; / / you can load nested referrer from here / / . withnestedreferrer tesuryoloader - > / / tesuryoloader.load ... / / ; ; for cmkaisha cmkaisha : cmkaishalist ... = cmkaisha.getcmkishtesuryolist ; about internal policy , the value of primary key and others too is treated as case-insensitive . the condition-bean , which the set-upper provides , has settings before callback as follows : cb.query . setcmkaishaid_inscope pklist ; cb.query . addorderby_cmkaishaid_asc ; ", "input": " List<CmKaisha> _selectedList \n CmKaishaBhv _myBhv \n BehaviorSelector _selector \n List<CmKishTesuryo> _referrerCmKishTesuryo \n List<CmKishRenrakusaki> _referrerCmKishRenrakusaki \n List<CmShain> _referrerCmShain \n\n List<CmKaisha> getSelectedList \n NestedReferrerLoaderGateway<LoaderOfCmKishRenrakusaki> loadCmKishRenrakusaki \n BehaviorSelector getSelector \n LoaderOfCmKaisha ready \n NestedReferrerLoaderGateway<LoaderOfCmShain> loadCmShain \n CmKaishaBhv myBhv", "output": "NestedReferrerLoaderGateway < LoaderOfCmKishTesuryo > function ( ReferrerConditionSetupper < CmKishTesuryoCB > arg0 ) { myBhv ( ) . loadCmKishTesuryo ( _selectedList , arg0 ) . withNestedReferrer ( refLs -> _referrerCmKishTesuryo = refLs ) ; return hd -> hd . handle ( new LoaderOfCmKishTesuryo ( ) . ready ( _referrerCmKishTesuryo , _selector ) ) ; }"}, {"instruction": "Generate java code\ngets the value of the mode property . ", "input": " String mode \n String id \n\n void setMode \n void setId \n String getId", "output": "String function ( ) { return mode ; }"}, {"instruction": "Generate java code\nsets the value of the settleamount property . ", "input": " XMLGregorianCalendar submitTimeUTC \n String lastName \n Boolean hasReturnedItems \n String product \n String transactionStatus \n String transId \n XMLGregorianCalendar submitTimeLocal \n String accountType \n BigDecimal settleAmount \n SubscriptionPaymentType subscription \n String accountNumber \n String marketType \n String firstName \n String mobileDeviceId \n String invoiceNumber \n\n void setTransId \n void setSubmitTimeUTC \n String getInvoiceNumber \n void setTransactionStatus \n BigDecimal getSettleAmount \n void setSubscription \n void setInvoiceNumber \n void setLastName \n String getMarketType \n XMLGregorianCalendar getSubmitTimeUTC \n void setAccountType \n void setMobileDeviceId \n SubscriptionPaymentType getSubscription \n String getTransId \n String getMobileDeviceId \n Boolean isHasReturnedItems \n void setProduct \n String getProduct \n void setAccountNumber \n void setMarketType \n String getAccountType \n String getLastName \n void setHasReturnedItems \n XMLGregorianCalendar getSubmitTimeLocal \n String getTransactionStatus \n void setFirstName \n String getAccountNumber \n String getFirstName \n void setSubmitTimeLocal", "output": "void function ( BigDecimal arg0 ) { this . settleAmount = arg0 ; }"}, {"instruction": "Generate java code\ntest of failed method , of class simplepenalizingvalidation . ", "input": " PlaceHolder placeHolder \n\n void setUpClass \n void testPassed \n void testToString \n void testGetPenalty \n void tearDownClass \n void testConstructor", "output": "void function ( ) { System . out . println ( \"srini_string\" ) ; double loc0 = 123.456 ; PenalizingValidation loc1 = SimplePenalizingValidation . FAILED ( loc0 ) ; assertEquals ( loc0 , loc1 . getPenalty ( ) , TestConstants . DOUBLE_COMPARISON_PRECISION ) ; }"}, {"instruction": "Generate java code\nthe grant token . for more information about using grant tokens , see grant tokens in the aws key management service developer guide . ", "input": " String grantId \n String grantToken \n\n String getGrantId \n void setGrantId \n int hashCode \n boolean equals \n CreateGrantResult clone \n CreateGrantResult withGrantId \n String toString \n void setGrantToken \n String getGrantToken", "output": "CreateGrantResult function ( String arg0 ) { setGrantToken ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nset the start delay in milliseconds . the start delay is added to the current system time when the bean starts to control the start time of the trigger . ", "input": " JobDetail jobDetail \n int misfireInstruction \n TimeZone timeZone \n String description \n int priority \n JobDataMap jobDataMap \n long startDelay \n String cronExpression \n String calendarName \n CronTrigger cronTrigger \n Constants constants \n String name \n Date startTime \n String beanName \n String group \n\n void setName \n CronTrigger getObject \n void setMisfireInstructionName \n void setJobDetail \n void setBeanName \n boolean isSingleton \n void setDescription \n JobDataMap getJobDataMap \n void setCronExpression \n void setMisfireInstruction \n void setGroup \n void afterPropertiesSet \n void setJobDataAsMap \n void setTimeZone \n void setCalendarName \n Class<?> getObjectType \n void setStartTime \n void setJobDataMap \n void setPriority", "output": "void function ( long arg0 ) { Assert . isTrue ( arg0 >= 0 , \"srini_string\" ) ; this . startDelay = arg0 ; }"}, {"instruction": "Generate java code\nreturn address reference for specified array object ", "input": " PlaceHolder placeHolder \n\n Object getPrototype \n Object resolveAddress \n int tie \n int tied \n int instance \n void untie \n int getAddressPrototype \n int size \n Object castTo \n void clear \n void poke \n int peek", "output": "int function ( Object arg0 [ ] ) { throw new RuntimeException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncreates and shows the dialog which allows user to choose credentials for login . ", "input": " int mTitleLinkStart \n ArrayAdapter<Credential> mAdapter \n Credential[] mCredentials \n Context mContext \n Credential mCredential \n int mTitleLinkEnd \n AlertDialog mDialog \n String mSigninButtonText \n boolean mWasDismissedByNative \n boolean mIsDestroyed \n String mTitle \n long mNativeAccountChooserDialog \n boolean mSigninButtonClicked \n String mOrigin \n\n void onClick \n void onDismiss \n void dismissDialog \n void nativeOnCredentialClicked \n ArrayAdapter<Credential> generateAccountsArrayAdapter \n void show \n void destroy \n void nativeDestroy \n void nativeOnLinkClicked \n void nativeCancelDialog \n void imageFetchComplete", "output": "AccountChooserDialog function ( WindowAndroid arg0 , long arg1 , Credential [ ] arg2 , String arg3 , int arg4 , int arg5 , String arg6 , String arg7 ) { Activity loc0 = arg0 . getActivity ( ) . get ( ) ; if ( loc0 == null ) return null ; AccountChooserDialog loc1 = new AccountChooserDialog ( loc0 , arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , arg7 ) ; loc1 . show ( ) ; return loc1 ; }"}, {"instruction": "Generate java code\nnormalizes the given vector of three floats to have length == 1.0 . vectors with length zero are unaffected . ", "input": " int mPrimitive \n float PI \n Buffer mIndexBuffer \n int INT_BYTES \n IntBuffer mColorBuffer \n IntBuffer mNormalBuffer \n float TWO_PI \n IntBuffer mTexcoordBuffer \n int mNumIndices \n boolean mEmitColors \n int SHORT_BYTES \n boolean mEmitTextureCoordinates \n int mIndexDatatype \n float DEGREES_TO_RADIANS \n IntBuffer mVertexBuffer \n boolean mEmitNormals \n float PI_OVER_TWO \n\n int toFixed \n int getNumTriangles \n void allocate \n float toFloat \n void cross \n float length \n float length \n void allocateBuffers \n void allocateBuffers \n void draw", "output": "void function ( float [ ] arg0 ) { float loc0 = loc0 ( arg0 ) ; if ( loc0 != 0.0f ) { float loc1 = 1.0f / loc0 ; arg0 [ 0 ] *= loc1 ; arg0 [ 1 ] *= loc1 ; arg0 [ 2 ] *= loc1 ; } }"}, {"instruction": "Generate java code\ngets the userid of this bookmarkentitypk . ", "input": " String bmid \n String userid \n\n void setBmid \n String getBmid \n int hashCode \n boolean equals \n String toString \n void setUserid", "output": "String function ( ) { return this . userid ; }"}, {"instruction": "Generate java code\nevaluate an item against the use cases in the item filter set . if an item satisfies all items in the item filter set , it should also ve added to the special all items filter . ", "input": " Logger log \n List<ItemFilter> itemFilters \n ItemFilter allFiltersFilter \n AuthorizeService authorizeService \n\n List<ItemFilter> getItemFilters \n int processSaveItems \n int processSaveItems \n ItemFilter getAllFiltersFilter", "output": "void function ( Context arg0 , org . dspace . content . Item arg1 , Item arg2 ) { boolean loc0 = true ; for ( ItemFilter loc1 : itemFilters ) { if ( loc1 . hasItemTest ( ) ) { loc0 &= loc1 . testItem ( arg0 , arg1 , arg2 ) ; } } if ( loc0 && allFiltersFilter != null ) { allFiltersFilter . addItem ( arg2 ) ; } }"}, {"instruction": "Generate java code\nreduces the size of the array to the specified size . if the array is already smaller than the specified size , no action is taken . ", "input": " boolean ordered \n int size \n float[] items \n\n void add \n void set \n void shrink \n void clear \n void insert \n float removeIndex \n void sort \n void reverse \n float peek \n float pop \n float random \n boolean contains \n boolean removeValue \n void addAll \n void addAll \n void addAll \n void addAll \n float get \n float[] toArray \n float[] resize \n String toString \n String toString \n float[] ensureCapacity \n void shuffle \n int indexOf", "output": "void function ( int arg0 ) { if ( size > arg0 ) size = arg0 ; }"}, {"instruction": "Generate java code\nretrieves resident identity provider for a given tenant ", "input": " IdentityProviderMgtServiceStub idPMgtStub \n Log log \n UserAdminStub userAdminStub \n\n String[] getAllLocalClaimUris \n void addIdP \n String[] getUserStoreDomains \n Map<String,FederatedAuthenticatorConfig> getAllFederatedAuthenticators \n void updateResidentIdP \n List<IdentityProvider> getIdPs \n void deleteIdP \n IdentityProvider getIdPByName \n Map<String,ProvisioningConnectorConfig> getCustomProvisioningConnectors \n List<IdentityProvider> getEnabledIdPs \n String getResidentIDPMetadata \n void updateIdP", "output": "IdentityProvider function ( ) { try { return idPMgtStub . getResidentIdP ( ) ; } catch ( Exception loc0 ) { log . error ( \"srini_string\" , loc0 ) ; throw new Exception ( \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nget the type of an attribute by position . ", "input": " Vector types \n Vector names \n Vector values \n\n String getValue \n String getValue \n String getName \n void addAttribute \n void clear \n int getLength \n void setAttributeList \n void removeAttribute", "output": "String function ( int arg0 ) { if ( arg0 < 0 ) { return null ; } try { return ( String ) types . elementAt ( arg0 ) ; } catch ( ArrayIndexOutOfBoundsException loc0 ) { return null ; } }"}, {"instruction": "Generate java code\nreturn the body text associated with this node if any . ", "input": " String name \n HashMap attributes \n TreeNode parent \n String body \n ArrayList children \n\n TreeNode findChild \n String findAttribute \n String getName \n void addAttribute \n Iterator findAttributes \n String toString \n void toString \n Iterator findChildren \n Iterator findChildren \n void removeAttribute \n void setBody \n void addChild \n void removeNode", "output": "String function ( ) { return ( this . body ) ; }"}, {"instruction": "Generate java code\nadd an http request header ", "input": " UriTemplateHandler uriTemplateHandler \n MultiValueMap<String,HttpCookie> cookies \n List<ClientWebRequestPostProcessor> postProcessors \n HttpHeaders httpHeaders \n HttpMethod httpMethod \n Publisher<?> body \n ResolvableType elementType \n URI url \n\n DefaultClientWebRequestBuilder headers \n DefaultClientWebRequestBuilder cookie \n DefaultClientWebRequestBuilder cookie \n DefaultClientWebRequestBuilder apply \n ClientWebRequest build \n DefaultClientWebRequestBuilder body \n DefaultClientWebRequestBuilder body \n DefaultClientWebRequestBuilder contentType \n DefaultClientWebRequestBuilder contentType \n DefaultClientWebRequestBuilder accept \n DefaultClientWebRequestBuilder accept", "output": "DefaultClientWebRequestBuilder function ( String arg0 , String ... arg1 ) { Arrays . stream ( arg1 ) . forEach ( value -> this . httpHeaders . add ( arg0 , value ) ) ; return this ; }"}, {"instruction": "Generate java code\nget the message limit ", "input": " boolean warningsAsErrors \n int warnings \n int limit \n PrintWriter writer \n int errors \n\n void setWarningsAsErrors \n boolean hasErrors \n boolean isWarningsAsErrors \n void setLimit \n int getNumberOfWarnings \n String format \n void checkLimit \n void warning \n void warning \n void reset \n void error \n void error \n int getNumberOfErrors", "output": "int function ( ) { return limit ; }"}, {"instruction": "Generate java code\nspecify the sort order : ascending true or descending false . ", "input": " Comparator<T> comparator \n boolean ascending \n\n int compare \n int hashCode \n boolean equals \n String toString \n boolean isAscending \n void invertOrder", "output": "void function ( boolean arg0 ) { this . ascending = arg0 ; }"}, {"instruction": "Generate java code\nreturns the tag stats id of this asset tag stats . ", "input": " AssetTagStats _assetTagStats \n\n long getClassNameId \n boolean isFinderCacheEnabled \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n boolean isEscapedModel \n boolean isCachedModel \n void setAssetCount \n ExpandoBridge getExpandoBridge \n int compareTo \n void setClassName \n AssetTagStats getWrappedModel \n void setModelAttributes \n int getAssetCount \n Map<String,Object> getModelAttributes \n void setClassNameId \n com.liferay.portal.kernel.model.CacheModel<AssetTagStats> toCacheModel \n int hashCode \n AssetTagStats toUnescapedModel \n void setPrimaryKey \n void persist \n boolean isEntityCacheEnabled \n void setNew \n void resetOriginalValues \n boolean isNew \n Serializable getPrimaryKeyObj \n Class<?> getModelClass \n void setTagId \n AssetTagStats toEscapedModel \n long getPrimaryKey \n long getTagId \n long getCompanyId \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n void setCachedModel \n java.lang.String toString \n void setTagStatsId \n java.lang.String getClassName \n String getModelClassName \n void setCompanyId", "output": "long function ( ) { return _assetTagStats . getTagStatsId ( ) ; }"}, {"instruction": "Generate java code\npaint svg image to specific area paintarea with graphics ", "input": " String filePath \n Dimension size \n Dimension INVALID_DIMENSION \n List<SVGShape> list \n boolean isInit \n boolean documentContainError \n\n void init \n Element getRootElement \n Element getRootElement \n Dimension getSize \n ImageData createImage \n void parseDefinition \n void setResourceManager \n void paint \n void paintImage", "output": "void function ( Graphics arg0 , Rectangle arg1 , ResourceManager arg2 ) { paintFigure ( arg0 , arg1 , arg2 , null ) ; }"}, {"instruction": "Generate java code\nreturns the standard error of the estimate for the slope . ", "input": " double r2 \n double svar \n double intercept \n double svar1 \n double svar0 \n double slope \n int N \n\n double R2 \n double intercept \n double predict \n String toString \n double slope \n double interceptStdErr", "output": "double function ( ) { return Math . sqrt ( svar1 ) ; }"}, {"instruction": "Generate java code\nreturns the number of legacy metadatas . ", "input": " LegacyMetadataPersistence _persistence \n\n void cacheResult \n void cacheResult \n List<LegacyMetadata> findWithDynamicQuery \n List<LegacyMetadata> findWithDynamicQuery \n List<LegacyMetadata> findWithDynamicQuery \n LegacyMetadata update \n LegacyMetadata update \n void clearCache \n void clearCache \n long countWithDynamicQuery \n java.util.List<de.uhh.l2g.plugins.migration.model.LegacyMetadata> findAll \n java.util.List<de.uhh.l2g.plugins.migration.model.LegacyMetadata> findAll \n java.util.List<de.uhh.l2g.plugins.migration.model.LegacyMetadata> findAll \n de.uhh.l2g.plugins.migration.model.LegacyMetadata remove \n de.uhh.l2g.plugins.migration.model.LegacyMetadata fetchByPrimaryKey \n void removeAll \n LegacyMetadataPersistence getPersistence \n de.uhh.l2g.plugins.migration.model.LegacyMetadata create \n de.uhh.l2g.plugins.migration.model.LegacyMetadata findByPrimaryKey \n void setPersistence \n de.uhh.l2g.plugins.migration.model.LegacyMetadata updateImpl", "output": "int function ( ) { return getPersistence ( ) . countAll ( ) ; }"}, {"instruction": "Generate java code\nsome text . ", "input": " int CONSTANT \n InnerClassWithAnnotations anon \n String fFirstName \n String tThirdName \n String sSecondName \n\n String method5 \n String method5 \n String method5 \n String method \n String method \n String method \n String method1 \n String method1 \n String method1 \n void method2 \n void method2 \n void method2 \n void method3 \n void method3 \n void method3 \n String method4 \n String method4 \n String method4", "output": "String function ( String arg0 , int arg1 , boolean arg2 ) { return \"srini_string\" ; }"}, {"instruction": "Generate java code\nregisters a handlerregistration with this container . the handler will be unregistered when this binder is disposed . ", "input": " GarbageCollector gc \n\n void dispose \n void registerDisposableAndUpdateTarget", "output": "void function ( HandlerRegistration arg0 ) { gc . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns plugins that should be loaded in the transport client ", "input": " NodeConfigurationSource EMPTY \n\n Collection<Class<? extends Plugin>> nodePlugins \n Settings transportClientSettings \n Settings transportClientSettings \n Settings nodeSettings \n Settings nodeSettings", "output": "Collection < Class < ? extends Plugin >> function ( ) { return Collections . emptyList ( ) ; }"}, {"instruction": "Generate java code\nretrieves whether values for the designated parameter can be signed numbers . ", "input": " int[] types \n int[] modes \n int parameterCount \n int[] nullability \n Result.ResultMetaData rmd \n boolean[] isIdentity \n String[] classNames \n\n int getParameterCount \n int getScale \n int isNullable \n int getParameterMode \n String toString \n String getParameterClassName \n String getParameterTypeName \n void checkRange \n int getPrecision \n String toStringImpl \n int getParameterType", "output": "boolean function ( int arg0 ) { checkRange ( arg0 ) ; Boolean loc0 = Types . isUnsignedAttribute ( types [ -- arg0 ] ) ; return loc0 != null && ! loc0 . booleanValue ( ) && ! isIdentity [ arg0 ] ; }"}, {"instruction": "Generate java code\ncalled on page transitions ", "input": " PluginManager pluginManager \n int expectedBridgeSecret \n String LOG_TAG \n NativeToJsMessageQueue jsMessageQueue \n\n void jsSetNativeToJsBridgeMode \n boolean isSecretEstablished \n boolean verifySecret \n String promptOnJsPrompt \n void reset \n String jsExec \n String jsRetrieveJsMessages \n int generateBridgeSecret", "output": "void function ( ) { expectedBridgeSecret = - 1 ; }"}, {"instruction": "Generate java code\nconstruct a new simple attachment key . ", "input": " String SERVICE_SUFFIX \n String GROUP \n String AUTHENTICATION \n Class<T> valueClass \n String AUTHORIZATION \n String USER \n\n T getAttachment \n void clear \n void clear \n int count \n ServiceBuilder<?> addDependency \n boolean matches \n void clearAll \n int getCurrentSize \n ServiceName createServiceName \n T cast \n SearchResult<R> search \n boolean contains \n R getResult \n T detach \n T attach", "output": "AttachmentKey < T > function ( final Class < ? super T > arg0 ) { return new AttachmentKey ( arg0 ) ; }"}, {"instruction": "Generate java code\nsets an array of extra fields to be written to the tiff image file directory ifd . fields with tags equal to the tag of any automatically generated fields are ignored . no error checking is performed with respect to the validity of the field contents or the appropriateness of the field for the image being encoded . ", "input": " Iterator extraImages \n int compression \n boolean convertJPEGRGBToYCbCr \n JPEGEncodeParam jpegEncodeParam \n int tileWidth \n int COMPRESSION_JPEG_BROKEN \n int COMPRESSION_JPEG_TTN2 \n int COMPRESSION_GROUP3_1D \n int COMPRESSION_GROUP3_2D \n int COMPRESSION_NONE \n int COMPRESSION_LZW \n int COMPRESSION_PACKBITS \n boolean writeTiled \n int COMPRESSION_DEFLATE \n int deflateLevel \n int COMPRESSION_GROUP4 \n int tileHeight \n TIFFField[] extraFields \n\n int getCompression \n int getTileHeight \n void setExtraImages \n int getTileWidth \n void setDeflateLevel \n void setWriteTiled \n boolean getJPEGCompressRGBToYCbCr \n void setJPEGEncodeParam \n void setCompression \n Iterator getExtraImages \n JPEGEncodeParam getJPEGEncodeParam \n void setTileSize \n boolean getWriteTiled \n void setJPEGCompressRGBToYCbCr \n int getDeflateLevel \n TIFFField[] getExtraFields", "output": "void function ( TIFFField [ ] arg0 ) { this . extraFields = arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the originalterminmonths property . ", "input": " CodeAndDescription reason \n Integer durationInMonths \n String associatedDealer \n String contractType \n XMLGregorianCalendar commitEndDate \n Long contractId \n String etfContractType \n long serialVersionUID \n XMLGregorianCalendar effectiveDate \n XMLGregorianCalendar commitStartDate \n Integer originalTermInMonths \n\n CodeAndDescription getReason \n void setCommitStartDate \n XMLGregorianCalendar getCommitEndDate \n Integer getDurationInMonths \n void setDurationInMonths \n XMLGregorianCalendar getCommitStartDate \n void setContractType \n void setOriginalTermInMonths \n String getEtfContractType \n void setEffectiveDate \n void setEtfContractType \n XMLGregorianCalendar getEffectiveDate \n void setContractId \n Long getContractId \n void setReason \n String getAssociatedDealer \n void setCommitEndDate \n String getContractType \n void setAssociatedDealer", "output": "Integer function ( ) { return originalTermInMonths ; }"}, {"instruction": "Generate java code\ndrops the given role using the sentry service and updates the impala catalog . if the rpc to the sentry service fails the impala catalog will not be modified . returns the removed role or null if the role did not exist in the catalog . throws exception if there was any error updating the sentry service . ", "input": " User processUser_ \n SentryPolicyService sentryPolicyService_ \n Logger LOG \n ScheduledExecutorService policyReader_ \n CatalogServiceCatalog catalog_ \n\n RolePrivilege revokeRolePrivilege \n Role createRole \n void refresh \n void run \n Role grantRoleGroup \n Role revokeRoleGroup \n RolePrivilege grantRolePrivilege \n void checkUserSentryAdmin", "output": "Role function ( User arg0 , String arg1 ) { sentryPolicyService_ . dropRole ( arg0 , arg1 , false ) ; return catalog_ . removeRole ( arg1 ) ; }"}, {"instruction": "Generate java code\ngets the hud component 's frame window ", "input": " HUDComponent component \n HUDView2D view \n Logger logger \n int zorder \n HUDImageComponent icon \n HUDView3D worldView \n Window2D frameWindow \n HUDComponentVisualState state \n Window2D window \n HUDView2D frameView \n boolean decorated \n HUDFrameHeader2D frame \n\n Window2D getWindow \n boolean isWorldVisible \n HUDFrameHeader2D getFrame \n void setWindow \n void setComponent \n boolean isVisible \n void setDecorated \n HUDImageComponent getIcon \n void setFrameView \n HUDView2D getFrameView \n void setIcon \n HUDComponentVisualState getState \n void setFrame \n void setView \n void setFrameWindow \n void setState \n HUDView3D getWorldView \n HUDComponent getComponent \n void setWorldView \n boolean isDecorated \n void setZOrder \n HUDView2D getView \n int getZOrder", "output": "Window2D function ( ) { return frameWindow ; }"}, {"instruction": "Generate java code\ngetter for prioritycalled . ", "input": " B bean \n int order \n\n void setOrder \n int hashCode \n boolean equals \n void setBean \n int compareTo \n B getBean", "output": "int function ( ) { return this . order ; }"}, {"instruction": "Generate java code\ncallback for remaining command line arguments after either #handle string , string or #handleunknown string return `` false '' . this will be called at the end of parsing evenwhen there are no remaining arguments . ", "input": " String DRIVER_JAVA_OPTIONS \n String DRIVER_LIBRARY_PATH \n String DRIVER_CORES \n String NUM_EXECUTORS \n String EXECUTOR_CORES \n String PY_FILES \n String PROXY_USER \n String VERBOSE \n String FILES \n String ARCHIVES \n String[][] switches \n String CONF \n String NAME \n String DEPLOY_MODE \n String CLASS \n String QUEUE \n String[][] opts \n String VERSION \n String JARS \n String EXECUTOR_MEMORY \n String KILL_SUBMISSION \n String DRIVER_CLASS_PATH \n String TOTAL_EXECUTOR_CORES \n String REPOSITORIES \n String HELP \n String MASTER \n String PACKAGES \n String STATUS \n String SUPERVISE \n String PROPERTIES_FILE \n String DRIVER_MEMORY \n\n String findCliOption \n boolean handleUnknown \n boolean handle \n void parse", "output": "void function ( List < String > arg0 ) { throw new UnsupportedOperationException ( ) ; }"}, {"instruction": "Generate java code\nthis method sets the patronid attribute of the object ", "input": " String MediaId \n Date cancelled_date \n Date reserved_date \n int cancellationId \n String PatronId \n\n void setCancellationId \n void setReserved_date \n Date getCancelled_date \n Date getReserved_date \n void setCancelled_date \n boolean equals \n String getPatronId \n String getMediaId \n String toString \n void setMediaId \n int getCancellationId", "output": "void function ( String arg0 ) { this . PatronId = arg0 ; }"}, {"instruction": "Generate java code\ngets the total number of mp3 sounds in the file . ", "input": " String magic \n NXFile file \n long stringCount \n long bitmapOffset \n String MAGIC \n long nodeOffset \n long soundOffset \n long stringOffset \n long soundCount \n long nodeCount \n long bitmapCount \n\n long getSoundOffset \n long getNodeCount \n long getNodeOffset \n long getStringCount \n long getBitmapOffset \n long getStringOffset \n NXFile getFile \n long getBitmapCount", "output": "long function ( ) { return soundCount ; }"}, {"instruction": "Generate java code\nreturn the underlying providers being used . ", "input": " int CACHE_LIMIT \n Map<String,TemplateAvailabilityProvider> cache \n TemplateAvailabilityProvider NONE \n Map<String,TemplateAvailabilityProvider> resolved \n List<TemplateAvailabilityProvider> providers \n\n boolean removeEldestEntry \n TemplateAvailabilityProvider findProvider \n boolean isTemplateAvailable \n TemplateAvailabilityProvider getProvider \n TemplateAvailabilityProvider getProvider", "output": "List < TemplateAvailabilityProvider > function ( ) { return this . providers ; }"}, {"instruction": "Generate java code\nloads the list of available templates onto the alltemplates list ", "input": " File sketchbookPath \n Editor editor \n File templatesFolder \n String defaultTemplate \n String fs \n File dataFolder \n ArrayList<File> allTemplates \n\n void init \n String loadString \n String getPath \n File loadFile \n void run \n void installDefaultTemplate \n void initialize \n String getMenuTitle \n void initTemplatesRoot \n void createTemplatesFolder \n void offerMenu", "output": "void function ( ) { String loc0 ; File [ ] loc1 = templatesFolder . listFiles ( ) ; for ( int loc2 = 0 ; loc2 < loc1 . length ; loc2 ++ ) { loc0 = loc1 [ loc2 ] . getAbsolutePath ( ) ; if ( loc0 . endsWith ( \"srini_string\" ) || loc0 . endsWith ( \"srini_string\" ) ) { allTemplates . add ( new File ( loc0 ) ) ; } } }"}, {"instruction": "Generate java code\nset the name ", "input": " int imageID \n int cost \n int level \n String description \n int viewRadius \n boolean enabled \n String picPath \n int defense \n String name \n int x \n int y \n int maxHealth \n int id \n int curHealth \n\n void setImageID \n int getMaxHealth \n void setY \n String getName \n void setX \n int getImageID \n void setCost \n int getId \n int getCurrentHealth \n void adjustDefense \n void setDes \n String getDes \n void create \n String getPic \n void adjustLevel \n int getDefense \n void setStats \n void adjustViewRadius \n int getLevel \n int getX \n void enableDisable \n int getY \n void adjustCurrentHealth \n void adjustMaxHealth \n int getViewRadius \n boolean isEnabled \n int getCost", "output": "void function ( String arg0 ) { this . name = arg0 ; }"}, {"instruction": "Generate java code\nadd an actual request header to allow . ", "input": " List<String> allowedOrigins \n Long maxAge \n List<String> exposedHeaders \n List<String> allowedHeaders \n List<String> allowedMethods \n String ALL \n Boolean allowCredentials \n\n List<String> getExposedHeaders \n void setExposedHeaders \n void setMaxAge \n List<String> getAllowedHeaders \n List<String> getAllowedMethods \n Boolean getAllowCredentials \n void addAllowedOrigin \n void addAllowedMethod \n void addAllowedMethod \n void setAllowedHeaders \n String checkOrigin \n List<String> getAllowedOrigins \n void setAllowedMethods \n Long getMaxAge \n void setAllowCredentials \n List<HttpMethod> checkHttpMethod \n List<String> checkHeaders \n void setAllowedOrigins \n void addExposedHeader \n CorsConfiguration combine \n List<String> combine", "output": "void function ( String arg0 ) { if ( this . allowedHeaders == null ) { this . allowedHeaders = new ArrayList < > ( ) ; } this . allowedHeaders . add ( arg0 ) ; }"}, {"instruction": "Generate java code\nconvert a value given in meters to a value of this unit ", "input": " DistanceUnit unit \n String[] names \n double value \n DistanceUnit DEFAULT \n double meters \n\n double getEarthCircumference \n double toMeters \n void writeDistanceUnit \n double getEarthRadius \n DistanceUnit parseUnit \n double convert \n double convert \n Distance convert \n double parse \n double parse \n int compareTo \n Distance parseDistance \n Distance parseDistance \n DistanceUnit readDistanceUnit \n int hashCode \n boolean equals \n String toString \n String toString \n String toString \n DistanceUnit fromString \n double getDistancePerDegree", "output": "double function ( double arg0 ) { return convert ( arg0 , DistanceUnit . METERS , this ) ; }"}, {"instruction": "Generate java code\nobtain a new instance of dbxclient and store it in configuration . ", "input": " String remotePath \n String query \n String clientIdentifier \n String localPath \n String newRemotePath \n DbxClient client \n DropboxUploadMode uploadMode \n String accessToken \n DropboxOperation operation \n\n void setNewRemotePath \n String getClientIdentifier \n void setUploadMode \n void setAccessToken \n void setLocalPath \n String getNewRemotePath \n DbxClient getClient \n String getRemotePath \n String getAccessToken \n String getLocalPath \n void setClient \n void setRemotePath \n DropboxOperation getOperation \n void setOperation \n DropboxUploadMode getUploadMode \n void setQuery \n String getQuery \n void setClientIdentifier", "output": "void function ( ) { DbxRequestConfig loc0 = new DbxRequestConfig ( clientIdentifier , Locale . getDefault ( ) . toString ( ) ) ; DbxClient loc1 = new DbxClient ( loc0 , accessToken ) ; this . client = loc1 ; }"}, {"instruction": "Generate java code\nset the minimum value of this axis . either a date or numeral . if null , interpreted on the client from the x/y values of the series or from the explicit ticks given . ", "input": " Boolean sortMergedLabels \n Boolean forceTickAt0 \n Object max \n String[] ticks \n Boolean show \n String label \n Boolean autoscale \n AxisType type \n Integer tickAngle \n Double pad \n Object min \n Double padMax \n Boolean forceTickAt100 \n Double padMin \n String tickFontSize \n\n Boolean getAutoscale \n void setTickFontSize \n String getLabel \n Boolean isSortMergedLabels \n Object getDoubleIfPossible \n String getTickFontSize \n void setSortMergedLabels \n void setTicks \n Double getPadMin \n void setPad \n Object getMin \n Double getPad \n void setForceTickAt0 \n void setMax \n void setAutoscale \n void setForceTickAt100 \n void setPadMax \n boolean hasRendererOptionsSet \n Object getMax \n void setType \n void setShow \n Boolean isForceTickAt0 \n String[] getTicks \n void setPadMin \n void setTickAngle \n void encodeTickOptions \n Integer getTickAngle \n AxisType getType \n Boolean getShow \n Boolean isForceTickAt100 \n void setLabel \n String toString \n void encodeTicks \n Double getPadMax \n boolean hasTickOptionsSet", "output": "void function ( String arg0 ) { this . min = arg0 ; }"}, {"instruction": "Generate java code\nroot , does n't match , but children on various levels do . a / \\ b c 1 / \\ \\ d 2 e f 3 ", "input": " int NO_MATCH \n int id \n int MATCH \n Predicate<View> FIND_MATCH \n\n ViewGroup mockViewGroup \n void itFindsTheRoot \n boolean apply \n void itFindsNothingIfNoNodeMatches \n ViewGroup match \n ViewGroup ignore \n AbstractNativeElementContext mockContext \n void assertFoundViews \n List<View> searchViews", "output": "void function ( ) { ViewGroup loc0 = match ( ) ; ViewGroup loc1 = ignore ( ) ; ViewGroup loc2 = match ( ) ; ViewGroup loc3 = ignore ( loc0 , loc1 ) ; ViewGroup loc4 = match ( loc2 ) ; ViewGroup loc5 = ignore ( loc3 , loc4 ) ; List < View > loc6 = searchViews ( loc5 ) ; assertFoundViews ( loc6 , loc4 , loc0 , loc2 ) ; }"}, {"instruction": "Generate java code\nreturns the class names of modules involved in creating this element . the first element index 0 is the class name of module that defined the element , and the last element is the class name of root module . ", "input": " ElementSource originalElementSource \n ModuleSource moduleSource \n Object declaringSource \n InMemoryStackTraceElement[] partialCallStack \n\n StackTraceElement[] getStackTrace \n Object getDeclaringSource \n String toString \n List<Integer> getModuleConfigurePositionsInStackTrace \n ElementSource getOriginalElementSource", "output": "List < String > function ( ) { return moduleSource . getModuleClassNames ( ) ; }"}, {"instruction": "Generate java code\nno-op in this case ", "input": " EhcacheHibernate ehcacheHibernate \n ObjectName cacheManagerObjectName \n String cacheManagerClusterUUID \n Status status \n int MAX_MBEAN_REGISTRATION_RETRIES \n EhCacheMessageLogger LOG \n String registeredCacheManagerName \n\n MBeanServer getMBeanServer \n void init \n void dispose \n void notifyCacheAdded \n Status getStatus \n void registerBean \n void enableHibernateStatisticsSupport \n void registerMBeanForCacheManager", "output": "void function ( String arg0 ) { }"}, {"instruction": "Generate java code\nget arraylist of posts ", "input": " String exception \n int itemid \n String item \n String warningcode \n ArrayList<MoodlePostWarning> warnings \n String debuginfo \n String message \n ArrayList<MoodlePost> posts \n String errorcode \n\n int getItemid \n String getWarningcode \n String getException \n ArrayList<MoodlePostWarning> getWarnings \n String getErrorcode \n String getMessage \n String getMessage \n String getItem \n String getDebuginfo", "output": "ArrayList < MoodlePost > function ( ) { return posts ; }"}, {"instruction": "Generate java code\ngets current project name . ", "input": " String FILE_SUFFIX \n boolean USE_VERSIONING \n\n IResource getSpecificResourceInPerlProject \n String getJobFileName \n String getJobFileName \n String getContextFileName \n String getRootProjectName \n String getRootProjectName \n String getRootProjectName \n String escapeSpace", "output": "String function ( ) { ProjectManager loc0 = ProjectManager . getInstance ( ) ; Project loc1 = loc0 . getCurrentProject ( ) ; return loc1 . getTechnicalLabel ( ) ; }"}, {"instruction": "Generate java code\nreturns the session associated with the username . ", "input": " String RESOURCE_NAME \n Log log \n SessionManager instance \n String serverName \n AtomicInteger connectionsCounter \n Map<String,ClientSession> clientSessions \n Map<String,Set<String>> tagUsernameMap \n Map<String,ClientSession> preAuthSessions \n Map<String,String> aliasUsernameMap \n ClientSessionListener clientSessionListener \n\n boolean removeSession \n ClientSession createClientSession \n void onConnectionClose \n Set<String> getUsernameSet \n void addSession \n Collection<ClientSession> getSessions \n void closeAllSessions \n String getUsernameByAlias \n void setTag \n SessionManager getInstance \n void setAlias", "output": "ClientSession function ( String arg0 ) { return getSession ( new JID ( arg0 , serverName , RESOURCE_NAME , true ) ) ; }"}, {"instruction": "Generate java code\nregister a new action type for event recording , lookups , etc. . ", "input": " TreeMap<String,ActionType> registeredActions \n\n ArrayList<ActionType> getActionsByShortname \n ArrayList<String> listActionsThatAllowRollback \n ActionType getAction \n String[] listAll \n ArrayList<String> listActionsThatAllowRestore \n void registerCustomAction \n TreeMap<String,ActionType> getRegisteredAction \n void registerPrismDefaultActions", "output": "void function ( ActionType arg0 ) { registeredActions . put ( arg0 . getName ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\ngets the cantidaddevolver value for this listalegislaturaswsexecute . ", "input": " java.lang.Object __equalsCalc \n boolean __hashCodeCalc \n org.apache.axis.description.TypeDesc typeDesc \n short cantidaddevolver \n int lgl_nro \n\n void setCantidaddevolver \n org.apache.axis.description.TypeDesc getTypeDesc \n org.apache.axis.encoding.Serializer getSerializer \n org.apache.axis.encoding.Deserializer getDeserializer \n int hashCode \n int getLgl_nro \n boolean equals \n void setLgl_nro", "output": "short function ( ) { return cantidaddevolver ; }"}, {"instruction": "Generate java code\nsubtracts the provided tuiotime from the private seconds and microseconds attributes . ", "input": " long start_seconds \n long seconds \n long frame_id \n long micro_seconds \n long start_micro_seconds \n\n TuioTime add \n TuioTime add \n TuioTime getSystemTime \n long getMicroseconds \n TuioTime getSessionTime \n long getSeconds \n long getTotalMilliseconds \n boolean equals \n void initSession \n long getFrameID \n void reset \n void setFrameID \n TuioTime getStartTime", "output": "TuioTime function ( TuioTime arg0 ) { long loc0 = seconds - arg0 . getSeconds ( ) ; long loc1 = micro_seconds - arg0 . getMicroseconds ( ) ; if ( loc1 < 0 ) { loc1 += 1000000 ; loc0 -- ; } return new TuioTime ( loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\ngets the number of detected errors . ", "input": " List<TestFailure> fErrors \n List<TestFailure> fFailures \n List<TestListener> fListeners \n boolean fStop \n int fRunTests \n\n void addError \n void startTest \n Enumeration<TestFailure> failures \n boolean wasSuccessful \n void run \n void removeListener \n boolean shouldStop \n void addFailure \n void stop \n List<TestListener> cloneListeners \n int runCount \n void endTest \n Enumeration<TestFailure> errors \n int failureCount \n void addListener \n void runProtected", "output": "int function ( ) { return fErrors . size ( ) ; }"}, {"instruction": "Generate java code\nread a list of keyvalue from the input stream - may contain regular keyvalue s or indexedkeyvalue s. ", "input": " int INDEX_TYPE_LENGTH_MARKER \n\n void write \n KeyValue readKeyValue", "output": "List < KeyValue > function ( DataInput arg0 ) { int loc0 = arg0 . readInt ( ) ; if ( loc0 == 0 ) { return Collections . < KeyValue > emptyList ( ) ; } List < KeyValue > loc1 = new ArrayList < KeyValue > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 . add ( readKeyValue ( arg0 ) ) ; } return loc1 ; }"}, {"instruction": "Generate java code\nobtains the type name . see notes on #getjavatype for details ", "input": " String typeName \n Class<X> javaType \n\n Class<X> getJavaType", "output": "String function ( ) { return typeName ; }"}, {"instruction": "Generate java code\ncreates the broker . ", "input": " List<NetworkVm> vmlist \n\n void CreateNetwork \n void main \n NetworkDatacenter createDatacenter \n void printCloudletList", "output": "NetDatacenterBroker function ( ) { NetDatacenterBroker loc0 = null ; try { loc0 = new NetDatacenterBroker ( \"srini_string\" ) ; } catch ( Exception loc1 ) { loc1 . printStackTrace ( ) ; return null ; } return loc0 ; }"}, {"instruction": "Generate java code\ninternal : in event abc : integer in event event1 operation foo operation myopp1 : integer var myint : integer var mybool : boolean var myreal : real var mystring : string ", "input": " ILinker linker \n IParser parser \n Provider<XtextResource> resourceProvider \n\n Scope interfaceScope \n XtextResource getResource \n Scope createInternalScope \n Scope createInterfaceScope \n EObject parseExpression \n EObject parseExpression", "output": "Scope function ( ) { return createInternalScope ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nget the last matched schema if the last match was a schema . ", "input": " int KEYWORD \n DbTableOrView lastMatchedTable \n HashMap<String,DbTableOrView> aliases \n DbTableOrView lastTable \n int FUNCTION \n String query \n String queryUpper \n HashSet<DbTableOrView> tables \n long stopAtNs \n DbSchema lastMatchedSchema \n int CONTEXT \n HashMap<String,String> next \n long MAX_PROCESSING_TIME \n\n void add \n HashMap<String,DbTableOrView> getAliases \n void addAlias \n void start \n void stopIfRequired \n DbTableOrView getLastTable \n HashMap<String,String> getNext \n DbTableOrView getLastMatchedTable \n void setLastMatchedSchema \n HashSet<DbTableOrView> getTables \n void setLastMatchedTable \n void setQuery \n String getQueryUpper \n void addTable \n String getQuery", "output": "DbSchema function ( ) { return lastMatchedSchema ; }"}, {"instruction": "Generate java code\nset the resourceadapter for the resourcestore , such as the fileresourceadapter or bytearrayresourceadapter default . ", "input": " JdbcTemplate jdbcTemplate \n ResourceAdapter resourceAdapter \n Log LOG \n LobHandler lobHandler \n String tableName \n SimpleJdbcInsert insertResource \n\n void add \n void setTableName \n MapSqlParameterSource createResourceParameterSource \n ByteArrayResource get \n ByteArrayResource get \n void clear \n void handleInputStream \n void setDataSource \n Resource[] handleRequest \n void remove \n void remove \n void remove \n void setLobHandler", "output": "void function ( ResourceAdapter arg0 ) { this . resourceAdapter = arg0 ; }"}, {"instruction": "Generate java code\nset the ifmodifiedsince value . ", "input": " DateTimeRfc1123 ocpDate \n String clientRequestId \n DateTimeRfc1123 ifUnmodifiedSince \n Boolean returnClientRequestId \n DateTimeRfc1123 ifModifiedSince \n Integer timeout \n String ifNoneMatch \n String ifMatch \n\n JobScheduleDeleteOptions withIfNoneMatch \n DateTime ocpDate \n String clientRequestId \n DateTime ifUnmodifiedSince \n JobScheduleDeleteOptions withTimeout \n JobScheduleDeleteOptions withClientRequestId \n JobScheduleDeleteOptions withIfMatch \n DateTime ifModifiedSince \n Integer timeout \n String ifNoneMatch \n String ifMatch \n JobScheduleDeleteOptions withReturnClientRequestId \n JobScheduleDeleteOptions withOcpDate \n Boolean returnClientRequestId \n JobScheduleDeleteOptions withIfUnmodifiedSince", "output": "JobScheduleDeleteOptions function ( DateTime arg0 ) { if ( arg0 == null ) { this . ifModifiedSince = null ; } else { this . ifModifiedSince = new DateTimeRfc1123 ( arg0 ) ; } return this ; }"}, {"instruction": "Generate java code\nreturns the servletcontext to be injected or null . this method can be overridden by subclasses when a context is obtained after the post-processor has been registered . ", "input": " ServletContext servletContext \n ServletConfig servletConfig \n\n ServletContext getServletContext \n Object postProcessBeforeInitialization \n Object postProcessAfterInitialization", "output": "ServletConfig function ( ) { return this . servletConfig ; }"}, {"instruction": "Generate java code\ngets the value of the actualdeliverypercentage property . ", "input": " Double actualDeliveryPercentage \n Double expectedDeliveryPercentage \n\n void setExpectedDeliveryPercentage \n Double getExpectedDeliveryPercentage \n void setActualDeliveryPercentage", "output": "Double function ( ) { return actualDeliveryPercentage ; }"}, {"instruction": "Generate java code\nget the unique id for this item . ", "input": " UUID m_guid \n byte[] m_unknown \n String m_description \n Integer m_parentId \n Integer m_uniqueID \n Object m_value \n\n UUID getGuid \n Object getValue \n void setGuid \n Integer getParent \n byte[] getUnknown \n void setValue \n String toString \n void setDescription \n void setParent \n void setUnknown \n String getDescription", "output": "Integer function ( ) { return m_uniqueID ; }"}, {"instruction": "Generate java code\nwhen nimbusdaemon is true , the local cluster will be started with a nimbus thrift server , allowing communication through for example org.apache.storm.utils.nimbusclient ", "input": " Boolean nimbusDaemon \n Integer portsPerSupervisor \n Map daemonConf \n Integer supervisors \n\n Boolean isNimbusDaemon \n void setDaemonConf \n void setSupervisors \n Integer getPortsPerSupervisor \n void setPortsPerSupervisor \n Map getDaemonConf \n Integer getSupervisors", "output": "void function ( Boolean arg0 ) { this . nimbusDaemon = arg0 ; }"}, {"instruction": "Generate java code\ncheck whether the given name points back to the given alias as an alias in the other direction already , catching a circular reference upfront and throwing a corresponding illegalstateexception . ", "input": " Map<String,String> aliasMap \n\n void registerAlias \n String[] getAliases \n boolean isAlias \n boolean allowAliasOverriding \n void removeAlias \n boolean hasAlias \n void retrieveAliases \n void resolveAliases \n String canonicalName", "output": "void function ( String arg0 , String arg1 ) { if ( hasAlias ( arg1 , arg0 ) ) { throw new IllegalStateException ( \"srini_string\" + arg1 + \"srini_string\" + arg0 + \"srini_string\" + arg0 + \"srini_string\" + arg1 + \"srini_string\" ) ; } }"}, {"instruction": "Generate java code\nthis function fills a rectangle with a vertical gradient . this implementation does not use the gradient mechanism based on background patterns since they do not work stable on all systems . ", "input": " PlaceHolder placeHolder \n\n void fillVerticalGradientRoundedRectangle \n Color mixColor", "output": "void function ( Graphics arg0 , Rectangle arg1 , Color arg2 , Color arg3 ) { arg0 . pushState ( ) ; arg0 . setForegroundColor ( arg3 ) ; arg0 . setBackgroundColor ( arg2 ) ; arg0 . fillGradient ( arg1 . x , arg1 . y , arg1 . width , arg1 . height , true ) ; arg0 . popState ( ) ; }"}, {"instruction": "Generate java code\nretrieve the initial known set of grammars . this method is called by a validator before the validation starts . the application can provide an initial set of grammars available to the current validation attempt . ", "input": " XMLGrammarPool pool \n Logger logger \n\n void unlockPool \n void clear \n void cacheGrammars \n void lockPool \n void clearDTDs \n Grammar retrieveGrammar", "output": "Grammar [ ] function ( String arg0 ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"srini_string\" + arg0 + \"srini_string\" ) ; } final Grammar [ ] loc0 = pool . retrieveInitialGrammarSet ( arg0 ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"srini_string\" + loc0 . length + \"srini_string\" ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nreturns the maximum record length for identifying a record . ", "input": " int minMatchLength \n int minLength \n int maxMatchLength \n int maxLength \n\n void setMinMatchLength \n int getMaxLength \n void setMinLength \n int getMinMatchLength \n String toString \n boolean matches \n void setMaxLength \n int getMinLength \n void setMaxMatchLength \n void validate", "output": "int function ( ) { return maxMatchLength ; }"}, {"instruction": "Generate java code\nsets the id . ", "input": " Logger log \n Integer dlistId \n long serialVersionUID \n PBKey pbKey \n Integer id \n Identity oid \n int position \n Object realSubject \n\n void prepareRealSubject \n Integer getDlistId \n void beforeUpdate \n void beforeInsert \n Logger getLog \n Integer getId \n void setOid \n void afterInsert \n void afterUpdate \n void setDlistId \n void setPosition \n Object getRealSubject \n PBKey getPBKey \n void setRealSubject \n void afterDelete \n int getPosition \n void prepareForPersistency \n String toString \n void beforeDelete \n Identity getOid \n void afterLookup \n TransactionImpl getTransaction", "output": "void function ( Integer arg0 ) { this . id = arg0 ; }"}, {"instruction": "Generate java code\ncreate an instance of section ", "input": " PlaceHolder placeHolder \n\n Data createData \n Correlation createCorrelation \n Surveys createSurveys \n Answer createAnswer \n Templates createTemplates \n Question createQuestion \n Template createTemplate \n Survey createSurvey", "output": "Section function ( ) { return new Section ( ) ; }"}, {"instruction": "Generate java code\ngets the value of the signaturepolicyid property . ", "input": " SignaturePolicyIdentifierType.SignaturePolicyImplied signaturePolicyImplied \n SignaturePolicyIdType signaturePolicyId \n\n void setSignaturePolicyId \n void setSignaturePolicyImplied \n SignaturePolicyIdentifierType.SignaturePolicyImplied getSignaturePolicyImplied", "output": "SignaturePolicyIdType function ( ) { return signaturePolicyId ; }"}, {"instruction": "Generate java code\ncreates a inmemorybodywritable from a byte array . ", "input": " PlaceHolder placeHolder \n\n placeholderType placeHolder", "output": "BodyWritable < ByteString > function ( byte [ ] arg0 , String arg1 ) { return new InMemoryBodyWritable ( ByteString . fromArray ( arg0 ) , arg1 ) ; }"}, {"instruction": "Generate java code\nprocess a single chunk ", "input": " TProcessor processor_ \n TProtocolFactory inputProtocolFactory_ \n TFileTransport inputTransport_ \n TProtocolFactory outputProtocolFactory_ \n TTransport outputTransport_ \n\n void processUntil", "output": "void function ( int arg0 ) { processChunk ( arg0 , arg0 ) ; }"}, {"instruction": "Generate java code\nsets the value of the d property . ", "input": " JAXBElement<XMLGregorianCalendar> d \n\n JAXBElement<XMLGregorianCalendar> getD", "output": "void function ( JAXBElement < XMLGregorianCalendar > arg0 ) { this . d = arg0 ; }"}, {"instruction": "Generate java code\nget the url value . ", "input": " Period kernelCPUTime \n Period wallClockTime \n double writeIOGiB \n DateTime startTime \n long readIOps \n Period waitTime \n String url \n Period userCPUTime \n double readIOGiB \n DateTime lastUpdateTime \n long writeIOps \n\n Period kernelCPUTime \n TaskStatistics withLastUpdateTime \n TaskStatistics withWaitTime \n TaskStatistics withUserCPUTime \n TaskStatistics withStartTime \n TaskStatistics withUrl \n Period userCPUTime \n long writeIOps \n TaskStatistics withReadIOps \n Period wallClockTime \n double writeIOGiB \n TaskStatistics withReadIOGiB \n TaskStatistics withWriteIOps \n DateTime startTime \n long readIOps \n TaskStatistics withKernelCPUTime \n Period waitTime \n TaskStatistics withWallClockTime \n double readIOGiB \n DateTime lastUpdateTime \n TaskStatistics withWriteIOGiB", "output": "String function ( ) { return this . url ; }"}, {"instruction": "Generate java code\nis gitblit running in debug mode ? ", "input": " IStoredSettings settings \n ServerStatus serverStatus \n Logger logger \n XssFilter xssFilter \n File baseFolder \n TimeZone timezone \n ServerSettings settingsModel \n Injector injector \n\n IStoredSettings getSettings \n RuntimeManager start \n Injector getInjector \n void logTimezone \n File getFileOrFolder \n File getFileOrFolder \n boolean updateSettings \n ServerStatus getStatus \n ServerSettings getSettingsModel \n void setBaseFolder \n RuntimeManager stop \n TimeZone getTimezone \n Date getBootDate \n XssFilter getXssFilter \n Locale getLocale \n File getBaseFolder", "output": "boolean function ( ) { return settings . getBoolean ( Keys . web . debugMode , false ) ; }"}, {"instruction": "Generate java code\ncalled by the system when the user grants permissions ", "input": " Activity activity \n CordovaPlugin permissionResultCallback \n int resultCode \n int activityResultRequestCode \n Intent intent \n Bundle savedPluginState \n String TAG \n PluginManager pluginManager \n CordovaPlugin activityResultCallback \n String initCallbackService \n ActivityResultHolder savedResult \n boolean activityWasDestroyed \n int requestCode \n ExecutorService threadPool \n\n void setActivityResultRequestCode \n ExecutorService getThreadPool \n void restoreInstanceState \n void requestPermission \n void onCordovaInit \n Activity getActivity \n void setActivityResultCallback \n void requestPermissions \n boolean onActivityResult \n void startActivityForResult \n boolean hasPermission \n Object onMessage \n void onSaveInstanceState", "output": "void function ( int arg0 , String [ ] arg1 , int [ ] arg2 ) { if ( permissionResultCallback != null ) { permissionResultCallback . onRequestPermissionResult ( arg0 , arg1 , arg2 ) ; permissionResultCallback = null ; } }"}, {"instruction": "Generate java code\ngets the value of the title property . ", "input": " String role \n String arcrole \n MDKeywordsType mdKeywords \n String show \n String actuate \n List<String> nilReason \n String href \n String type \n String title \n String uuidref \n\n String getHref \n void setMDKeywords \n List<String> getNilReason \n void setUuidref \n String getUuidref \n void setHref \n String getRole \n String getArcrole \n void setTitle \n void setActuate \n void setArcrole \n MDKeywordsType getMDKeywords \n String getActuate \n void setType \n void setShow \n String getType \n String getShow \n void setRole", "output": "String function ( ) { return title ; }"}, {"instruction": "Generate java code\ngets the value of the arcrole property . ", "input": " String role \n String arcrole \n MICoverageDescriptionType miCoverageDescription \n String show \n String actuate \n List<String> nilReason \n String href \n String type \n String title \n String uuidref \n\n String getHref \n List<String> getNilReason \n void setUuidref \n String getUuidref \n void setHref \n String getRole \n void setTitle \n void setActuate \n void setArcrole \n String getActuate \n void setType \n MICoverageDescriptionType getMICoverageDescription \n void setShow \n String getTitle \n void setMICoverageDescription \n String getType \n String getShow \n void setRole", "output": "String function ( ) { return arcrole ; }"}, {"instruction": "Generate java code\nwhether the flags specify `` binary '' mode for reads and writes . ", "input": " int RDWR \n int BINARY \n int WRONLY \n int TRUNC \n int CREAT \n int APPEND \n int flags \n int NONBLOCK \n int RDONLY \n int ACCMODE \n int EXCL \n\n boolean isExclusive \n int getOpenFileFlags \n boolean isAppendable \n boolean isReadOnly \n boolean isCreate \n boolean isSubsetOf \n boolean isTruncate \n String toString \n boolean isWritable \n boolean isReadable \n String toJavaModeString", "output": "boolean function ( ) { return ( flags & BINARY ) != 0 ; }"}, {"instruction": "Generate java code\ninitializes a clientfactory which runs the given transportclientbootstraps prior to returning a new client . bootstraps will be executed synchronously , and must run successfully in order to create a client . ", "input": " boolean closeIdleConnections \n Logger logger \n RpcHandler rpcHandler \n TransportConf conf \n MessageDecoder decoder \n MessageEncoder encoder \n\n TransportConf getConf \n TransportChannelHandler createChannelHandler \n TransportServer createServer \n TransportServer createServer \n TransportServer createServer \n TransportServer createServer \n TransportChannelHandler initializePipeline \n TransportChannelHandler initializePipeline", "output": "TransportClientFactory function ( List < TransportClientBootstrap > arg0 ) { return new TransportClientFactory ( this , arg0 ) ; }"}, {"instruction": "Generate java code\nperforms the graph traversion with a single root element . so this root element and all elements which are reachable from this root elements will be visited . ", "input": " int linkCount \n Map myVisitedElements \n Iterator myElements \n boolean done \n\n boolean isVisited \n void beginVisit \n Iterator getElementLinks \n void endVisit \n void setVisited \n int visit \n int getVisitedDepth", "output": "void function ( Object arg0 ) { List loc0 = new ArrayList ( ) ; loc0 . add ( arg0 ) ; this . perform ( loc0 . iterator ( ) ) ; }"}, {"instruction": "Generate java code\ndetermines whether this object includes the supplied error . ", "input": " String mUrl \n int SSL_INVALID \n int SSL_IDMISMATCH \n int SSL_MAX_ERROR \n SslCertificate mCertificate \n int SSL_UNTRUSTED \n int mErrors \n int SSL_DATE_INVALID \n int SSL_EXPIRED \n int SSL_NOTYETVALID \n\n boolean addError \n String getUrl \n SslCertificate getCertificate \n int getPrimaryError \n SslError SslErrorFromChromiumErrorCode \n String toString", "output": "boolean function ( int arg0 ) { boolean loc0 = ( 0 <= arg0 && arg0 < SslError . SSL_MAX_ERROR ) ; if ( loc0 ) { loc0 = ( ( mErrors & ( 0x1 << arg0 ) ) != 0 ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nthis scanner is working solely on the in-memory memstore therefore this interface is not relevant . ", "input": " Cell last \n boolean stopSkippingKVsIfNextRow \n long readPoint \n long scannerOrder \n Segment segment \n Cell current \n Iterator<Cell> iter \n long DEFAULT_SCANNER_ORDER \n\n Cell next \n boolean realSeekDone \n boolean reseek \n void enforceSeek \n boolean seekToPreviousRow \n Cell getNext \n Segment getSegment \n boolean seek \n Cell peek \n boolean isFileScanner \n Cell getHighest \n boolean seekToLastRow \n boolean shouldSeek \n void shipped \n Cell getNextIndexedKey \n boolean backwardSeek \n String toString \n long getScannerOrder \n void close \n boolean shouldUseScanner", "output": "boolean function ( Cell arg0 , boolean arg1 , boolean arg2 ) { throw new IllegalStateException ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\nreturn the high address as a dotted ip address . will be zero for cidr/31 and cidr/32 if the inclusive flag is false . ", "input": " int netmask \n int network \n Pattern addressPattern \n String SLASH_FORMAT \n int NBITS \n int address \n boolean inclusiveHostCount \n int broadcast \n String IP_ADDRESS \n Pattern cidrPattern \n\n int broadcast \n String toCidrNotation \n boolean isInRange \n boolean isInRange \n void setInclusiveHostCount \n int network \n String getCidrSignature \n int pop \n int toInteger \n int high \n String getLowAddress \n int netmask \n int low \n int getAddressCount \n int[] toArray \n String getAddress \n void calculate \n String getBroadcastAddress \n boolean isInclusiveHostCount \n int address \n SubnetInfo getInfo \n String format \n int asInteger \n int rangeCheck \n String getNetmask \n String toString \n String[] getAllAddresses \n int matchAddress \n String getNetworkAddress", "output": "String function ( ) { return format ( toArray ( high ( ) ) ) ; }"}, {"instruction": "Generate java code\nwrite ` vre ' file description for each subnetwork . for writing , use a ` vrensubnetwriter ' object for each subnetwork . ", "input": " World world \n boolean forceWorldCreation \n GlobalProperties properties \n boolean verbose \n\n void printVerbose \n void saveWorld \n void updateInfos \n void createVRERooms \n boolean worldExists \n void createWorld \n void createVREMachines \n void main \n void loadWorld \n void execute \n void createRoomsSubnets \n void saveCollecting", "output": "void function ( ) { printVerbose ( \"srini_string\" ) ; for ( Enumeration loc0 = world . getSubnets ( ) . elements ( ) ; loc0 . hasMoreElements ( ) ; ) ( new VRESubnetWriter ( ( Subnet ) loc0 . nextElement ( ) ) ) . write ( ) ; }"}, {"instruction": "Generate java code\nadds a request representing the `` get blob '' operation to this batch . the options can beused in the same way as for storage #get blobid , blobgetoption . calling storagebatchresult #get on the return value yields the requested blob ifsuccessful , null if no such blob exists , or throws a storageexception if theoperation failed . ", "input": " StorageRpc storageRpc \n RpcBatch batch \n StorageOptions options \n\n RpcBatch.Callback<StorageObject> createUpdateCallback \n RpcBatch.Callback<Void> createDeleteCallback \n Object getBatch \n void submit \n StorageBatchResult<Blob> update \n StorageRpc getStorageRpc \n RpcBatch.Callback<StorageObject> createGetCallback \n StorageOptions getOptions \n StorageBatchResult<Boolean> delete \n StorageBatchResult<Boolean> delete", "output": "StorageBatchResult < Blob > function ( String arg0 , String arg1 , BlobGetOption ... arg2 ) { return get ( BlobId . of ( arg0 , arg1 ) , arg2 ) ; }"}, {"instruction": "Generate java code\nreturns the current reference count . ", "input": " AtomicInteger refCount \n T object \n\n void decRef \n void release \n T get \n void incRef", "output": "int function ( ) { return refCount . get ( ) ; }"}, {"instruction": "Generate java code\nconstruct an httpservletrequest credential plugin specified by the drpc storm configuration ", "input": " String LOGIN_CONTEXT_SERVER \n Logger LOG \n String LOGIN_CONTEXT_CLIENT \n String SERVICE \n\n Collection<INimbusCredentialPlugin> getNimbusAutoCredPlugins \n IGroupMappingServiceProvider GetGroupMappingServiceProviderPlugin \n IPrincipalToLocal GetPrincipalToLocalPlugin \n Subject populateSubject \n IHttpCredentialsPlugin GetHttpCredentialsPlugin \n Configuration GetConfiguration \n String get \n Collection<IAutoCredentials> GetAutoCredentials \n ITransportPlugin GetTransportPlugin \n Collection<ICredentialsRenewer> GetCredentialRenewers \n IHttpCredentialsPlugin GetUiHttpCredentialsPlugin \n void updateSubject", "output": "IHttpCredentialsPlugin function ( Map arg0 ) { String loc0 = ( String ) arg0 . get ( Config . DRPC_HTTP_CREDS_PLUGIN ) ; return AuthUtils . GetHttpCredentialsPlugin ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\ncheck whether the given collection contains the given element instance . enforces the given instance to be present , rather than returning true for an equal element as well . ", "input": " Enumeration<E> enumeration \n Map<K,List<V>> map \n\n Iterator<E> toIterator \n E next \n void mergePropertiesIntoMap \n Collection<List<V>> values \n void remove \n List<V> remove \n boolean containsValue \n List<V> put \n MultiValueMap<K,V> unmodifiableMultiValueMap \n V getFirst \n int hashCode \n List<V> get \n void putAll \n A[] toArray \n MultiValueMap<K,V> toMultiValueMap \n void setAll \n Set<K> keySet \n void add \n List arrayToList \n void set \n Set<Entry<K,List<V>>> entrySet \n T findValueOfType \n Object findValueOfType \n boolean containsKey \n boolean isEmpty \n boolean isEmpty \n boolean isEmpty \n boolean containsAny \n boolean hasUniqueObject \n void clear \n boolean hasNext \n Map<K,V> toSingleValueMap \n boolean contains \n boolean contains \n E findFirstMatch \n int size \n boolean equals \n String toString \n Class<?> findCommonElementType \n void mergeArrayIntoCollection", "output": "boolean function ( Collection < ? > arg0 , Object arg1 ) { if ( arg0 != null ) { for ( Object loc0 : arg0 ) { if ( loc0 == arg1 ) { return true ; } } } return false ; }"}, {"instruction": "Generate java code\nsetter method for segmentnamelist ", "input": " String campaignContents \n List<CampaignVO> circleNameList \n boolean editCapability \n int campaignId \n String circleName \n String description \n String campaignName \n boolean viewCapability \n String retailer \n int segmentId \n List<CampaignVO> campaignSearchList \n String createdBy \n int circleId \n List<CampaignVO> segmentNameList \n String segmentName \n String endDate \n String startDate \n String status \n\n String getCampaignContents \n List<CampaignVO> getCircleNameList \n String getStartDate \n boolean isViewCapability \n List<CampaignVO> getSegmentNameList \n String getCampaignName \n int getCircleId \n String getEndDate \n void setDescription \n String getStatus \n String getDescription \n void setEndDate \n void setCircleId \n void setEditCapability \n void setCircleName \n String getRetailer \n void setSegmentId \n void setViewCapability \n void setRetailer \n void setCampaignId \n void setCircleNameList \n int getSegmentId \n void setStartDate \n int getCampaignId \n void setStatus \n String getSegmentName \n void setSegmentName \n void setCampaignContents \n List<CampaignVO> getCampaignSearchList \n String getCircleName \n void setCreatedBy \n boolean isEditCapability \n void setCampaignSearchList \n String getCreatedBy \n void setCampaignName", "output": "void function ( List < CampaignVO > arg0 ) { this . segmentNameList = arg0 ; }"}, {"instruction": "Generate java code\ncalls casexxx for each class of the model until one returns a non null result ; it yields that result . ", "input": " HttpPackage modelPackage \n\n Object caseHttpOperation \n Object caseHttpBinding \n Object caseHttpAddress \n Object defaultCase", "output": "Object function ( EObject arg0 ) { return doSwitch ( arg0 . eClass ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\ngets empty item view ", "input": " WheelView wheel \n List<View> emptyItems \n List<View> items \n\n int recycleItems \n View getCachedView \n View getItem \n void recycleView \n List<View> addView \n void clearAll", "output": "View function ( ) { return getCachedView ( emptyItems ) ; }"}, {"instruction": "Generate java code\nverbose log message with printf formatting . ", "input": " int WARN \n int VERBOSE \n int ERROR \n int LOGLEVEL \n int DEBUG \n int INFO \n\n boolean isLoggable \n void d \n void d \n void d \n void setLogLevel \n void setLogLevel \n void e \n void e \n void e \n void w \n void w \n void w \n void i \n void i \n void i", "output": "void function ( String arg0 , String arg1 , Object ... arg2 ) { if ( LOG . VERBOSE >= LOGLEVEL ) Log . v ( arg0 , String . format ( arg1 , arg2 ) ) ; }"}, {"instruction": "Generate java code\nsets the lognode data will be sent to . . ", "input": " LogNode mNext \n\n void println \n LogNode getNext", "output": "void function ( LogNode arg0 ) { mNext = arg0 ; }"}, {"instruction": "Generate java code\nget this node 's position right , as defined by style . ", "input": " CSSNode mParent \n CSSNode nextAbsoluteChild \n CSSStyle style \n ArrayList<CSSNode> mChildren \n int lineIndex \n MeasureFunction mMeasureFunction \n CachedCSSLayout lastLayout \n LayoutState mLayoutState \n CSSLayout layout \n CSSNode nextFlexChild \n\n Spacing getBorder \n CSSPositionType getPositionType \n void markHasNewLayout \n void markLayoutSeen \n Spacing getMargin \n void toStringWithIndentation \n float getFlex \n float getPositionTop \n int indexOf \n boolean isMeasureDefined \n void setWrap \n void setPositionTop \n float getStyleHeight \n boolean valuesEqual \n float getStyleWidth \n float getLayoutHeight \n int getChildCount \n float getPositionLeft \n void setFlex \n void measure \n MeasureOutput measure \n void addChildAt \n boolean hasNewLayout \n void setPositionRight \n void setAlignItems \n void reset \n void setAlignSelf \n void setJustifyContent \n CSSJustify getJustifyContent \n float getLayoutWidth \n void setPositionType \n float getPositionBottom \n CSSAlign getAlignItems \n CSSDirection getStyleDirection \n void setFlexDirection \n boolean isDirty \n void calculateLayout \n void setDirection \n void setStyleWidth \n void dirty \n void setDefaultPadding \n void setPadding \n CSSNode getParent \n Spacing getPadding \n void setMargin \n float getLayoutY \n float getLayoutX \n void setPositionBottom \n void setPositionLeft \n void setMeasureFunction \n CSSFlexDirection getFlexDirection \n CSSDirection getLayoutDirection \n CSSNode getChildAt \n void setBorder \n CSSNode removeChildAt \n String toString \n CSSAlign getAlignSelf \n void setStyleHeight", "output": "float function ( ) { return style . position [ POSITION_RIGHT ] ; }"}, {"instruction": "Generate java code\ncreates a new connection handle for the underlying physical connection represented by the managedconnection instance . ", "input": " ValidManagedConnectionFactory1 mcf \n List<ConnectionEventListener> listeners \n Object connection \n PrintWriter logwriter \n\n void associateConnection \n LocalTransaction getLocalTransaction \n void setLogWriter \n void cleanup \n void removeConnectionEventListener \n void destroy \n XAResource getXAResource \n void closeHandle \n ManagedConnectionMetaData getMetaData \n void addConnectionEventListener \n PrintWriter getLogWriter", "output": "Object function ( Subject arg0 , ConnectionRequestInfo arg1 ) { connection = new ValidConnectionImpl1 ( this , mcf ) ; return connection ; }"}, {"instruction": "Generate java code\nreturn an sslsocket if already connected , otherwise null . ", "input": " int uriPort \n Address address \n InputStream sslInputStream \n InputStream inputStream \n boolean requiresTunnel \n SSLSocket sslSocket \n String socketHost \n int socketPort \n Proxy proxy \n OutputStream sslOutputStream \n Socket socket \n OutputStream outputStream \n SSLSocket unverifiedSocket \n String uriHost \n\n SSLSocket verifySecureSocketHostname \n void setupSecureSocket \n boolean isEligibleForRecycling \n void setSoTimeout \n InputStream getInputStream \n Socket getSocket \n int hashCode \n boolean equals \n OutputStream getOutputStream \n Address getAddress \n void closeQuietly \n void closeQuietly \n boolean isStale \n void closeSocketAndStreams \n HttpConnection connect", "output": "SSLSocket function ( ) { return sslSocket ; }"}, {"instruction": "Generate java code\nreturns the number of rows matching the dynamic query . ", "input": " SocialActivityLimitLocalService _socialActivityLimitLocalService \n\n java.lang.String getOSGiServiceIdentifier \n com.liferay.portlet.social.model.SocialActivityLimit addActivityLimit \n void setWrappedService \n com.liferay.portlet.social.model.SocialActivityLimit deleteSocialActivityLimit \n com.liferay.portlet.social.model.SocialActivityLimit deleteSocialActivityLimit \n com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery getActionableDynamicQuery \n com.liferay.portlet.social.model.SocialActivityLimit getSocialActivityLimit \n com.liferay.portlet.social.model.SocialActivityLimit createSocialActivityLimit \n com.liferay.portlet.social.model.SocialActivityLimit updateSocialActivityLimit \n com.liferay.portal.kernel.dao.orm.DynamicQuery dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<com.liferay.portlet.social.model.SocialActivityLimit> getSocialActivityLimits \n com.liferay.portlet.social.model.SocialActivityLimit fetchActivityLimit \n int getSocialActivityLimitsCount \n com.liferay.portal.model.PersistedModel deletePersistedModel \n com.liferay.portlet.social.model.SocialActivityLimit fetchSocialActivityLimit \n com.liferay.portal.model.PersistedModel getPersistedModel \n com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery getIndexableActionableDynamicQuery \n com.liferay.portlet.social.model.SocialActivityLimit addSocialActivityLimit \n SocialActivityLimitLocalService getWrappedService", "output": "long function ( com . liferay . portal . kernel . dao . orm . DynamicQuery arg0 , com . liferay . portal . kernel . dao . orm . Projection arg1 ) { return _socialActivityLimitLocalService . dynamicQueryCount ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nremove the content-length headers . call this when dropping the body on a request or response , such as when a redirect changes the method from post to get . ", "input": " boolean onlyIfCached \n RawHeaders headers \n String transferEncoding \n String acceptEncoding \n String proxyAuthorization \n int maxStaleSeconds \n long contentLength \n String userAgent \n String ifModifiedSince \n URI uri \n int maxAgeSeconds \n String ifNoneMatch \n boolean hasAuthorization \n boolean noCache \n String host \n String connection \n int minFreshSeconds \n String contentType \n\n void setIfModifiedSince \n String getAcceptEncoding \n void setContentLength \n void setConnection \n boolean hasConnectionClose \n String buildCookieHeader \n String getIfNoneMatch \n void setAcceptEncoding \n void addCookies \n boolean isNoCache \n String getConnection \n boolean isChunked \n int getMaxAgeSeconds \n void setContentType \n String getHost \n String getIfModifiedSince \n int getMaxStaleSeconds \n String getTransferEncoding \n void setHost \n RawHeaders getHeaders \n void setChunked \n void setUserAgent \n String getProxyAuthorization \n long getContentLength \n boolean hasConditions \n boolean hasAuthorization \n void setIfNoneMatch \n int getMinFreshSeconds \n String getUserAgent \n String getContentType \n URI getUri \n boolean isOnlyIfCached", "output": "void function ( ) { if ( contentLength != - 1 ) { headers . removeAll ( \"srini_string\" ) ; contentLength = - 1 ; } }"}, {"instruction": "Generate java code\nresets the map to empty . ", "input": " long serialVersionUID \n Map store \n\n Stroke getStroke \n boolean containsKey \n void writeObject \n boolean equals \n Object clone \n void put \n void readObject", "output": "void function ( ) { this . store . clear ( ) ; }"}, {"instruction": "Generate java code\nthe elastic ip address . ", "input": " String domain \n String publicIp \n String allocationId \n\n String getDomain \n void setAllocationId \n AllocateAddressResult withAllocationId \n String getPublicIp \n AllocateAddressResult withDomain \n AllocateAddressResult withDomain \n String getAllocationId \n void setDomain \n void setDomain \n int hashCode \n boolean equals \n AllocateAddressResult clone \n String toString \n AllocateAddressResult withPublicIp", "output": "void function ( String arg0 ) { this . publicIp = arg0 ; }"}, {"instruction": "Generate java code\nserve all urls with the index view . ", "input": " long lastWriteTime \n boolean ignore \n String collidingId \n Logger LOGGER \n Random random \n File home \n\n void schedule \n void init \n void doIgnore \n String getId \n String getCollidingId \n void execute", "output": "void function ( StaplerRequest arg0 , StaplerResponse arg1 ) { arg1 . setStatus ( SC_INTERNAL_SERVER_ERROR ) ; arg0 . getView ( this , \"srini_string\" ) . forward ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nloggingdelegate api ", "input": " String msg \n int mMinLogLevel \n int priority \n int WTF \n int INFO \n ArrayList<LogLine> mLogs \n int WARN \n int DEBUG \n int VERBOSE \n int ASSERT \n String tag \n Throwable tr \n int ERROR \n\n boolean logContains \n boolean isLoggable \n void setMinimumLoggingLevel \n boolean matchLogQuery \n void d \n void d \n void log \n void e \n void e \n void v \n void v \n void w \n void w \n void wtf \n void wtf \n void i \n void i \n void logImpl", "output": "int function ( ) { return mMinLogLevel ; }"}, {"instruction": "Generate java code\nsets the enabled state of the action . ", "input": " VActionContext actionContext_ \n PropertyChangeSupport propertyChangeSupport_ \n Hashtable propertyDictionary_ \n String copyright \n boolean enabled_ \n VAction action_ \n\n void actionPerformed \n Object getValue \n void setAction \n void initializeTransient \n VActionContext getActionContext \n boolean isEnabled \n VAction getAction \n void putValue \n void setActionContext \n void removePropertyChangeListener \n void addPropertyChangeListener \n void readObject", "output": "void function ( boolean arg0 ) { Boolean loc0 = new Boolean ( enabled_ ) ; Boolean loc1 = new Boolean ( arg0 ) ; enabled_ = arg0 ; if ( action_ != null ) action_ . setEnabled ( arg0 ) ; propertyChangeSupport_ . firePropertyChange ( \"srini_string\" , loc0 , loc1 ) ; }"}, {"instruction": "Generate java code\ndoes nothing . callback function called when arriving a 2xx re-invite/modify accepted ", "input": " PlaceHolder placeHolder \n\n void onCallModifying \n void onCallTransfer \n void onCallAccepted \n void onCallClosed \n void onCallTransferSuccess \n void onCallConfirmed \n void onCallTransferFailure \n void onCallClosing \n void onCallTransferAccepted \n void onCallRefused \n void onCallRinging \n void onCallReInviteRefused \n void onCallCanceling \n void onCallRedirection \n void onCallTransferRefused \n void onCallIncoming \n void onCallReInviteTimeout \n void onCallTimeout", "output": "void function ( Call arg0 , String arg1 , Message arg2 ) { }"}, {"instruction": "Generate java code\nadds a file to the current zip output stream ", "input": " int BUFFER_SIZE \n\n void addFolderToZip \n void compressFiles", "output": "void function ( File arg0 , ZipOutputStream arg1 ) { arg1 . putNextEntry ( new ZipEntry ( arg0 . getName ( ) ) ) ; BufferedInputStream loc0 = new BufferedInputStream ( new FileInputStream ( arg0 ) ) ; byte [ ] loc1 = new byte [ BUFFER_SIZE ] ; int loc2 = 0 ; while ( ( loc2 = loc0 . loc2 ( loc1 ) ) != - 1 ) { arg1 . write ( loc1 , 0 , loc2 ) ; } arg1 . closeEntry ( ) ; }"}, {"instruction": "Generate java code\nmake the priority queue logically empty . ", "input": " int size \n PairNode root \n PairNode[] treeArray \n\n PairNode addItem \n PairNode compareAndLink \n boolean isEmpty \n PairNode insert \n int deleteMin \n PairNode combineSiblings \n void decreaseKey \n void main \n PairNode[] doubleIfFull \n int findMin", "output": "void function ( ) { size = 0 ; root = null ; }"}, {"instruction": "Generate java code\nsets the maximum time in seconds that this data source will wait while attempting to connect to a database . a value of zero specifies that the timeout is the default system timeout if there is one ; otherwise , it specifies that there is no timeout . when a datasource object is created , the login timeout is initially zero . ", "input": " int loginTimeout \n PrintWriter logWriter \n String user \n String database \n String password \n\n Connection getConnection \n Connection getConnection \n void setPassword \n String getDatabase \n void setLogWriter \n void setDatabase \n String getUser \n int getLoginTimeout \n void setUser \n Reference getReference \n java.io.PrintWriter getLogWriter", "output": "void function ( int arg0 ) { loginTimeout = 0 ; }"}, {"instruction": "Generate java code\npostmultiplies this matrix with a scale matrix . postmultiplication is also used by opengl es ' gltranslate/glrotate/glscale . ", "input": " float[] val \n int M11 \n int M21 \n float DEGREE_TO_RAD \n int M00 \n int M10 \n int M20 \n int M01 \n long serialVersionUID \n int M02 \n int M12 \n int M22 \n float[] tmp \n\n Matrix3 rotate \n Matrix3 set \n Matrix3 set \n float[] getValues \n Matrix3 mul \n void mul \n Matrix3 setToScaling \n Matrix3 translate \n Matrix3 setToRotation \n Matrix3 inv \n Matrix3 trn \n Matrix3 trn \n float det \n Matrix3 idt \n String toString \n Matrix3 setToTranslation \n Matrix3 scl \n Matrix3 scl", "output": "Matrix3 function ( float arg0 , float arg1 ) { tmp [ 0 ] = arg0 ; tmp [ 1 ] = 0 ; tmp [ 2 ] = 0 ; tmp [ 3 ] = 0 ; tmp [ 4 ] = arg1 ; tmp [ 5 ] = 0 ; tmp [ 6 ] = 0 ; tmp [ 7 ] = 0 ; tmp [ 8 ] = 1 ; mul ( val , tmp ) ; return this ; }"}, {"instruction": "Generate java code\ndetects objects of different sizes in the input image . the detected objects are returned as a list of rectangles . the function is parallelized with the tbb library . ", "input": " long nativeObj \n\n boolean load_0 \n void detectMultiScale_3 \n boolean load \n long CascadeClassifier_1 \n long CascadeClassifier_0 \n boolean empty_0 \n void finalize \n void detectMultiScale_1 \n void delete \n void detectMultiScale_2 \n boolean empty \n void detectMultiScale_0", "output": "void function ( Mat arg0 , MatOfRect arg1 , MatOfInt arg2 , MatOfDouble arg3 ) { Mat loc0 = arg1 ; Mat loc1 = arg2 ; Mat loc2 = arg3 ; detectMultiScale_3 ( nativeObj , arg0 . nativeObj , loc0 . nativeObj , loc1 . nativeObj , loc2 . nativeObj ) ; return ; }"}, {"instruction": "Generate java code\ngets the value of the systemmodstamp property . ", "input": " String jobId \n Long apexProcessingTime \n XMLGregorianCalendar createdDate \n Integer numberRecordsFailed \n int numberRecordsProcessed \n String stateMessage \n XMLGregorianCalendar systemModstamp \n String id \n BatchStateEnum state \n Long totalProcessingTime \n Long apiActiveProcessingTime \n\n void setStateMessage \n void setJobId \n void setApiActiveProcessingTime \n String getJobId \n Long getTotalProcessingTime \n Long getApiActiveProcessingTime \n String getId \n int getNumberRecordsProcessed \n void setTotalProcessingTime \n void setNumberRecordsFailed \n BatchStateEnum getState \n void setNumberRecordsProcessed \n void setCreatedDate \n void setSystemModstamp \n Long getApexProcessingTime \n void setId \n void setState \n XMLGregorianCalendar getCreatedDate \n String getStateMessage \n Integer getNumberRecordsFailed \n void setApexProcessingTime", "output": "XMLGregorianCalendar function ( ) { return systemModstamp ; }"}, {"instruction": "Generate java code\nset the . woo file encoding ", "input": " int htmlBodyType \n String adaptorName \n String gid \n boolean createBodyTag \n String Key \n String wooEncoding \n String mavenVersion \n String artifactId \n String componentName \n String packageName \n String projectName \n String antFolderName \n\n String getProjectName \n String getComponentName \n void setAdaptorName \n void setGroupId \n String getAntFolderName \n void setMavenProjectVersion \n void setPackageName \n boolean getCreateBodyTag \n boolean getCreatePackageDeclaration \n String getGroupId \n void setComponentName \n void setProjectName \n String getAdaptorName \n String getWOOEncoding \n void setArtifactId \n String getPluginName \n void setCreateBodyTag \n void setHTMLBodyType \n String getDate \n int getHTMLBodyType \n void setAntFolderName \n String getArtifactId \n String getPackageName \n String getMavenProjectVersion", "output": "void function ( String arg0 ) { this . wooEncoding = arg0 ; }"}, {"instruction": "Generate java code\nsets the value of the title property . ", "input": " String role \n String arcrole \n ShowType show \n ActuateType actuate \n String href \n TypeType type \n String title \n\n String getHref \n void setHref \n String getRole \n String getArcrole \n void setActuate \n void setArcrole \n ActuateType getActuate \n void setType \n void setShow \n String getTitle \n TypeType getType \n ShowType getShow \n void setRole", "output": "void function ( String arg0 ) { this . title = arg0 ; }"}, {"instruction": "Generate java code\nreturns the current x offset in the scroll . ", "input": " long mDuration \n float mDeltaAngle \n boolean mFinished \n float mCoeffVelocity \n long mStartTime \n int DEFAULT_DURATION \n int mMode \n int SCROLL_MODE \n float mDeceleration \n float mVelocity \n float mStartAngle \n float mCurrAngle \n int FLING_MODE \n\n void abortAnimation \n void forceFinished \n int timePassed \n void extendDuration \n long getDuration \n float getStartAngle \n void startRotate \n void startRotate \n boolean computeAngleOffset \n boolean isFinished \n float getCurrVelocity \n void fling", "output": "float function ( ) { return mCurrAngle ; }"}, {"instruction": "Generate java code\nget the length of the string currently in the byte stream . ", "input": " int streamPosition \n byte[] bytes \n int bytesLength \n\n boolean isBundle \n OSCMessage convertMessage \n String readString \n char[] readTypes \n Object readInteger \n OSCPacket convert \n Date readTimeTag \n Object readArgument \n Object readChar \n Object readDouble \n Object readBigInteger \n OSCBundle convertBundle \n Object readFloat \n Object[] readArray \n void moveToFourByteBoundry", "output": "int function ( ) { int loc0 = 0 ; while ( bytes [ streamPosition + loc0 ] != 0 ) loc0 ++ ; return loc0 ; }"}, {"instruction": "Generate java code\na regular state may be a dead end . ", "input": " SGraphFactory factory \n BasicDiagnostic diagnostics \n SGraphJavaValidator validator \n StextFactory sTextFactory \n State state \n Region region \n Statechart statechart \n\n void choiceOutgoingTransitions \n void initialEntryWithoutOutTransition \n void prepareStateTest \n void assertNoIssue \n void incomingTransitionCount \n void vertexNotReachable \n void stateWithoutName \n void stateWithWhitespaceName \n void entryMultipleOutTransition \n void disallowTrigger \n Diagnostic issueByName \n void assertIssueCount \n void nameIsNotEmpty \n void validInitialEntry \n void testAllChecksHaveTests \n void validState \n void finalStateValid \n void assertError \n void finalStateIsolated \n void setUp \n Transition createTransition \n void outgoingTransitionCount \n void assertWarning \n void assertIssue", "output": "void function ( ) { prepareStateTest ( ) ; validator . validate ( state , diagnostics , new HashMap < Object , Object > ( ) ) ; assertNoIssue ( diagnostics , ISSUE_STATE_WITHOUT_OUTGOING_TRANSITION ) ; }"}, {"instruction": "Generate java code\nwrite the script markup and then gradually write the script code by calling the ` write ' write methods on the scriptwriter instance . ", "input": " UIComponent component \n ResponseWriter writer \n\n void writeScriptEnd \n void startScript \n void endScript \n void write \n void write \n void write \n void write \n void write \n void write \n void write \n void write \n void writeScriptStart \n void writeScriptStart", "output": "ScriptWriter function ( FacesContext arg0 , final UIComponent arg1 ) { return new ScriptWriter ( arg0 . getResponseWriter ( ) , arg1 ) ; }"}, {"instruction": "Generate java code\nget the index of the first character following the run with respect to all attributes containing the current character . ", "input": " AttributedCharacterIterator aci \n int end \n int begin \n\n char next \n Map getAttributes \n int getIndex \n char last \n char previous \n int getBeginIndex \n char current \n Object getAttribute \n int getEndIndex \n char setIndex \n Object clone \n int getRunStart \n int getRunStart \n int getRunStart \n Set getAllAttributeKeys \n char first", "output": "int function ( ) { return Math . min ( aci . getRunLimit ( ) , end ) ; }"}, {"instruction": "Generate java code\ngets the value of the encoding property . ", "input": " String id \n String mimeType \n String encoding \n List<Object> content \n\n String getMimeType \n void setEncoding \n List<Object> getContent \n void setMimeType \n void setId \n String getId", "output": "String function ( ) { return encoding ; }"}, {"instruction": "Generate java code\nsets the starting point of the transition , a float between 0.0 and 1.0 . defaults to 0.0 . ", "input": " boolean fired \n boolean submit \n boolean queued \n float fps \n boolean sync \n int sequenceId \n float duration \n String sequence \n float delay \n boolean transitory \n float from \n float to \n String id \n EffectsArguments ea \n boolean queueEnd \n String queue \n\n void setDuration \n void setSequence \n int getSequenceId \n float getDelay \n String getId \n boolean isSync \n void setSync \n boolean isFired \n float getDuration \n void setQueue \n void setFired \n int hashCode \n String getQueue \n void setId \n void setOptions \n boolean isQueueEnd \n boolean isQueued \n void setDelay \n float getFrom \n String getFunctionName \n void setTransitory \n void setQueueEnd \n void setFps \n int getIntfromString \n void setSequenceId \n float getTo \n boolean isTransitory \n boolean isSubmit \n void setSubmit \n void setQueued \n boolean equals \n void setTo \n String toString \n String toString \n float getFps \n String getSequence", "output": "void function ( float arg0 ) { this . from = arg0 ; ea . add ( \"srini_string\" , arg0 ) ; }"}, {"instruction": "Generate java code\ntells if player has the book with this name or not . ", "input": " List<Subject> completedSubjects \n Integer invWeight \n List<Book> books \n String name \n Integer hp \n List<Subject> enrolledSubjects \n Room location \n Integer amtKeys \n\n void setName \n Room getLocation \n void addCompletedSubjects \n void addEnrolledSubjects \n Subject findCompletedSubjects \n Subject findCompletedSubjects \n String getName \n Integer getHp \n Integer getWeight \n boolean removeEnrolledSubjects \n void addKey \n Boolean addBook \n Integer getKeysAmount \n void setHp \n List<Book> getAllBooks \n boolean removeKey \n void setLocation \n Subject findEnrolledSubjects \n Subject findEnrolledSubjects \n List<Subject> getCompletedSubjects \n void config \n boolean removeCompletedSubjects \n Book findBook \n Book findBook \n List<Subject> getEnrolledSubjects \n boolean removeBook", "output": "boolean function ( String arg0 ) { for ( Book loc0 : books ) { if ( loc0 . getName ( ) . equals ( arg0 ) ) { return true ; } } return false ; }"}, {"instruction": "Generate java code\ngets the value of the return property . ", "input": " String _return \n\n void setReturn", "output": "String function ( ) { return _return ; }"}, {"instruction": "Generate java code\nretrieves whether values for the designated parameter can be signed numbers . ", "input": " int[] types \n int[] modes \n int parameterCount \n int[] nullability \n Result.ResultMetaData rmd \n boolean[] isIdentity \n String[] classNames \n\n int getParameterCount \n int getScale \n int isNullable \n int getParameterMode \n String toString \n String getParameterClassName \n String getParameterTypeName \n void checkRange \n int getPrecision \n String toStringImpl \n int getParameterType", "output": "boolean function ( int arg0 ) { checkRange ( arg0 ) ; Boolean loc0 = Types . isUnsignedAttribute ( types [ -- arg0 ] ) ; return loc0 != null && ! loc0 . booleanValue ( ) && ! isIdentity [ arg0 ] ; }"}, {"instruction": "Generate java code\ngets motechuser with given email ", "input": " MotechUsersDataService dataService \n\n void add \n List<MotechUser> findByRole \n MotechUser findByUserName \n List<MotechUser> getUsers \n void addOpenIdUser \n void update \n MotechUser findUserByOpenId \n List<MotechUser> getOpenIdUsers \n void remove \n void setDataService", "output": "MotechUser function ( String arg0 ) { return null == arg0 ? null : dataService . findByEmail ( arg0 ) ; }"}, {"instruction": "Generate java code\nfree text description of this package type . ", "input": " String QUERY_FIND_BY_RESOURCE_TYPE_ID \n ConfigurationDefinition deploymentConfigurationDefinition \n String displayName \n ConfigurationDefinition packageExtraPropertiesDefinition \n String description \n boolean supportsArchitecture \n long serialVersionUID \n Set<Package> packages \n long discoveryInterval \n boolean isCreationData \n String QUERY_FIND_BY_NAME_AND_NULL_RESOURCE_TYPE \n String QUERY_FIND_ALL \n String QUERY_DYNAMIC_CONFIG_VALUES \n String name \n int id \n PackageCategory category \n String QUERY_FIND_BY_RESOURCE_TYPE_ID_AND_NAME \n String QUERY_FIND_BY_RESOURCE_TYPE_ID_AND_CREATION_FLAG \n ResourceType resourceType \n\n void setName \n String getName \n void setSupportsArchitecture \n void afterUnmarshal \n void addPackage \n void update \n int getId \n void setDescription \n ConfigurationDefinition getDeploymentConfigurationDefinition \n ConfigurationDefinition getPackageExtraPropertiesDefinition \n void setDisplayName \n long getDiscoveryInterval \n boolean isCreationData \n void setCategory \n int hashCode \n void setCreationData \n ResourceType getResourceType \n void setId \n void setPackageExtraPropertiesDefinition \n PackageCategory getCategory \n void setDiscoveryInterval \n boolean isSupportsArchitecture \n String getDisplayName \n boolean equals \n Set<Package> getPackages \n void setResourceType \n String toString \n void setPackages \n void setDeploymentConfigurationDefinition", "output": "String function ( ) { return description ; }"}, {"instruction": "Generate java code\nget the booleanproperty value . ", "input": " Integer defaultIntegerProperty \n Boolean booleanProperty \n Double doubleProperty \n URL urlProperty \n String failure \n int id \n Long longProperty \n Integer integerProperty \n\n void setLogWriter \n void setLongProperty \n ManagedConnection matchManagedConnections \n Integer getDefaultIntegerProperty \n void setDefaultIntegerProperty \n void setIntegerProperty \n void setDoubleProperty \n Long getLongProperty \n ManagedConnection createManagedConnection \n void setFailure \n int hashCode \n boolean equals \n Object createConnectionFactory \n Object createConnectionFactory \n Double getDoubleProperty \n URL getUrlProperty \n void setBooleanProperty \n Integer getIntegerProperty \n void setUrlProperty \n PrintWriter getLogWriter", "output": "Boolean function ( ) { return booleanProperty ; }"}, {"instruction": "Generate java code\nsearches the subscription database for a subscription by the given uuid ", "input": " Logger LOG \n WebServiceContext context \n\n RenewResponse renewOp \n UnsubscribeResponse unsubscribeOp \n GetStatusResponse getStatusOp \n SubscriptionManagerInterfaceForManagers getSubscriptionManagerBackend \n String retrieveSubscriptionUUID", "output": "SubscriptionTicket function ( String arg0 ) { SubscriptionTicket loc0 = getSubscriptionManagerBackend ( ) . findTicket ( UUID . fromString ( arg0 ) ) ; if ( loc0 == null ) { LOG . severe ( \"srini_string\" + arg0 ) ; throw new UnknownSubscription ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\ngets the value of the assocarraydata property . ", "input": " InfoboxReadDataAssocArrayType assocArrayData \n Base64XMLContentType binaryFileData \n\n void setBinaryFileData \n Base64XMLContentType getBinaryFileData \n void setAssocArrayData", "output": "InfoboxReadDataAssocArrayType function ( ) { return assocArrayData ; }"}, {"instruction": "Generate java code\nsets the value of the vm property . ", "input": " ManagedObjectReference vm \n ManagedObjectReference host \n ManagedObjectReference pool \n List<String> testType \n ManagedObjectReference _this \n\n void setThis \n void setPool \n ManagedObjectReference getThis \n void setHost \n ManagedObjectReference getVm \n ManagedObjectReference getPool \n List<String> getTestType \n ManagedObjectReference getHost", "output": "void function ( ManagedObjectReference arg0 ) { this . vm = arg0 ; }"}, {"instruction": "Generate java code\nsets the friendly name of this connection . this is returned by #tostring and is useful for providing applicationspecific identifying information in the logging . may be null for the default name of `` connection x '' , where x is the connection id . ", "input": " TcpConnection tcp \n UdpConnection udp \n int lastPingID \n KryoNetException lastProtocolError \n boolean isConnected \n int id \n EndPoint endPoint \n Object listenerLock \n long lastPingSendTime \n String name \n Listener[] listeners \n InetSocketAddress udpRemoteAddress \n int returnTripTime \n\n int getTcpWriteBufferSize \n void setBufferPositionFix \n void updateReturnTripTime \n boolean isConnected \n void notifyDisconnected \n int getReturnTripTime \n void setIdleThreshold \n int sendUDP \n void close \n void addListener \n InetSocketAddress getRemoteAddressUDP \n void notifyReceived \n int getID \n void removeListener \n void notifyConnected \n void setTimeout \n void setKeepAliveTCP \n EndPoint getEndPoint \n void notifyIdle \n KryoNetException getLastProtocolError \n boolean isIdle \n String toString \n void initialize \n int sendTCP \n void setConnected \n InetSocketAddress getRemoteAddressTCP", "output": "void function ( String arg0 ) { this . name = arg0 ; }"}, {"instruction": "Generate java code\nsets the value of the strategy property . ", "input": " String notes \n Boolean winner \n RecordRef competitor \n String strategy \n String url \n\n String getStrategy \n void setCompetitor \n String getUrl \n void setNotes \n Boolean isWinner \n String getNotes \n RecordRef getCompetitor \n void setWinner \n void setUrl", "output": "void function ( String arg0 ) { this . strategy = arg0 ; }"}, {"instruction": "Generate java code\ndefine el valor de la propiedad encoding . ", "input": " String id \n String mimeType \n String encoding \n List<Object> content \n\n String getEncoding \n String getMimeType \n List<Object> getContent \n void setMimeType \n void setId \n String getId", "output": "void function ( String arg0 ) { this . encoding = arg0 ; }"}, {"instruction": "Generate java code\ninitialize the context ", "input": " ServletContext servletContext \n String COUNT_KEY \n String EVENT_KEY \n int counter \n Set<User> users \n String USERS_KEY \n\n void addUsername \n boolean isAnonymous \n void decrementUserCounter \n void attributeReplaced \n void removeUsername \n void contextDestroyed \n void incrementUserCounter \n void attributeAdded \n void attributeRemoved", "output": "void function ( ServletContextEvent arg0 ) { servletContext = arg0 . getServletContext ( ) ; servletContext . setAttribute ( ( COUNT_KEY ) , Integer . toString ( counter ) ) ; }"}, {"instruction": "Generate java code\nplace the composite in the backing bloom filter . ", "input": " String file \n StampedLock lock \n com.google.common.hash.BloomFilter<Composite> source \n\n boolean mightContainCached \n boolean putCached \n BloomFilter create \n BloomFilter create \n void sync \n BloomFilter open \n boolean mightContain \n boolean mightContain", "output": "boolean function ( Composite arg0 ) { long loc0 = lock . writeLock ( ) ; try { return source . put ( arg0 ) ; } finally { lock . unlockWrite ( loc0 ) ; } }"}, {"instruction": "Generate java code\nthis method is invoked when this component is deactivated to stop the separate thread if still running . ", "input": " boolean shared \n boolean running \n AbstractResourceBundleProvider<E> provider \n List<BundleEvent> queue \n Thread runningThread \n boolean closed \n Logger logger \n\n void addEvent \n void addAll \n void processBundleChanged \n void run", "output": "void function ( ) { synchronized ( this ) { closed = true ; notifyAll ( ) ; } Thread loc0 = this . runningThread ; if ( loc0 != null ) { try { loc0 . join ( 30000 ) ; } catch ( InterruptedException loc1 ) { } } }"}, {"instruction": "Generate java code\nsets the remark 800 evidence code for the site . ", "input": " String lineEnd \n String siteID \n long serialVersionUID \n List<Group> groups \n String evCode \n String description \n\n void remark800toPDB \n String remark800toPDB \n void setSiteID \n String toPDB \n void toPDB \n String getSiteID \n void setDescription \n int compareTo \n String getDescription \n int hashCode \n boolean equals \n String toString \n String getEvCode \n void setGroups \n List<Group> getGroups", "output": "void function ( String arg0 ) { this . evCode = arg0 ; }"}, {"instruction": "Generate java code\nends a com.codahale.metrics.timer.context only if it exists . ", "input": " boolean instrumentationEnabled \n MetricContext metricContext \n Random RAND \n String METRIC_CONTEXT_NAME_KEY \n Closer closer \n\n boolean isLineageInstrumented \n void markMeter \n void markMeter \n MetricContext getMetricContext \n MetricContext getMetricContext \n MetricContext getMetricContext \n List<Tag<?>> generateTags \n MetricContext newContextFromReferenceContext \n void switchMetricContext \n void switchMetricContext \n void setMetricContextName \n boolean isInstrumentationEnabled \n Optional<Timer.Context> timerContext \n void updateTimer \n void close", "output": "void function ( Optional < Timer . Context > arg0 ) { arg0 . transform ( new Function < Timer . Context , Timer . Context > ( ) { @ Override public Timer . Context apply ( @ Nonnull Timer . Context arg1 ) { arg1 . close ( ) ; return arg1 ; } } ) ; }"}, {"instruction": "Generate java code\nreturns the file id for a given path . if the given path does not exist in alluxio , the method attempts to load it from ufs . ", "input": " FileSystemMaster mFileSystemMaster \n\n List<Long> getLostFiles \n List<WorkerInfo> getWorkerInfoList \n AlluxioURI getPath \n List<FileBlockInfo> getFileBlockInfoList \n FileInfo getFileInfo \n PersistenceState getFilePersistenceState", "output": "long function ( AlluxioURI arg0 ) { return mFileSystemMaster . getFileId ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the group id of this favorite site . ", "input": " FavoriteSite _favoriteSite \n\n boolean isFinderCacheEnabled \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setGroupId \n boolean isEscapedModel \n boolean isCachedModel \n com.liferay.portlet.expando.model.ExpandoBridge getExpandoBridge \n int compareTo \n FavoriteSite getWrappedModel \n void setModelAttributes \n Map<String,Object> getModelAttributes \n com.liferay.portal.model.CacheModel<com.liferay.so.model.FavoriteSite> toCacheModel \n int hashCode \n void setPrimaryKey \n com.liferay.so.model.FavoriteSite toUnescapedModel \n void setUserUuid \n void persist \n boolean isEntityCacheEnabled \n void setNew \n long getFavoriteSiteId \n void setFavoriteSiteId \n java.lang.String getUserUuid \n FavoriteSite getWrappedFavoriteSite \n void resetOriginalValues \n boolean isNew \n java.io.Serializable getPrimaryKeyObj \n Class<?> getModelClass \n long getPrimaryKey \n com.liferay.so.model.FavoriteSite toEscapedModel \n long getCompanyId \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n void setCachedModel \n java.lang.String toString \n String getModelClassName \n void setCompanyId \n long getUserId \n void setUserId", "output": "long function ( ) { return _favoriteSite . getGroupId ( ) ; }"}, {"instruction": "Generate java code\nreturns the amount of ports a task needs ", "input": " double REQUIRED_PORT_COUNT \n Logger LOGGER \n String DEFAULT_KIBANA_VERSION \n String zookeeper \n Map<TaskID,Long> usedPortNumbers \n String DOCKER_IMAGE_NAME \n int apiPort \n double requiredMem \n String kibanaVersion \n Map<String,List<TaskID>> runningTasks \n String FRAMEWORK_NAME \n Options OPTIONS \n double requiredDisk \n State state \n double requiredCpu \n Map<String,Integer> requiredTasks \n\n String getZookeeper \n String getDockerImageName \n void setZookeeper \n double getRequiredDisk \n void parseLaunchArguments \n TaskID getYoungestTask \n double getRequiredCpu \n void registerRequirement \n int getRequirementDelta \n int getApiPort \n State getState \n void setRequiredMem \n Map<String,Integer> getRequirementDeltaMap \n void setRequiredCpu \n void setKibanaVersion \n void setState \n long pickAndRegisterPortNumber \n double getRequiredMem \n Options getOptions \n void registerTask \n String getFrameworkName \n void setRequiredDisk \n void setApiPort \n void unregisterTask", "output": "double function ( ) { return REQUIRED_PORT_COUNT ; }"}, {"instruction": "Generate java code\nsets the cookie store that will be used by the underlying client . ", "input": " int maxWaitPeriodInSeconds \n int MILLIS_PER_SEC \n DefaultHttpClient httpClient \n int ERROR_NOT_EXPECTED \n Logger LOGGER \n\n void setMaxWaitPeriodInSeconds \n boolean responseNotFound \n CredentialsProvider getCredentialsProvider \n T executeWithWaitForUriAvailability \n HttpResponse get \n T get \n int getMaxWaitPeriodInSeconds \n HttpResponse execute \n HttpResponse execute \n T execute \n T execute \n HttpResponse handleResponse", "output": "void function ( CookieStore arg0 ) { httpClient . setCookieStore ( arg0 ) ; }"}, {"instruction": "Generate java code\nreturns the series color . ", "input": " NumberFormat mChartValuesFormat \n boolean mGradientEnabled \n BasicStroke mStroke \n boolean mHighlighted \n int mGradientStopColor \n boolean mDisplayBoundingPoints \n boolean mShowLegendItem \n int mColor \n double mGradientStartValue \n double mGradientStopValue \n int mGradientStartColor \n\n void setGradientStart \n boolean isHighlighted \n void setHighlighted \n BasicStroke getStroke \n void setGradientEnabled \n double getGradientStartValue \n boolean isDisplayBoundingPoints \n int getGradientStartColor \n void setShowLegendItem \n NumberFormat getChartValuesFormat \n int getGradientStopColor \n void setDisplayBoundingPoints \n void setColor \n double getGradientStopValue \n boolean isShowLegendItem \n void setChartValuesFormat \n void setStroke \n boolean isGradientEnabled \n void setGradientStop", "output": "int function ( ) { return mColor ; }"}, {"instruction": "Generate java code\nutil method to write an attribute with the ns prefix ", "input": " javax.xml.namespace.QName MY_QNAME \n\n String generatePrefix \n void serialize \n void serialize \n void writeQName \n void writeQNames \n javax.xml.stream.XMLStreamReader getPullParser \n void writeQNameAttribute \n String registerPrefix \n org.apache.axiom.om.OMElement getOMElement \n AddRenterResponse parse \n void writeStartElement", "output": "void function ( String arg0 , String arg1 , String arg2 , String arg3 , javax . xml . stream . XMLStreamWriter arg4 ) { if ( arg4 . getPrefix ( arg1 ) == null ) { arg4 . writeNamespace ( arg0 , arg1 ) ; arg4 . setPrefix ( arg0 , arg1 ) ; } arg4 . writeAttribute ( arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nthe amount of the recurring charge . ", "input": " Double amount \n String frequency \n\n String getFrequency \n int hashCode \n RecurringCharge withFrequency \n RecurringCharge withFrequency \n boolean equals \n RecurringCharge clone \n String toString \n void setAmount \n void setFrequency \n void setFrequency \n Double getAmount", "output": "RecurringCharge function ( Double arg0 ) { setAmount ( arg0 ) ; return this ; }"}, {"instruction": "Generate java code\nreturns the string representation of this edge ", "input": " Vertex a \n Vertex b \n\n boolean equals \n boolean equalsPresicion", "output": "String function ( ) { return \"srini_string\" + a . pos + \"srini_string\" + a . pos + \"srini_string\" ; }"}, {"instruction": "Generate java code\nremove account from device ", "input": " String KEY_ACCOUNT_TYPE \n String TAG \n String KEY_USER_ACCOUNT_VERSION \n\n List<OUser> getAllAccounts \n boolean cancelUserSync \n OUser getActiveUser \n boolean logout \n String userObjectKEY \n boolean isValidUserObj \n boolean anyActiveUser \n boolean hasAnyAccount \n OUser updateUserData \n OUser updateUserData \n OUser getDetails \n boolean createAccount \n OUser login", "output": "boolean function ( Context arg0 , String arg1 ) { OUser loc0 = getDetails ( arg0 , arg1 ) ; if ( loc0 != null ) { AccountManager loc1 = AccountManager . get ( arg0 ) ; loc1 . removeAccount ( loc0 . getAccount ( ) , null , null ) ; return true ; } return false ; }"}, {"instruction": "Generate java code\nreads , validates and returns all attributes of a node associated with the specified reader as key-value map . ", "input": " Map<String,Boolean> validationMaskTemplate \n\n placeholderType placeHolder", "output": "Map < String , String > function ( HierarchicalStreamReader arg0 ) { return readValidatedAttributes ( arg0 , this . validationMaskTemplate ) ; }"}, {"instruction": "Generate java code\nconstructs a service loader , using the extension class loader . ", "input": " LinkedList<String> queue \n ClassLoader classLoader \n boolean isRead \n Class<S> service \n Set<URL> services \n\n S next \n void readClass \n Iterator<S> iterator \n void reload \n ServiceLoader<S> load \n ServiceLoader<S> load \n void checkValidJavaClassName \n String toString \n boolean hasNext \n void internalLoad \n void remove \n S loadFromSystemProperty", "output": "ServiceLoader < S > function ( Class < S > arg0 ) { ClassLoader loc0 = ClassLoader . getSystemClassLoader ( ) ; if ( loc0 != null ) { while ( loc0 . getParent ( ) != null ) { loc0 = loc0 . getParent ( ) ; } } return ServiceLoader . load ( arg0 , loc0 ) ; }"}, {"instruction": "Generate java code\nthe path from the execution root to the actual root . for source roots , this returns the empty fragment , root #getexecpath . ", "input": " Set<Artifact> idlGeneratedJavaFiles \n String javaPackage \n Set<SourceDirectory> idlDirs \n ImmutableCollection<SourceDirectory> assetDirs \n Artifact generatedManifest \n Set<Artifact> idlSrcs \n ImmutableCollection<Artifact> idlSrcs \n Artifact signedApk \n ImmutableCollection<Artifact> apksUnderTest \n Artifact generatedManifest \n Artifact idlClassJar \n PathFragment relativePath \n boolean isSource \n Artifact apk \n Set<SourceDirectory> assetDirs \n ImmutableCollection<Artifact> idlGeneratedJavaFiles \n Artifact idlSourceJar \n ImmutableCollection<SourceDirectory> idlImports \n Artifact manifest \n Artifact idlClassJar \n Set<SourceDirectory> resourceDirs \n PathFragment rootPath \n Artifact idlSourceJar \n Set<Artifact> apksUnderTest \n String javaPackage \n Artifact manifest \n boolean definesAndroidResources \n PathFragment rootExecutionPathFragment \n ImmutableCollection<SourceDirectory> resourceDirs \n\n Builder addAllResources \n Builder addAllApksUnderTest \n Builder addAssetSource \n Builder setGeneratedManifest \n Artifact getManifest \n SourceDirectory fromSourceRoot \n Artifact getIdlClassJar \n Artifact getIdlSourceJar \n ImmutableCollection<SourceDirectory> getIdlImports \n ImmutableCollection<Artifact> getIdlSrcs \n void addIdlDirs \n int hashCode \n Builder addIdlSrcs \n Builder addIdlGeneratedJavaFiles \n boolean isSource \n Builder setApk \n String getJavaPackage \n ImmutableCollection<Artifact> getIdlGeneratedJavaFiles \n SourceDirectory fromRoot \n Builder addResourceSource \n Builder setDefinesAndroidResources \n Builder setIdlClassJar \n Builder addAllAssets \n ImmutableCollection<SourceDirectory> getResourceDirs \n Builder setManifest \n Builder addIdlParcelables \n Artifact getGeneratedManifest \n ImmutableCollection<SourceDirectory> getAssetDirs \n Builder addResourceSources \n Builder addAssetSources \n Builder setIdlSourceJar \n Artifact getSignedApk \n AndroidIdeInfoProvider build \n boolean equals \n boolean definesAndroidResources \n String toString \n PathFragment getRootPath \n PathFragment getRelativePath \n Builder setJavaPackage \n ImmutableCollection<Artifact> getApksUnderTest", "output": "PathFragment function ( ) { return rootExecutionPathFragment ; }"}, {"instruction": "Generate java code\ncreate an instance of itemreceiptitemlist ", "input": " QName _VendorBill_QNAME \n QName _PurchaseOrder_QNAME \n QName _VendorReturnAuthorization_QNAME \n QName _VendorPayment_QNAME \n QName _ItemReceipt_QNAME \n QName _VendorCredit_QNAME \n\n ItemReceiptItem createItemReceiptItem \n VendorCreditItem createVendorCreditItem \n PurchaseOrderExpenseList createPurchaseOrderExpenseList \n ItemReceipt createItemReceipt \n JAXBElement<ItemReceipt> createItemReceipt \n VendorPaymentCreditList createVendorPaymentCreditList \n VendorCreditExpenseList createVendorCreditExpenseList \n VendorBillExpenseList createVendorBillExpenseList \n PurchaseOrder createPurchaseOrder \n JAXBElement<PurchaseOrder> createPurchaseOrder \n VendorReturnAuthorization createVendorReturnAuthorization \n JAXBElement<VendorReturnAuthorization> createVendorReturnAuthorization \n VendorCreditItemList createVendorCreditItemList \n VendorCreditExpense createVendorCreditExpense \n PurchaseOrderItem createPurchaseOrderItem \n ItemReceiptExpenseList createItemReceiptExpenseList \n PurchaseOrderItemList createPurchaseOrderItemList \n ItemReceiptExpense createItemReceiptExpense \n VendorReturnAuthorizationExpenseList createVendorReturnAuthorizationExpenseList \n VendorBillItemList createVendorBillItemList \n PurchaseOrderExpense createPurchaseOrderExpense \n VendorBill createVendorBill \n JAXBElement<VendorBill> createVendorBill \n VendorPayment createVendorPayment \n JAXBElement<VendorPayment> createVendorPayment \n VendorCredit createVendorCredit \n JAXBElement<VendorCredit> createVendorCredit \n VendorPaymentApply createVendorPaymentApply \n VendorBillItem createVendorBillItem \n VendorReturnAuthorizationExpense createVendorReturnAuthorizationExpense \n PurchLandedCostList createPurchLandedCostList \n VendorBillExpense createVendorBillExpense \n VendorCreditApplyList createVendorCreditApplyList \n VendorPaymentCredit createVendorPaymentCredit \n VendorCreditApply createVendorCreditApply \n VendorPaymentApplyList createVendorPaymentApplyList \n VendorReturnAuthorizationItemList createVendorReturnAuthorizationItemList \n VendorReturnAuthorizationItem createVendorReturnAuthorizationItem", "output": "ItemReceiptItemList function ( ) { return new ItemReceiptItemList ( ) ; }"}, {"instruction": "Generate java code\nextracts the first word from a timezone displayname . ", "input": " DateFormat selectedFormat \n int[] pacificXCoords \n int[] nfldXCoords \n int[] easternYCoords \n int[] alaskaYCoords \n int[] pacificYCoords \n ArrayList allTimeZoneList \n int[] mountainXCoords \n TimeZone serverTimeZone \n int[] hawaiiXCoords \n DateFormat serverFormat \n int[] easternXCoords \n int[] alaskaXCoords \n int[] nfldYCoords \n TimeZone selectedTimeZone \n int[] centralXCoords \n int[] centralYCoords \n int[] hawaiiYCoords \n int[] mountainYCoords \n\n void init \n String getSelectedTime \n String getServerTimeZoneName \n DateFormat buildDateFormatForTimeZone \n String formatCurrentTime \n String getSelectedTimeZoneName \n TimeZoneWrapper getTimeZoneWrapperByComponentId \n String getServerTime \n void listen", "output": "String function ( String arg0 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } else { int loc0 = arg0 . indexOf ( ' ' ) ; if ( loc0 != - 1 ) { arg0 = arg0 . substring ( 0 , loc0 ) ; } } return arg0 ; }"}, {"instruction": "Generate java code\ngets the value of the defaultidentitystoreid property . ", "input": " String defaultAttributeStoreId \n ExternalConfigType externalConfig \n OptionsType options \n IdentityStoreMappingsType identityStoreMappings \n String id \n String clazz \n String defaultIdentityStoreId \n\n String getClazz \n void setClazz \n void setExternalConfig \n String getId \n void setDefaultIdentityStoreId \n IdentityStoreMappingsType getIdentityStoreMappings \n ExternalConfigType getExternalConfig \n void setIdentityStoreMappings \n String getDefaultAttributeStoreId \n void setId \n void setOptions \n OptionsType getOptions \n void setDefaultAttributeStoreId", "output": "String function ( ) { return defaultIdentityStoreId ; }"}, {"instruction": "Generate java code\nmethod to stop the progress bar ", "input": " int PAUSE_AMOUNT_S \n PortableRenderer renderer \n int percent \n boolean isRunning \n SelectItem[] AVAILABLE_MODES \n String PUSH_GROUP \n Boolean isIndeterminate \n Thread progressThread \n\n boolean getIsRunning \n void setIsRunning \n boolean getIsIndeterminatePrimitive \n void stop \n void setPercent \n Boolean getIsIndeterminate \n SelectItem[] getAvailableModes \n String startProgress \n void start \n int getPercent \n void setIsIndeterminate \n void modeChanged", "output": "String function ( ) { stop ( ) ; return \"srini_string\" ; }"}, {"instruction": "Generate java code\nthis method should be called by a central configuration mechanism to enable screen reader support for the application . ", "input": " String ACCESS_BRIDGE \n boolean myActive \n String ATK_WRAPPER \n\n boolean isEnabled \n boolean isActive", "output": "void function ( boolean arg0 ) { myActive = arg0 ; }"}, {"instruction": "Generate java code\nlogs the message without checking the #shouldlog method first . ", "input": " Logger log \n LoggingLevel level \n Marker marker \n\n void setLog \n LoggingLevel getLevel \n boolean shouldLog \n boolean shouldLog \n Marker getMarker \n void setLogName \n void setMarker \n void setMarker \n void log \n void log \n void log \n void log \n void log \n void log \n void log \n void log \n Logger getLog \n String toString \n void setLevel", "output": "void function ( String arg0 ) { log ( log , level , marker , arg0 ) ; }"}, {"instruction": "Generate java code\nthe shape to use to draw this glyph . this is set to null after the glyph is stored in a glyphpage . ", "input": " short yOffset \n int xOffset \n Shape shape \n Texture texture \n boolean isMissing \n float u \n float v \n short width \n int xAdvance \n float v2 \n float u2 \n int codePoint \n short height \n\n int getXOffset \n void setTexture \n int getCodePoint \n float getU2 \n float getV2 \n int getWidth \n int getYOffset \n int getXAdvance \n void setShape \n Texture getTexture \n float getU \n float getV \n int getHeight \n boolean isMissing", "output": "Shape function ( ) { return shape ; }"}, {"instruction": "Generate java code\nsize of the set ", "input": " Integer hashcode_cache \n Hashtable _all \n\n Enumeration all \n lalr_item add \n void add \n void not_null \n boolean is_superset_of \n void remove \n void remove \n boolean contains \n lalr_item find \n int hashCode \n lalr_item get_one \n boolean equals \n boolean equals \n boolean is_subset_of \n void compute_closure \n String toString", "output": "int function ( ) { return _all . size ( ) ; }"}, {"instruction": "Generate java code\nsets the maximum size to which the log file can grow before being automatically checkpointed . ", "input": " Log log \n SimpleLog appLog \n boolean logStatements \n LockFile lf \n boolean syncFile \n\n void checkpoint \n int getLogSize \n void synchLog \n void releaseLock \n int getScriptType \n int getWriteDelay \n void openLog \n boolean closeLog \n boolean hasLog \n void writeCommitStatement \n void setScriptType \n void setWriteDelay \n DataFileCache getCache \n void writeToLog \n void closeTextCache \n DataFileCache openTextCache \n void writeSequenceStatement \n void acquireLock \n void logConnectUser \n boolean hasCache \n void writeInsertStatement \n void writeDeleteStatement \n void synchLogForce", "output": "void function ( int arg0 ) { if ( log != null ) { log . setLogSize ( arg0 ) ; } }"}, {"instruction": "Generate java code\nincrement by delta a given counter by name , if not exists then create it and set its value to delta ", "input": " ConcurrentHashMap<String,AtomicLong> counterMap \n\n Map<String,Long> getCounters \n void resetCounter \n AtomicLong getOrCreateCounter", "output": "void function ( String arg0 , long arg1 ) { getOrCreateCounter ( arg0 ) . addAndGet ( arg1 ) ; }"}, {"instruction": "Generate java code\nsets the value of the searchvalue property . ", "input": " Long searchValue2 \n Long searchValue \n SearchLongFieldOperator operator \n\n Long getSearchValue2 \n Long getSearchValue \n void setOperator \n void setSearchValue2 \n SearchLongFieldOperator getOperator", "output": "void function ( Long arg0 ) { this . searchValue = arg0 ; }"}, {"instruction": "Generate java code\ndefine valor do atributo idperfilacesso . ", "input": " String aprovaBaseConhecimento \n String permiteLeituraGravacao \n Integer idPerfilAcesso \n Date dataFim \n String nomePasta \n String permiteLeitura \n long serialVersionUID \n Date dataInicio \n Integer idPasta \n\n void setDataInicio \n String getAprovaBaseConhecimento \n String getPermiteLeituraGravacao \n Integer getIdPasta \n String getNomePasta \n Date getDataInicio \n void setAprovaBaseConhecimento \n void setPermiteLeituraGravacao \n void setIdPasta \n void setNomePasta \n void setPermiteLeitura \n Integer getIdPerfilAcesso \n Date getDataFim \n String getPermiteLeitura \n void setDataFim", "output": "void function ( Integer arg0 ) { this . idPerfilAcesso = arg0 ; }"}, {"instruction": "Generate java code\nmakes the password database key for the url : inserts the login after the scheme : http://login@url . ", "input": " boolean mySaveOnDisk \n String myPassword \n Project myProject \n String myLogin \n String myUrl \n Logger LOG \n String myTitle \n Collection<String> myUrlsFromCommand \n String myPasswordKey \n Class<GitHttpAuthenticator> PASS_REQUESTER \n GitHttpAuthDataProvider myDataProvider \n boolean myWasCancelled \n\n AuthDialog showAuthDialog \n void forgetPassword \n void forgetPassword \n List<GitHttpAuthDataProvider> getProviders \n String askUsername \n void saveAuthData \n String getUsername \n String askPassword \n String adjustHttpUrlForSettings \n AuthData getAuthData \n boolean wasCancelled \n String notNullizeUrl \n String getHost \n Pair<GitHttpAuthDataProvider,AuthData> findBestAuthData", "output": "String function ( @ NotNull String arg0 , @ Nullable String arg1 ) { if ( arg1 == null ) { return arg0 ; } Couple < String > loc0 = UriUtil . splitScheme ( arg0 ) ; String loc1 = loc0 . getFirst ( ) ; if ( StringUtil . isEmpty ( loc1 ) ) { return loc1 + URLUtil . SCHEME_SEPARATOR + arg1 + \"srini_string\" + loc0 . getSecond ( ) ; } return arg1 + \"srini_string\" + arg0 ; }"}, {"instruction": "Generate java code\ndisposes of this file alteration manager such that it will no longer reference any pathnames or listeners , and the timer and its associated thread will be stopped . ", "input": " Timer timer \n ArrayList<Listener> listeners \n File file \n ArrayList<FileDetails> files \n long lastModified \n String pathname \n\n void checkFileTimes \n void fireFileTouched \n void fileTouched \n void removeListener \n void addPathname \n void addListener", "output": "void function ( ) { timer . cancel ( ) ; files = new ArrayList < FileDetails > ( ) ; listeners = new ArrayList < Listener > ( ) ; timer = null ; }"}, {"instruction": "Generate java code\nget the full file model object for an absolute name . ", "input": " Document dom \n File projectPath \n FullBuildModel model \n String[] sourcePaths \n\n String checkNotBlank \n FullBuildModel getModel \n void setSourcePaths \n Document getDocument \n File getProjectPath \n void setProjectPath \n void parse \n void execute \n String fixAbsolutePath \n int getInt \n String[] getSourcePaths \n String resolveName \n void setModel", "output": "FullFileModel function ( String arg0 ) { File loc0 = new File ( arg0 ) ; String loc1 = resolveName ( arg0 ) ; return getFileModel ( loc1 , loc0 ) ; }"}, {"instruction": "Generate java code\nthe stop time interval . ", "input": " long overallTime \n long elapsedTimeStart \n long elapsedTimeStop \n long intervals \n\n long getIntervals \n void startInterval \n long getIntervalInMillis \n double getMean \n long getCurrentTime \n long getTotalTime", "output": "void function ( ) { elapsedTimeStop = getCurrentTime ( ) ; intervals ++ ; overallTime += ( elapsedTimeStop - elapsedTimeStart ) ; }"}, {"instruction": "Generate java code\nturns quantized value from byte array back into a double . ", "input": " double LAT_DECODE \n double LON_DECODE \n double LAT_SCALE \n short BITS \n double LON_SCALE \n\n int encodeLongitude \n double decodeLongitude \n double decodeLongitude \n int encodeLatitudeCeil \n int encodeLongitudeCeil \n int encodeLatitude", "output": "double function ( byte [ ] arg0 , int arg1 ) { return decodeLatitude ( NumericUtils . sortableBytesToInt ( arg0 , arg1 ) ) ; }"}, {"instruction": "Generate java code\nclears all the headers set in this handler . ", "input": " String lastSoapRequest \n String lastSoapResponse \n String lastServiceCalled \n String lastOperationCalled \n Set<SOAPElement> soapHeaders \n\n String getLastRequestXml \n String getLastOperationCalled \n Set<SOAPElement> getAddedHeaders \n void addHeader \n Set<QName> getHeaders \n void captureServiceAndOperationNames \n String getLastResponseXml \n boolean handleFault \n String getLastServiceCalled \n boolean handleMessage \n void captureSoapXml \n void close", "output": "void function ( ) { this . soapHeaders . clear ( ) ; }"}, {"instruction": "Generate java code\nreduces the size of the array to the specified size . if the array is already smaller than the specified size , no action is taken . ", "input": " boolean ordered \n int size \n long[] items \n\n void add \n void set \n void shrink \n void clear \n void insert \n long removeIndex \n void sort \n void reverse \n long peek \n long pop \n long random \n boolean contains \n boolean removeValue \n void addAll \n void addAll \n void addAll \n void addAll \n long get \n long[] toArray \n long[] resize \n String toString \n String toString \n long[] ensureCapacity \n void shuffle \n int indexOf", "output": "void function ( int arg0 ) { if ( size > arg0 ) size = arg0 ; }"}, {"instruction": "Generate java code\nreceive the given byte data . ", "input": " DatagramSocket mySocket \n int myPort \n DatagramPacket myPacketIn \n DatagramPacket myPacketOut \n int myClientPort \n InetAddress myClientAddress \n\n void send \n void close \n void connect", "output": "byte [ ] function ( int arg0 ) { byte [ ] loc0 = new byte [ arg0 ] ; myPacketIn = new DatagramPacket ( loc0 , loc0 . length ) ; mySocket . receive ( myPacketIn ) ; return loc0 ; }"}, {"instruction": "Generate java code\ngets the bin id . ", "input": " Integer binId \n Integer dossierPartsTempId \n String name \n String type \n Date creationDate \n byte[] content \n\n Date getCreationDate \n void setName \n void setBinId \n void setContent \n void setCreationDate \n String getName \n Integer getDossierPartsTempId \n String getType \n byte[] getContent \n void setType \n void setDossierPartsTempId", "output": "Integer function ( ) { return binId ; }"}, {"instruction": "Generate java code\nreturns a constraint that matches this one on the height attributes , but has a range width constraint . ", "input": " LengthConstraintType widthConstraintType \n Range widthRange \n double width \n RectangleConstraint NONE \n Range heightRange \n double height \n LengthConstraintType heightConstraintType \n\n RectangleConstraint toFixedHeight \n RectangleConstraint toRangeHeight \n Range getWidthRange \n double getWidth \n RectangleConstraint toUnconstrainedHeight \n Size2D calculateConstrainedSize \n RectangleConstraint toUnconstrainedWidth \n Range getHeightRange \n double getHeight \n LengthConstraintType getHeightConstraintType \n LengthConstraintType getWidthConstraintType \n String toString \n RectangleConstraint toFixedWidth", "output": "RectangleConstraint function ( Range arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new RectangleConstraint ( arg0 . getUpperBound ( ) , arg0 , LengthConstraintType . RANGE , this . height , this . heightRange , this . heightConstraintType ) ; }"}, {"instruction": "Generate java code\nreturns the user uuid of this kaleo task . ", "input": " KaleoTask _kaleoTask \n\n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n java.lang.String getName \n void setGroupId \n boolean isEscapedModel \n boolean isCachedModel \n long getKaleoNodeId \n int compareTo \n KaleoTask getWrappedModel \n long getGroupId \n long getKaleoDefinitionId \n void setKaleoNodeId \n void setModelAttributes \n Map<String,Object> getModelAttributes \n com.liferay.portal.kernel.model.CacheModel<KaleoTask> toCacheModel \n Date getCreateDate \n KaleoTask toUnescapedModel \n void setPrimaryKey \n java.lang.String getUserName \n void setUserUuid \n boolean isEntityCacheEnabled \n void resetOriginalValues \n Serializable getPrimaryKeyObj \n Date getModifiedDate \n KaleoTask toEscapedModel \n long getPrimaryKey \n void setCreateDate \n void setCachedModel \n String getModelClassName \n void setCompanyId \n void setUserId \n void setName \n boolean isFinderCacheEnabled \n long getKaleoTaskId \n ExpandoBridge getExpandoBridge \n void setDescription \n java.lang.String getDescription \n void setKaleoTaskId \n void setUserName \n int hashCode \n void persist \n void setNew \n void setKaleoDefinitionId \n boolean isNew \n Class<?> getModelClass \n void setModifiedDate \n long getCompanyId \n java.util.List<KaleoTaskAssignment> getKaleoTaskAssignments \n java.lang.String toXmlString \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n KaleoNode getKaleoNode \n java.lang.String toString \n long getUserId", "output": "java . lang . String function ( ) { return _kaleoTask . getUserUuid ( ) ; }"}, {"instruction": "Generate java code\ncleanup when the tasktracker is declared as ` lost/blacklisted ` by the jobtracker . the method assumes that the lock on the jobtracker is obtainedby the caller . ", "input": " Log LOG \n JobInProgress jobForFallowMapSlot \n JobInProgress jobForFallowReduceSlot \n String trackerName \n TaskTrackerStatus status \n\n String getTrackerName \n void unreserveSlots \n JobInProgress getJobForFallowSlot \n TaskTrackerStatus getStatus \n int getAvailableSlots \n void setStatus \n void reserveSlots", "output": "void function ( ) { if ( jobForFallowMapSlot != null ) { unreserveSlots ( TaskType . MAP , jobForFallowMapSlot ) ; } if ( jobForFallowReduceSlot != null ) { unreserveSlots ( TaskType . REDUCE , jobForFallowReduceSlot ) ; } }"}, {"instruction": "Generate java code\ndecodes a bit of an url encoded by a browser . the string is expected to be encoded as per rfc 3986 , section 2 . this is the encoding used by javascript functions encodeuri and encodeuricomponent , but not escape . for example in this encoding , &eacute; in unicode u +00 e9 or in utf-8 0xc3 0xa9 is encoded as % c3 % a9 or % c3 % a9 . this is essentially equivalent to calling java.net.urldecoder urldecoder . java.net.urldecoder #decode string , string except that it 's over 2x faster and generates less garbage for the gc . actually this function does n't allocate any memory if there 's nothing to decode , the argument itself is returned . ", "input": " PathTrie.Decoder REST_DECODER \n\n Pattern checkCorsSettingForRegex \n void decodeQueryString \n void addParam \n char decodeHexNibble \n String[] corsSettingAsArray \n String decode \n int decode \n boolean decodingNeeded", "output": "String function ( final String arg0 , final Charset arg1 ) { if ( arg0 == null ) { return \"srini_string\" ; } final int loc0 = arg0 . length ( ) ; if ( ! decodingNeeded ( arg0 , loc0 ) ) { return arg0 ; } final byte [ ] loc1 = new byte [ loc0 ] ; int loc2 = decode ( arg0 , loc0 , loc1 ) ; return new String ( loc1 , 0 , loc2 , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the value of the returndesc property . ", "input": " String returnCode \n PaymentScheduleInfo paymentScheduleInfo \n MandateInfo mandateInfo \n Creditor creditor \n DirectDebitInfo directDebitInfo \n String returnDesc \n\n Creditor getCreditor \n DirectDebitInfo getDirectDebitInfo \n void setCreditor \n MandateInfo getMandateInfo \n void setMandateInfo \n void setDirectDebitInfo \n String getReturnDesc \n void setPaymentScheduleInfo \n PaymentScheduleInfo getPaymentScheduleInfo \n void setReturnCode \n String getReturnCode", "output": "void function ( String arg0 ) { this . returnDesc = arg0 ; }"}, {"instruction": "Generate java code\ncreate a versionedname with the supplied name and version . ", "input": " String name \n String version \n\n String getVersion \n String getName \n int hashCode \n boolean equals \n String toString \n String getFormatted", "output": "VersionedName function ( String arg0 , String arg1 ) { checkNotNull ( arg0 , \"srini_string\" ) ; checkNotNull ( arg1 , \"srini_string\" ) ; return new VersionedName ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nperforms a dynamic query on the database and returns an ordered range of the matching rows . useful when paginating results . returns a maximum of end - start instances . start and end are not primary keys , they are indexes in the result set . thus , 0 refers to the first result in the set . setting both start and end to com.liferay.portal.kernel.dao.orm.queryutil #all_pos will return the full result set . if orderbycomparator is specified , then the query will include the given order by logic . if orderbycomparator is absent and pagination is required start and end are not com.liferay.portal.kernel.dao.orm.queryutil #all_pos , then the query will include the default order by logic from com.liferay.portal.workflow.kaleo.model.impl.kaleonodemodelimpl . if both orderbycomparator and pagination are absent , for performance reasons , the query will not have an order by clause and the returned result set will be sorted on by the primary key in an ascending order . ", "input": " ServiceTracker<KaleoNodeLocalService,KaleoNodeLocalService> _serviceTracker \n\n java.lang.String getOSGiServiceIdentifier \n void deleteKaleoDefinitionKaleoNodes \n com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery getActionableDynamicQuery \n int getKaleoNodesCount \n com.liferay.portal.kernel.dao.orm.DynamicQuery dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n com.liferay.portal.workflow.kaleo.model.KaleoNode addKaleoNode \n com.liferay.portal.workflow.kaleo.model.KaleoNode addKaleoNode \n KaleoNodeLocalService getService \n com.liferay.portal.workflow.kaleo.model.KaleoNode deleteKaleoNode \n com.liferay.portal.workflow.kaleo.model.KaleoNode deleteKaleoNode \n com.liferay.portal.workflow.kaleo.model.KaleoNode createKaleoNode \n long dynamicQueryCount \n long dynamicQueryCount \n void deleteCompanyKaleoNodes \n com.liferay.portal.kernel.model.PersistedModel deletePersistedModel \n com.liferay.portal.kernel.model.PersistedModel getPersistedModel \n com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery getIndexableActionableDynamicQuery \n com.liferay.portal.workflow.kaleo.model.KaleoNode fetchKaleoNode \n com.liferay.portal.workflow.kaleo.model.KaleoNode getKaleoNode \n java.util.List<com.liferay.portal.workflow.kaleo.model.KaleoNode> getKaleoNodes \n java.util.List<com.liferay.portal.workflow.kaleo.model.KaleoNode> getKaleoDefinitionKaleoNodes \n com.liferay.portal.workflow.kaleo.model.KaleoNode updateKaleoNode", "output": "java . util . List < T > function ( com . liferay . portal . kernel . dao . orm . DynamicQuery arg0 , int arg1 , int arg2 , com . liferay . portal . kernel . util . OrderByComparator < T > arg3 ) { return getService ( ) . arg0 ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\ncreate a new statistics object that has the supplied optimization time . ", "input": " long planningMillis \n long executionMillis \n long resultFormulationMillis \n ThreadLocal<DecimalFormat> FORMATTER \n long serialVersionUID \n long optimizationMillis \n Statistics EMPTY_STATISTICS \n\n void readable \n long totalTime \n Statistics withPlanningTime \n Statistics withPlanningTime \n int compareTo \n Statistics withResultsFormulationTime \n Statistics withResultsFormulationTime \n long getResultFormulationTime \n long getOptimizationTime \n long getPlanningTime \n long getExecutionTime \n String toString \n Statistics withExecutionTime \n Statistics withExecutionTime \n DecimalFormat initialValue \n long getTotalTime", "output": "Statistics function ( long arg0 , TimeUnit arg1 ) { long loc0 = TimeUnit . NANOSECONDS . convert ( arg0 , arg1 ) ; return new Statistics ( planningMillis , loc0 , resultFormulationMillis , executionMillis ) ; }"}, {"instruction": "Generate java code\ngets the value of the value property . ", "input": " String meshname \n String value \n\n String getMeshname \n void setValue \n void setMeshname", "output": "String function ( ) { return value ; }"}, {"instruction": "Generate java code\nmerges fields specified by a fieldmask from one message to another with the specified merge options . ", "input": " String FIELD_SEPARATOR_REGEX \n String FIELD_PATH_SEPARATOR \n String FIELD_PATH_SEPARATOR_REGEX \n boolean replacePrimitiveFields \n boolean replaceMessageFields \n boolean replaceRepeatedFields \n\n FieldMask fromJsonString \n boolean isValid \n boolean isValid \n boolean isValid \n boolean isValid \n boolean replaceMessageFields \n FieldMask fromFieldNumbers \n FieldMask fromFieldNumbers \n FieldMask union \n void setReplaceMessageFields \n FieldMask fromStringList \n void setReplaceRepeatedFields \n boolean replacePrimitiveFields \n FieldMask normalize \n FieldMask intersection \n String toString \n FieldMask fromString \n FieldMask fromString \n boolean replaceRepeatedFields \n String toJsonString \n void setReplacePrimitiveFields", "output": "void function ( FieldMask arg0 , Message arg1 , Message . Builder arg2 , MergeOptions arg3 ) { new FieldMaskTree ( arg0 ) . merge ( arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\nperforms a dynamic query on the database and returns the matching rows . ", "input": " ServiceTracker<DDMStructureVersionLocalService,DDMStructureVersionLocalService> _serviceTracker \n\n java.lang.String getOSGiServiceIdentifier \n int getStructureVersionsCount \n com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery getActionableDynamicQuery \n java.util.List<com.liferay.dynamic.data.mapping.model.DDMStructureVersion> getStructureVersions \n java.util.List<com.liferay.dynamic.data.mapping.model.DDMStructureVersion> getStructureVersions \n java.util.List<com.liferay.dynamic.data.mapping.model.DDMStructureVersion> getDDMStructureVersions \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion updateDDMStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion createDDMStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion getStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion getStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion getDDMStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion deleteDDMStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion deleteDDMStructureVersion \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion addDDMStructureVersion \n com.liferay.portal.kernel.dao.orm.DynamicQuery dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n java.util.List<T> dynamicQuery \n DDMStructureVersionLocalService getService \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion fetchDDMStructureVersion \n int getDDMStructureVersionsCount \n long dynamicQueryCount \n long dynamicQueryCount \n com.liferay.portal.model.PersistedModel deletePersistedModel \n com.liferay.portal.model.PersistedModel getPersistedModel \n com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery getIndexableActionableDynamicQuery \n com.liferay.dynamic.data.mapping.model.DDMStructureVersion getLatestStructureVersion", "output": "java . util . List < T > function ( com . liferay . portal . kernel . dao . orm . DynamicQuery arg0 ) { return getService ( ) . arg0 ( arg0 ) ; }"}, {"instruction": "Generate java code\nremoves pooledconnection from list of connections . the closing of the connection is separate from this method . this method is called usually when the caller encouters an error when using the connection and wants it removed from the pool . ", "input": " List<ConnectionDesc> conns \n Reference<Object> ref \n boolean debug \n int DEFAULT_SIZE \n int maxSize \n boolean trace \n int prefSize \n boolean closed \n\n void td \n void td \n void td \n String getStats \n boolean releasePooledConnection \n void d \n void d \n void d \n PooledConnection get \n boolean expire \n PooledConnection getOrCreateConnection \n void close", "output": "boolean function ( PooledConnection arg0 ) { if ( conns . remove ( new ConnectionDesc ( arg0 ) ) ) { d ( \"srini_string\" , arg0 ) ; notifyAll ( ) ; d ( \"srini_string\" ) ; td ( \"srini_string\" , arg0 ) ; if ( conns . isEmpty ( ) ) { ref = null ; } return true ; } else { d ( \"srini_string\" , arg0 ) ; return false ; } }"}, {"instruction": "Generate java code\nmethod to get the full path for the passed file name ", "input": " PlaceHolder placeHolder \n\n String pickAFile \n String pickPath \n String getMediaDirectory", "output": "String function ( String arg0 ) { String loc0 = null ; String loc1 = getMediaDirectory ( ) ; boolean loc2 = true ; loc0 = loc1 + arg0 ; return loc0 ; }"}, {"instruction": "Generate java code\nfetch numeric value of token , provided it 's a number . ", "input": " int BOOLEAN_KIND \n double number \n String symbol \n int SYMBOL_KIND \n boolean bool \n int kind \n int NUMBER_KIND \n int PROCEDURE_KIND \n List<Token> procedure \n\n boolean isBoolean \n boolean isSymbol \n int kind \n boolean isNumber \n boolean equals \n List<Token> getProcedure \n boolean getBoolean \n String toString \n boolean isProcedure \n String getSymbol", "output": "double function ( ) { Assert . pre ( isNumber ( ) , \"srini_string\" ) ; return number ; }"}, {"instruction": "Generate java code\ninfo log message . ", "input": " int WARN \n int VERBOSE \n int ERROR \n int LOGLEVEL \n int DEBUG \n int INFO \n\n boolean isLoggable \n void d \n void d \n void d \n void setLogLevel \n void setLogLevel \n void e \n void e \n void e \n void v \n void v \n void v \n void w \n void w \n void w", "output": "void function ( String arg0 , String arg1 ) { if ( LOG . INFO >= LOGLEVEL ) Log . i ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nsets the access token of this o auth token . ", "input": " OAuthToken _oAuthToken \n\n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n void setExpandoBridgeAttributes \n java.lang.String getGadgetKey \n boolean isEscapedModel \n boolean isCachedModel \n int compareTo \n OAuthToken getWrappedModel \n java.lang.String getAccessToken \n void setModelAttributes \n Map<String,Object> getModelAttributes \n long getOAuthTokenId \n com.liferay.portal.kernel.model.CacheModel<com.liferay.opensocial.model.OAuthToken> toCacheModel \n Date getCreateDate \n com.liferay.opensocial.model.OAuthToken toUnescapedModel \n void setPrimaryKey \n java.lang.String getUserName \n void setUserUuid \n boolean isEntityCacheEnabled \n void setGadgetKey \n void resetOriginalValues \n void setModuleId \n Serializable getPrimaryKeyObj \n Date getModifiedDate \n com.liferay.opensocial.model.OAuthToken toEscapedModel \n long getPrimaryKey \n void setTokenSecret \n void setCreateDate \n java.lang.String getTokenName \n void setCachedModel \n String getModelClassName \n java.lang.String getSessionHandle \n void setCompanyId \n void setUserId \n boolean isFinderCacheEnabled \n java.lang.String getServiceName \n ExpandoBridge getExpandoBridge \n long getModuleId \n void setExpiration \n void setTokenName \n void setUserName \n int hashCode \n void setOAuthTokenId \n void setServiceName \n void persist \n void setNew \n java.lang.String getTokenSecret \n java.lang.String getUserUuid \n boolean isNew \n Class<?> getModelClass \n void setModifiedDate \n long getExpiration \n long getCompanyId \n java.lang.String toXmlString \n void setSessionHandle \n boolean equals \n java.lang.Object clone \n void setPrimaryKeyObj \n java.lang.String toString \n long getUserId", "output": "void function ( java . lang . String arg0 ) { _oAuthToken . setAccessToken ( arg0 ) ; }"}, {"instruction": "Generate java code\nfully-qualified class name for the source type used in the mapping . if specified , the input to the mapping is converted to the specified type before being mapped with dozer . ", "input": " String mappingFile \n String unmarshalId \n String targetModel \n String name \n String marshalId \n String sourceModel \n DozerBeanMapperConfiguration mappingConfiguration \n\n String getUnmarshalId \n void setName \n String getName \n void setTargetModel \n String getMarshalId \n void setUnmarshalId \n void setMappingConfiguration \n DozerBeanMapperConfiguration getMappingConfiguration \n String getSourceModel \n String getTargetModel \n void setMarshalId \n String getMappingFile \n void setMappingFile", "output": "void function ( String arg0 ) { this . sourceModel = arg0 ; }"}, {"instruction": "Generate java code\ncreates a sql query function . ", "input": " Supplier<Result<SQLiteDatabase>> databaseSupplier \n Function<Cursor,T> cursorToItem \n Merger<SQLiteDatabase,R,Result<T>> databaseWithSqlArgument \n\n Function<SqlDeleteRequest,Result<Integer>> databaseDeleteFunction \n Result<T> apply \n Result<Long> merge \n Result<Integer> merge \n Result<Integer> merge \n Result<List<T>> merge \n Function<SqlInsertRequest,Result<Long>> databaseInsertFunction \n Function<SqlUpdateRequest,Result<Integer>> databaseUpdateFunction", "output": "Function < SqlRequest , Result < List < T >>> function ( @ NonNull final Supplier < Result < SQLiteDatabase >> arg0 , @ NonNull Function < Cursor , T > arg1 ) { return new DatabaseFunction < > ( arg0 , new DatabaseQueryMerger < > ( arg1 ) ) ; }"}]