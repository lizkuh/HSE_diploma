[{"instruction": "Generate java code\nlook for fields in the specified class that begin with the specified prefix . ", "input": " String lineSep \n RootDoc root \n Map<ClassDoc,Set<ClassDoc>> cmap \n boolean dump_class_tree \n\n void gather_derived_classes \n void process_class_sorted_texinfo \n void process \n int find_enabled \n boolean start \n int optionLength \n void process_class_tree_txt", "output": "Vector < FieldDoc > function ( ClassDoc arg0 , String arg1 ) { Vector < FieldDoc > loc0 = new Vector < FieldDoc > ( ) ; for ( FieldDoc loc1 : arg0 . fields ( ) ) { if ( loc1 . name ( ) . startsWith ( arg1 ) ) loc0 . add ( loc1 ) ; } return ( loc0 ) ; }"}, {"instruction": "Generate java code\nanalyzes if the given resource is the best matching for the given release . returns true if so , false otherwise . ", "input": " ResourceReleaseComparator resourceReleaseComparator \n\n List<ResourceEntity> getAllFutureReleases \n int compare \n boolean isBestMatchingPastReleaseTime \n Set<ResourceEntity> getResourceEntitiesByRelease \n Boolean isBestMatchingFutureReleaseTime \n Set<ConsumedResourceRelationEntity> getConsumedMasterRelationsForRelease \n Set<ProvidedResourceRelationEntity> getProvidedMasterRelationsForRelease \n Set<ResourceEntity> getConsumedRelatedResourcesByResourceType \n Set<ProvidedResourceRelationEntity> getProvidedSlaveRelationsForRelease \n ReleaseEntity findMostRelevantRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity findMostRelevantResource", "output": "boolean function ( @ NotNull ResourceEntity arg0 , @ NotNull ReleaseEntity arg1 ) { return arg0 . equals ( getResourceEntityForRelease ( arg0 . getResourceGroup ( ) , arg1 ) ) ; }"}, {"instruction": "Generate java code\nreturns the sampleduration of the track in seconds . ", "input": " Buffer outputBuffer \n Codec codec \n Buffer inputBuffer \n ArrayList<VideoTrack> tracks \n String nameFormat \n Format videoFormat \n int count \n int width \n Format fileFormat \n File dir \n int height \n\n boolean isVFRSupported \n Format getFileFormat \n boolean isEmpty \n void writeSamples \n int getTrackCount \n int addTrack \n int addVideoTrack \n void writeSample \n boolean isDataLimitReached \n Format getFormat \n void createCodec \n void write \n void write \n void close", "output": "Rational function ( int arg0 ) { VideoTrack loc0 = tracks . get ( arg0 ) ; return new Rational ( loc0 . count , 30 ) ; }"}, {"instruction": "Generate java code\nreturn the items for this channel . ", "input": " String managingEditor \n String title \n String language \n String link \n ArrayList skipDays \n TextInput textInput \n String rating \n String pubDate \n String description \n String lastBuildDate \n String webMaster \n String copyright \n ArrayList skipHours \n ArrayList items \n Image image \n String docs \n double version \n\n void addSkipDay \n void removeItem \n void setCopyright \n String getWebMaster \n void setDescription \n String getDescription \n void addSkipHour \n String getDocs \n void addItem \n Item[] getItems \n String getTitle \n String[] getSkipHours \n String[] findSkipHours \n String[] findSkipDays \n void render \n void render \n void render \n void render \n void render \n void render \n String[] getSkipDays \n void setManagingEditor \n double getVersion \n String getLanguage \n String getCopyright \n void setVersion \n String getPubDate \n void setWebMaster \n void setTitle \n void setTextInput \n void setPubDate \n void setLink \n String getLink \n String getLastBuildDate \n void setDocs \n void removeSkipHour \n void removeSkipDay \n TextInput getTextInput \n Image getImage \n void setLastBuildDate \n void setRating \n String getManagingEditor \n void setImage \n void setLanguage \n String getRating", "output": "Item [ ] function ( ) { synchronized ( items ) { Item loc0 [ ] = new Item [ this . items . size ( ) ] ; return ( ( Item [ ] ) this . items . toArray ( loc0 ) ) ; } }"}, {"instruction": "Generate java code\nactually walks the bag to make sure the count is correct and resets the running total ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n\n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "int function ( ) { _total = extractList ( ) . size ( ) ; return _total ; }"}, {"instruction": "Generate java code\nget kdc tcp port ", "input": " KdcConfig kdcConfig \n BackendConfig backendConfig \n KOptions startupOptions \n\n int getKdcPort \n String getKdcRealm \n int checkGetKdcTcpPort \n int getKdcUdpPort \n int checkGetKdcUdpPort \n boolean allowTcp \n boolean allowUdp \n KdcConfig getKdcConfig \n String getKdcHost \n BackendConfig getBackendConfig", "output": "int function ( ) { int loc0 = startupOptions . getIntegerOption ( KdcServerOption . KDC_TCP_PORT ) ; if ( loc0 < 1 ) { loc0 = kdcConfig . getKdcTcpPort ( ) ; } if ( loc0 < 1 ) { loc0 = getKdcPort ( ) ; } return loc0 ; }"}, {"instruction": "Generate java code\nload a map for the current locale to translate a character into a corresponding virtual keycode-based keystroke . ", "input": " KeyStrokeMapProvider generator \n Map chars \n boolean loaded \n Map characterMap \n Map keyStrokeMap \n Map keycodes \n\n Map generateKeyStrokeMappings \n void loadMaps \n Map getKeyStrokeMap \n Map getCharacterMap \n InputStream findMap \n void main \n KeyStroke getKeyStroke \n String[] getMapNames \n String[] getMapDescriptions \n String getOSType \n char getChar \n String getFilename \n Map generateCharacterMappings \n KeyStrokeMapProvider getGenerator \n Map loadKeyStrokeMap \n String[] getMapStrings", "output": "Map function ( ) { loadMaps ( ) ; return characterMap ; }"}, {"instruction": "Generate java code\nreturn an iterator over values in a column . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n\n ColumnMetaData[] getColumnMetaData \n ColumnMetaData getColumnMetaData \n ColumnMetaData getColumnMetaData \n long getRowCount \n List<ColumnMetaData> getRoots \n void readColumnMetaData \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n ColumnFileMetaData getMetaData \n void readHeader \n void readMagic \n void close", "output": "ColumnValues < T > function ( int arg0 ) { return new ColumnValues < T > ( columns [ arg0 ] ) ; }"}, {"instruction": "Generate java code\ndiscards any characters outside of the base64 alphabet see page 25 of rfc 2045 `` any characters outside of the base64 alphabet are to be ignored in base64 encoded data . '' ", "input": " byte[] decodingTable \n byte[] encodingTable \n\n void encode \n byte[] encode \n int computeEncodedSize \n byte[] decode \n byte[] decode \n String decode \n String decode \n boolean isValidBase64Byte \n String discardNonBase64Chars", "output": "byte [ ] function ( byte [ ] arg0 ) { byte loc0 [ ] = new byte [ arg0 . length ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0 . length ; loc2 ++ ) { if ( isValidBase64Byte ( arg0 [ loc2 ] ) ) { loc0 [ loc1 ++ ] = arg0 [ loc2 ] ; } } byte loc3 [ ] = new byte [ loc1 ] ; System . arraycopy ( loc0 , 0 , loc3 , 0 , loc1 ) ; return loc3 ; }"}, {"instruction": "Generate java code\nset the name of the catalog to be searched , ornull to search the default catalog . ", "input": " String name \n String catalogName \n boolean optional \n String nameKey \n\n void setName \n String getNameKey \n String getName \n void setNameKey \n String getCatalogName \n boolean postprocess \n Command getCommand \n boolean isOptional \n boolean execute \n void setOptional", "output": "void function ( String arg0 ) { this . catalogName = arg0 ; }"}]