[{"instruction": "Generate java code\nactually walks the bag to make sure the count is correct and resets the running total ", "input": " Object _current \n int _total \n DefaultMapBag _parent \n Map _map \n int _mods \n Iterator _support \n\n boolean add \n boolean add \n Object next \n boolean containsAll \n boolean containsAll \n void clear \n boolean isEmpty \n boolean hasNext \n void remove \n boolean remove \n boolean remove \n Map getMap \n int modCount \n boolean contains \n Iterator iterator \n boolean removeAll \n int size \n boolean addAll \n int hashCode \n boolean equals \n Object[] toArray \n Object[] toArray \n Set uniqueSet \n void setMap \n String toString \n int getCount \n List extractList \n boolean retainAll \n boolean retainAll", "output": "int function ( ) { _total = extractList ( ) . size ( ) ; return _total ; }"}, {"instruction": "Generate java code\ncontrols whether the compiler should perform statements recovery . to be effective , this method must be called before any of #getroot , #getastrewrite , #getimportremover . this method has no effect if the target object has been created with #compilationunitrewrite icompilationunit , compilationunit . defaults to true do perform statements recovery . ", "input": " ImportRewrite fImportRewrite \n ImportRemover fImportRemover \n WorkingCopyOwner fOwner \n ASTRewrite fRewrite \n boolean fStatementsRecovery \n List<TextEditGroup> fTextEditGroups \n ICompilationUnit fCu \n IDocument fRememberContent \n CompilationUnit fRoot \n boolean fResolveBindings \n boolean fBindingsRecovery \n\n void clearASTRewrite \n ASTRewrite getASTRewrite \n void rememberContent \n AST getAST \n void setBindingRecovery \n ImportRemover getImportRemover \n CompilationUnitChange createChange \n org.eclipse.jdt.internal.corext.refactoring.changes.CompilationUnitChange createChange \n CompilationUnitChange createChange \n CompilationUnitChange createChange \n void clearASTAndImportRewrites \n CompilationUnitChange attachChange \n CategorizedTextEditGroup createCategorizedGroupDescription \n TextEditGroup createGroupDescription \n void setResolveBindings \n ImportRewrite getImportRewrite \n ICompilationUnit getCu \n void clearImportRewrites \n void clearGroupDescriptionEdits \n CompilationUnit getRoot \n boolean isEmptyEdit", "output": "void function ( boolean arg0 ) { fStatementsRecovery = arg0 ; }"}, {"instruction": "Generate java code\noverride and return true for database updates that produce changed class metadata ", "input": " String _db4oVersion \n byte _db4oHeaderVersion \n\n String fileName \n String fileName \n String getTempPath \n void runDefrag \n void checkDatabaseFile \n void update \n int db4oMajorVersion \n void checkUpdatedDatabaseFile \n void investigateFileHeaderVersion \n boolean isApplicableForDb4oVersion \n void withDatabase \n void deconfigure \n void setUp \n String fileNamePrefix \n void assertObjectDeletion \n void assertObjectsAreReadable \n String databasePath \n void configureForStore \n void test \n void test \n void deconfigureForStore \n void configure \n void store \n void deconfigureForTest \n void tearDown \n void configureForTest \n void storeObject \n void createDatabase \n void createDatabase \n void assertObjectsAreUpdated \n void updateDatabaseFile \n String oldVersionFileName \n void createDatabaseFor \n byte db4oHeaderVersion \n int db4oMinorVersion \n String[] versionNames \n void runDeletionTests", "output": "boolean function ( ) { return false ; }"}, {"instruction": "Generate java code\nget identity znode . ", "input": " String ENCRYPTION_KEY_NO_ZNODE_NAME \n String KEY_VERSION_ZNODE_NAME \n String PRINCIPAL_NAME_ZNODE_NAME \n String baseZNode \n String CREATED_TIME_ZNODE_NAME \n String KDC_FLAGS_ZNODE_NAME \n String DISABLED_ZNODE_NAME \n String KEYS_ZNODE_NAME \n String IDENTITIES_ZNODE_NAME \n String KEY_ZNODE_NAME \n String EXPIRE_TIME_ZNODE_NAME \n String KEY_TYPE_ZNODE_NAME \n String LOCKED_ZNODE_NAME \n\n String getEncryptionKeyTypeZNode \n String getBaseZNode \n String getDisabledZNode \n String getKeyTypeZNode \n String getEncryptionKeyNoZNode \n String getEncryptionKeyZNode \n String getLockedZNode \n String getCreatedTimeZNode \n String getExpireTimeZNode \n String getKeyVersionZNode \n String getKeysZNode \n String getIdentitiesZNode \n List<String> getIdentityNames \n String getPrincipalNameZnode \n String getKdcFlagsZNode", "output": "String function ( String arg0 ) { return ZKUtil . joinZNode ( getIdentitiesZNode ( ) , arg0 ) ; }"}, {"instruction": "Generate java code\ncompareto , lexicogaphical comparison . ", "input": " List<C> val \n Logger logger \n GenVectorModul<C> modul \n\n int signum \n GenVector<C> leftLinearCombination \n GenVector<C> rightScalarProduct \n GenVector<C> subtract \n GenVector<C> scalarMultiply \n GenVector<C> sum \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> linearCombination \n GenVector<C> leftScalarMultiply \n C scalarProduct \n GenVector<C> scalarProduct \n GenVector<C> abs \n int hashCode \n GenVector<C> negate \n boolean equals \n GenVector<C> clone \n boolean isZERO \n String toString", "output": "int function ( GenVector < C > arg0 ) { if ( ! modul . equals ( arg0 . modul ) ) { return - 1 ; } List < C > loc0 = arg0 . val ; int loc1 = 0 ; for ( C loc2 : val ) { int loc3 = loc2 . compareTo ( loc0 . get ( loc1 ++ ) ) ; if ( loc3 != 0 ) { return loc3 ; } } return 0 ; }"}, {"instruction": "Generate java code\nsets the tag position if one is associated with the nls element . ", "input": " Region fTagPosition \n String TAG_POSTFIX \n AccessorClassReference fAccessorClassReference \n boolean fIsEclipseNLS \n int TAG_PREFIX_LENGTH \n String TAG_PREFIX \n int fIndex \n int TAG_POSTFIX_LENGTH \n String fValue \n Region fPosition \n\n String getValue \n Region getPosition \n boolean isEclipseNLS \n boolean hasTag \n void setAccessorClassReference \n AccessorClassReference getAccessorClassReference \n void setValue \n String createTagText \n String getTagText \n String toString \n Region getTagPosition", "output": "void function ( int arg0 , int arg1 ) { fTagPosition = new Region ( arg0 , arg1 ) ; }"}, {"instruction": "Generate java code\nconvenience method to find a zero of a univariate real function . a default solver is used . ", "input": " UnivariateRealSolverFactory factory \n\n double[] bracket \n double[] bracket \n double midpoint \n void setup", "output": "double function ( UnivariateRealFunction arg0 , double arg1 , double arg2 ) { setup ( arg0 ) ; return factory . newDefaultSolver ( arg0 ) . solve ( arg1 , arg2 ) ; }"}, {"instruction": "Generate java code\ndo we get multiple clicks even when the individual clicks are on different frames ? ", "input": " boolean gotBug1Event \n java.util.ArrayList bugList \n\n boolean fileDialogRequiresDismiss \n boolean hasHierarchyEventGenerationBug \n boolean hasKeyStrokeGenerationBug \n String[] bugCheck \n boolean hasRobotMotionBug \n boolean reportsIncorrectLockingKeyState \n boolean fileDialogMisreportsBounds \n boolean needsRobotVerification \n boolean hasMenuDisableBug \n boolean hasInputMethodInsteadOfKeyTyped \n boolean hasMissingWindowMouseMotion \n boolean hasEscapeGenerationBug \n boolean showAWTPopupMenuBlocks \n boolean hasChoiceLockupBug \n boolean hasRobotButtonsSwapped \n boolean hasKeyInputDelay \n boolean hasFrameDeiconifyBug \n boolean dragDropRequiresNativeEvents \n boolean hasTextComponentSelectionDelay \n boolean fileDialogRequiresVisibleFrame", "output": "boolean function ( ) { return Platform . isWindows ( ) || Platform . isOSX ( ) || Platform . JAVA_VERSION < Platform . JAVA_1_3 ; }"}, {"instruction": "Generate java code\ngets the fractional second precision of the type qualifier of the interval data type descriptor of this field iff interval type . gets the interval type descriptor 's fractional second precision iff interval type . ", "input": " SqlIntervalQualifier intervalQualifier \n Integer precision \n Boolean isNullable \n String name \n Integer scale \n List<String> workspaceSchemaPath \n List<FieldType> fields \n SqlTypeName type \n String sql \n\n String getName \n String getName \n boolean isDynamic \n List<String> getWorkspaceSchemaPath \n SqlIntervalQualifier getIntervalQualifier \n boolean hasStar \n TimeUnit getEndUnit \n RelDataType getRowType \n Integer getPrecision \n void setSql \n String getSql \n TimeUnit getStartUnit \n List<FieldType> getFields \n Integer getScale \n SqlTypeName getType \n Boolean getIsNullable", "output": "Integer function ( ) { return null == intervalQualifier ? null : intervalQualifier . getFractionalSecondPrecisionPreservingDefault ( ) ; }"}, {"instruction": "Generate java code\nconvert drawable to byte array ", "input": " PlaceHolder placeHolder \n\n Drawable bitmapToDrawable \n void closeInputStream \n Bitmap drawableToBitmap \n Bitmap byteToBitmap \n Bitmap getBitmapFromUrl \n Bitmap getBitmapFromUrl \n Bitmap scaleImage \n byte[] bitmapToByte \n Bitmap scaleImageTo \n Drawable byteToDrawable \n Drawable getDrawableFromUrl \n Drawable getDrawableFromUrl \n InputStream getInputStreamFromUrl \n InputStream getInputStreamFromUrl", "output": "byte [ ] function ( Drawable arg0 ) { return bitmapToByte ( drawableToBitmap ( arg0 ) ) ; }"}, {"instruction": "Generate java code\nresets migration flag . should only be used in tests . ", "input": " String APP_PREFS_NAME \n String PROFILE_PREFS_NAME_PREFIX \n String[] PROFILE_MIGRATIONS_0_TO_1 \n EnumSet<Flags> disableMigrations \n boolean migrationDone \n int PREFS_VERSION \n String LOGTAG \n String PREFS_VERSION_KEY \n\n int getVersion \n void migrateIfNecessary \n SharedPreferences forApp \n SharedPreferences forApp \n Editor migrateFromPreferenceManager \n void performMigration \n SharedPreferences forProfile \n SharedPreferences forProfile \n SharedPreferences forProfileName \n SharedPreferences forProfileName \n void putEntry", "output": "void function ( ) { migrationDone = false ; }"}, {"instruction": "Generate java code\ncomment f1z ", "input": " int I1z \n int I2z \n int I1 \n int I3 \n int I2 \n int I4 \n\n void fz \n void f \n void f11 \n void f1 \n void f2", "output": "void function ( ) { }"}, {"instruction": "Generate java code\ncreates a dialog to present a refactoringstatus to the user . thefollowing values are returned from the dialogs open method : org.eclipse.jface.dialogs.idialogconstants #ok_id idialogconstants #ok_id : if the user has pressed the continue button . org.eclipse.jface.dialogs.idialogconstants #cancel_id idialogconstants #cancel_id : if the user has pressed the cancel button . org.eclipse.jface.dialogs.idialogconstants #back_id idialogconstants #back_id : if the user has pressed the back button . ", "input": " PlaceHolder placeHolder \n\n Dialog createRefactoringWizardDialog \n Composite createRefactoringHistoryControl \n Composite createSortableRefactoringHistoryControl \n PerformChangeOperation createUIAwareChangeOperation \n Dialog createLightWeightStatusDialog", "output": "Dialog function ( RefactoringStatus arg0 , Shell arg1 , String arg2 , boolean arg3 ) { return new RefactoringStatusDialog ( arg0 , arg1 , arg2 , arg3 ) ; }"}, {"instruction": "Generate java code\ngets the current stroke color ", "input": " boolean knockout \n LineDashPattern lineDashPattern \n BaseColor fillColor \n float wordSpacing \n float leading \n BaseColor strokeColor \n int lineJoinStyle \n float miterLimit \n int lineCapStyle \n float lineWidth \n int renderMode \n PdfName colorSpaceFill \n PdfName colorSpaceStroke \n float fontSize \n float rise \n Matrix ctm \n float horizontalScaling \n float characterSpacing \n CMapAwareDocumentFont font \n\n float getFontSize \n int getRenderMode \n void setLineDashPattern \n int getLineJoinStyle \n PdfName getColorSpaceStroke \n float getCharacterSpacing \n void setLineWidth \n Matrix getCtm \n void setLineCapStyle \n PdfName getColorSpaceFill \n float getMiterLimit \n float getLineWidth \n float getWordSpacing \n boolean isKnockout \n BaseColor getFillColor \n CMapAwareDocumentFont getFont \n void setMiterLimit \n float getRise \n int getLineCapStyle \n float getLeading \n LineDashPattern getLineDashPattern \n float getHorizontalScaling \n void setLineJoinStyle", "output": "BaseColor function ( ) { return strokeColor ; }"}, {"instruction": "Generate java code\ntest method for org.jboss.security.config.securityconfiguration #getapplicationpolicy java.lang.string . ", "input": " PlaceHolder placeHolder \n\n void testGetCipherAlgorithm \n void testSetIterationCount \n void testGetKeyStoreURL \n void testGetSalt \n void testGetTrustStoreType \n void testGetKeyStoreType \n void testSetTrustStoreURL \n void testSetKeyStoreURL \n void testSetSalt \n void testLoadPassword \n void testSetCipherSpec \n void testGetExternalPasswordCacheInstance \n void testSetKeyStoreType \n void testIsDeepCopySubjectMode \n void testGetKeyStorePass \n WebArchive deployment \n void testSetTrustStorePass \n void testGetTrustStorePass \n void testSetCipherAlgorithm \n void testSetTrustStoreType \n void testGetTrustStoreURL \n void testSetDeepCopySubjectMode \n void testGetCipherSpec \n void testAddApplicationPolicy \n void testSetKeyStorePass \n void testRemoveApplicationPolicy \n void testSetCipherKey \n void testGetIterationCount \n void testGetCipherKey", "output": "void function ( ) { SecurityConfiguration . getApplicationPolicy ( \"srini_string\" ) ; }"}, {"instruction": "Generate java code\ncopy method ", "input": " PlaceHolder placeHolder \n\n void validateMin2 \n void validate \n Predicate[] validate \n void validate \n void validate", "output": "Transformer [ ] function ( Transformer [ ] arg0 ) { if ( arg0 == null ) { return null ; } return ( Transformer [ ] ) arg0 . clone ( ) ; }"}, {"instruction": "Generate java code\nabre el libro y retorna el marcador con la pagina actual ", "input": " String dimensiones \n int numeroPaginas \n String titulo \n String colorPortada \n String autor \n int marcador \n\n void setColorPortada \n void setDimensiones \n String getColorPortada \n String getAutor \n void setTitulo \n int cerrar \n String getTitulo \n void setNumeroPaginas \n int getNumeroPaginas \n int leer \n String getDimensiones \n void setMarcador \n int escribir \n void setAutor \n Libro clone \n String toString \n int getMarcador", "output": "int function ( ) { return this . getMarcador ( ) ; }"}, {"instruction": "Generate java code\nreturns the element surrounding the selection of the given editor . ", "input": " IJavaElement[] EMPTY_RESULT \n\n IJavaElement selectJavaElement \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] codeResolve \n IJavaElement[] performForkedCodeResolve \n boolean canOperateOn \n IStructuredSelection getStructuredSelection \n IClassFile getInputAsClassFile \n IJavaElement[] codeResolveForked \n ITypeRoot getInput \n ITypeRoot getInput \n IType getTypeAtOffset \n IJavaElement[] codeResolveOrInputForked \n ICompilationUnit getInputAsCompilationUnit \n IJavaElement[] getElements \n IJavaElement resolveEnclosingElement \n IJavaElement resolveEnclosingElement", "output": "IJavaElement function ( JavaEditor arg0 , boolean arg1 ) { ITypeRoot loc0 = getInput ( arg0 , arg1 ) ; if ( loc0 != null ) return getElementAtOffset ( loc0 , ( ITextSelection ) arg0 . getSelectionProvider ( ) . getSelection ( ) ) ; return null ; }"}, {"instruction": "Generate java code\ncoordinates building a loadplan that defines just a single root entity return may have fetches . typically this includes building load plans for entity loading or cascade loading . ", "input": " PlaceHolder placeHolder \n\n LoadPlan buildRootCollectionLoadPlan", "output": "LoadPlan function ( LoadPlanBuildingAssociationVisitationStrategy arg0 , EntityPersister arg1 ) { MetamodelGraphWalker . visitEntity ( arg0 , arg1 ) ; return arg0 . buildLoadPlan ( ) ; }"}, {"instruction": "Generate java code\ncompute a single body-body or body-cell interaction ", "input": " MathVector acc0 \n MathVector pos \n double mass \n int IMAX \n MathVector pos0 \n double phi0 \n double EPS \n Body pskip \n\n Node loadTree \n int oldSubindex \n String toString \n double hackcofm \n HG walkSubTree", "output": "HG function ( HG arg0 ) { MathVector loc0 = new MathVector ( ) ; loc0 . subtraction ( pos , arg0 . pos0 ) ; double loc1 = loc0 . dotProduct ( ) + ( EPS * EPS ) ; double loc2 = Math . sqrt ( loc1 ) ; double loc3 = mass / loc2 ; arg0 . phi0 -= loc3 ; double loc4 = loc3 / loc1 ; loc0 . multScalar ( loc4 ) ; arg0 . acc0 . addition ( loc0 ) ; return arg0 ; }"}, {"instruction": "Generate java code\nset the name of the catalog to be searched , ornull to search the default catalog . ", "input": " String name \n String catalogName \n boolean optional \n String nameKey \n\n void setName \n String getNameKey \n String getName \n void setNameKey \n String getCatalogName \n boolean postprocess \n Command getCommand \n boolean isOptional \n boolean execute \n void setOptional", "output": "void function ( String arg0 ) { this . catalogName = arg0 ; }"}, {"instruction": "Generate java code\nreturn an iterator over values in a column . ", "input": " ColumnFileMetaData metaData \n Map<String,ColumnDescriptor> columnsByName \n Input file \n ColumnDescriptor[] columns \n long rowCount \n int columnCount \n\n ColumnMetaData[] getColumnMetaData \n ColumnMetaData getColumnMetaData \n ColumnMetaData getColumnMetaData \n long getRowCount \n List<ColumnMetaData> getRoots \n void readColumnMetaData \n void readColumnStarts \n ColumnDescriptor<T> getColumn \n long getColumnCount \n ColumnFileMetaData getMetaData \n void readHeader \n void readMagic \n void close", "output": "ColumnValues < T > function ( int arg0 ) { return new ColumnValues < T > ( columns [ arg0 ] ) ; }"}, {"instruction": "Generate java code\nwhen the login machine terminates , we might not be in the married state , and therefore we ca n't sync . this method messages as much to the user . to avoid stopping us syncing altogether , we set a soft error rather than a hard error . in future , we would like to set a hard error if we are in , for example , the separated state , and then have some user initiated activity mark the android account as ready to sync again . this is tricky , though , so we play it safe for now . ", "input": " BlockingQueue<Result> latch \n SyncResult syncResult \n\n void setSyncResultSuccess \n void postponeSync \n void setSyncResultSoftError \n void handleError \n void handleSuccess \n void rejectSync \n void setSyncResultHardError", "output": "void function ( State arg0 ) { setSyncResultSoftError ( ) ; latch . offer ( Result . Error ) ; }"}, {"instruction": "Generate java code\nconverts the handle . handle need not exist , but must be a source reference . ", "input": " IType fOldType \n IType fNewType \n Map<IJavaElement,String> fRefactoredSimilarElements \n\n IMember resolveTypeInMember \n String resolveTypeName \n IMember[] convertElements \n void addElements \n String[] resolveParameterTypes \n String resolveElementName \n String replaceAll", "output": "IMember function ( IMember arg0 ) { final LinkedList < IMember > loc0 = new LinkedList < > ( ) ; addElements ( arg0 , loc0 ) ; final IMember [ ] loc1 = convertElements ( loc0 . toArray ( new IMember [ 0 ] ) ) ; return loc1 [ loc1 . length - 1 ] ; }"}, {"instruction": "Generate java code\nreturns the sampleduration of the track in seconds . ", "input": " Buffer outputBuffer \n Codec codec \n Buffer inputBuffer \n ArrayList<VideoTrack> tracks \n String nameFormat \n Format videoFormat \n int count \n int width \n Format fileFormat \n File dir \n int height \n\n boolean isVFRSupported \n Format getFileFormat \n boolean isEmpty \n void writeSamples \n int getTrackCount \n int addTrack \n int addVideoTrack \n void writeSample \n boolean isDataLimitReached \n Format getFormat \n void createCodec \n void write \n void write \n void close", "output": "Rational function ( int arg0 ) { VideoTrack loc0 = tracks . get ( arg0 ) ; return new Rational ( loc0 . count , 30 ) ; }"}, {"instruction": "Generate java code\ndoes a popularity reorder on this document set . ", "input": " boolean configured \n Distribution reorderIntvlDist \n boolean useRanks \n double zipfExp \n long meanReorderIntvl \n RandomGenerator rand \n String name \n ZipfDistribution dist \n int startRank \n Logger log \n List<Integer> keyPopularity \n int size \n\n void setName \n String getName \n int getKeyForPublish \n void checkConfigure \n void setMeanReorderIntvl \n void setZipfExp \n void configure \n int getSize \n boolean containsResourcesOf \n void setSize \n Distribution getReorderDistribution \n int getKeyForLookup \n void setBeginRank", "output": "void function ( ) { int loc0 = rand . nextInt ( size ) ; int loc1 = rand . nextInt ( size ) ; log . debug ( \"srini_string\" + Simulator . getCurrentTime ( ) + \"srini_string\" + loc0 + \"srini_string\" + loc1 ) ; keyPopularity . add ( loc1 , keyPopularity . remove ( loc0 ) ) ; getKeyForLookup ( ) ; }"}, {"instruction": "Generate java code\ngets the child scripts that make up this block . this list is live so that it can be modified if requried ", "input": " List list \n\n void addScript \n Script compile \n void trimWhitespace \n String toString \n void run \n void removeScript", "output": "List function ( ) { return list ; }"}, {"instruction": "Generate java code\nanalyzes if the given resource is the best matching for the given release . returns true if so , false otherwise . ", "input": " ResourceReleaseComparator resourceReleaseComparator \n\n List<ResourceEntity> getAllFutureReleases \n int compare \n boolean isBestMatchingPastReleaseTime \n Set<ResourceEntity> getResourceEntitiesByRelease \n Boolean isBestMatchingFutureReleaseTime \n Set<ConsumedResourceRelationEntity> getConsumedMasterRelationsForRelease \n Set<ProvidedResourceRelationEntity> getProvidedMasterRelationsForRelease \n Set<ResourceEntity> getConsumedRelatedResourcesByResourceType \n Set<ProvidedResourceRelationEntity> getProvidedSlaveRelationsForRelease \n ReleaseEntity findMostRelevantRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity getResourceEntityForRelease \n ResourceEntity findMostRelevantResource", "output": "boolean function ( @ NotNull ResourceEntity arg0 , @ NotNull ReleaseEntity arg1 ) { return arg0 . equals ( getResourceEntityForRelease ( arg0 . getResourceGroup ( ) , arg1 ) ) ; }"}, {"instruction": "Generate java code\nget the docker rest uri . ", "input": " String address \n int port \n String host \n String DEFAULT_HOST \n String DEFAULT_UNIX_ENDPOINT \n int DEFAULT_PORT \n URI uri \n String dockerCertPath \n\n int defaultPort \n DockerHost fromEnv \n String address \n int port \n String host \n DockerHost from \n String toString \n String dockerCertPath", "output": "URI function ( ) { return uri ; }"}, {"instruction": "Generate java code\ngets the value of the getcontentlanguage property . ", "input": " Owner owner \n PrincipalURL principalURL \n Creationdate creationdate \n Getlastmodified getlastmodified \n Getcontentlanguage getcontentlanguage \n Getetag getetag \n Getcontentlength getcontentlength \n SupportedReportSet supportedReportSet \n Acl acl \n PrincipalCollectionSet principalCollectionSet \n Resourcetype resourcetype \n List<Element> any \n QuotaUsedBytes quotaUsedBytes \n Lockdiscovery lockdiscovery \n QuotaAvailableBytes quotaAvailableBytes \n Getcontenttype getcontenttype \n Displayname displayname \n Supportedlock supportedlock \n Group group \n\n PrincipalCollectionSet getPrincipalCollectionSet \n Creationdate getCreationdate \n void setCreationdate \n void setQuotaAvailableBytes \n Getcontentlength getGetcontentlength \n Displayname getDisplayname \n void setGetcontenttype \n void setAcl \n Owner getOwner \n Getlastmodified getGetlastmodified \n Supportedlock getSupportedlock \n void setLockdiscovery \n void setOwner \n SupportedReportSet getSupportedReportSet \n void setSupportedReportSet \n void setSupportedlock \n void setPrincipalCollectionSet \n QuotaUsedBytes getQuotaUsedBytes \n Acl getAcl \n void setQuotaUsedBytes \n void setPrincipalURL \n PrincipalURL getPrincipalURL \n void setGetetag \n Resourcetype getResourcetype \n void setResourcetype \n Getetag getGetetag \n void setGroup \n Getcontenttype getGetcontenttype \n Group getGroup \n void setGetcontentlanguage \n Lockdiscovery getLockdiscovery \n void setGetlastmodified \n QuotaAvailableBytes getQuotaAvailableBytes \n void setDisplayname \n void setGetcontentlength \n List<Element> getAny", "output": "Getcontentlanguage function ( ) { return getcontentlanguage ; }"}]